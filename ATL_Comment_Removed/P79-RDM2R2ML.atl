

module RDM2R2ML; 
create OUT : R2ML from IN : RDM;



uses strings;







helper def: getAtomForClassElement(cla : RDM!Class) : RDM!Atom = 

	let allAtoms : Sequence(RDM!Atom) = RDM!Atom.allInstancesFrom('IN')->asSequence()->select(c | c.hasPredicateSymbol.oclIsKindOf(RDM!Class)) in

		allAtoms->iterate(p; res : RDM!Atom = allAtoms->first() |

			if(p.childrenClasses(cla)->includes(cla))

				then p

				else res

				endif

		);



helper context RDM!Atom def: childrenClasses(cla : RDM!Class) : Sequence(RDM!Class) = 

	if self.hasPredicateSymbol.oclIsTypeOf(RDM!Class)

		then Sequence{self.hasPredicateSymbol}

		else Sequence{self.hasPredicateSymbol.childrenClasses(cla)}->flatten()

	endif;

	

helper context RDM!IntersectionClass def: childrenClasses(cla : RDM!Class) : Sequence(RDM!Class) = 

	let allClasses : Sequence(RDM!Class) = self.intersectionOf->select(e | e.oclIsTypeOf(RDM!Class)) in

		allClasses.union(self.intersectionOf->select(e | not e.oclIsTypeOf(RDM!Class))->collect(c | c.childrenClasses(cla))->flatten())->append(self);



helper context RDM!UnionClass def: childrenClasses(cla : RDM!Class) : Sequence(RDM!Class) = 

	let allClasses : Sequence(RDM!Class) = self.unionOf->select(e | e.oclIsTypeOf(RDM!Class)) in

		allClasses.union(self.unionOf->select(e | not e.oclIsTypeOf(RDM!Class))->collect(c | c.childrenClasses(cla))->flatten())->append(self);



helper context RDM!ComplementClass def: childrenClasses(cla : RDM!Class) : Sequence(RDM!Class) = 

	if(self.complementOf.oclIsTypeOf(RDM!Class)) then

		Sequence{self.complementOf}->append(self)

	else self.complementOf.childrenClasses(cla)->append(self)

	endif;



helper context RDM!EnumeratedClass def: childrenClasses(cla : RDM!Class) : Sequence(RDM!Class) = 

	self.oneOf->asSequence();



helper context RDM!HasValueRestriction def: childrenClasses(cla : RDM!Class) : Sequence(RDM!Class) = 

	Sequence{self};

	

helper context RDM!MinCardinalityRestriction def: childrenClasses(cla : RDM!Class) : Sequence(RDM!Class) = 

	Sequence{self};



helper context RDM!MaxCardinalityRestriction def: childrenClasses(cla : RDM!Class) : Sequence(RDM!Class) = 

	Sequence{self};

	

helper context RDM!CardinalityRestriction def: childrenClasses(cla : RDM!Class) : Sequence(RDM!Class) = 

	Sequence{self};	



helper context RDM!SomeValuesFromRestriction def: childrenClasses(cla : RDM!Class) : Sequence(RDM!Class) =

	if(not self.someValuesFromClass.oclIsUndefined()) then

		Sequence{self.someValuesFromClass}->append(self)

	else Sequence {self}

	endif;	



helper context RDM!AllValuesFromRestriction def: childrenClasses(cla : RDM!Class) : Sequence(RDM!Class) =

	if(not self.allValuesFromClass.oclIsUndefined()) then

		Sequence{self.allValuesFromClass}->append(self)

	else Sequence {self}

	endif;	

	

helper context RDM!ObjectProperty def: childrenClasses(cla : RDM!Class) : Sequence(RDM!Class) = 

	Sequence{};	





helper def: getAtomForDataElement(dtp : RDM!OntologyElement) : RDM!Atom = 

	let allAtoms : Sequence(RDM!Atom) = RDM!Atom.allInstancesFrom('IN')->asSequence()->select(c | c.hasPredicateSymbol.oclIsKindOf(RDM!OntologyElement)) in

		allAtoms->iterate(p; res : RDM!Atom = allAtoms->first() |

			if(p.childrenElems(dtp)->includes(dtp))

				then p

				else res

				endif

		);



helper context RDM!Atom def: childrenElems(ont : RDM!OntologyElement) : Sequence(RDM!OntologyElement) = 

	if self.hasPredicateSymbol.oclIsKindOf(RDM!Datatype) or self.hasPredicateSymbol.oclIsTypeOf(RDM!DataRange)

		then Sequence{self.hasPredicateSymbol.childrenElems(ont)}->flatten()

		else Sequence{self.hasPredicateSymbol}

	endif;



helper context RDM!DataRange def: childrenElems(dtp : RDM!OntologyElement) : Sequence(RDM!OntologyElement) = 

	if self.oneOf.oclIsUndefined()

		then Sequence {self.datatype}->append(self)

		else self.oneOf->select(e | e.oclIsKindOf(RDM!OntologyElement))->append(self)

		endif;



helper context RDM!AllValuesFromRestriction def: childrenElems(dtp : RDM!OntologyElement) : Sequence(RDM!OntologyElement) = 

	self.allValuesFromRange.oneOf->select(e | e.oclIsKindOf(RDM!OntologyElement))->append(self);



helper context RDM!SomeValuesFromRestriction def: childrenElems(dtp : RDM!OntologyElement) : Sequence(RDM!OntologyElement) = 

	self.someValuesFromRange.oneOf->select(e | e.oclIsKindOf(RDM!OntologyElement))->append(self);



helper context RDM!HasValueRestriction def: childrenElems(dtp : RDM!OntologyElement) : Sequence(RDM!OntologyElement) = 

	Sequence{self.hasLiteralValue}->append(self);

	

helper context RDM!MinCardinalityRestriction def: childrenElems(dtp : RDM!OntologyElement) : Sequence(RDM!OntologyElement) = 

	Sequence{self};



helper context RDM!MaxCardinalityRestriction def: childrenElems(dtp : RDM!OntologyElement) : Sequence(RDM!OntologyElement) = 

	Sequence{self};



helper context RDM!CardinalityRestriction def: childrenElems(dtp : RDM!OntologyElement) : Sequence(RDM!OntologyElement) = 

	Sequence{self};	



helper context RDM!Literal def: childrenElems(dtp : RDM!OntologyElement) : Sequence(RDM!OntologyElement) =

	Sequence{self};

	

helper context RDM!PrimitiveType def: childrenElems(dtp : RDM!OntologyElement) : Sequence(RDM!OntologyElement) =

	Sequence{self};

	

helper context RDM!DatatypeProperty def: childrenElems(dtp : RDM!OntologyElement) : Sequence(RDM!OntologyElement) =

	Sequence{};	





helper context RDM!MinCardinalityRestriction def: maxCardinalityOnSameProperty : RDM!MaxCardinalityRestriction = 

	let maxCardinalityRestrictions : Sequence(RDM!MaxCardinalityRestriction) = RDM!MaxCardinalityRestriction.allInstancesFrom('IN')->asSequence() in

		maxCardinalityRestrictions->iterate(p; res : RDM!MaxCardinalityRestriction = maxCardinalityRestrictions->first() |

			if(p.onProperty->asSequence()->includes(self.onProperty->asSequence()->first()))

				then p

				else res

				endif

		);



helper context RDM!MaxCardinalityRestriction def: minCardinalityOnSameProperty : RDM!MinCardinalityRestriction = 

	let minCardinalityRestrictions : Sequence(RDM!MinCardinalityRestriction) = RDM!MinCardinalityRestriction.allInstancesFrom('IN')->asSequence() in

		minCardinalityRestrictions->iterate(p; res : RDM!MinCardinalityRestriction = minCardinalityRestrictions->first() |

			if(p.onProperty->asSequence()->includes(self.onProperty->asSequence()->first()))

				then p

				else res

				endif

		);

	

helper context RDM!Class def: transform(parent : RDM!Class, transformedClass : R2ML!Class) : R2ML!ObjectClassificationAtom =

               		R2ML!ObjectClassificationAtom.newInstance()

				    	.refSetValue('isNegated', false)

                    	.refSetValue('term', thisModule.IndividualVariable2ObjectVariable(thisModule.getAtomForClassElement(parent).terms->first()))

                    	.refSetValue('type', transformedClass);



helper def: getDefaultTypedLiteral(type : String) : RDM!TypedLiteral = 

	let typ : RDM!TypedLiteral = RDM!TypedLiteral.allInstancesFrom('IN')->asSequence()->select(c | c.theType = type)->first() in

		if typ.oclIsUndefined()

		then OclUndefined

		else typ

		endif;



helper def: getDefaultPlainLiteral() : RDM!PlainLiteral = 

	let typ : RDM!PlainLiteral = RDM!PlainLiteral.allInstancesFrom('IN')->asSequence()->first() in

		if typ.oclIsUndefined()

		then OclUndefined

		else typ

		endif;



helper context RDM!Rule def: getAllAtoms() : Sequence(RDM!Atom) = 

	self.hasAntecedent.containsAtom->asSequence().union(self.hasConsequent.containsAtom->asSequence());

		







rule ClassAtom2ObjectClassificationAtom {

	from i : RDM!Atom (

			i.name = 'ClassAtom' and i.hasPredicateSymbol.oclIsTypeOf(RDM!Class)

		)

	to o : R2ML!ObjectClassificationAtom (

				isNegated <- false,

				term <- thisModule.IndividualVariable2ObjectVariable(i.terms->first()),

				type <- thisModule.Class2Class(i.hasPredicateSymbol)

			)

}



rule Intersection2Conjuction {

	from i : RDM!Atom (

			i.name = 'ClassAtom' and i.hasPredicateSymbol.oclIsTypeOf(RDM!IntersectionClass)

		)

	to 

		o : R2ML!Conjuction (

				formulas <- Sequence { i.hasPredicateSymbol.intersectionOf->asSequence()->select(c | c.oclIsTypeOf(RDM!Class))->collect(e | e.transform(i.hasPredicateSymbol, thisModule.Class2Class(e))),

									   i.hasPredicateSymbol.intersectionOf->asSequence()->select(c | not c.oclIsTypeOf(RDM!Class))->asSequence()

							}

			)

}



rule UnionAtom2Disjunction {

	from i : RDM!Atom (

			i.name = 'ClassAtom' and i.hasPredicateSymbol.oclIsTypeOf(RDM!UnionClass)

		)

	to 

		o : R2ML!Disjunction (

				formulas <- Sequence { i.hasPredicateSymbol.unionOf->asSequence()->select(c | c.oclIsTypeOf(RDM!Class))->collect(e | e.transform(i.hasPredicateSymbol, thisModule.Class2Class(e))),

									   i.hasPredicateSymbol.unionOf->asSequence()->select(c | not c.oclIsTypeOf(RDM!Class))->asSequence()

							}

			)

}



rule Union2Disjunction {

	from i : RDM!UnionClass (

			i.oclIsTypeOf(RDM!UnionClass) and

			RDM!Atom.allInstancesFrom('IN')->asSequence()->collect(c | c.hasPredicateSymbol)->flatten()->excludes(i)

		)

	to 

		o : R2ML!Disjunction (

				formulas <- Sequence { i.unionOf->asSequence()->select(c | c.oclIsTypeOf(RDM!Class))->collect(e | e.transform(i, thisModule.Class2Class(e))),

									   i.unionOf->asSequence()->select(c | not c.oclIsTypeOf(RDM!Class))->asSequence()

							}

			)

}



rule Complement2Negation {

	from i : RDM!Atom (

			i.name = 'ClassAtom' and i.hasPredicateSymbol.oclIsTypeOf(RDM!ComplementClass)

		)

	to 

		o : R2ML!StrongNegation (

				formula <- if i.hasPredicateSymbol.complementOf.oclIsTypeOf(RDM!Class) then

							    i.hasPredicateSymbol.complementOf.transform(i.hasPredicateSymbol, thisModule.Class2Class(i.hasPredicateSymbol.complementOf))

							else i.hasPredicateSymbol.complementOf

							endif

			)	

}



rule EnumeratedClass2Disjunction {

	from i : RDM!EnumeratedClass (

			i.oclIsTypeOf(RDM!EnumeratedClass) and 

			RDM!Atom.allInstancesFrom('IN')->asSequence()->collect(c | c.hasPredicateSymbol)->flatten()->excludes(i)

		)

	to 

		o : R2ML!Disjunction (

				formulas <- i.oneOf

			)

}



rule EnumeratedClassAtom2Disjunction {

	from i : RDM!Atom (

			i.name = 'ClassAtom' and i.hasPredicateSymbol.oclIsTypeOf(RDM!EnumeratedClass)

		)

	to 

		o : R2ML!Disjunction (

				formulas <- i.hasPredicateSymbol.oneOf

			)

}



rule Individual2EqualityAtom {

	from i : RDM!Individual (

			RDM!EnumeratedClass.allInstancesFrom('IN')->asSequence()->collect(e | e.oneOf)->flatten()->includes(i)

		)

	to o : R2ML!EqualityAtom (

			terms <- Sequence{obj, thisModule.IndividualVariable2ObjectVariable(thisModule.getAtomForClassElement(i).terms->first())}

		),

		obj : R2ML!ObjectName (

			name <- i.name

			)

}



unique lazy rule Class2ObjectClassificationAtom {

	from i : RDM!Class 

	to o : R2ML!ObjectClassificationAtom (

				isNegated <- false,

				term <- thisModule.IndividualVariable2ObjectVariable(thisModule.getAtomForClassElement(i).terms->first()), 
				type <-	thisModule.Class2Class(i)

			)

}



unique lazy rule Class2Class {

	from i : RDM!Class 

	to cla : R2ML!Class (

				name <- i.name,

				predicateCategory <- #closed

			)

}



rule HasValueRestrictionClass2ReferencePropertyAtom {

	from i : RDM!HasValueRestriction (

			i.oclIsTypeOf(RDM!HasValueRestriction) and not i.hasValue.oclIsUndefined()

			and i.onProperty->asSequence()->first().oclIsTypeOf(RDM!ObjectProperty)

		)

	to o : R2ML!ReferencePropertyAtom (

		isNegated <- false,

		object <- thisModule.Individual2ObjectVariable(i.hasValue),

		referenceProperty <- i.onProperty->asSequence()->first(),

		subject <- thisModule.IndividualVariable2ObjectVariable(thisModule.getAtomForClassElement(i).terms->first())

		)

}



rule SomeValuesFromRestrictionClass2ExistentiallyQuantifiedFormula {

	from i : RDM!SomeValuesFromRestriction (

			i.oclIsTypeOf(RDM!SomeValuesFromRestriction) and not i.someValuesFromClass.oclIsUndefined()

		)

	to o : R2ML!ExistentiallyQuantifiedFormula (

			variables <- objVar,

			formula <- conj

		),

		objVar : R2ML!ObjectVariable (

				name <- 'x',

				typeCategory <- #individual

			),

		conj : R2ML!Conjuction (

				formulas <- if i.someValuesFromClass.oclIsTypeOf(RDM!Class) then

								Sequence {i.someValuesFromClass.transform(i, thisModule.Class2Class(i.someValuesFromClass)), refPropAt}

							else Sequence{ i.someValuesFromClass, refPropAt }

							endif

			),

		refPropAt : R2ML!ReferencePropertyAtom (

			isNegated <- false,

			subject <- thisModule.IndividualVariable2ObjectVariable(thisModule.getAtomForClassElement(i).terms->first()),

			object <- objVar,

			referenceProperty <- i.onProperty->asSequence()->first()

			)	

}



rule AllValuesFromRestrictionClass2UniversallyQuantifiedFormula {

	from i : RDM!AllValuesFromRestriction (

			i.oclIsTypeOf(RDM!AllValuesFromRestriction) and not i.allValuesFromClass.oclIsUndefined()

		)

	to o : R2ML!UniversallyQuantifiedFormula (

			variables <- objVar,

			formula <- impl

		),

		objVar : R2ML!ObjectVariable (

				name <- 'x',

				typeCategory <- #individual

			),

		impl : R2ML!Implication (

				antecedent <- refPropAt,

				consequent <- if i.allValuesFromClass.oclIsTypeOf(RDM!Class) then

								i.allValuesFromClass.transform(i, thisModule.Class2Class(i.allValuesFromClass))

							else i.allValuesFromClass

							endif

			),

		refPropAt : R2ML!ReferencePropertyAtom (

			isNegated <- false,

			subject <- thisModule.IndividualVariable2ObjectVariable(thisModule.getAtomForClassElement(i).terms->first()),

			object <- objVar,

			referenceProperty <- i.onProperty->asSequence()->first()

			)	

}



rule MinCardinalityRestrictionClass2AtLeastQuantifiedFormula {

	from i : RDM!MinCardinalityRestriction (

			i.oclIsTypeOf(RDM!MinCardinalityRestriction) and

			RDM!MaxCardinalityRestriction.allInstancesFrom('IN')->asSequence()->collect(c | c.onProperty)->flatten()->excludes(i.onProperty->asSequence()->first()) and

			i.onProperty->asSequence()->first().oclIsTypeOf(RDM!ObjectProperty)

		)

	to o : R2ML!AtLeastQuantifiedFormula (

		minCardinality <- i.minCardinality.lexicalForm.toInteger(),

		variables <- objVar,

		formula <- refPropAt

		),

		objVar : R2ML!ObjectVariable (

				name <- 'x',

				typeCategory <- #individual

		),

		refPropAt : R2ML!ReferencePropertyAtom (

			isNegated <- false,

			subject <- thisModule.IndividualVariable2ObjectVariable(thisModule.getAtomForClassElement(i).terms->first()),

			object <- objVar,

			referenceProperty <- i.onProperty->asSequence()->first()

		)		

}



rule MaxCardinalityRestrictionClass2AtLeastQuantifiedFormula {

	from i : RDM!MaxCardinalityRestriction (

			i.oclIsTypeOf(RDM!MaxCardinalityRestriction) and

			RDM!MinCardinalityRestriction.allInstancesFrom('IN')->asSequence()->collect(c | c.onProperty)->flatten()->excludes(i.onProperty->asSequence()->first()) and

			i.onProperty->asSequence()->first().oclIsTypeOf(RDM!ObjectProperty)

		)

	to o : R2ML!AtMostQuantifiedFormula (

		maxCardinality <- i.maxCardinality.lexicalForm.toInteger(),

		variables <- objVar,

		formula <- refPropAt

		),

		objVar : R2ML!ObjectVariable (

				name <- 'x',

				typeCategory <- #individual

		),

		refPropAt : R2ML!ReferencePropertyAtom (

			isNegated <- false,

			subject <- thisModule.IndividualVariable2ObjectVariable(thisModule.getAtomForClassElement(i).terms->first()),

			object <- objVar,

			referenceProperty <- i.onProperty->asSequence()->first()

		)		

}



rule MaxMinCardinalityRestrictionClass2AtLeastAndAtMostQuantifiedFormula {

	from i : RDM!MaxCardinalityRestriction (

			i.oclIsTypeOf(RDM!MaxCardinalityRestriction) and

			RDM!MinCardinalityRestriction.allInstancesFrom('IN')->asSequence()->collect(c | c.onProperty)->flatten()->includes(i.onProperty->asSequence()->first()) and

			i.onProperty->asSequence()->first().oclIsTypeOf(RDM!ObjectProperty) and

			RDM!Atom.allInstancesFrom('IN')->asSequence()->collect(c | c.hasPredicateSymbol)->flatten()->excludes(i.minCardinalityOnSameProperty)

		)

	to o : R2ML!AtLeastAndAtMostQuantifiedFormula (

			maxCardinality <- i.maxCardinality.lexicalForm.toInteger(),

			minCardinality <- i.minCardinalityOnSameProperty.minCardinality.lexicalForm.toInteger(),

			variables <- objVar,

			formula <- refPropAt

		),

		objVar : R2ML!ObjectVariable (

				name <- 'x',

				typeCategory <- #individual

		),

		refPropAt : R2ML!ReferencePropertyAtom (

			isNegated <- false,

			subject <- thisModule.IndividualVariable2ObjectVariable(thisModule.getAtomForClassElement(i).terms->first()),

			object <- objVar,

			referenceProperty <- i.onProperty->asSequence()->first()

		)		

}



rule MinMaxCardinalityRestrictionClass2AtLeastAndAtMostQuantifiedFormula {

	from i : RDM!MinCardinalityRestriction ( 
											 
			i.oclIsTypeOf(RDM!MinCardinalityRestriction) and

			RDM!MaxCardinalityRestriction.allInstancesFrom('IN')->asSequence()->collect(c | c.onProperty)->flatten()->includes(i.onProperty->asSequence()->first()) and

			i.onProperty->asSequence()->first().oclIsTypeOf(RDM!ObjectProperty) and

			RDM!Atom.allInstancesFrom('IN')->asSequence()->collect(c | c.hasPredicateSymbol)->flatten()->excludes(i.maxCardinalityOnSameProperty)

		)

	to o : R2ML!AtLeastAndAtMostQuantifiedFormula (

			maxCardinality <- i.maxCardinalityOnSameProperty.maxCardinality.lexicalForm.toInteger(),

			minCardinality <- i.minCardinality.lexicalForm.toInteger(),

			variables <- objVar,

			formula <- refPropAt

		),

		objVar : R2ML!ObjectVariable (

				name <- 'x',

				typeCategory <- #individual

		),

		refPropAt : R2ML!ReferencePropertyAtom (

			isNegated <- false,

			subject <- thisModule.IndividualVariable2ObjectVariable(thisModule.getAtomForClassElement(i).terms->first()),

			object <- objVar,

			referenceProperty <- i.onProperty->asSequence()->first()

		)		

}



rule CardinalityRestrictionClass2AtLeastAndAtMostQuantifiedFormula {

	from i : RDM!CardinalityRestriction (

			i.oclIsTypeOf(RDM!CardinalityRestriction) and i.onProperty->asSequence()->first().oclIsTypeOf(RDM!ObjectProperty)		

		)

	to o : R2ML!AtLeastAndAtMostQuantifiedFormula (

			maxCardinality <- i.cardinality.lexicalForm.toInteger(),

			minCardinality <- i.cardinality.lexicalForm.toInteger(),

			variables <- objVar,

			formula <- refPropAt

		),

		objVar : R2ML!ObjectVariable (

				name <- 'x',

				typeCategory <- #individual

		),

		refPropAt : R2ML!ReferencePropertyAtom (

			isNegated <- false,

			subject <- thisModule.IndividualVariable2ObjectVariable(thisModule.getAtomForClassElement(i).terms->first()),

			object <- objVar,

			referenceProperty <- i.onProperty->asSequence()->first()

		)		

}





rule DataRangeAtomOneOf2DataClassificationAtom {

	from i : RDM!Atom (

			i.name = 'DataRangeAtom' and 

			if i.hasPredicateSymbol.oclIsTypeOf(RDM!DataRange) then

				not i.hasPredicateSymbol.datatype.oclIsUndefined()

			else 

				false

			endif

		)

	to 

		o : R2ML!DataClassificationAtom (

				isNegated <- false,

				term <- thisModule.IndividualVariable2DataVariable(i.terms->first()),

				type <- if thisModule.getDefaultTypedLiteral(i.hasPredicateSymbol.datatype.name) <> OclUndefined

							then thisModule.TypedLiteral2Datatype( thisModule.getDefaultTypedLiteral(i.hasPredicateSymbol.datatype.name) )

							else thisModule.PrimitiveType2Datatype(i.hasPredicateSymbol.datatype)

						endif

				

				

			)

}



rule DataRange2DataClassificationAtom {

	from i : RDM!DataRange (

		i.oclIsTypeOf(RDM!DataRange) 

		and RDM!Atom.allInstancesFrom('IN')->asSequence()->collect(c | c.hasPredicateSymbol)->flatten()->excludes(i)

		and if i.datatype.oclIsUndefined() then

				 false

			else true

			endif

		)

	to o : R2ML!DataClassificationAtom (

				isNegated <- false,

				term <- thisModule.IndividualVariable2DataVariable(thisModule.getAtomForDataElement(i).terms->first()),

				type <- if thisModule.getDefaultTypedLiteral(i.datatype.name) <> OclUndefined

							then thisModule.TypedLiteral2Datatype( thisModule.getDefaultTypedLiteral(i.datatype.name) )

							else thisModule.PrimitiveType2Datatype(i.datatype)

						endif

			)

}



unique lazy rule PrimitiveType2Datatype {

	from i : RDM!PrimitiveType

	to o : R2ML!Datatype (

		predicateCategory <- #closed,

		name <- i.name

		)

}



rule DataRangeAtom2Disjunction {

	from i : RDM!Atom (

			i.name = 'DataRangeAtom' and 

			if i.hasPredicateSymbol.oclIsTypeOf(RDM!DataRange) then

				i.hasPredicateSymbol.datatype.oclIsUndefined()

			else 

				false

			endif

		)

	to 

		o : R2ML!Disjunction (

				formulas <- i.hasPredicateSymbol.oneOf

			)

}



rule DataRange2Disjunction {

	from i : RDM!DataRange (

		i.oclIsTypeOf(RDM!DataRange) and

		RDM!Atom.allInstancesFrom('IN')->asSequence()->collect(c | c.hasPredicateSymbol)->flatten()->excludes(i)

		and if i.datatype.oclIsUndefined() then

		       true

			else false

			endif

		)

	to o : R2ML!Disjunction (

				formulas <- i.oneOf

			)

}



rule PlainLiteral2PlainLiteral {

	from i : RDM!PlainLiteral (

		i.oclIsTypeOf(RDM!PlainLiteral) and RDM!DataRange.allInstancesFrom('IN')->asSequence()->select(e | not e.oneOf.oclIsUndefined())->collect(c | c.oneOf)->flatten()->excludes(i)

		)

	to o : R2ML!PlainLiteral (

		languageTag <- i.language,

		lexicalValue <- i.lexicalForm,

		typeCategory <- #individual

		)

}



rule TypedLiteral2TypedLiteral {

	from i : RDM!TypedLiteral (

			i.oclIsTypeOf(RDM!TypedLiteral) and RDM!DataRange.allInstancesFrom('IN')->asSequence()->select(e | not e.oneOf.oclIsUndefined())->collect(c | c.oneOf)->flatten()->excludes(i) and

			RDM!CardinalityRestriction.allInstancesFrom('IN')->asSequence()->collect(c | c.cardinality)->flatten()->excludes(i) and

			RDM!MinCardinalityRestriction.allInstancesFrom('IN')->asSequence()->collect(c | c.minCardinality)->flatten()->excludes(i) and

			RDM!MaxCardinalityRestriction.allInstancesFrom('IN')->asSequence()->collect(c | c.maxCardinality)->flatten()->excludes(i)

		)

	to o : R2ML!TypedLiteral (

		type <- thisModule.TypedLiteral2Datatype( thisModule.getDefaultTypedLiteral(i.theType) ),

		lexicalValue <- i.lexicalForm,

		typeCategory <- #individual

		)

}



unique lazy rule TypedLiteral2Datatype {

	from i : RDM!TypedLiteral

	to o : R2ML!Datatype (

		name <- i.theType,

		predicateCategory <- #closed

		)

}



rule PlainLiteral2DatatypePredicateAtom {

	from i : RDM!PlainLiteral (

		i.oclIsTypeOf(RDM!PlainLiteral) and RDM!DataRange.allInstancesFrom('IN')->asSequence()->select(e | not e.oneOf.oclIsUndefined())->collect(c | c.oneOf)->flatten()->includes(i)

		)

	to o : R2ML!DatatypePredicateAtom (

		isNegated <- false,

		dataArguments <- Sequence { pl, thisModule.IndividualVariable2DataVariable(thisModule.getAtomForDataElement(i).terms->first()) },

		predicate <- thisModule.PlainLiteral2DatatypePredicate(thisModule.getDefaultPlainLiteral())

		),

	    pl : R2ML!PlainLiteral (

	    	lexicalValue <- i.lexicalForm,

			typeCategory <- #individual

	    	)

}



rule TypedLiteral2DatatypePredicateAtom {

	from i : RDM!TypedLiteral (

		i.oclIsTypeOf(RDM!TypedLiteral) and RDM!DataRange.allInstancesFrom('IN')->asSequence()->select(e | not e.oneOf.oclIsUndefined())->collect(c | c.oneOf)->flatten()->includes(i)

		)

	to o : R2ML!DatatypePredicateAtom (

		isNegated <- false,

		dataArguments <- Sequence { pl, thisModule.IndividualVariable2DataVariable(thisModule.getAtomForDataElement(i).terms->first()) },

		predicate <- thisModule.TypedLiteral2DatatypePredicate( thisModule.getDefaultTypedLiteral(i.theType) )

		),

	    pl : R2ML!TypedLiteral (

	    	lexicalValue <- i.lexicalForm,

			type <- thisModule.TypedLiteral2Datatype( thisModule.getDefaultTypedLiteral(i.theType) ),

			typeCategory <- #individual

	    	)

}



unique lazy rule TypedLiteral2DatatypePredicate {

	from i : RDM!TypedLiteral

	to o : R2ML!DatatypePredicate (

		   	name <- 'swrlb:equal',

			predicateCategory <- #closed

	   	)

}



unique lazy rule PlainLiteral2DatatypePredicate {

	from i : RDM!PlainLiteral

	to o : R2ML!DatatypePredicate (

		   	name <- 'swrlb:equal',

			predicateCategory <- #closed

	   	)

}



unique lazy rule DatatypeProperty2Attribute {

	from i : RDM!DatatypeProperty

	to o : R2ML!Attribute(

		name <- i.name,

		predicateCategory <- #closed

		)

}



rule AllValuesFromRestrictionData2UniversallyQuantifiedFormula {

	from i : RDM!AllValuesFromRestriction (

			i.oclIsTypeOf(RDM!AllValuesFromRestriction) and not i.allValuesFromRange.oclIsUndefined()

		)

	to o : R2ML!UniversallyQuantifiedFormula (

			variables <- objVar,

			formula <- impl

		),

		objVar : R2ML!ObjectVariable (

				name <- 'x',

				typeCategory <- #individual

			),

		impl : R2ML!Implication (

				antecedent <- attrAt,

				consequent <- i.allValuesFromRange

			),

		attrAt : R2ML!AttributionAtom (

			isNegated <- false,

			attribute <- thisModule.DatatypeProperty2Attribute(i.onProperty->asSequence()->first()),

			subject <- objVar,

			dataValue <- thisModule.IndividualVariable2DataVariable(thisModule.getAtomForDataElement(i).terms->first())

			)

		

}



rule SomeValuesFromRestrictionData2ExistentiallyQuantifiedFormula {

	from i : RDM!SomeValuesFromRestriction (

			i.oclIsTypeOf(RDM!SomeValuesFromRestriction) and not i.someValuesFromRange.oclIsUndefined()

		)

	to o : R2ML!ExistentiallyQuantifiedFormula (

			variables <- objVar,

			formula <- conj

		),

		objVar : R2ML!ObjectVariable (

				name <- 'x',

				typeCategory <- #individual

			),

		conj : R2ML!Conjuction (

				formulas <- Sequence{i.someValuesFromRange, attrAt}

			),

		attrAt : R2ML!AttributionAtom (

			isNegated <- false,

			attribute <- thisModule.DatatypeProperty2Attribute(i.onProperty->asSequence()->first()),

			subject <- objVar,

			dataValue <- thisModule.IndividualVariable2DataVariable(thisModule.getAtomForDataElement(i).terms->first())

			)

}



rule HasValueRestrictionData2AttributeAtom {

	from i : RDM!HasValueRestriction (

			i.oclIsTypeOf(RDM!HasValueRestriction) and not i.hasLiteralValue.oclIsUndefined()

		)

	to o : R2ML!AttributionAtom (

			isNegated <- false,

			attribute <- thisModule.DatatypeProperty2Attribute(i.onProperty->asSequence()->first()),

			subject <- thisModule.IndividualVariable2ObjectVariable(thisModule.getAtomForDataElement(i).terms->first()),

			dataValue <- i.hasLiteralValue

			)

}



rule MinCardinalityRestrictionData2AtLeastQuantifiedFormula {

	from i : RDM!MinCardinalityRestriction (

			i.oclIsTypeOf(RDM!MinCardinalityRestriction) and

			RDM!MaxCardinalityRestriction.allInstancesFrom('IN')->asSequence()->collect(c | c.onProperty)->flatten()->excludes(i.onProperty->asSequence()->first()) and

			i.onProperty->asSequence()->first().oclIsTypeOf(RDM!DatatypeProperty)

		)

	to o : R2ML!AtLeastQuantifiedFormula (

		minCardinality <- i.minCardinality.lexicalForm.toInteger(),

		variables <- objVar,

		formula <- attrAt

		),

		objVar : R2ML!ObjectVariable (

				name <- 'x',

				typeCategory <- #individual

		), 

	   attrAt: R2ML!AttributionAtom (

	   		isNegated <- false,

			attribute <- thisModule.DatatypeProperty2Attribute(i.onProperty->asSequence()->first()),

			subject <- objVar,

			dataValue <- thisModule.IndividualVariable2DataVariable(thisModule.getAtomForDataElement(i).terms->first())

			)

}



rule MaxCardinalityRestrictionData2AtLeastQuantifiedFormula {

	from i : RDM!MaxCardinalityRestriction (

			i.oclIsTypeOf(RDM!MaxCardinalityRestriction) and

			RDM!MinCardinalityRestriction.allInstancesFrom('IN')->asSequence()->collect(c | c.onProperty)->flatten()->excludes(i.onProperty->asSequence()->first()) and

			i.onProperty->asSequence()->first().oclIsTypeOf(RDM!DatatypeProperty)

		)

	to o : R2ML!AtMostQuantifiedFormula (

		maxCardinality <- i.maxCardinality.lexicalForm.toInteger(),

		variables <- objVar,

		formula <- attrAt

		),

		objVar : R2ML!ObjectVariable (

				name <- 'x',

				typeCategory <- #individual

		), 

	   attrAt: R2ML!AttributionAtom (

		   	isNegated <- false,

			attribute <- thisModule.DatatypeProperty2Attribute(i.onProperty->asSequence()->first()),

			subject <- objVar,

			dataValue <- thisModule.IndividualVariable2DataVariable(thisModule.getAtomForDataElement(i).terms->first())

			)		

}



rule MinMaxCardinalityRestrictionData2AtLeastAndAtMostQuantifiedFormula {

	from i : RDM!MinCardinalityRestriction ( 
											 
			i.oclIsTypeOf(RDM!MinCardinalityRestriction) and

			RDM!MaxCardinalityRestriction.allInstancesFrom('IN')->asSequence()->collect(c | c.onProperty)->flatten()->includes(i.onProperty->asSequence()->first()) and

			RDM!Atom.allInstancesFrom('IN')->asSequence()->collect(c | c.hasPredicateSymbol)->flatten()->excludes(i.maxCardinalityOnSameProperty) and

			i.onProperty->asSequence()->first().oclIsTypeOf(RDM!DatatypeProperty)

		)

	to o : R2ML!AtLeastAndAtMostQuantifiedFormula (

			maxCardinality <- i.maxCardinalityOnSameProperty.maxCardinality.lexicalForm.toInteger(),

			minCardinality <- i.minCardinality.lexicalForm.toInteger(),

			variables <- objVar,

			formula <- attrAt

		),

		objVar : R2ML!ObjectVariable (

				name <- 'x',

				typeCategory <- #individual

		), 

	    attrAt: R2ML!AttributionAtom (

	    	isNegated <- false,

			attribute <- thisModule.DatatypeProperty2Attribute(i.onProperty->asSequence()->first()),

			subject <- objVar,

			dataValue <- thisModule.IndividualVariable2DataVariable(thisModule.getAtomForDataElement(i).terms->first())

			)		

}



rule MaxMinCardinalityRestrictionData2AtLeastAndAtMostQuantifiedFormula {

	from i : RDM!MaxCardinalityRestriction ( 

			i.oclIsTypeOf(RDM!MaxCardinalityRestriction) and

			RDM!MinCardinalityRestriction.allInstancesFrom('IN')->asSequence()->collect(c | c.onProperty)->flatten()->includes(i.onProperty->asSequence()->first()) and

			RDM!Atom.allInstancesFrom('IN')->asSequence()->collect(c | c.hasPredicateSymbol)->flatten()->excludes(i.minCardinalityOnSameProperty) and

			i.onProperty->asSequence()->first().oclIsTypeOf(RDM!DatatypeProperty)

		)

	to o : R2ML!AtLeastAndAtMostQuantifiedFormula (

			maxCardinality <- i.maxCardinality.lexicalForm.toInteger(),

			minCardinality <- i.minCardinalityOnSameProperty.minCardinality.lexicalForm.toInteger(),

			variables <- objVar,

			formula <- attrAt

		),

		objVar : R2ML!ObjectVariable (

				name <- 'x',

				typeCategory <- #individual

		), 

	    attrAt: R2ML!AttributionAtom (

	    	isNegated <- false,

			attribute <- thisModule.DatatypeProperty2Attribute(i.onProperty->asSequence()->first()),

			subject <- objVar,

			dataValue <- thisModule.IndividualVariable2DataVariable(thisModule.getAtomForDataElement(i).terms->first())

			)		

}



rule CardinalityRestrictionData2AtLeastAndAtMostQuantifiedFormula {

	from i : RDM!CardinalityRestriction (

			i.oclIsTypeOf(RDM!CardinalityRestriction) and i.onProperty->asSequence()->first().oclIsTypeOf(RDM!DatatypeProperty)

		)

	to o : R2ML!AtLeastAndAtMostQuantifiedFormula (

			maxCardinality <- i.cardinality.lexicalForm.toInteger(),

			minCardinality <- i.cardinality.lexicalForm.toInteger(),

			variables <- objVar,

			formula <- attrAt

		),

		objVar : R2ML!ObjectVariable (

				name <- 'x',

				typeCategory <- #individual

		),  

	    attrAt: R2ML!AttributionAtom (

	    	isNegated <- false,

			attribute <- thisModule.DatatypeProperty2Attribute(i.onProperty->asSequence()->first()),

			subject <- objVar,

			dataValue <- thisModule.IndividualVariable2DataVariable(thisModule.getAtomForDataElement(i).terms->first())

			)	

}





rule DataValuedPropertyAtom2AttributeAtom {

	from i : RDM!Atom (

		i.name = 'DataValuedPropertyAtom'

	)

	to o : R2ML!AttributionAtom (

			isNegated <- false,

			attribute <- thisModule.DatatypeProperty2Attribute(i.hasPredicateSymbol),

			subject <- thisModule.IndividualVariable2ObjectVariable(i.terms->select(e | e.oclIsKindOf(RDM!IndividualVariable))->first()),

			dataValue <- if i.terms->select(c | c.oclIsTypeOf(RDM!DataValue))->size() > 0 then

						 i.terms->select(c | c.oclIsTypeOf(RDM!DataValue))->collect(e | thisModule.DataValue2TypedLiteral(e))->first()

					 else

					     i.terms->select(c | c.oclIsTypeOf(RDM!DataVariable))->collect(e | thisModule.DataVariable2DataVariable(e))->first()

				     endif

		)

}



lazy rule DataValue2TypedLiteral {

	from i : RDM!DataValue

	to o : R2ML!TypedLiteral (

			lexicalValue <- i.value,

			type <- thisModule.PrimitiveType2Datatype(i.type),

			typeCategory <- #individual

		)

}





rule SameIndividualAtom2EqualityAtom {

	from i : RDM!Atom (

		i.name = 'SameIndividualAtom'

	)

	to o : R2ML!EqualityAtom (

			terms <- Sequence { i.terms->select(e | e.oclIsTypeOf(RDM!IndividualVariable))->collect(c | thisModule.IndividualVariable2ObjectVariable(c)),

								i.terms->select(e | e.oclIsTypeOf(RDM!Individual))->collect(c | thisModule.Individual2ObjectVariable(c))

					 }

		) 

}





rule DifferentIndividualAtom2InequalityAtom {

	from i : RDM!Atom (

		i.name = 'DifferentIndividualAtom'

	)

	to o : R2ML!InequalityAtom (

			terms <-  Sequence { i.terms->select(e | e.oclIsTypeOf(RDM!IndividualVariable))->collect(c | thisModule.IndividualVariable2ObjectVariable(c)),

								 i.terms->select(e | e.oclIsTypeOf(RDM!Individual))->collect(c | thisModule.Individual2ObjectVariable(c))

					  }

		)

}





rule BuiltinAtom2DatatypePredicateAtom {

	from i : RDM!Atom (

		i.name = 'BuiltinAtom'

	)

	to o : R2ML!DatatypePredicateAtom (

		isNegated <- false,

		dataArguments <- Sequence { i.terms->select(e | e.oclIsKindOf(RDM!DataVariable))->collect(c | thisModule.DataVariable2DataVariable(c)),

									i.terms->select(e | e.oclIsKindOf(RDM!DataValue))->collect(c | thisModule.DataValue2TypedLiteral(c))							

						},		     

		predicate <- thisModule.BuiltIn2DatatypePredicate(i.hasPredicateSymbol)

		)

}



unique lazy rule BuiltIn2DatatypePredicate {

	from i : RDM!BuiltIn 

	to o : R2ML!DatatypePredicate (

		name <- i.buildInID

		)

}





rule IndividualPropertyAtom2ReferencePropertyAtom{

	from i : RDM!Atom (

		i.name = 'IndividualPropertyAtom'

	)

	to refpropat : R2ML!ReferencePropertyAtom (

				isNegated <- false,

				referenceProperty <- i.hasPredicateSymbol,

				subject <- if i.terms->last().oclIsTypeOf(RDM!IndividualVariable) then

							thisModule.IndividualVariable2ObjectVariable(i.terms->last())

						   else thisModule.Individual2ObjectVariable(i.terms->last())

						   endif,

				object <- thisModule.IndividualVariable2ObjectVariable(i.terms->first())

			)	

}



rule ObjectProperty2ReferenceProperty {

	from i : RDM!ObjectProperty

	to o : R2ML!ReferenceProperty (

			predicateCategory <- #closed,

			name <- i.name

		)

}



rule DatatypeProperty2ReferenceProperty {

	from i : RDM!DatatypeProperty

	to o : R2ML!ReferenceProperty (

			predicateCategory <- #closed,

			name <- i.name

		)

}

	

rule Rule2Implication {

	from i : RDM!Rule 

	to  ir : R2ML!AlethicIntegrityRule (

				constraint <- o

			),

			o : R2ML!UniversallyQuantifiedFormula (

					
					variables <- let atoms : Sequence (RDM!Atom) = i.getAllAtoms() in

								Sequence { atoms->select(c | c.name = 'ClassAtom')->collect(e | e.terms)->flatten()->collect(c | thisModule.IndividualVariable2ObjectVariable(c)),

										   atoms->select(c | c.name = 'DataValuedPropertyAtom')->collect(e | e.terms)->flatten()->select(e | e.oclIsKindOf(RDM!IndividualVariable))->collect(c | thisModule.IndividualVariable2ObjectVariable(c)),

										   atoms->select(c | c.name = 'DataValuedPropertyAtom')->collect(e | e.terms)->flatten()->select(e | e.oclIsKindOf(RDM!DataVariable))->collect(c | thisModule.DataVariable2DataVariable(c)),

										   atoms->select(c | c.name = 'SameIndividualAtom')->collect(e | e.terms)->flatten()->select(e | e.oclIsKindOf(RDM!IndividualVariable))->collect(c | thisModule.IndividualVariable2ObjectVariable(c)),

										   atoms->select(c | c.name = 'SameIndividualAtom')->collect(e | e.terms)->flatten()->select(e | e.oclIsKindOf(RDM!Individual))->collect(c | thisModule.Individual2ObjectVariable(c)),

					  					   atoms->select(c | c.name = 'DifferentIndividualAtom')->collect(e | e.terms)->flatten()->select(e | e.oclIsKindOf(RDM!IndividualVariable))->collect(c | thisModule.IndividualVariable2ObjectVariable(c)),

										   atoms->select(c | c.name = 'DifferentIndividualAtom')->collect(e | e.terms)->flatten()->select(e | e.oclIsKindOf(RDM!Individual))->collect(c | thisModule.Individual2ObjectVariable(c)),

										   atoms->select(c | c.name = 'IndividualPropertyAtom')->collect(e | e.terms)->flatten()->select(e | e.oclIsKindOf(RDM!IndividualVariable))->collect(c | thisModule.IndividualVariable2ObjectVariable(c)),

										   atoms->select(c | c.name = 'DataRangeAtom')->collect(e | e.terms)->flatten()->select(e | e.oclIsKindOf(RDM!IndividualVariable))->collect(c | thisModule.IndividualVariable2DataVariable(c)),

										   atoms->select(c | c.name = 'BuiltinAtom')->collect(e | e.terms)->flatten()->select(e | e.oclIsKindOf(RDM!DataVariable))->collect(c | thisModule.DataVariable2DataVariable(c))										

										},

					formula <- imp

				),

			imp : R2ML!Implication (

				antecedent <- if i.hasAntecedent.containsAtom->size() > 1

	 				  	 	  then i.hasAntecedent

						      else if i.hasAntecedent.containsAtom->asSequence()->first().hasPredicateSymbol.oclIsKindOf(RDM!Restriction) then

							  		i.hasAntecedent.containsAtom->asSequence()->first().hasPredicateSymbol

									else i.hasAntecedent.containsAtom->asSequence()->first()

									endif

						      endif,

				consequent <- if i.hasConsequent.containsAtom->size() > 1

					  	      then i.hasConsequent

					  	      else if i.hasConsequent.containsAtom->asSequence()->first().hasPredicateSymbol.oclIsKindOf(RDM!Restriction) then

								  	i.hasConsequent.containsAtom->asSequence()->first().hasPredicateSymbol

								   else i.hasConsequent.containsAtom->asSequence()->first()

								   endif	

					  	      endif

		)

}



endpoint rule RuleBase() {

     to rb : R2ML!RuleBase (

				rules <- Sequence { rs }

			),

    rs : R2ML!IntegrityRuleSet (

				rules <- RDM!Rule.allInstancesFrom('IN')->asSequence()

			)

}





rule Antecedent2Conjuction {

	from i : RDM!Antecedent (

			i.containsAtom->size () > 1

		)

	to o : R2ML!Conjuction (

			formulas <- Sequence{ i.containsAtom->select(c | c.hasPredicateSymbol.oclIsKindOf(RDM!Restriction))->collect(c | c.hasPredicateSymbol)->flatten(),

  								  i.containsAtom->select(c | not c.hasPredicateSymbol.oclIsKindOf(RDM!Restriction))			

								}

		)

}



rule Consequent2Conjuction {

	from i : RDM!Consequent (

			i.containsAtom->size () > 1

		)

	to o : R2ML!Conjuction (

			formulas <- Sequence{ i.containsAtom->select(c | c.hasPredicateSymbol.oclIsKindOf(RDM!Restriction))->collect(c | c.hasPredicateSymbol)->flatten(),

  								  i.containsAtom->select(c | not c.hasPredicateSymbol.oclIsKindOf(RDM!Restriction))			

								}

		)

}



unique lazy rule IndividualVariable2ObjectVariable {

	from i : RDM!IndividualVariable

	to o : R2ML!ObjectVariable (

			name <- i.name,

			classRef <- if not i.classRef.oclIsUndefined() then

							thisModule.Class2Class(i.classRef)

						else OclUndefined

						endif

		)		

}



unique lazy rule Individual2ObjectVariable {

	from i : RDM!Individual

	to o : R2ML!ObjectVariable (

			name <- i.name,

			typeCategory <- #individual,

			classRef <- if not i.type.oclIsUndefined() then

							thisModule.Class2Class(i.type)

						else OclUndefined

						endif 

		)		

}



unique lazy rule IndividualVariable2DataVariable {

	from i : RDM!IndividualVariable

	to o : R2ML!DataVariable (

			name <- i.name,

			typeCategory <- #individual

		)		

}



unique lazy rule DataVariable2DataVariable {

	from i : RDM!DataVariable

	to o : R2ML!DataVariable (

			name <- i.name,

			typeCategory <- #individual

		)		

}
