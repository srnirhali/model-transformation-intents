,Unnamed: 0,Name,Content,cleaned,Category
0,0,P1-Ant2Maven.atl,"module Ant2Maven;
create OUTMaven : MavenMaven ,OUTProject : MavenProject  from IN : Ant;

-- central element : Project
-- two files to create : MavenMaven (representing maven.xml)
--						and MavenProject (representing project.xml)
rule AntProject2Maven{
		from a : Ant!Project(
		if a.description.oclIsUndefined() 
			then false
			else not (a.description='')
			endif
	)
		-- for MavenProject
		to mp : MavenProject!Project(
			    id <- a.name,
			    name <- a.name,
				description <- a.description,
				build <- mpBuild
				),
			 mpBuild : MavenProject!Build(
				sourceDirectory <- a.basedir,
				defaultGoal <- a.default.name
				),
		-- for MavenMaven
			mm : MavenMaven!Project(
				xmlns <- itsXmlns,
				default <- a.default,
				path <- a.path,
				properties <- a.properties,
				taskdefs <- a.taskdef,
				goals <- a.targets
			 	),
			itsXmlns : MavenMaven!Xmlns(
				name <- 'ant',
				value <- 'jelly:ant'
			)
}

rule AntProject2MavenWithoutDescription{
		from a : Ant!Project(
		if a.description.oclIsUndefined() 
			then true
			else a.description=''
			endif
	)
		-- for MavenProject
		to mp : MavenProject!Project(
			    id <- a.name,
			    name <- a.name,
				build <- mpBuild
				),
			 mpBuild : MavenProject!Build(
				sourceDirectory <- a.basedir,
				defaultGoal <- a.default.name
				),
		-- for MavenMaven
			mm : MavenMaven!Project(
				xmlns <- itsXmlns,
				default <- a.default,
				path <- a.path,
				properties <- a.properties,
				taskdefs <- a.taskdef,
				goals <- a.targets--,
			--	prePostGoals <- a.targets -> select(e|not e.depends.oclIsUndefined() and e.depends->size()>0)
			 	),
			itsXmlns : MavenMaven!Xmlns(
				name <- 'ant',
				value <- 'jelly:ant'
			)
}

-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-- rules only for Maven.xml (meta model : MavenMaven)

 -- goals
-- rule AntTarget2MavenMavenGoal2{
--	from a : Ant!Target(
--		a.depends.oclIsUndefined() or a.depends->size()=0
--	)
--	to mg : MavenMaven!Goal(
--		name <- a.name,
--		contentsGoal <- a.tasks
--		)
-- }

rule AntTarget2MavenMavenGoal{
	from a : Ant!Target
	using {
		itsDependencies : Sequence(Ant!Target) = a.depends->asSequence();
	}
	to mg : MavenMaven!Goal(
		name <- a.name,
		contentsGoal <- Sequence{dependencies,a.tasks}
		),
	dependencies : distinct MavenMaven!AttainGoal foreach(g in itsDependencies) (
		attainGoal <- g
	)
 }
 
------------------------------------------------------------------------------------
------------------------------------------------------------------------------------
------------------------------------------------------------------------------------
-- for the following rules : simple copy
-----------------------------------------------------------
-- copy of Ant Properties

rule AntPropertyValue2MavenMavenAntPropertyValue{
	from a : Ant!PropertyValue
	to m : MavenMaven!AntPropertyValue(
		name <- a.name,
		value <- a.value
	)
}

rule AntPropertyLocation2MavenMavenAntPropertyLocation{
	from a : Ant!PropertyLocation
	to m : MavenMaven!AntPropertyLocation(
		name <- a.name,
		location <- a.location
	)
}


rule AntPropertyFile2MavenMavenAntPropertyFile{
	from a : Ant!PropertyFile
	to m : MavenMaven!AntPropertyFile(
		file <- a.file)
}

rule AntPropertyEnv2MavenMavenAntPropertyEnv{
	from a : Ant!PropertyEnv
	to m : MavenMaven!AntPropertyEnv(
		environment <- a.environment)
}

----------------------------------------------------------------------------------------
-- copy of tasks

------------------------------------------------------
-- java tasks
rule AntJava2MavenMavenJava{
	from a : Ant!Java
	to m : MavenMaven!Java(
		classname <- a.classname,
		jar <- a.jar,
		fork <- a.fork,
  		classPath <- a.classPath
	)
}

rule AntJavac2MavenMavenJavac{
	from a : Ant!Javac
	to m : MavenMaven!Javac(
		destdir <- a.destdir,
		srcdir <- a.srcdir,
  		classPath <- a.classPath,
		inExcludes <- a.inExcludes
	)
}

rule AntJavadoc2MavenMavenJavadoc{
	from a : Ant!Javadoc
	to m : MavenMaven!Javadoc(
	 	sourcepath <- a.sourcepath,
  		destdir <- a.destdir,
  		packagenames <- a.packagenames,
  		defaultexcludes <- a.defaultexcludes,
  		author <- a.author,
  		version <- a.version,
  		use <- a.use,
  		windowtitle <- a.windowtitle
	)
}

---------------------------------------------------------
-- MANAGEMENT PROPERTIES tasks 
rule AntTstamp2MavenMavenTstamp{
    from a : Ant!Tstamp
	to m : MavenMaven!Tstamp()
}

---------------------------------------------------------
-- MANAGEMENT ARCHIVE tasks 
rule AntJar2MavenMavenJar{
	from a : Ant!Jar
	to m : MavenMaven!Jar(
		jarfile <- a.jarfile,
		basedir <- a.basedir)
}

---------------------------------------------------------
-- MANAGEMENT FILES tasks 
rule AntMkdir2MavenMavenMkdir{
	from a : Ant!Mkdir
	to m : MavenMaven!Mkdir(
		dir <- a.dir)
}

rule AntCopy2MavenMavenCopy{
	from a : Ant!Copy
	to m : MavenMaven!Copy(
		todir <- a.todir,
		fileset <- a.fileset,
		filterset <- a.filterset
	)
}


rule AntDelete2MavenMavenDelete{
	from a : Ant!Delete
	to m : MavenMaven!Delete(
		dir <- a.dir)
}

------------------------------------------------------------
-- tasks defined by the user
rule AntTaskDef2MavenMavenTaskDef{
	from a : Ant!TaskDef
	to m : MavenMaven!AntTaskDef(
		name <- a.name,
		classname <- a.classname
	)
}

rule AntNewTask2MavenMavenNewTask{
	from a : Ant!NewTask
	to m : MavenMaven!NewTask(
		taskName <- a.taskName,
		attributes <- a.attributes
	)
}

rule AntAttribut2MavenMavenAttribut{
	from a : Ant!Attribut
	to m : MavenMaven!Attribut(
		name <- a.name,
		value <- a.value
	)
}
-------------------------------------------------------------------------------------
-- copy for Path

 rule AntPath2MavenMavenPath{
	from a : Ant!Path
	to mm : MavenMaven!Path(
		id <- a.id,
		refid <- a.refid,
		fileset <- a.fileset,
		path <- a.path,
	 	pathElement <- a.pathElement
	)
}

 rule AntClassPath2MavenMavenClassPath{
	from a : Ant!ClassPath
	to mm : MavenMaven!ClassPath(
		refid <- a.refid,
		pathElement <- a.pathElement,
        fileset <- a.fileset
	)
 }
 
rule AntPathElement2MavenMavenPathElement{
	from a : Ant!PathElement
	to mm : MavenMaven!PathElement(
		path <- a.path,
		location <- a.location
	)
}

rule AntFileSet2MavenMavenFileSet{
	from a : Ant!FileSet
	to m : MavenMaven!FileSet(
		dir <- a.dir,
        patternset <- a.patternset,
        include <- a.include,
        exclude <- a.exclude
	)
}

-- filters
rule AntFilterSet2MavenMavenFilterSet{
	from a : Ant!FilterSet
	to m : MavenMaven!FilterSet(
		starttoken <- a.starttoken,
   		endtoken <- a.endtoken,
		filter <- a.filter,
		filtersfile <- a.filtersfile
	)
}

rule AntFilter2MavenMavenFilter{
	from a : Ant!Filter
	to m : MavenMaven!Filter(
		token <- a.token,
		value <- a.value
	)
}

rule AntFiltersFile2MavenMavenFiltersFile{
	from a : Ant!FiltersFile
	to m : MavenMaven!FiltersFile(
		file <- a.file
	)
}

-- pattern
rule AntPatternset2MavenMavenPatternset{
	from a : Ant!PatternSet
	to m : MavenMaven!PatternSet(
		inexcludes <- a.inexcludes
	)
}
 

 rule AntIncludes2MavenMavenIncludes{
	from a : Ant!Includes
	to m : MavenMaven!Includes(
		name <- a.name,
		ifCondition <- a.ifCondition,
		unless <- a.unless
	)
}
 
rule AntExcludes2MavenMavenExcludes{
	from a : Ant!Excludes
	to m : MavenMaven!Excludes(
		name <- a.name,
		ifCondition <- a.ifCondition,
		unless <- a.unless
		)
}

rule AntIncludesFile2MavenMavenIncludesFile{
	from a : Ant!IncludesFile
	to m : MavenMaven!IncludesFile(
		name <- a.name,
		ifCondition <- a.ifCondition,
		unless <- a.unless
	)
}

rule AntExcludesFile2MavenMavenExcludesFile{
	from a : Ant!ExcludesFile
	to m : MavenMaven!ExcludesFile(
		name <- a.name,
		ifCondition <- a.ifCondition,
		unless <- a.unless
		)
}",modul ant maven creat outmaven mavenmaven outproject mavenproject in ant central element project two file creat mavenmaven repres maven xml mavenproject repres project xml rule antproject maven ant project descript oclisundefin fals els descript endif mavenproject mp mavenproject project id name name name descript descript build mpbuild mpbuild mavenproject build sourcedirectori basedir defaultgo default name mavenmaven mm mavenmaven project xmlns itsxmln default default path path properti properti taskdef taskdef goal target itsxmln mavenmaven xmlns name ant valu jelli ant rule antproject mavenwithoutdescript ant project descript oclisundefin true els descript endif mavenproject mp mavenproject project id name name name build mpbuild mpbuild mavenproject build sourcedirectori basedir defaultgo default name mavenmaven mm mavenmaven project xmlns itsxmln default default path path properti properti taskdef taskdef goal target prepostgo target select e e depend oclisundefin e depend size itsxmln mavenmaven xmlns name ant valu jelli ant rule maven xml meta model mavenmaven goal rule anttarget mavenmavengo ant target depend oclisundefin depend size mg mavenmaven goal name name contentsgo task rule anttarget mavenmavengo ant target use itsdepend sequenc ant target depend assequ mg mavenmaven goal name name contentsgo sequenc depend task depend distinct mavenmaven attaingo foreach g itsdepend attaingo g follow rule simpl copi copi ant properti rule antpropertyvalu mavenmavenantpropertyvalu ant propertyvalu mavenmaven antpropertyvalu name name valu valu rule antpropertyloc mavenmavenantpropertyloc ant propertyloc mavenmaven antpropertyloc name name locat locat rule antpropertyfil mavenmavenantpropertyfil ant propertyfil mavenmaven antpropertyfil file file rule antpropertyenv mavenmavenantpropertyenv ant propertyenv mavenmaven antpropertyenv environ environ copi task java task rule antjava mavenmavenjava ant java mavenmaven java classnam classnam jar jar fork fork classpath classpath rule antjavac mavenmavenjavac ant javac mavenmaven javac destdir destdir srcdir srcdir classpath classpath inexclud inexclud rule antjavadoc mavenmavenjavadoc ant javadoc mavenmaven javadoc sourcepath sourcepath destdir destdir packagenam packagenam defaultexclud defaultexclud author author version version use use windowtitl windowtitl manag properti task rule anttstamp mavenmaventstamp ant tstamp mavenmaven tstamp manag archiv task rule antjar mavenmavenjar ant jar mavenmaven jar jarfil jarfil basedir basedir manag file task rule antmkdir mavenmavenmkdir ant mkdir mavenmaven mkdir dir dir rule antcopi mavenmavencopi ant copi mavenmaven copi todir todir fileset fileset filterset filterset rule antdelet mavenmavendelet ant delet mavenmaven delet dir dir task defin user rule anttaskdef mavenmaventaskdef ant taskdef mavenmaven anttaskdef name name classnam classnam rule antnewtask mavenmavennewtask ant newtask mavenmaven newtask tasknam tasknam attribut attribut rule antattribut mavenmavenattribut ant attribut mavenmaven attribut name name valu valu copi path rule antpath mavenmavenpath ant path mm mavenmaven path id id refid refid fileset fileset path path pathel pathel rule antclasspath mavenmavenclasspath ant classpath mm mavenmaven classpath refid refid pathel pathel fileset fileset rule antpathel mavenmavenpathel ant pathel mm mavenmaven pathel path path locat locat rule antfileset mavenmavenfileset ant fileset mavenmaven fileset dir dir patternset patternset includ includ exclud exclud filter rule antfilterset mavenmavenfilterset ant filterset mavenmaven filterset starttoken starttoken endtoken endtoken filter filter filtersfil filtersfil rule antfilt mavenmavenfilt ant filter mavenmaven filter token token valu valu rule antfiltersfil mavenmavenfiltersfil ant filtersfil mavenmaven filtersfil file file pattern rule antpatternset mavenmavenpatternset ant patternset mavenmaven patternset inexclud inexclud rule antinclud mavenmaveninclud ant includ mavenmaven includ name name ifcondit ifcondit unless unless rule antexclud mavenmavenexclud ant exclud mavenmaven exclud name name ifcondit ifcondit unless unless rule antincludesfil mavenmavenincludesfil ant includesfil mavenmaven includesfil name name ifcondit ifcondit unless unless rule antexcludesfil mavenmavenexcludesfil ant excludesfil mavenmaven excludesfil name name ifcondit ifcondit unless unless,0
1,1,P1-Maven2XML.atl,"module Maven2XML;
create  XML1 : XMLMaven  , XML2 : XMLProject 
			from InMaven : MavenMaven, InProject : MavenProject;

-- In this module, the two files are transformed in XML
-- but there is no link in the transformation

-- helper getXmlnsAux : returns the name of the Xmlns element having
-- the same value that given in parameter
helper def:getXmlnsAux(name: String): String =
	MavenMaven!Xmlns.allInstances() ->
		select(e|e.value=name)->first().name;

-- helper getXmlns : returns the prefix corresponding to name
helper def:getXmlns(name: String): String =
	let completeValue: String = thisModule.getXmlnsAux(name)in
	if completeValue.size()>0
		then completeValue+':'
		else ''
		endif;

-- rules for the file representing maven.xml

-- central rule for maven.xml
rule MavenMavenProject2XMLMavenRoot{
	from i : MavenMaven!Project
	to o : XMLMaven!Root(
		name <- 'project',
		children <- Sequence {i.xmlns,goalDefault,
								i.path,i.properties,i.taskdefs,
								i.prePostGoals,i.goals}
	),
	goalDefault : XMLMaven!Attribute (
		name <- 'default',
		value <- i.default.name
	)
	
}


rule Xmlns{
	from i : MavenMaven!Xmlns
	to o:XMLMaven!Attribute(
		name <- 'xmlns:'+i.name,
		value <- i.value
	)
}
------------------------------------------------------------------------------------
-- Antproperty

rule PropertyValue{
	from i : MavenMaven!AntPropertyValue
	to o : XMLMaven!Element(
		name <- thisModule.getXmlns('jelly:ant')+'property',
		children <- Sequence{propertyName2,propertyValue}
	),
	propertyName2 : XMLMaven!Attribute(
		name <- 'name',
		value <- i.name
	),
	propertyValue : XMLMaven!Attribute(
		name <- 'value',
		value <- i.value
	)
}
rule PropertyLocation{
	from i : MavenMaven!AntPropertyLocation
	to o : XMLMaven!Element(
		name <- thisModule.getXmlns('jelly:ant')+'property',
		children <- Sequence{propertyName2,propertyLocation}
	),
	propertyName2 : XMLMaven!Attribute(
		name <- 'name',
		value <- i.name
	),
	propertyLocation : XMLMaven!Attribute(
		name <- 'location',
		value <- i.location
	)
}

rule PropertyFile{
	from i : MavenMaven!AntPropertyFile
	to o : XMLMaven!Element(
		name <- thisModule.getXmlns('jelly:ant')+'property',
		children <- nameFile
	),
	nameFile : XMLMaven!Attribute(
		name <- 'file',
		value <- i.file
	)
}

rule PropertyEnv{
	from i : MavenMaven!AntPropertyEnv
	to o : XMLMaven!Element(
		name <- thisModule.getXmlns('jelly:ant')+'property',
		children <- environmentName
	),
	environmentName : XMLMaven!Attribute(
		name <- 'environment',
		value <- i.environment
	)
}

------------------------------------------------------------------------------------------------
-- goal
rule Goal{
	from i : MavenMaven!Goal
	to o : XMLMaven!Element(
		name <- 'goal',
		children <- Sequence{nameAttribute,i.contentsGoal}
	),
	nameAttribute : XMLMaven!Attribute(
		name <- 'name',
		value <- i.name
	)
}

rule AttainGoal{
	from i : MavenMaven!AttainGoal
	to o : XMLMaven!Element (
		name <- 'attainGoal',
		children <- attainGoalAttribute
	),
	attainGoalAttribute : XMLMaven!Attribute (
		name <- 'name',
		value <- i.attainGoal.name
	)
}


rule PreGoal{
	from i : MavenMaven!PreGoal
	to o : XMLMaven!Element(
		name <- 'preGoal',
		children <- Sequence{nameAttribute,i.contentsGoal}
	),
	nameAttribute : XMLMaven!Attribute(
		name <- 'name',
		value <- i.centralGoal.name
	)
}


rule PostGoal{
	from i : MavenMaven!PostGoal
	to o : XMLMaven!Element(
		name <- 'postGoal',
		children <- Sequence{nameAttribute,i.contentsGoal}
	),
	nameAttribute : XMLMaven!Attribute(
		name <- 'name',
		value <- i.centralGoal.name
	)
}
--------------------------------------------------------------------------------
-- jelly commands

rule JellySet{
	from i:MavenMaven!JellySet
	to o : XMLMaven!Element(
		name <- thisModule.getXmlns('jelly:core')+'set',
		children <- Sequence{varAttribute,valueAttribute}
	),
	varAttribute : XMLMaven!Attribute(
		name <- 'var',
		value <- i.var
	),
	valueAttribute : XMLMaven!Attribute(
		name <- 'value',
		value <- i.value
	)
}


------------------------------------------------------------------------
-- tasks

------------------------------------------------------------------------
-- task defined by the user
rule TaskDef{
	from i : MavenMaven!AntTaskDef
	to o : XMLMaven!Element(
		name <- thisModule.getXmlns('jelly:ant')+'taskdef',
		children <- Sequence{nameName,nameClassName}
	),
	nameName : XMLMaven!Attribute(
		name <- 'name',
		value <- i.name
	),
	nameClassName : XMLMaven!Attribute(
		name <- 'classname',
		value <- i.classname
	)
}

rule NewTask{
	from i : MavenMaven!NewTask
	to o : XMLMaven!Element(
		name <- i.taskName.name,
		children <- i.attributes
	)
}

rule Attribut{
	from i : MavenMaven!Attribut
	to o : XMLMaven!Attribute(
		name <- i.name,
		value <- i.value
	)
}

----------------------
-- pre defined tasks

rule Tstamp{
	from i : MavenMaven!Tstamp
	to o : XMLMaven!Element(
		name <- thisModule.getXmlns('jelly:ant')+'tstamp'
	)
}

rule Mkdir{
	from i : MavenMaven!Mkdir
	to o : XMLMaven!Element(
		name <- thisModule.getXmlns('jelly:ant')+'mkdir',
		children <- dirAttribute
	),
	dirAttribute : XMLMaven!Attribute(
		name <- thisModule.getXmlns('jelly:ant')+'dir',
		value <- i.dir
	)
}

rule Javac{
	from i : MavenMaven!Javac
	to o : XMLMaven!Element(
		name <- thisModule.getXmlns('jelly:ant')+'javac',
		children <- Sequence{sourceDirAttribute,destDirAttribute,i.inExcludes,i.classPath}
	),
	sourceDirAttribute : XMLMaven!Attribute(
		name <- 'srcdir',
		value <- i.srcdir
	),
	destDirAttribute : XMLMaven!Attribute(
		name <- 'destdir',
		value <- i.destdir
	)
}

rule Copy{
	from i : MavenMaven!Copy
	to o : XMLMaven!Element(
		name <- thisModule.getXmlns('jelly:ant')+'copy',
		children <- Sequence{toDirAttribute,i.fileset}
	),
	toDirAttribute : XMLMaven!Attribute(
		name <- 'todir',
		value <- i.todir
	)
}



--------------------------------------------------------------------------------------------
-- path,pattern and filter (like ANT2XML)
rule Path{
	from i : MavenMaven!Path
	to o : XMLMaven!Element(
		name <- thisModule.getXmlns('jelly:ant')+'path',
		children <- Sequence{idAttribute,i.fileset,i.path,i.pathElement}
	),
	idAttribute : XMLMaven!Attribute(
		name <- 'id',
		value <- i.id
	)
}

rule ClassPath{
	from i : MavenMaven!ClassPath
	to o : XMLMaven!Element(
		name <- thisModule.getXmlns('jelly:ant')+'classpath',
		children <- refidAttribute),
	refidAttribute : XMLMaven!Attribute(
		name <- 'refid',
		value <- i.refid
	)
}

rule Fileset{
	from i : MavenMaven!FileSet
	to o : XMLMaven!Element(
		name <- thisModule.getXmlns('jelly:ant')+'fileset',
		children <- Sequence{dirAttribute,i.patternset,i.include,i.exclude}
	),
	dirAttribute : XMLMaven!Attribute(
		name <- 'dir',
		value <- i.dir
	)
}

rule PathElement{
	from i : MavenMaven!PathElement
	to o : XMLMaven!Element(
		name <- thisModule.getXmlns('jelly:ant')+'pathelement'
	)
}

rule PatternSet{
	from i : MavenMaven!PatternSet
	to o : XMLMaven!Element(
		name <- thisModule.getXmlns('jelly:ant')+'patternset',
		children <- i.inexcludes
	)
}

rule Include{
	from i : MavenMaven!Includes
	to o : XMLMaven!Element(
		name <- thisModule.getXmlns('jelly:ant')+'include',
		children <- nameAttribute
	),
	nameAttribute : XMLMaven!Attribute(
		name <- 'name',
		value <- i.name
	)
}

rule Exclude{
	from i : MavenMaven!Excludes
	to o : XMLMaven!Element(
		name <- thisModule.getXmlns('jelly:ant')+'exclude',
		children <- nameAttribute
	),
	nameAttribute : XMLMaven!Attribute(
		name <- 'name',
		value <- i.name
	)
}



------------------------------------------------------------------------
------------------------------------------------------------------------
-- rules for the file representing project.xml

-- central rule for project.xml
rule MavenProjectProject2XMLProjectRoot{
	from i : MavenProject!Project(
		if i.description.oclIsUndefined() 
			then false
			else not (i.description='')
			endif
	)
	to o : XMLProject!Root(
		name <- 'project',
		children <- Sequence{idAttribute,nameAttribute,descriptionElement,i.build}
	),
	 idAttribute : XMLProject!Attribute(
		name <- 'id',
		value <- i.id
	),
	 nameAttribute : XMLProject!Attribute(
		name <- 'name',
		value <- i.name
	),
	descriptionElement : XMLProject!Element(
		name <- 'description',
		children <- descriptionText
	),
	descriptionText : XMLProject!Text(
		value <- i.description
	)
}

rule MavenProjectProject2XMLProjectRootWithoutDescription{
	from i : MavenProject!Project(
		if i.description.oclIsUndefined() 
			then true
			else i.description=''
			endif
	)
	to o : XMLProject!Root(
		name <- 'project',
		children <- Sequence{idAttribute,nameAttribute,i.build}
	),
	 idAttribute : XMLProject!Attribute(
		name <- 'id',
		value <- i.id
	),
	 nameAttribute : XMLProject!Attribute(
		name <- 'name',
		value <- i.name
	)
}


rule MavenProjectDescription{
	from i : MavenProject!Description
	to o : XMLProject!Element(
		name <- 'description',
		children <- textText
	),
	textText : XMLProject!Text(
		value <- i.description
	)
}

rule MavenProjectBuild{
	from i : MavenProject!Build
	to o : XMLProject!Element(
		name <- 'build',
		children <- Sequence{defaultGoalElement,sourceDirectoryElement}
	),
	defaultGoalElement : XMLProject!Element(
		name <- 'defaultGoal',
		children <- defaultGoalText
	),
	defaultGoalText : XMLProject!Text(
		value <- i.defaultGoal
	),
	sourceDirectoryElement : XMLProject!Element(
		name <- 'sourceDirectory',
		children <- sourceDirectoryText
	),
	sourceDirectoryText : XMLProject!Text(
		value <- i.sourceDirectory
	)
}",modul maven xml creat xml xmlmaven xml xmlproject inmaven mavenmaven inproject mavenproject in modul two file transform xml link transform helper getxmlnsaux return name xmlns element valu given paramet helper def getxmlnsaux name string string mavenmaven xmlns allinst select e e valu name first name helper getxmln return prefix correspond name helper def getxmln name string string let completevalu string thismodul getxmlnsaux name completevalu size completevalu els endif rule file repres maven xml central rule maven xml rule mavenmavenproject xmlmavenroot mavenmaven project xmlmaven root name project children sequenc xmlns goaldefault path properti taskdef prepostgo goal goaldefault xmlmaven attribut name default valu default name rule xmlns mavenmaven xmlns xmlmaven attribut name xmlns name valu valu antproperti rule propertyvalu mavenmaven antpropertyvalu xmlmaven element name thismodul getxmln jelli ant properti children sequenc propertynam propertyvalu propertynam xmlmaven attribut name name valu name propertyvalu xmlmaven attribut name valu valu valu rule propertyloc mavenmaven antpropertyloc xmlmaven element name thismodul getxmln jelli ant properti children sequenc propertynam propertyloc propertynam xmlmaven attribut name name valu name propertyloc xmlmaven attribut name locat valu locat rule propertyfil mavenmaven antpropertyfil xmlmaven element name thismodul getxmln jelli ant properti children namefil namefil xmlmaven attribut name file valu file rule propertyenv mavenmaven antpropertyenv xmlmaven element name thismodul getxmln jelli ant properti children environmentnam environmentnam xmlmaven attribut name environ valu environ goal rule goal mavenmaven goal xmlmaven element name goal children sequenc nameattribut contentsgo nameattribut xmlmaven attribut name name valu name rule attaingo mavenmaven attaingo xmlmaven element name attaingo children attaingoalattribut attaingoalattribut xmlmaven attribut name name valu attaingo name rule pregoal mavenmaven pregoal xmlmaven element name pregoal children sequenc nameattribut contentsgo nameattribut xmlmaven attribut name name valu centralgo name rule postgoal mavenmaven postgoal xmlmaven element name postgoal children sequenc nameattribut contentsgo nameattribut xmlmaven attribut name name valu centralgo name jelli command rule jellyset mavenmaven jellyset xmlmaven element name thismodul getxmln jelli core set children sequenc varattribut valueattribut varattribut xmlmaven attribut name var valu var valueattribut xmlmaven attribut name valu valu valu task task defin user rule taskdef mavenmaven anttaskdef xmlmaven element name thismodul getxmln jelli ant taskdef children sequenc namenam nameclassnam namenam xmlmaven attribut name name valu name nameclassnam xmlmaven attribut name classnam valu classnam rule newtask mavenmaven newtask xmlmaven element name tasknam name children attribut rule attribut mavenmaven attribut xmlmaven attribut name name valu valu pre defin task rule tstamp mavenmaven tstamp xmlmaven element name thismodul getxmln jelli ant tstamp rule mkdir mavenmaven mkdir xmlmaven element name thismodul getxmln jelli ant mkdir children dirattribut dirattribut xmlmaven attribut name thismodul getxmln jelli ant dir valu dir rule javac mavenmaven javac xmlmaven element name thismodul getxmln jelli ant javac children sequenc sourcedirattribut destdirattribut inexclud classpath sourcedirattribut xmlmaven attribut name srcdir valu srcdir destdirattribut xmlmaven attribut name destdir valu destdir rule copi mavenmaven copi xmlmaven element name thismodul getxmln jelli ant copi children sequenc todirattribut fileset todirattribut xmlmaven attribut name todir valu todir path pattern filter like ant xml rule path mavenmaven path xmlmaven element name thismodul getxmln jelli ant path children sequenc idattribut fileset path pathel idattribut xmlmaven attribut name id valu id rule classpath mavenmaven classpath xmlmaven element name thismodul getxmln jelli ant classpath children refidattribut refidattribut xmlmaven attribut name refid valu refid rule fileset mavenmaven fileset xmlmaven element name thismodul getxmln jelli ant fileset children sequenc dirattribut patternset includ exclud dirattribut xmlmaven attribut name dir valu dir rule pathel mavenmaven pathel xmlmaven element name thismodul getxmln jelli ant pathel rule patternset mavenmaven patternset xmlmaven element name thismodul getxmln jelli ant patternset children inexclud rule includ mavenmaven includ xmlmaven element name thismodul getxmln jelli ant includ children nameattribut nameattribut xmlmaven attribut name name valu name rule exclud mavenmaven exclud xmlmaven element name thismodul getxmln jelli ant exclud children nameattribut nameattribut xmlmaven attribut name name valu name rule file repres project xml central rule project xml rule mavenprojectproject xmlprojectroot mavenproject project descript oclisundefin fals els descript endif xmlproject root name project children sequenc idattribut nameattribut descriptionel build idattribut xmlproject attribut name id valu id nameattribut xmlproject attribut name name valu name descriptionel xmlproject element name descript children descriptiontext descriptiontext xmlproject text valu descript rule mavenprojectproject xmlprojectrootwithoutdescript mavenproject project descript oclisundefin true els descript endif xmlproject root name project children sequenc idattribut nameattribut build idattribut xmlproject attribut name id valu id nameattribut xmlproject attribut name name valu name rule mavenprojectdescript mavenproject descript xmlproject element name descript children texttext texttext xmlproject text valu descript rule mavenprojectbuild mavenproject build xmlproject element name build children sequenc defaultgoalel sourcedirectoryel defaultgoalel xmlproject element name defaultgo children defaultgoaltext defaultgoaltext xmlproject text valu defaultgo sourcedirectoryel xmlproject element name sourcedirectori children sourcedirectorytext sourcedirectorytext xmlproject text valu sourcedirectori,0
2,2,P1-XML2Ant.atl,"module XML2Ant;
create OUT : Ant from IN : XML;


----------------------------------------------------------------------------------
-- helper : to extract a list of String from a String

-- extract a sequence of String from the String listString in the same order
-- (two elements are separated by a comma)
helper def:getList(listString : String):Sequence(String)=
	if(listString.size()=0)
		then Sequence{}
		else thisModule.getListAux(listString,1,1,Sequence{})
		endif;

-- index1 : begin of the word
-- index2 : compteur
helper def:getListAux(listString : String,index1 : Integer,index2 : Integer,provSequence : Sequence(String)):Sequence(String)=
	if (listString.size()<index2)
		then provSequence -> append(listString.substring(index1,index2-1))
		else
			if (listString.substring(index2,index2)=',')
				then thisModule.getListAux(listString,index2+1,index2+1, provSequence -> append(listString.substring(index1,index2-1)))
				else thisModule.getListAux(listString,index1,index2+1, provSequence)
			endif
	endif;


------------------------------------------------------------------------------------------
-- helper : to get an attribute

-- returns the value of the attribute 'name' (without test of existence)
helper context XML!Element def: getAttrVal(name : String) : String =
    self.children->
		select(c | c.oclIsKindOf(XML!Attribute) and c.name = name)
			->first().value;

-- returns true if the attribute 'name' is defined
helper context XML!Element def: testAttribute(name : String) : Boolean =
	not (self.children -> select(d | d.oclIsKindOf(XML!Attribute) and d.name = name)->
		first().oclIsUndefined());


-- returns the value of the attribute given in parameter
-- returns '' if this attribute does not exist
helper context XML!Element def:getAttribute(name : String):String = 
	if (self.testAttribute(name))
		then self.getAttrVal(name)
		else ''
		endif;

--------------------------------------------------------------------------------
-- others helpers

-- returns true if the element 'name' is defined
helper context XML!Element def: testElement(name : String) : Boolean =
	not (self.children -> select(d | d.oclIsKindOf(XML!Element) and d.name = name)->
		first().oclIsUndefined());



-- returns the value  of a text belonging to an element 'name'
-- return '' if the element does not exist
helper context XML!Element def: getText(name : String) : String =
	if self.testElement(name) then
    	self.children->
			select(c | c.oclIsKindOf(XML!Element) and c.name=name) ->
				first().children ->
					select(c | c.oclIsKindOf(XML!Text)) -> 
						first().value
	else ''
	endif;


--------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------
--									RULES											--


-- central rule
rule Root2Project{
	from i : XML!Root
	to o : Ant!Project(
		name <- i.getAttribute('name'),
		basedir <- i.getAttribute('basedir'),
		description <- i.getText('description'),
		default <-  XML!Element.allInstances() ->
			select(d |  d.name = 'target' 
				and d.getAttribute('name')=i.getAttribute('default')) ->
					first(),
		path <- i.children ->
			select(d | d.oclIsKindOf(XML!Element) and d.name = 'path')
				-> first(),
		properties <- i.children ->
			select(d | d.oclIsKindOf(XML!Element) and d.name = 'property'),
		taskdef <- i.children ->
			select(d | d.oclIsKindOf(XML!Element) and d.name = 'taskdef'),
		targets <- i.children ->
			select(d | d.oclIsKindOf(XML!Element) and d.name = 'target')
	)
}

---------------------------------------------------------------------
-- properties

rule PropertyLocation{
	from i : XML!Element(
		i.name = 'property' and
		i.testAttribute('location')
	)
	to o : Ant!PropertyLocation(
		name <- i.getAttribute('name'),
		location <- i.getAttribute('location')
	)
}

rule PropertyValue{
	from i : XML!Element(
		i.name = 'property' and
		i.testAttribute('value')
	)
	to o : Ant!PropertyValue(
		name <- i.getAttribute('name'),
		value <- i.getAttribute('value')
	)
}

rule PropertyFile{
	from i : XML!Element(
		i.name = 'property' and
		i.testAttribute('file')
	)
	to o : Ant!PropertyFile(
		file <- i.getAttribute('file')
	)
}

rule PropertyEnv{
	from i : XML!Element(
		i.name = 'property' and
		i.testAttribute('environment')
	)
	to o : Ant!PropertyEnv(
		environment <- i.getAttribute('environment')
	)
}


---------------------------------------------------------------
-- target
rule Target{
	from i : XML!Element(
		i.name = 'target'
	)
	to o : Ant!Target(
		name <- i.getAttribute('name'),
		description <- i.getAttribute('description'),
		ifCondition <- i.getAttribute('if'),
		unless <- i.getAttribute('unless'),
		depends <-  XML!Element.allInstances() ->
			select(d |  d.name = 'target' 
				and thisModule.getList(i.getAttribute('depends'))->
						includes( d.getAttribute('name'))),
		tasks <- i.children ->
			select(d | d.oclIsKindOf(XML!Element))
	)
}



-----------------------------------------------------------------
-- tasks
-----------------------------------------------------------------
-- concerning the taks defined by the user

-- definition of the task
rule TaskDef{
	from i : XML!Element(
		i.name = 'taskdef'
	)
	to o : Ant!TaskDef(
		name <- i.getAttribute('name'),
		classname <- i.getAttribute('classname')
	)
}

-- call of a task created by the user
rule NewTask{
	from i : XML!Element(
		-- this task must be defined
		not(XML!Element.allInstances() ->
			select(d |  d.name = 'taskdef' 
				and d.getAttribute('name')=i.name) ->
					isEmpty())
	)
	to o : Ant!NewTask(
		-- reference to the definition of this task
		taskName <- XML!Element.allInstances() ->
			select(d |  d.name = 'taskdef' 
				and d.getAttribute('name')=i.name) ->
					first(),
		-- its attributes
		attributes <- i.children ->
			select(d | d.oclIsKindOf(XML!Attribute))
	)
}


rule Attribut{
	from i : XML!Attribute(
		not(XML!Element.allInstances() ->
			select(d |  d.name = 'taskdef' 
				and d.getAttribute('name')=i.parent.name) ->
					isEmpty())
	)
	to o : Ant!Attribut(
		name <- i.name,
		value<- i.value
	)
}


---------------------------------------------------------------------
-- pre defined tasks

rule Mkdir{
	from i : XML!Element(
		i.name = 'mkdir'
	)
	to o : Ant!Mkdir(
		dir <- i.getAttribute('dir')
	)
}

rule Tstamp{
	from i : XML!Element(
		i.name = 'tstamp'
	)
	to o : Ant!Tstamp()
}

rule Java{
	from i : XML!Element(
		i.name = 'java'
	)
	to o : Ant!Java(
		classname <- i.getAttribute('classname'),
		jar <- i.getAttribute('jar'),
		fork <- i.getAttribute('fork'),
  		classPath <- i.children ->
			select(d | d.oclIsKindOf(XML!Element) and d.name = 'classpath')
	)
}

rule Javac{
	from i : XML!Element(
		i.name = 'javac'
	)
	to o : Ant!Javac(
		destdir <- i.getAttribute('destdir'),
		srcdir <- i.getAttribute('srcdir'),
  		classPath <- i.children ->
			select(d | d.oclIsKindOf(XML!Element) and d.name = 'classpath')->
				first(),
		inExcludes <- i.children ->
			select(d | d.oclIsKindOf(XML!Element) and (d.name = 'include' or d.name = 'exclude'))
	)
}

rule Javadoc{
	from i : XML!Element(
		i.name = 'javadoc'
	)
	to o : Ant!Javadoc(
	 	sourcepath <- i.getAttribute('sourcepath'),
  		destdir <- i.getAttribute('destdir'),
  		packagenames <- i.getAttribute('packagenames'),
  		defaultexcludes <- i.getAttribute('defaultexcludes'),
  		author <- i.getAttribute('author'),
  		version <- i.getAttribute('version'),
  		use <- i.getAttribute('use'),
  		windowtitle <- i.getAttribute('windowtitle')
	)
}

rule Copy{
	from i : XML!Element(
		i.name = 'copy'
	)
	to o : Ant!Copy(
		todir <- i.getAttribute('todir'),
		fileset <- i.children ->
			select(d | d.oclIsKindOf(XML!Element) and d.name = 'fileset') ->
				first(),
		filterset <- i.children ->
			select(d | d.oclIsKindOf(XML!Element) and d.name = 'filterset') ->
				first()
	)
}

rule Delete{
	from i : XML!Element(
		i.name = 'delete'
	)
	to o : Ant!Delete(
		dir <- i.getAttribute('dir')
	)
}

rule Jar{
	from i : XML!Element(
		i.name = 'jar'
	)
	to o : Ant!Jar(
		jarfile <- i.getAttribute('jarfile'),
		basedir <- i.getAttribute('basedir')
	)
}

------------------------------------------------------------------------------
-- path, file and pattern

rule Path{
	from i : XML!Element(
		i.name = 'path')
	to o : Ant!Path(
		id <- i.getAttribute('id'),
		refid <- i.getAttribute('refid'),
		fileset <- i.children ->
			select(d | d.oclIsKindOf(XML!Element) and d.name = 'fileset')
	)
}

rule FileSet{
	from i : XML!Element(
		i.name = 'fileset'
	)
	to o : Ant!FileSet(
		dir <- i.getAttribute('dir'),
		patternset <- i.children ->
			select(d | d.oclIsKindOf(XML!Element) and d.name = 'patternset'),
		include <- i.children ->
			select(d | d.oclIsKindOf(XML!Element) and d.name = 'include'),
		exclude <- i.children ->
			select(d | d.oclIsKindOf(XML!Element) and d.name = 'exclude')
	)
}

rule PatternSet{
	from i : XML!Element(
		i.name = 'patternset'
	)
	to o : Ant!PatternSet(
		inexcludes <- i.children ->
			select(d | d.oclIsKindOf(XML!Element) and (d.name = 'exclude' or d.name='include'))
	)
}

rule ClassPath{
	from i : XML!Element(
		i.name = 'classpath'
	)
	to o : Ant!ClassPath(
		refid <- i.getAttribute('refid'),
		pathElement <- i.children ->
			select(d | d.oclIsKindOf(XML!Element) and d.name = 'pathElement'),
        fileset <- i.children ->
			select(d | d.oclIsKindOf(XML!Element) and d.name = 'fileset')
	)
 }
  
rule PathElement{
	from i : XML!Element(
		i.name = 'pathelement'
	)
	to o : Ant!PathElement(
		path <- i.getAttribute('path'),
		location <- i.getAttribute('location')
	)
}



rule FilterSet{
	from i : XML!Element(
		i.name = 'filterset'
	)
	to o : Ant!FilterSet(
		starttoken <- i.getAttribute('starttoken'),
   		endtoken <- i.getAttribute('endtoken'),
		filter <- i.children ->
			select(d | d.oclIsKindOf(XML!Element) and d.name = 'filter'),
		filtersfile <- i.children ->
			select(d | d.oclIsKindOf(XML!Element) and d.name = 'filtersfile')
	)
}

rule Filter{
	from i : XML!Element(
		i.name = 'filter'
	)
	to o : Ant!Filter(
		token <- i.getAttribute('token'),
		value <- i.getAttribute('value')
	)
}

rule FiltersFile{
	from i : XML!Element(
		i.name = 'filtersfile'
	)
	to o : Ant!FiltersFile(
		file <- i.getAttribute('file')
	)
}

rule Includes{
	from i : XML!Element(
		i.name = 'include'
	)
	to o : Ant!Includes(
		name <- i.getAttribute('name'),
		ifCondition <- i.getAttribute('if'),
		unless <- i.getAttribute('unless')
	)
}

rule Excludes{
	from i : XML!Element(
		i.name = 'exclude'
	)
	to o : Ant!Excludes(
		name <- i.getAttribute('name'),
		ifCondition <- i.getAttribute('if'),
		unless <- i.getAttribute('unless')
	)
}

rule IncludesFile{
	from i : XML!Element(
		i.name = 'includesfile'
	)
	to o: Ant!IncludesFile(
		name <- i.getAttribute('name'),
		ifCondition <- i.getAttribute('if'),
		unless <- i.getAttribute('unless')
	)
}

rule ExcludesFile{
	from i : XML!Element(
		i.name = 'excludesfile'
	)
	to o : Ant!ExcludesFile(
		name <- i.getAttribute('name'),
		ifCondition <- i.getAttribute('if'),
		unless <- i.getAttribute('unless')
	)
}",modul xml ant creat out ant in xml helper extract list string string extract sequenc string string liststr order two element separ comma helper def getlist liststr string sequenc string liststr size sequenc els thismodul getlistaux liststr sequenc endif index begin word index compteur helper def getlistaux liststr string index integ index integ provsequ sequenc string sequenc string liststr size index provsequ append liststr substr index index els liststr substr index index thismodul getlistaux liststr index index provsequ append liststr substr index index els thismodul getlistaux liststr index index provsequ endif endif helper get attribut return valu attribut name without test exist helper context xml element def getattrv name string string self children select c c ocliskindof xml attribut c name name first valu return true attribut name defin helper context xml element def testattribut name string boolean self children select ocliskindof xml attribut name name first oclisundefin return valu attribut given paramet return attribut exist helper context xml element def getattribut name string string self testattribut name self getattrv name els endif other helper return true element name defin helper context xml element def testel name string boolean self children select ocliskindof xml element name name first oclisundefin return valu text belong element name return element exist helper context xml element def gettext name string string self testel name self children select c c ocliskindof xml element c name name first children select c c ocliskindof xml text first valu els endif rule central rule rule root project xml root ant project name getattribut name basedir getattribut basedir descript gettext descript default xml element allinst select name target getattribut name getattribut default first path children select ocliskindof xml element name path first properti children select ocliskindof xml element name properti taskdef children select ocliskindof xml element name taskdef target children select ocliskindof xml element name target properti rule propertyloc xml element name properti testattribut locat ant propertyloc name getattribut name locat getattribut locat rule propertyvalu xml element name properti testattribut valu ant propertyvalu name getattribut name valu getattribut valu rule propertyfil xml element name properti testattribut file ant propertyfil file getattribut file rule propertyenv xml element name properti testattribut environ ant propertyenv environ getattribut environ target rule target xml element name target ant target name getattribut name descript getattribut descript ifcondit getattribut unless getattribut unless depend xml element allinst select name target thismodul getlist getattribut depend includ getattribut name task children select ocliskindof xml element task concern tak defin user definit task rule taskdef xml element name taskdef ant taskdef name getattribut name classnam getattribut classnam call task creat user rule newtask xml element task must defin xml element allinst select name taskdef getattribut name name isempti ant newtask refer definit task tasknam xml element allinst select name taskdef getattribut name name first attribut attribut children select ocliskindof xml attribut rule attribut xml attribut xml element allinst select name taskdef getattribut name parent name isempti ant attribut name name valu valu pre defin task rule mkdir xml element name mkdir ant mkdir dir getattribut dir rule tstamp xml element name tstamp ant tstamp rule java xml element name java ant java classnam getattribut classnam jar getattribut jar fork getattribut fork classpath children select ocliskindof xml element name classpath rule javac xml element name javac ant javac destdir getattribut destdir srcdir getattribut srcdir classpath children select ocliskindof xml element name classpath first inexclud children select ocliskindof xml element name includ name exclud rule javadoc xml element name javadoc ant javadoc sourcepath getattribut sourcepath destdir getattribut destdir packagenam getattribut packagenam defaultexclud getattribut defaultexclud author getattribut author version getattribut version use getattribut use windowtitl getattribut windowtitl rule copi xml element name copi ant copi todir getattribut todir fileset children select ocliskindof xml element name fileset first filterset children select ocliskindof xml element name filterset first rule delet xml element name delet ant delet dir getattribut dir rule jar xml element name jar ant jar jarfil getattribut jarfil basedir getattribut basedir path file pattern rule path xml element name path ant path id getattribut id refid getattribut refid fileset children select ocliskindof xml element name fileset rule fileset xml element name fileset ant fileset dir getattribut dir patternset children select ocliskindof xml element name patternset includ children select ocliskindof xml element name includ exclud children select ocliskindof xml element name exclud rule patternset xml element name patternset ant patternset inexclud children select ocliskindof xml element name exclud name includ rule classpath xml element name classpath ant classpath refid getattribut refid pathel children select ocliskindof xml element name pathel fileset children select ocliskindof xml element name fileset rule pathel xml element name pathel ant pathel path getattribut path locat getattribut locat rule filterset xml element name filterset ant filterset starttoken getattribut starttoken endtoken getattribut endtoken filter children select ocliskindof xml element name filter filtersfil children select ocliskindof xml element name filtersfil rule filter xml element name filter ant filter token getattribut token valu getattribut valu rule filtersfil xml element name filtersfil ant filtersfil file getattribut file rule includ xml element name includ ant includ name getattribut name ifcondit getattribut unless getattribut unless rule exclud xml element name exclud ant exclud name getattribut name ifcondit getattribut unless getattribut unless rule includesfil xml element name includesfil ant includesfil name getattribut name ifcondit getattribut unless getattribut unless rule excludesfil xml element name excludesfil ant excludesfil name getattribut name ifcondit getattribut unless getattribut unless,0
3,3,P1-XML2Text.atl,"query XML2Text = XML!Root.allInstances()
		->asSequence()
		->first().toString2('').writeTo('YourDirectory\\maven.xml');


helper context XML!Element def: toString2(indent : String) : String =
	let na : Sequence(XML!Node) =
		self.children->select(e | not e.oclIsKindOf(XML!Attribute)) in
	let a : Sequence(XML!Node) =
		self.children->select(e | e.oclIsKindOf(XML!Attribute)) in
	indent + '<' + self.name + 
	a->iterate(e; acc : String = '' |
		acc + ' ' + e.toString2()
	) +
	if na->size() > 0 then
		'>'
		+ na->iterate(e; acc : String = '' |
			acc + 
			if e.oclIsKindOf(XML!Text) then
				''
			else
				'\r\n'
			endif
			+ e.toString2(indent + '  ')
		) +
		if na->first().oclIsKindOf(XML!Text) then
			'</' + self.name + '>'
			else
				'\r\n' + indent + '</' + self.name + '>'
		endif
	else
		'/>'
	endif;

	
helper context XML!Attribute def: toString2() : String =
	if (self.value.oclIsUndefined())or(self.value='')
		then ''
		else self.name + '=\""' + self.value + '\""'
		endif;
--self.name + '=\""' + self.value + '\""';

helper context XML!Text def: toString2() : String =
	self.value;
",queri xml text xml root allinst assequ first tostr writeto yourdirectori maven xml helper context xml element def tostr indent string string let na sequenc xml node self children select e e ocliskindof xml attribut let sequenc xml node self children select e e ocliskindof xml attribut indent self name iter e acc string acc e tostr na size na iter e acc string acc e ocliskindof xml text els r n endif e tostr indent na first ocliskindof xml text self name els r n indent self name endif els endif helper context xml attribut def tostr string self valu oclisundefin self valu els self name self valu endif self name self valu helper context xml text def tostr string self valu,5
4,4,P10-RedundantInheritance-context.atl,"-- @name		Remove redundant inheritance
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		Baudry Julien (jul.baudry<at>gmail.com)
-- @date		2006/08/02
-- @description	The purpose of this transformation is to remove redundant inheritance.
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 2.3, page 15
-- @see author of article : K. Lano

module RedundantInheritance; 
create OUT : KM3target from IN : KM3;

--helper context KM3!Class def: getAllSuperTypes : Sequence(KM3!Class) =
--    if self.supertypes->isEmpty()
--        then Sequence {}
--    	else	
--   				self.supertypes->iterate(a; acc:Sequence(KM3!Class)=self.supertypes|
--														 a.getSuperTypes->iterate(b; bcc:Sequence(KM3!Class)=acc|bcc->append(b)))
--    endif;
--    
helper context KM3!Class def : getSuperTypes : Sequence(KM3!Class) =
	self.supertypes->iterate(a; acc:Sequence(KM3!Class)=Sequence{}|
						if self.getAllSuperTypes->count(a)>1											
						then acc->union(Sequence{})
						else acc->append(a)
						endif 
	);

helper context KM3!Class def: getAllSuperTypes : Sequence(KM3!Class) =
	if self.supertypes->isEmpty()
		then Sequence{}	
	else 		self.supertypes->select(c | c.supertypes->notEmpty())
					->iterate(a; acc : Sequence(KM3!Class)=Sequence{} |(acc->including(a.getSuperTypes)))
					->union(
					self.supertypes->iterate(a; acc : Sequence(KM3!Class)=Sequence{} | acc->including(a))
			).flatten()
	endif;
	
--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3target!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
--@end rule Metamodel

--@begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3target!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
--@end rule Package

--@begin rule Class
rule Class {
	from
		inputA:KM3!Class 
	to
		outputA:KM3target!Class (
			name <- inputA.name,
			isAbstract <- inputA.isAbstract,
			structuralFeatures <- inputA.structuralFeatures,
			supertypes <- inputA.getSuperTypes
		)
}
--@end rule Class

--@begin rule attribute 
rule attribute {
	from
		inputAtt:KM3!Attribute 
	to
		outputAtt:KM3target!Attribute(
			name <- inputAtt.name,
			isOrdered <- inputAtt.isOrdered,
			isUnique <- inputAtt.isUnique,
			location <- inputAtt.location,
			lower <- inputAtt.lower,
			upper <- inputAtt.upper,
			type <- inputAtt.type,
			owner <- inputAtt.owner
			
		)
}
--@end rule attribute

--@begin rule DataType
rule DataType {
from
		inputData:KM3!DataType
	to
		outputData:KM3target!DataType(
			name <- inputData.name,
			location <- inputData.location
		)
}
--@end rule DataType

--@begin reference
rule reference {
	from
		inputRef:KM3!Reference 
	to
		outputRef:KM3target!Reference (
			name <- inputRef.name,
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			location <- inputRef.location,
			lower <- inputRef.lower,
			upper <- inputRef.upper,
			type <- inputRef.type,
			owner <- inputRef.owner,
			opposite <- inputRef.opposite
		)
}
--@end reference

--@begin enumeration
rule enumeration {
	from
		inputEnum:KM3!Enumeration 
	to
		outputEnum:KM3target!Enumeration (
			location <- inputEnum.location,
			name  <- inputEnum.name,
			package  <- inputEnum.package
		)

}
--@end enumeration

--@begin literal
rule literal {
	from
		inputEnum:KM3!EnumLiteral
	to
		outputEnum:KM3target!EnumLiteral (
			location <- inputEnum.location,
			name  <- inputEnum.name,
			enum  <- inputEnum.enum
		)

}
--@end literal",name remov redund inherit version domain catalogu model transform author baudri julien jul baudri gmail com date descript the purpos transform remov redund inherit see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul redundantinherit creat out km target in km helper context km class def getallsupertyp sequenc km class self supertyp isempti sequenc els self supertyp iter acc sequenc km class self supertyp getsupertyp iter b bcc sequenc km class acc bcc append b endif helper context km class def getsupertyp sequenc km class self supertyp iter acc sequenc km class sequenc self getallsupertyp count acc union sequenc els acc append endif helper context km class def getallsupertyp sequenc km class self supertyp isempti sequenc els self supertyp select c c supertyp notempti iter acc sequenc km class sequenc acc includ getsupertyp union self supertyp iter acc sequenc km class sequenc acc includ flatten endif begin rule metamodel rule metamodel inputmm km metamodel outputmm km target metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km target packag name inputpkg name content inputpkg content end rule packag begin rule class rule class inputa km class outputa km target class name inputa name isabstract inputa isabstract structuralfeatur inputa structuralfeatur supertyp inputa getsupertyp end rule class begin rule attribut rule attribut inputatt km attribut outputatt km target attribut name inputatt name isord inputatt isord isuniqu inputatt isuniqu locat inputatt locat lower inputatt lower upper inputatt upper type inputatt type owner inputatt owner end rule attribut begin rule datatyp rule datatyp inputdata km datatyp outputdata km target datatyp name inputdata name locat inputdata locat end rule datatyp begin refer rule refer inputref km refer outputref km target refer name inputref name isord inputref isord isuniqu inputref isuniqu locat inputref locat lower inputref lower upper inputref upper type inputref type owner inputref owner opposit inputref opposit end refer begin enumer rule enumer inputenum km enumer outputenum km target enumer locat inputenum locat name inputenum name packag inputenum packag end enumer begin liter rule liter inputenum km enumliter outputenum km target enumliter locat inputenum locat name inputenum name enum inputenum enum end liter,8
5,5,P10-RedundantInheritance-without.atl,"-- @name		Remove redundant inheritance
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		Baudry Julien (jul.baudry<at>gmail.com)
-- @date		2006/08/02
-- @description	The purpose of this transformation is to remove redundant inheritance.
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 2.3, page 15
-- @see author of article : K. Lano

module RedundantInheritance; 
create OUT : KM3target from IN : KM3;

-- helper getSuperTypes
-- OUT : Sequence(KM3!Class)
-- Corresponds to all the direct or indirect supertypes of the class. 
-- If a class inherit from another class by two different ways, it appears two times in the sequence.
helper context KM3!Class def : getSuperTypes : Sequence(KM3!Class) =
	self.supertypes->iterate(a; acc:Sequence(KM3!Class)=Sequence{}|
						if self.getAllSuperTypes->count(a)>1											
						then acc->union(Sequence{})
						else acc->append(a)
						endif 
	);

-- helper getAllSuperTypes
helper context KM3!Class def: getAllSuperTypes : Sequence(KM3!Class) =
	if self.supertypes->isEmpty()
		then Sequence{}	
	else 		self.supertypes->select(c | c.supertypes->notEmpty())
					->iterate(a; acc : Sequence(KM3!Class)=Sequence{} |(acc->including(a.getSuperTypes)))
					->union(
					self.supertypes->iterate(a; acc : Sequence(KM3!Class)=Sequence{} | acc->including(a))
			).flatten()
	endif;
	
--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3target!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
--@end rule Metamodel

--@begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3target!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
--@end rule Package

--@begin rule Class
rule Class {
	from
		inputA:KM3!Class 
	to
		outputA:KM3target!Class (
			name <- inputA.name,
			isAbstract <- inputA.isAbstract,
			structuralFeatures <- inputA.structuralFeatures,
			supertypes <- inputA.getSuperTypes
		)
}
--@end rule Class",name remov redund inherit version domain catalogu model transform author baudri julien jul baudri gmail com date descript the purpos transform remov redund inherit see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul redundantinherit creat out km target in km helper getsupertyp out sequenc km class correspond direct indirect supertyp class if class inherit anoth class two differ way appear two time sequenc helper context km class def getsupertyp sequenc km class self supertyp iter acc sequenc km class sequenc self getallsupertyp count acc union sequenc els acc append endif helper getallsupertyp helper context km class def getallsupertyp sequenc km class self supertyp isempti sequenc els self supertyp select c c supertyp notempti iter acc sequenc km class sequenc acc includ getsupertyp union self supertyp iter acc sequenc km class sequenc acc includ flatten endif begin rule metamodel rule metamodel inputmm km metamodel outputmm km target metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km target packag name inputpkg name content inputpkg content end rule packag begin rule class rule class inputa km class outputa km target class name inputa name isabstract inputa isabstract structuralfeatur inputa structuralfeatur supertyp inputa getsupertyp end rule class,1
6,6,P100-XML2XSLT.atl,"-- @path XML=/XSLT2XQuery/XML/XML.ecore
-- @path XQuery=/XSLT2XQuery/XQuery/XQuery.ecore
-- @path XSLT=/XSLT2XQuery/XSLT/XSLT.ecore

module XML2XSLT;
create OUT : XSLT from IN : XML;

rule Stylesheet {
	from
		iroot : XML!Root (
			iroot.name = 'xsl:stylesheet'
		)
	-- without verify iroot.name = xsl:""stylesheet""
	to
		out : XSLT!XSLTRootNode (
			-- default value is xsl:""stylesheet""
			name <- iroot.name,
			parentNode <- iroot.parent	-- TODO : Root n'a pas de parent
		)
}

-- Rule for creating NodeText 

rule T2T {
	from
		it : XML!TextNode
	to
		out : XSLT!TextNode (
		   	name <- it.name,
		   	value <- it.value,
		   	nodes <- it.children,
			output <- 'Peter_test'
		)
}

-- Rule for creating Template elements 

rule E2T {
	from
		it : XML!Element (
				it.name = 'xsl:template'
		)
	to
		out : XSLT!Template (
			name <- it.name,
			match <- it.children->select(c | c.name = 'match')->first().value,
			 -- we are sure that each element of template have only one attribute
			nodes <- it.children->select(c | c.name <> 'select'),
			parentNode <- it.parent
		)
}

-- Rule for creating ValueOf elements 
rule E2V {
	from
		iv : XML!Element (
			iv.name = 'xsl:value-of'
		)
	to
		out : XSLT!ValueOf (
			name <- 'xsl:value-of',
			select <- iv.children->select(c | c.name = 'select')->first().value,
			nodes <- iv.children->select(c | c.name <> 'select')
		)
}

-- Rule for creating ApplyTemplates elements 
rule E2A {
	from
		iat : XML!Element (
			iat.name = 'xsl:apply-templates'
		)
	to
		out : XSLT!ApplyTemplates (
			name <- iat.name,
			select <- iat.children->select(c | c.name='select')->first().value,
			nodes <- iat.children->select(c | c.name <> 'select')
		)
}

-- Rule for creating Condition element
-- IF
rule E2I {
	from
		iif : XML!Element (
			iif.name = 'xsl:if'
		)
	to
		out : XSLT!If (
			name <- iif.name,
			test <- iif.children->select(c | c.name = 'test')->first().value,
			nodes <- iif.children->select(c | c.name <> 'test')
		)
}

-- ForEach
rule E2FE {
	from
		ife : XML!Element (
			ife.name = 'xsl:foreach'
		)
	to
		out : XSLT!ForEach (
			name <- ife.name,
			select <- ife.children->select(c | c.name = 'select')->first().value,
			nodes <- ife.children
		)
}


-- Sort
rule E2S {
	from
		is : XML!Element (
			is.name = 'xsl:short'
		)
	to
		out : XSLT!Sort (
			name <- is.name,
			select <- is.children->select(c | c.name = 'select')->first().value,
			nodes <- is.children
		)
}

-- CopyOF
rule E2CO {
	from
		icp : XML!Element (
			icp.name = 'xsl:copy-of'
		)
	to
		out : XSLT!CopyOf (
			name <- icp.name,
			select <- icp.children->select(c | c.name = 'select')->first().value,
			nodes <- icp.children
		)
}

-- Choose
rule E2C1 {
	from
		ich : XML!Element( ich.name = 'xsl:choose' )
	to
		out : XSLT!Choose (
			name <- ich.name,
			nodes <- ich.children
	)
}

-- When
rule E2W {
	from
		iw : XML!Element (
			iw.name = 'xsl:when'
		)
	to
		ow : XSLT!When (
			name <- iw.name,
			test <- iw.children->select(c | c.name = 'test')->first().value,
			nodes <- iw.children
		)
}

-- Otherwise
rule E2C2 {
	from
		io : XML!Element (
			io.name = 'xsl:otherwise'
		)
	to
		oo : XSLT!Choose (
			name <- io.name,
			nodes <- io.children
		)
}


rule El2El {
	from
		io : XML!Element (
			(io.name <> 'xsl:otherwise') and
			(io.name <> 'xsl:when') and
			(io.name <> 'xsl:choose') and
			(io.name <> 'xsl:copy-of') and
			(io.name <> 'xsl:short') and
			(io.name <> 'xsl:foreach') and
			(io.name <> 'xsl:if') and
			(io.name <> 'xsl:apply-templates') and
			(io.name <> 'xsl:value-of') and
			(io.name <> 'xsl:template') and
			(io.name <> 'xsl:stylesheet') 
		)
	
	to
		oo : XSLT!ElementNode (
			name <- io.name,
			nodes <- io.children
		)
	
}

rule At2At {
 	from
		attr : XML!Attribute (
			(attr.parent.name <> 'xsl:otherwise') and
			(attr.parent.name <> 'xsl:when') and
			(attr.parent.name <> 'xsl:choose') and
			(attr.parent.name <> 'xsl:copy-of') and
			(attr.parent.name <> 'xsl:short') and
			(attr.parent.name <> 'xsl:foreach') and
			(attr.parent.name <> 'xsl:if') and
			(attr.parent.name <> 'xsl:apply-templates') and
			(attr.parent.name <> 'xsl:value-of') and
			(attr.parent.name <> 'xsl:template') and
			(attr.parent.name <> 'xsl:stylesheet') 
		)
	to
		out : XSLT!AttributeNode (
		  	name <- attr.name,
		  	value <- attr.value
		)
} 
",path xml xslt xqueri xml xml ecor path xqueri xslt xqueri xqueri xqueri ecor path xslt xslt xqueri xslt xslt ecor modul xml xslt creat out xslt in xml rule stylesheet iroot xml root iroot name xsl stylesheet without verifi iroot name xsl stylesheet xslt xsltrootnod default valu xsl stylesheet name iroot name parentnod iroot parent todo root n pas de parent rule creat nodetext rule t t xml textnod xslt textnod name name valu valu node children output peter test rule creat templat element rule e t xml element name xsl templat xslt templat name name match children select c c name match first valu sure element templat one attribut node children select c c name select parentnod parent rule creat valueof element rule e v iv xml element iv name xsl valu xslt valueof name xsl valu select iv children select c c name select first valu node iv children select c c name select rule creat applytempl element rule e a iat xml element iat name xsl appli templat xslt applytempl name iat name select iat children select c c name select first valu node iat children select c c name select rule creat condit element if rule e i iif xml element iif name xsl xslt if name iif name test iif children select c c name test first valu node iif children select c c name test foreach rule e fe ife xml element ife name xsl foreach xslt foreach name ife name select ife children select c c name select first valu node ife children sort rule e s xml element name xsl short xslt sort name name select children select c c name select first valu node children copyof rule e co icp xml element icp name xsl copi xslt copyof name icp name select icp children select c c name select first valu node icp children choos rule e c ich xml element ich name xsl choos xslt choos name ich name node ich children when rule e w iw xml element iw name xsl ow xslt when name iw name test iw children select c c name test first valu node iw children otherwis rule e c io xml element io name xsl otherwis oo xslt choos name io name node io children rule el el io xml element io name xsl otherwis io name xsl io name xsl choos io name xsl copi io name xsl short io name xsl foreach io name xsl io name xsl appli templat io name xsl valu io name xsl templat io name xsl stylesheet oo xslt elementnod name io name node io children rule at at attr xml attribut attr parent name xsl otherwis attr parent name xsl attr parent name xsl choos attr parent name xsl copi attr parent name xsl short attr parent name xsl foreach attr parent name xsl attr parent name xsl appli templat attr parent name xsl valu attr parent name xsl templat attr parent name xsl stylesheet xslt attributenod name attr name valu attr valu,17
7,7,P100-XQuery2Code.atl,"-- @path XML=/XSLT2XQuery/XML/XML.ecore
-- @path XQuery=/XSLT2XQuery/XQuery/XQuery.ecore
-- @path XSLT=/XSLT2XQuery/XSLT/XSLT.ecore

query XQuery2Code = XQuery!XQueryProgram.allInstances()->collect(e | e.toString().
	writeTo('/XSLT2XQuery/out_test.xquery'));

-- please change the path name in the writeTo expression above

helper context XQuery!XQueryProgram def: toString() : String =
	self.expressions->iterate(e; acc : String = '' |
		acc + e.toString() + '\n'
	);

helper context XQuery!FunctionDeclaration def: toString() : String =
		'define function ' + self.name + '(' +
		'$paramVar' +	-- TODO: make arguments part of the XQuery metamodel
		')' + '\n' +
		'{\n' +
		self.expression->iterate(e; acc : String = '' |
			acc + e.toString()		
		) +
		'}';

helper context XQuery!FLWOR def: toString() : String =
	if not self.""for"".oclIsUndefined() then
		self.""for"".toString() + '\n'
	else
		''
	endif +
	if not self.""let"".oclIsUndefined() then
		self.""let"".toString() + '\n'
	else
		''
	endif +
	if not self.where.oclIsUndefined() then
		self.where.toString() + '\n'
	else
		''
	endif +
	if not self.orderBy.oclIsUndefined() then
		self.orderBy.toString() + '\n'
	else
		''
	endif +
	if not self.return.oclIsUndefined() then
		self.return.toString()
	else
		''
	endif;

helper context XQuery!For def: toString() : String =
	'for ' + self.var + ' in ' + self.expression.toString();

helper context XQuery!Let def: toString() : String =
	'let ' + self.var + ' := ' + self.expression.toString();

helper context XQuery!Where def: toString() : String =
	'where ' + self.expression.toString();

--helper context XQuery!OrderBy def: toString() : String =
--	'let ' + self.var + ' := ' + self.expression.toString();

helper context XQuery!Return def: toString() : String =
	'return\n' +
	self.expressions->iterate(e; acc : String = '' |
		acc + e.toString()
	) + '\n';

helper context XQuery!XPath def: toString() : String =
	self.value;

helper context XQuery!ReturnXPath def: toString() : String =
	'{' + self.value + '}';

helper context XQuery!BooleanExp def: toString() : String =
	self.value;
	
helper context XQuery!FunctionCall def: toString() : String =
	'{' + self.name + '(' + self.parameters->iterate(e; acc : String = '' |
		acc + if acc = '' then '' else ', ' endif + e.toString()
	) + ')}';

helper context XQuery!ElementNode def: toString() : String =
	'<' + self.name +
	if self.nodes->size() > 0 then
		'>' +
			self.nodes->iterate(e; acc : String = '' |
				acc + e.toString()
			) +
		'</' + self.name + '>'
	else
		'/>'
	endif;
",path xml xslt xqueri xml xml ecor path xqueri xslt xqueri xqueri xqueri ecor path xslt xslt xqueri xslt xslt ecor queri xqueri code xqueri xqueryprogram allinst collect e e tostr writeto xslt xqueri test xqueri pleas chang path name writeto express helper context xqueri xqueryprogram def tostr string self express iter e acc string acc e tostr n helper context xqueri functiondeclar def tostr string defin function self name paramvar todo make argument part xqueri metamodel n n self express iter e acc string acc e tostr helper context xqueri flwor def tostr string self oclisundefin self tostr n els endif self let oclisundefin self let tostr n els endif self oclisundefin self tostr n els endif self orderbi oclisundefin self orderbi tostr n els endif self return oclisundefin self return tostr els endif helper context xqueri for def tostr string self var self express tostr helper context xqueri let def tostr string let self var self express tostr helper context xqueri where def tostr string self express tostr helper context xqueri orderbi def tostr string let self var self express tostr helper context xqueri return def tostr string return n self express iter e acc string acc e tostr n helper context xqueri xpath def tostr string self valu helper context xqueri returnxpath def tostr string self valu helper context xqueri booleanexp def tostr string self valu helper context xqueri functioncal def tostr string self name self paramet iter e acc string acc acc els endif e tostr helper context xqueri elementnod def tostr string self name self node size self node iter e acc string acc e tostr self name els endif,5
8,8,P100-XSLT2XQuery.atl,"-- @path XML=/XSLT2XQuery/XML/XML.ecore
-- @path XQuery=/XSLT2XQuery/XQuery/XQuery.ecore
-- @path XSLT=/XSLT2XQuery/XSLT/XSLT.ecore

module XSLT2XQuery;
create OUT : XQuery from IN : XSLT;

rule P2P {
  from
  	xslt : XSLT!XSLTRootNode
	-- this rule will be called for each XSLTRootNode
  to
  	out : XQuery!XQueryProgram (
  	-- this rule will instanciate a XQueryProgram variable named out
	-- which will represent a XQueryProgram element in the OUT.xmi file
  	),
	
	flwor : XQuery!FLWOR (
	-- the variable flwor is of the type FLWOR and
	-- will be initialized with the following values:
    	xQueryProgram <- out,
		""for"" <- ""for"", 
		-- the attribute for of flwor refers to the variable for which is intialized below
		return <- return
		-- the attribute return of flwor refers to the variable return which is intialized below
	),
	""for"" : XQuery!For (
		var <- '$var',
		-- the string value '$var' is attributed to for.var
		expression <- forExpression
	),
	forExpression : XQuery!XPath (
		value <- 'document(\""xmlFile.xml\"")/*'
	),
	return : XQuery!Return (
 		expressions <- xslt.nodes->select(t | t.oclIsKindOf(XSLT!Template))->select(t | t.match = '/')->collect(t | t.nodes)->flatten()	
	)  
}

rule Template2FLOWR {
	from 
		template : XSLT!Template (
			template.match <> '/'
		)
	to
		out : XQuery!FunctionDeclaration (
			name <- 'fct' + template.match,
    		expression <- Sequence {flwor},
      		xQueryProgram <- XSLT!XSLTRootNode.allInstances()->asSequence()->first()
		),

		flwor : XQuery!FLWOR (
  			""for"" <- ""for"",
    		return <- return
		),

		""for"" : XQuery!For (
    		expression <- forExpression,
    		var <- '$var'
		),

		forExpression : XQuery!XPath (
    		value <- '$paramVar'
		),

  		return : XQuery!Return (
    		expressions <- template.nodes
  		)
}	

rule If2FLOWR {
	from 
		""if"": XSLT!If
	to
		out : XQuery!FLWOR (
			""let"" <- varlet,
	    	where <- where,
	    	return <- return
	  	),

		varlet : XQuery!Let (
	    	expression <- letExpression,
	    	var <- '$var'
	  	),

	  	letExpression : XQuery!XPath(
    		value <- '$var'
  		),

  		where : XQuery!Where (
    		expression <- whereExpression
  		),

 		whereExpression : XQuery!BooleanExp (
    		value <- '$var/' + ""if"".test
  		),
  
		return : XQuery!Return (
    		expressions <- ""if"".nodes
 		)
}

rule ApplyTemplate2FunctionCall {
	from 
		_applyTemplates : XSLT!ApplyTemplates
	to
		out : XQuery!FunctionCall (
    	name <- 'fct' + _applyTemplates.select,
    	parameters <- Sequence{ parameter }
  	),

	parameter : XQuery!XPath(
    	value <- '$var/' + _applyTemplates.select
  	)  
}


rule ValueOf2ReturnXPath {
	from 
    	_valueOf : XSLT!ValueOf
	to
   		out : XQuery!ReturnXPath (
    	value <- '$var/' + _valueOf.select
	)
}

rule ElementNode2ElementNode {
	from 
		elementNode : XSLT!ElementNode (
    	(elementNode.name <> 'xsl:otherwise') and
    	(elementNode.name <> 'xsl:when') and
    	(elementNode.name <> 'xsl:choose') and
    	(elementNode.name <> 'xsl:copy-of') and
    	(elementNode.name <> 'xsl:sort') and
    	(elementNode.name <> 'xsl:foreach') and
    	(elementNode.name <> 'xsl:if') and
    	(elementNode.name <> 'xsl:apply-templates') and
    	(elementNode.name <> 'xsl:value-of') and
    	(elementNode.name <> 'xsl:template') and
    	(elementNode.name <> 'xsl:stylesheet') 
  	) 
  	to
    	out : XQuery!ElementNode (
      	name <- elementNode.name,
      	nodes <- elementNode.nodes
    )
 }

rule Attribute2Attribute {
	from 
  		attributeNode : XSLT!AttributeNode (
    		(attributeNode.name <> 'xsl:otherwise') and
    		(attributeNode.name <> 'xsl:when') and
    		(attributeNode.name <> 'xsl:choose') and
    		(attributeNode.name <> 'xsl:copy-of') and
    		(attributeNode.name <> 'xsl:sort') and
    		(attributeNode.name <> 'xsl:foreach') and
    		(attributeNode.name <> 'xsl:if') and
    		(attributeNode.name <> 'xsl:apply-templates') and
    		(attributeNode.name <> 'xsl:value-of') and
    		(attributeNode.name <> 'xsl:template') and
    		(attributeNode.name <> 'xsl:stylesheet') 
	) 
	to
   		out : XQuery!AttributeNode (
     		name <- attributeNode.name,
     		value <- attributeNode.value
	)
}
",path xml xslt xqueri xml xml ecor path xqueri xslt xqueri xqueri xqueri ecor path xslt xslt xqueri xslt xslt ecor modul xslt xqueri creat out xqueri in xslt rule p p xslt xslt xsltrootnod rule call xsltrootnod xqueri xqueryprogram rule instanci xqueryprogram variabl name repres xqueryprogram element out xmi file flwor xqueri flwor variabl flwor type flwor initi follow valu xqueryprogram attribut flwor refer variabl intial return return attribut return flwor refer variabl return intial xqueri for var var string valu var attribut var express forexpress forexpress xqueri xpath valu document xmlfile xml return xqueri return express xslt node select ocliskindof xslt templat select match collect node flatten rule templat flowr templat xslt templat templat match xqueri functiondeclar name fct templat match express sequenc flwor xqueryprogram xslt xsltrootnod allinst assequ first flwor xqueri flwor return return xqueri for express forexpress var var forexpress xqueri xpath valu paramvar return xqueri return express templat node rule if flowr xslt if xqueri flwor let varlet return return varlet xqueri let express letexpress var var letexpress xqueri xpath valu var xqueri where express whereexpress whereexpress xqueri booleanexp valu var test return xqueri return express node rule applytempl functioncal applytempl xslt applytempl xqueri functioncal name fct applytempl select paramet sequenc paramet paramet xqueri xpath valu var applytempl select rule valueof returnxpath valueof xslt valueof xqueri returnxpath valu var valueof select rule elementnod elementnod elementnod xslt elementnod elementnod name xsl otherwis elementnod name xsl elementnod name xsl choos elementnod name xsl copi elementnod name xsl sort elementnod name xsl foreach elementnod name xsl elementnod name xsl appli templat elementnod name xsl valu elementnod name xsl templat elementnod name xsl stylesheet xqueri elementnod name elementnod name node elementnod node rule attribut attribut attributenod xslt attributenod attributenod name xsl otherwis attributenod name xsl attributenod name xsl choos attributenod name xsl copi attributenod name xsl sort attributenod name xsl foreach attributenod name xsl attributenod name xsl appli templat attributenod name xsl valu attributenod name xsl templat attributenod name xsl stylesheet xqueri attributenod name attributenod name valu attributenod valu,17
9,9,P11-equivalenceOfAttributeAndAssociations.atl,"-- @name		Equivalence of attributes and associations
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		Baudry Julien (jul.baudry<at>gmail.com)
-- @date		2006/08/02
-- @description	The purpose of this transformation is to replace association by equivalent attributes.
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 1.5, page 4
-- @see author of article : K. Lano

module UML2Transformations; -- Module Template
create OUT : UML2target from IN : UML2;

helper context UML2!Class def : getProperties : Sequence(UML2!Properties) =
		UML2!Association.allInstances()->select(a|a.endType->includes(self))
				->iterate(a;acc : Sequence(UML2!Property) = Sequence {}|
							acc->including(a.ownedEnd->select(p|p.type <> self)
										->first()))
	;

--@begin rule model
rule model {
	from
		inputModel : UML2!Model 
	to
		outputModel : UML2target!Model (
			name <- inputModel.name,
			visibility <- inputModel.visibility,
			packageableElement_visibility <- inputModel.packageableElement_visibility,
			ownedMember <-inputModel.ownedMember
		)
}
--@end rule model

--@begin rule class
rule class {
	from
		inputClass : UML2!Class 
	to
		outputClass : UML2target!Class (
			name <- inputClass.name,
			visibility <- inputClass.visibility,
			packageableElement_visibility <- inputClass.packageableElement_visibility,
			isAbstract <- inputClass.isAbstract,
			isLeaf <- inputClass.isLeaf,
			isActive <- inputClass.isActive,
			ownedAttribute <- inputClass.getProperties->union(inputClass.ownedAttribute)	
		)
}
--@end rule class

--@begin rule property
rule property {
	from
		inputProperty : UML2!Property 
	to
		outputProperty : UML2target!Property (
			isDerived <- inputProperty.isDerived,
			isDerivedUnion <- inputProperty.isDerivedUnion,
			isLeaf <- inputProperty.isLeaf,
			isOrdered <- inputProperty.isOrdered,
			isReadOnly <- inputProperty.isReadOnly,
			isStatic <- inputProperty.isStatic,
			isUnique <- inputProperty.isUnique,
			name <- inputProperty.name,
			visibility <- inputProperty.visibility,
			lowerValue <- inputProperty.lowerValue,
			upperValue <- inputProperty.upperValue
		)
}
--@end rule property

--@begin literal null
rule literalNull {
	from 
		inputLiteral : UML2!LiteralNull
	to 
		outputLiteral : UML2target!LiteralNull (
			name <- inputLiteral.name,
			value <- inputLiteral.value
		)
}
--@end literal null

--@begin literal integer 
rule literalInteger {
	from 
		inputLiteral : UML2!LiteralInteger
	to 
		outputLiteral : UML2target!LiteralInteger (
			name <- inputLiteral.name,
			value <- inputLiteral.value
		)
}
--@end literal integer

--@begin literal unlimited natural 
rule literalUnlimitedNatural {
	from 
		inputLiteral : UML2!LiteralUnlimitedNatural
	to 
		outputLiteral : UML2target!LiteralUnlimitedNatural (
			name <- inputLiteral.name,
			value <- inputLiteral.value
		)	
}
--@end literal unlimited natural
",name equival attribut associ version domain catalogu model transform author baudri julien jul baudri gmail com date descript the purpos transform replac associ equival attribut see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul uml transform modul templat creat out uml target in uml helper context uml class def getproperti sequenc uml properti uml associ allinst select endtyp includ self iter acc sequenc uml properti sequenc acc includ ownedend select p p type self first begin rule model rule model inputmodel uml model outputmodel uml target model name inputmodel name visibl inputmodel visibl packageableel visibl inputmodel packageableel visibl ownedmemb inputmodel ownedmemb end rule model begin rule class rule class inputclass uml class outputclass uml target class name inputclass name visibl inputclass visibl packageableel visibl inputclass packageableel visibl isabstract inputclass isabstract isleaf inputclass isleaf isact inputclass isact ownedattribut inputclass getproperti union inputclass ownedattribut end rule class begin rule properti rule properti inputproperti uml properti outputproperti uml target properti isderiv inputproperti isderiv isderivedunion inputproperti isderivedunion isleaf inputproperti isleaf isord inputproperti isord isreadon inputproperti isreadon isstat inputproperti isstat isuniqu inputproperti isuniqu name inputproperti name visibl inputproperti visibl lowervalu inputproperti lowervalu uppervalu inputproperti uppervalu end rule properti begin liter null rule literalnul inputliter uml literalnul outputliter uml target literalnul name inputliter name valu inputliter valu end liter null begin liter integ rule literalinteg inputliter uml literalinteg outputliter uml target literalinteg name inputliter name valu inputliter valu end liter integ begin liter unlimit natur rule literalunlimitednatur inputliter uml literalunlimitednatur outputliter uml target literalunlimitednatur name inputliter name valu inputliter valu end liter unlimit natur,13
10,10,P12-PrimaryKey-context.atl,"-- @name		Introducing Primary key
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		Baudry Julien (jul.baudry<at>gmail.com)
-- @date		2006/08/02
-- @description	The purpose of this transformation is to introduce a primary key in each class
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 1.6, page 6
-- @see author of article : K. Lano

module PrimaryKey; 
create OUT : KM3target from IN : KM3;

----@begin rule Metamodel
--entrypoint rule Metamodel() {
--	do {
--		KM3!Metamodel.allInstances().debug('metamodels');
--		KM3!Package.allInstances().debug('packages');
--		KM3!Class.allInstances().debug('classes');
--		KM3!DataType.allInstances().debug('datatypes');
--	}
--}
----@end rule Metamodel

--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3target!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
--@end rule Metamodel

--@begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3target!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
--@end rule Package

--@begin rule Class
rule Class {
	from
		inputA:KM3!Class 
	to
		outputA:KM3target!Class (
			name <- inputA.name,
			isAbstract <- inputA.isAbstract,
			structuralFeatures <- inputA.structuralFeatures,
			supertypes <- inputA.supertypes
		),

		key:KM3target!Attribute (
			name <- inputA.name.toLower()+'Key',
			isOrdered <- false,
			isUnique <- false,
			location <- '',
			lower <- 1,
			upper <- 1,
			type <- KM3!DataType.allInstances()->select(a|a.name = 'Integer')->first(),
			owner <- outputA
		)
}
--@end rule Class

--@begin rule attribute 
rule attribute {
	from
		inputAtt:KM3!Attribute 
	to
		outputAtt:KM3target!Attribute(
			name <- inputAtt.name,
			isOrdered <- inputAtt.isOrdered,
			isUnique <- inputAtt.isUnique,
			location <- inputAtt.location,
			lower <- inputAtt.lower,
			upper <- inputAtt.upper,
			type <- inputAtt.type,
			owner <- inputAtt.owner
			
		)
}
--@end rule attribute

--@begin rule DataType
rule DataType {
from
		inputData:KM3!DataType
	to
		outputData:KM3target!DataType(
			name <- inputData.name,
			location <- inputData.location
		)
}
--@end rule DataType

--@begin reference
rule reference {
	from
		inputRef:KM3!Reference 
	to
		outputRef:KM3target!Reference (
			name <- inputRef.name,
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			location <- inputRef.location,
			lower <- inputRef.lower,
			upper <- inputRef.upper,
			type <- inputRef.type,
			owner <- inputRef.owner,
			opposite <- inputRef.opposite
		)
}
--@end reference

--@begin enumeration
rule enumeration {
	from
		inputEnum:KM3!Enumeration 
	to
		outputEnum:KM3target!Enumeration (
			location <- inputEnum.location,
			name  <- inputEnum.name,
			package  <- inputEnum.package
		)

}
--@end enumeration

--@begin literal
rule literal {
	from
		inputEnum:KM3!EnumLiteral
	to
		outputEnum:KM3target!EnumLiteral (
			location <- inputEnum.location,
			name  <- inputEnum.name,
			enum  <- inputEnum.enum
		)

}
--@end literal",name introduc primari key version domain catalogu model transform author baudri julien jul baudri gmail com date descript the purpos transform introduc primari key class see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul primarykey creat out km target in km begin rule metamodel entrypoint rule metamodel km metamodel allinst debug metamodel km packag allinst debug packag km class allinst debug class km datatyp allinst debug datatyp end rule metamodel begin rule metamodel rule metamodel inputmm km metamodel outputmm km target metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km target packag name inputpkg name content inputpkg content end rule packag begin rule class rule class inputa km class outputa km target class name inputa name isabstract inputa isabstract structuralfeatur inputa structuralfeatur supertyp inputa supertyp key km target attribut name inputa name tolow key isord fals isuniqu fals locat lower upper type km datatyp allinst select name integ first owner outputa end rule class begin rule attribut rule attribut inputatt km attribut outputatt km target attribut name inputatt name isord inputatt isord isuniqu inputatt isuniqu locat inputatt locat lower inputatt lower upper inputatt upper type inputatt type owner inputatt owner end rule attribut begin rule datatyp rule datatyp inputdata km datatyp outputdata km target datatyp name inputdata name locat inputdata locat end rule datatyp begin refer rule refer inputref km refer outputref km target refer name inputref name isord inputref isord isuniqu inputref isuniqu locat inputref locat lower inputref lower upper inputref upper type inputref type owner inputref owner opposit inputref opposit end refer begin enumer rule enumer inputenum km enumer outputenum km target enumer locat inputenum locat name inputenum name packag inputenum packag end enumer begin liter rule liter inputenum km enumliter outputenum km target enumliter locat inputenum locat name inputenum name enum inputenum enum end liter,1
11,11,P12-PrimaryKey-without.atl,"-- @name		Introducing Primary key
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		Baudry Julien (jul.baudry<at>gmail.com)
-- @date		2006/08/02
-- @description	The purpose of this transformation is to introduce a primary key in each class
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 1.6, page 6
-- @see author of article : K. Lano

module PrimaryKey; 
create OUT : KM3target from IN : KM3;

--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3target!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
--@end rule Metamodel

--@begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3target!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
--@end rule Package

--@begin rule Class
rule Class {
	from
		inputA:KM3!Class 
	to
		outputA:KM3target!Class (
			name <- inputA.name,
			isAbstract <- inputA.isAbstract,
			structuralFeatures <- inputA.structuralFeatures
		),

		key:KM3target!Attribute (
			name <- inputA.name.toLower()+'Key',
			isOrdered <- false,
			isUnique <- false,
			location <- '',
			lower <- 1,
			upper <- 1,
			type <- KM3!DataType.allInstances()->select(a|a.name = 'Integer')->first(),
			owner <- outputA
		)
}
--@end rule Class

--@begin rule reference
rule DataType {
from
		inputData:KM3!DataType
	to
		outputData:KM3target!DataType(
			name <- inputData.name,
			location <- inputData.location
		)
}
--@end rule reference
",name introduc primari key version domain catalogu model transform author baudri julien jul baudri gmail com date descript the purpos transform introduc primari key class see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul primarykey creat out km target in km begin rule metamodel rule metamodel inputmm km metamodel outputmm km target metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km target packag name inputpkg name content inputpkg content end rule packag begin rule class rule class inputa km class outputa km target class name inputa name isabstract inputa isabstract structuralfeatur inputa structuralfeatur key km target attribut name inputa name tolow key isord fals isuniqu fals locat lower upper type km datatyp allinst select name integ first owner outputa end rule class begin rule refer rule datatyp inputdata km datatyp outputdata km target datatyp name inputdata name locat inputdata locat end rule refer,1
12,12,P13-introducingAnInterface.atl,"-- @name	 Introducing an interface
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		Baudry Julien (jul.baudry<at>gmail.com)
-- @date		2006/08/02
-- @description	The purpose of this transformation is introduce an interface to each reference
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 2.6, page 16
-- @see author of article : K. Lano

module UML2Transformations; -- Module Template
create OUT : UML2target from IN : UML2, MODEL : XML;

-- helper getOperations
-- IN :  UML2!Class, UML2!Class
-- OUT : Sequence(UML2!Operation)
-- this helper returns in a sequence the operations of the class 'class' use by the class 'sub	class'
helper context UML2!Property def: getOperations(class : UML2!Class,subClass : UML2!Class) : Sequence(UML2!Operation) =
	XML!Root.allInstances()->asSequence()->first().children
											->select(a|a.name = class.name)->first().children
											->select(a|(a.name = subClass.name)and((a.children->select(a|a.name='model')->first().value)=subClass.package.name))
											->first().children
											->select(a|a.oclIsTypeOf(XML!Element));
																

--@begin rule model
rule model {
	from
		inputModel : UML2!Model 
	to
		outputModel : UML2target!Model (
			name <- inputModel.name,
			visibility <- inputModel.visibility,
			packageableElement_visibility <- inputModel.packageableElement_visibility,
			ownedMember <-inputModel.ownedMember
		)
}
--@end rule model

--@begin rule class
rule class {
	from
		inputClass : UML2!Class 
	to
		outputClass : UML2target!Class (
			name <- inputClass.name,
			visibility <- inputClass.visibility,
			packageableElement_visibility <- inputClass.packageableElement_visibility,
			isAbstract <- inputClass.isAbstract,
			isLeaf <- inputClass.isLeaf,
			isActive <- inputClass.isActive,
			ownedAttribute <- inputClass.ownedAttribute,
			ownedOperation <- inputClass.ownedOperation
		)
}
--@end rule class

--@begin association
rule association {
	from 
		inputAssoc : UML2!Association 
	to
		outputAssoc : UML2target!Association (
				isAbstract <- inputAssoc.isAbstract,
				isDerived <- inputAssoc.isDerived,
				isLeaf <- inputAssoc.isLeaf,
				ownedEnd <- inputAssoc.ownedEnd,
				memberEnd <- inputAssoc.memberEnd,
				name <- inputAssoc.name,
				packageableElement_visibility <- inputAssoc.packageableElement_visibility,
				visibility <- inputAssoc.visibility
		)
}	

--@end association

--@begin rule property
rule property {
	from
		inputProperty : UML2!Property 
	to
		outputProperty : UML2target!Property (
			isDerived <- inputProperty.isDerived,
			isDerivedUnion <- inputProperty.isDerivedUnion,
			isLeaf <- inputProperty.isLeaf,
			isOrdered <- inputProperty.isOrdered,
			isReadOnly <- inputProperty.isReadOnly,
			isStatic <- inputProperty.isStatic,
			isUnique <- inputProperty.isUnique,
			name <- inputProperty.name,
			visibility <- inputProperty.visibility,
			lowerValue <- inputProperty.lowerValue,
			upperValue <- inputProperty.upperValue,
			type <- outputInterface
		),
		outputInterface : UML2target!Interface (
			name <- inputProperty.name+'_interface_'+inputProperty.association.name,
			ownedOperation <- inputProperty.getOperations(inputProperty.association.endType->excluding(inputProperty.type)->first(),
																							inputProperty.type)
																							->iterate (a; acc : Sequence(UML2target!Operation) = Sequence{}|
																												acc->including(thisModule.operationXML(a)))
		),
		outputImplementation : UML2target!Implementation (
			name <- inputProperty.name+'_implementation_'+inputProperty.association.name,
			contract <- outputInterface,
			implementingClassifier <- inputProperty.type
		)
}
--@end rule property

--@begin literal null
rule literalNull {
	from 
		inputLiteral : UML2!LiteralNull
	to 
		outputLiteral : UML2target!LiteralNull (
			name <- inputLiteral.name,
			value <- inputLiteral.value
		)
}
--@end literal null

--@begin literal integer 
rule literalInteger {
	from 
		inputLiteral : UML2!LiteralInteger
	to 
		outputLiteral : UML2target!LiteralInteger (
			name <- inputLiteral.name,
			value <- inputLiteral.value
		)
}
--@end literal integer

--@begin literal unlimited natural 
rule literalUnlimitedNatural {
	from 
		inputLiteral : UML2!LiteralUnlimitedNatural
	to 
		outputLiteral : UML2target!LiteralUnlimitedNatural (
			name <- inputLiteral.name,
			value <- inputLiteral.value
		)	
}
--@end literal unlimited natural

--@begin operation
rule operation {
	from
		inputOperation : UML2!Operation
	to
		outputOperation : UML2target!Operation (
			isAbstract <- inputOperation.isAbstract,
			isLeaf <- inputOperation.isLeaf,
			isOrdered <- inputOperation.isOrdered,
			isQuery <- inputOperation.isQuery,
			isStatic <- inputOperation.isStatic,
			isUnique <- inputOperation.isUnique,
			name <- inputOperation.name,
			visibility <- inputOperation.visibility
		)
}
--@end operation

--@begin operationXML
lazy rule operationXML {
	from
		inputElement : XML!Element
	to
		outputOperation : UML2target!Operation (
			name <- inputElement.name
		)
}
--@end operationXML
",name introduc interfac version domain catalogu model transform author baudri julien jul baudri gmail com date descript the purpos transform introduc interfac refer see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul uml transform modul templat creat out uml target in uml model xml helper getoper in uml class uml class out sequenc uml oper helper return sequenc oper class class use class sub class helper context uml properti def getoper class uml class subclass uml class sequenc uml oper xml root allinst assequ first children select name class name first children select name subclass name children select name model first valu subclass packag name first children select oclistypeof xml element begin rule model rule model inputmodel uml model outputmodel uml target model name inputmodel name visibl inputmodel visibl packageableel visibl inputmodel packageableel visibl ownedmemb inputmodel ownedmemb end rule model begin rule class rule class inputclass uml class outputclass uml target class name inputclass name visibl inputclass visibl packageableel visibl inputclass packageableel visibl isabstract inputclass isabstract isleaf inputclass isleaf isact inputclass isact ownedattribut inputclass ownedattribut ownedoper inputclass ownedoper end rule class begin associ rule associ inputassoc uml associ outputassoc uml target associ isabstract inputassoc isabstract isderiv inputassoc isderiv isleaf inputassoc isleaf ownedend inputassoc ownedend memberend inputassoc memberend name inputassoc name packageableel visibl inputassoc packageableel visibl visibl inputassoc visibl end associ begin rule properti rule properti inputproperti uml properti outputproperti uml target properti isderiv inputproperti isderiv isderivedunion inputproperti isderivedunion isleaf inputproperti isleaf isord inputproperti isord isreadon inputproperti isreadon isstat inputproperti isstat isuniqu inputproperti isuniqu name inputproperti name visibl inputproperti visibl lowervalu inputproperti lowervalu uppervalu inputproperti uppervalu type outputinterfac outputinterfac uml target interfac name inputproperti name interfac inputproperti associ name ownedoper inputproperti getoper inputproperti associ endtyp exclud inputproperti type first inputproperti type iter acc sequenc uml target oper sequenc acc includ thismodul operationxml outputimplement uml target implement name inputproperti name implement inputproperti associ name contract outputinterfac implementingclassifi inputproperti type end rule properti begin liter null rule literalnul inputliter uml literalnul outputliter uml target literalnul name inputliter name valu inputliter valu end liter null begin liter integ rule literalinteg inputliter uml literalinteg outputliter uml target literalinteg name inputliter name valu inputliter valu end liter integ begin liter unlimit natur rule literalunlimitednatur inputliter uml literalunlimitednatur outputliter uml target literalunlimitednatur name inputliter name valu inputliter valu end liter unlimit natur begin oper rule oper inputoper uml oper outputoper uml target oper isabstract inputoper isabstract isleaf inputoper isleaf isord inputoper isord isqueri inputoper isqueri isstat inputoper isstat isuniqu inputoper isuniqu name inputoper name visibl inputoper visibl end oper begin operationxml lazi rule operationxml inputel xml element outputoper uml target oper name inputel name end operationxml,13
13,13,P14-partial2totalRole-context.atl,"module Replace; -- Module Template
create OUT : KM3target from IN : KM3;

--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3target!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
--@end rule Metamodel

--@begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3target!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
--@end rule Package

--@begin Class 
rule ClassWithPartialOrder {
	from
		inputClass:KM3!Class (
			not(inputClass.structuralFeatures->select(r|(r.upper=1)and(r.lower=0))->isEmpty())	
		)
		
	to
		outputClass:KM3target!Class (
			name <- inputClass.name,
			isAbstract <- inputClass.isAbstract,
			structuralFeatures <- inputClass.structuralFeatures,
			supertypes <- inputClass.supertypes
		),
		totalOrderClass : KM3target!Class (
			name <- inputClass.name+'TotalOrder',
			isAbstract <- true,
			package <- inputClass.package,
			supertypes <- inputClass.structuralFeatures->iterate(a;acc:Sequence(KM3!Class)=Sequence{}|
																	if (a->oclIsKindOf(KM3!Reference)) 
																		then acc->including(a.opposite.owner)
																		else acc->union(Sequence{})
																		endif)
		)
}
--@end Class

--@begin Class 
rule ClassWithoutPartialOrder {
	from
		inputClass:KM3!Class (
			inputClass.structuralFeatures->select(r|(r.upper=1)and(r.lower=0))->isEmpty()
		)
		
	to
		outputClass:KM3target!Class (
			name <- inputClass.name,
			isAbstract <- inputClass.isAbstract,
			structuralFeatures <- inputClass.structuralFeatures,
			supertypes <- inputClass.supertypes
		)
}
--@end Class

--@begin reference partial order
rule referencePartialOrder {
	from 
		inputRef : KM3!Reference (
			inputRef.upper = 1 and inputRef.lower = 0
		)
	to
		outputRef : KM3target!Reference (
			name <- inputRef.opposite.owner.name+'TotalOrder',
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			location <- inputRef.location,
			lower <- 1,
			upper <- 1,
			type <- KM3target!Class.allInstances()->select(a|a.name=inputRef.owner.name+'TotalOrder')->asSequence()->first(),
			owner <- inputRef.owner,
			opposite <- inputRef.opposite
		),
		outputOppositeRef : KM3target!Reference (
			name <- inputRef.opposite.owner.name+'OppositeTotalOrder',
			isOrdered <- inputRef.opposite.isOrdered,
			isUnique <- inputRef.opposite.isUnique,
			location <- inputRef.opposite.location,
			lower <- 1,
			upper <- 1,
			type <- inputRef.opposite.type,
			owner <- KM3target!Class.allInstances()->select(a|a.name=inputRef.owner.name+'TotalOrder')->asSequence()->first(),
			opposite <- outputRef
		)
}

--@begin rule attribute 
rule attribute {
	from
		inputAtt:KM3!Attribute 
	to
		outputAtt:KM3target!Attribute(
			name <- inputAtt.name,
			isOrdered <- inputAtt.isOrdered,
			isUnique <- inputAtt.isUnique,
			location <- inputAtt.location,
			lower <- inputAtt.lower,
			upper <- inputAtt.upper,
			type <- inputAtt.type,
			owner <- inputAtt.owner
			
		)
}
--@end rule attribute

--@begin rule DataType
rule DataType {
from
		inputData:KM3!DataType
	to
		outputData:KM3target!DataType(
			name <- inputData.name,
			location <- inputData.location
		)
}
--@end rule DataType

--@begin reference
rule reference {
	from
		inputRef:KM3!Reference (
			not(inputRef.upper = 1 and 	inputRef.lower = 0) and
			not(inputRef.opposite.upper = 1 and inputRef.opposite.lower = 0)
		)
	to
		outputRef:KM3target!Reference (
			name <- inputRef.name,
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			location <- inputRef.location,
			lower <- inputRef.lower,
			upper <- inputRef.upper,
			type <- inputRef.type,
			owner <- inputRef.owner,
			opposite <- inputRef.opposite
		)
}
--@end reference

--@begin enumeration
rule enumeration {
	from
		inputEnum:KM3!Enumeration 
	to
		outputEnum:KM3target!Enumeration (
			location <- inputEnum.location,
			name  <- inputEnum.name,
			package  <- inputEnum.package
		)

}
--@end enumeration

--@begin literal
rule literal {
	from
		inputEnum:KM3!EnumLiteral
	to
		outputEnum:KM3target!EnumLiteral (
			location <- inputEnum.location,
			name  <- inputEnum.name,
			enum  <- inputEnum.enum
		)

}
--@end literal
",modul replac modul templat creat out km target in km begin rule metamodel rule metamodel inputmm km metamodel outputmm km target metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km target packag name inputpkg name content inputpkg content end rule packag begin class rule classwithpartialord inputclass km class inputclass structuralfeatur select r r upper r lower isempti outputclass km target class name inputclass name isabstract inputclass isabstract structuralfeatur inputclass structuralfeatur supertyp inputclass supertyp totalorderclass km target class name inputclass name totalord isabstract true packag inputclass packag supertyp inputclass structuralfeatur iter acc sequenc km class sequenc ocliskindof km refer acc includ opposit owner els acc union sequenc endif end class begin class rule classwithoutpartialord inputclass km class inputclass structuralfeatur select r r upper r lower isempti outputclass km target class name inputclass name isabstract inputclass isabstract structuralfeatur inputclass structuralfeatur supertyp inputclass supertyp end class begin refer partial order rule referencepartialord inputref km refer inputref upper inputref lower outputref km target refer name inputref opposit owner name totalord isord inputref isord isuniqu inputref isuniqu locat inputref locat lower upper type km target class allinst select name inputref owner name totalord assequ first owner inputref owner opposit inputref opposit outputoppositeref km target refer name inputref opposit owner name oppositetotalord isord inputref opposit isord isuniqu inputref opposit isuniqu locat inputref opposit locat lower upper type inputref opposit type owner km target class allinst select name inputref owner name totalord assequ first opposit outputref begin rule attribut rule attribut inputatt km attribut outputatt km target attribut name inputatt name isord inputatt isord isuniqu inputatt isuniqu locat inputatt locat lower inputatt lower upper inputatt upper type inputatt type owner inputatt owner end rule attribut begin rule datatyp rule datatyp inputdata km datatyp outputdata km target datatyp name inputdata name locat inputdata locat end rule datatyp begin refer rule refer inputref km refer inputref upper inputref lower inputref opposit upper inputref opposit lower outputref km target refer name inputref name isord inputref isord isuniqu inputref isuniqu locat inputref locat lower inputref lower upper inputref upper type inputref type owner inputref owner opposit inputref opposit end refer begin enumer rule enumer inputenum km enumer outputenum km target enumer locat inputenum locat name inputenum name packag inputenum packag end enumer begin liter rule liter inputenum km enumliter outputenum km target enumliter locat inputenum locat name inputenum name enum inputenum enum end liter,8
14,14,P14-partial2totalRole-without.atl,"-- @name	 Making partial role total (a)
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		Baudry Julien (jul.baudry<at>gmail.com)
-- @date		2006/08/02
-- @description	The purpose of this transformation is to making a patial role total
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 2.14, page 23
-- @see author of article : K. Lano

module Replace; -- Module Template
create OUT : KM3target from IN : KM3;

--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3target!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
--@end rule Metamodel

--@begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3target!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
--@end rule Package

--@begin ClassWithPartialOrder
rule ClassWithPartialOrder {
	from
		inputClass:KM3!Class (
			not(inputClass.structuralFeatures->select(r|(r.upper=1)and(r.lower=0))->isEmpty())	
		)
		
	to
		outputClass:KM3target!Class (
			name <- inputClass.name,
			isAbstract <- inputClass.isAbstract,
			structuralFeatures <- inputClass.structuralFeatures,
			supertypes <- inputClass.supertypes
		),
		totalOrderClass : KM3target!Class (
			name <- inputClass.name+'TotalOrder',
			isAbstract <- true,
			package <- inputClass.package,
			supertypes <- inputClass.structuralFeatures->iterate(a;acc:Sequence(KM3!Class)=Sequence{}|
																	acc->including(a.opposite.owner))	
		)
}
--@end ClassWithPartialOrder

--@begin ClassWithoutPartialOrder
rule ClassWithoutPartialOrder {
	from
		inputClass:KM3!Class (
			inputClass.structuralFeatures->select(r|(r.upper=1)and(r.lower=0))->isEmpty()
		)
		
	to
		outputClass:KM3target!Class (
			name <- inputClass.name,
			isAbstract <- inputClass.isAbstract,
			structuralFeatures <- inputClass.structuralFeatures,
			supertypes <- inputClass.supertypes
		)
}
--@end ClassWithoutPartialOrder

--@begin reference partial order
rule referencePartialOrder {
	from 
		inputRef : KM3!Reference (
			inputRef.upper = 1 and inputRef.lower = 0
		)
	to
		outputRef : KM3target!Reference (
			name <- inputRef.opposite.owner.name+'TotalOrder',
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			location <- inputRef.location,
			lower <- 1,
			upper <- 1,
			type <- KM3target!Class.allInstances()->select(a|a.name=inputRef.owner.name+'TotalOrder')->asSequence()->first(),
			owner <- inputRef.owner,
			opposite <- inputRef.opposite
		),
		outputOppositeRef : KM3target!Reference (
			name <- inputRef.opposite.owner.name+'OppositeTotalOrder',
			isOrdered <- inputRef.opposite.isOrdered,
			isUnique <- inputRef.opposite.isUnique,
			location <- inputRef.opposite.location,
			lower <- 1,
			upper <- 1,
			type <- inputRef.opposite.type,
			owner <- KM3target!Class.allInstances()->select(a|a.name=inputRef.owner.name+'TotalOrder')->asSequence()->first(),
			opposite <- outputRef
		)
}
--@end reference partial order",name make partial role total version domain catalogu model transform author baudri julien jul baudri gmail com date descript the purpos transform make patial role total see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul replac modul templat creat out km target in km begin rule metamodel rule metamodel inputmm km metamodel outputmm km target metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km target packag name inputpkg name content inputpkg content end rule packag begin classwithpartialord rule classwithpartialord inputclass km class inputclass structuralfeatur select r r upper r lower isempti outputclass km target class name inputclass name isabstract inputclass isabstract structuralfeatur inputclass structuralfeatur supertyp inputclass supertyp totalorderclass km target class name inputclass name totalord isabstract true packag inputclass packag supertyp inputclass structuralfeatur iter acc sequenc km class sequenc acc includ opposit owner end classwithpartialord begin classwithoutpartialord rule classwithoutpartialord inputclass km class inputclass structuralfeatur select r r upper r lower isempti outputclass km target class name inputclass name isabstract inputclass isabstract structuralfeatur inputclass structuralfeatur supertyp inputclass supertyp end classwithoutpartialord begin refer partial order rule referencepartialord inputref km refer inputref upper inputref lower outputref km target refer name inputref opposit owner name totalord isord inputref isord isuniqu inputref isuniqu locat inputref locat lower upper type km target class allinst select name inputref owner name totalord assequ first owner inputref owner opposit inputref opposit outputoppositeref km target refer name inputref opposit owner name oppositetotalord isord inputref opposit isord isuniqu inputref opposit isuniqu locat inputref opposit locat lower upper type inputref opposit type owner km target class allinst select name inputref owner name totalord assequ first opposit outputref end refer partial order,1
15,15,P15-PartialRolesTotalB-context.atl,"-- @name	 Making partial role total (a)
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		Baudry Julien (jul.baudry<at>gmail.com)
-- @date		2006/08/02
-- @description	The purpose of this transformation is to making a patial role total
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 2.14, page 23
-- @see author of article : K. Lano

module PartialRolesTotalB; -- Module Template
create OUT : KM3Target from IN : KM3;

helper context KM3!Class def: hasChild : Boolean =
	KM3!Class.allInstances()->select(c|c.supertypes->notEmpty())->exists(r|r.supertypes.first() = self)
	;


--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3Target!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
--@end rule Metamodel

--@begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3Target!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
--@end rule Package

--@begin rule DataType
rule DataType {
	from
		inputData:KM3!DataType
	to
		outputData:KM3Target!DataType(
			name <- inputData.name,
			location <- inputData.location
		)
}
--@end rule DataType

--@begin rule EnumLiteral
rule EnumLiteral {
	from
		inputL:KM3!EnumLiteral
	to
		outputL:KM3Target!EnumLiteral (
			name <- inputL.name,
			location <- inputL.location,
			enum  <- inputL.enum,
			package <- inputL.package
		)
}
--@end rule EnumLiteral

--@begin rule Enumeration 
rule Enumeration {
	from
		inputEnum:KM3!Enumeration
	to
		outputEnum:KM3Target!Enumeration (
			name <- inputEnum.name,
			location <- inputEnum.location,
			package <- inputEnum.package,
			literals <- inputEnum.literals
		)
}
--@end rule Enumeration 

--@begin rule Class
rule Class {
	from
		inputC:KM3!Class
		( 		not( inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.upper=1)
					and inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.lower=0)
					and inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.opposite.upper=1)
					and inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.opposite.lower=1)
					and inputC.hasChild
				)
				and
				not( inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.upper=1)
					and inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.lower=1)
					and inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.opposite.upper=1)
					and inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.opposite.lower=0)
					and inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(c|c.type.hasChild)
				)
				and
				not( inputC.supertypes->exists(r|r.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.upper=1))
					and inputC.supertypes->exists(r|r.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.lower=0))
					and inputC.supertypes->exists(r|r.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.opposite.upper=1))
					and inputC.supertypes->exists(r|r.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.opposite.lower=1))
					and inputC.supertypes->notEmpty()
				)
			)
			to
		outputC:KM3Target!Class (
			isAbstract <- inputC.isAbstract,
			supertypes <- inputC.supertypes,
			name <- inputC.name,
			location <- inputC.location,
			package <- inputC.package,
			structuralFeatures <- inputC.structuralFeatures
		)
}
--@end rule Class

--@begin rule Attribute
rule Attribute {
	from
		inputAttr : KM3!Attribute
	to
		outputAttr : KM3Target!Attribute (
			package <- inputAttr.package,
			name <- inputAttr.name,
			lower <- inputAttr.lower,
			upper <- inputAttr.upper,
			isOrdered <- inputAttr.isOrdered,
			isUnique <- inputAttr.isUnique,
			owner <- inputAttr.owner,
			type <- inputAttr.type
		)
}
--@end rule Attribute

--@begin rule Reference
rule Reference {
	from
		inputRef : KM3!Reference
			( 	not( inputRef.upper=1
					and inputRef.lower=0
					and inputRef.opposite.upper=1
					and inputRef.opposite.lower=1
					and inputRef.owner.hasChild
				)
				and
				not( inputRef.upper=1
					and inputRef.lower=1
					and inputRef.opposite.upper=1
					and inputRef.opposite.lower=0
					and inputRef.type.hasChild
				)
			)
	to
		outputRef : KM3Target!Reference (
			package <- inputRef.package,
			name <- inputRef.name,
			lower <- inputRef.lower,
			upper <- inputRef.upper,
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			owner <- inputRef.owner,
			type <- inputRef.type,
			isContainer <- inputRef.isContainer,
			opposite <- inputRef.opposite
		)
}
--@end rule Attribute

--@begin rule Merging
rule PartialRoles {
	from
		inputSuperType : KM3!Class,
		inputChild : KM3!Class,
		inputClass : KM3!Class,
		inputRef : KM3!Reference,
		inputRef2 : KM3!Reference
	( (inputChild.supertypes->includes(inputSuperType)
		and inputRef.owner = inputSuperType
		and inputRef2.owner = inputClass
		and inputRef.upper = 1
		and inputRef.lower = 0
		and not inputRef.isContainer
		and inputRef2.upper = 1
		and inputRef2.lower = 1
		and not inputRef2.isContainer
		and inputRef.opposite=inputRef2
		)
	)
	to
		outputSuperType: KM3Target!Class(
			isAbstract <- inputSuperType.isAbstract,
			supertypes <- inputSuperType.supertypes,
			name <- inputSuperType.name,
			location <- inputSuperType.location,
			package <- inputSuperType.package,
			structuralFeatures <- inputSuperType.structuralFeatures->select(r| r<>inputRef)
			),
		outputClass: KM3Target!Class(
			isAbstract <- inputClass.isAbstract,
			supertypes <- inputClass.supertypes,
			name <- inputClass.name,
			location <- inputClass.location,
			package <- inputClass.package,
			structuralFeatures <- inputClass.structuralFeatures->select(r|r<>inputRef2),
			structuralFeatures <- outputRef2
			),
		outputRef: KM3Target!Reference(
			package <- inputRef.package,
			name <- inputRef.name,
			lower <- 1,
			upper <- 1,
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			owner <- outputChild,
			type <- outputClass,
			isContainer <- false,
			opposite <- outputRef2
			),
		outputChild: KM3Target!Class(
			isAbstract <- inputChild.isAbstract,
			supertypes <- inputChild.supertypes,
			name <- inputChild.name,
			location <- inputChild.location,
			package <- inputChild.package,
			structuralFeatures <- inputChild.structuralFeatures,
			structuralFeatures <- outputRef
			),
		outputRef2: KM3Target!Reference(
			package <- inputRef2.package,
			name <- inputRef2.name,
			lower <- 1,
			upper <- 1,
			isOrdered <- inputRef2.isOrdered,
			isUnique <- inputRef2.isUnique,
			owner <- inputRef2.owner,
			type <- outputChild,
			isContainer <- false,
			opposite <- outputRef
			)		
		
}




",name make partial role total version domain catalogu model transform author baudri julien jul baudri gmail com date descript the purpos transform make patial role total see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul partialrolestotalb modul templat creat out km target in km helper context km class def haschild boolean km class allinst select c c supertyp notempti exist r r supertyp first self begin rule metamodel rule metamodel inputmm km metamodel outputmm km target metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km target packag name inputpkg name content inputpkg content end rule packag begin rule datatyp rule datatyp inputdata km datatyp outputdata km target datatyp name inputdata name locat inputdata locat end rule datatyp begin rule enumliter rule enumliter inputl km enumliter outputl km target enumliter name inputl name locat inputl locat enum inputl enum packag inputl packag end rule enumliter begin rule enumer rule enumer inputenum km enumer outputenum km target enumer name inputenum name locat inputenum locat packag inputenum packag liter inputenum liter end rule enumer begin rule class rule class inputc km class inputc structuralfeatur select r r oclistypeof km refer exist r r upper inputc structuralfeatur select r r oclistypeof km refer exist r r lower inputc structuralfeatur select r r oclistypeof km refer exist r r opposit upper inputc structuralfeatur select r r oclistypeof km refer exist r r opposit lower inputc haschild inputc structuralfeatur select r r oclistypeof km refer exist r r upper inputc structuralfeatur select r r oclistypeof km refer exist r r lower inputc structuralfeatur select r r oclistypeof km refer exist r r opposit upper inputc structuralfeatur select r r oclistypeof km refer exist r r opposit lower inputc structuralfeatur select r r oclistypeof km refer exist c c type haschild inputc supertyp exist r r structuralfeatur select r r oclistypeof km refer exist r r upper inputc supertyp exist r r structuralfeatur select r r oclistypeof km refer exist r r lower inputc supertyp exist r r structuralfeatur select r r oclistypeof km refer exist r r opposit upper inputc supertyp exist r r structuralfeatur select r r oclistypeof km refer exist r r opposit lower inputc supertyp notempti outputc km target class isabstract inputc isabstract supertyp inputc supertyp name inputc name locat inputc locat packag inputc packag structuralfeatur inputc structuralfeatur end rule class begin rule attribut rule attribut inputattr km attribut outputattr km target attribut packag inputattr packag name inputattr name lower inputattr lower upper inputattr upper isord inputattr isord isuniqu inputattr isuniqu owner inputattr owner type inputattr type end rule attribut begin rule refer rule refer inputref km refer inputref upper inputref lower inputref opposit upper inputref opposit lower inputref owner haschild inputref upper inputref lower inputref opposit upper inputref opposit lower inputref type haschild outputref km target refer packag inputref packag name inputref name lower inputref lower upper inputref upper isord inputref isord isuniqu inputref isuniqu owner inputref owner type inputref type iscontain inputref iscontain opposit inputref opposit end rule attribut begin rule merg rule partialrol inputsupertyp km class inputchild km class inputclass km class inputref km refer inputref km refer inputchild supertyp includ inputsupertyp inputref owner inputsupertyp inputref owner inputclass inputref upper inputref lower inputref iscontain inputref upper inputref lower inputref iscontain inputref opposit inputref outputsupertyp km target class isabstract inputsupertyp isabstract supertyp inputsupertyp supertyp name inputsupertyp name locat inputsupertyp locat packag inputsupertyp packag structuralfeatur inputsupertyp structuralfeatur select r r inputref outputclass km target class isabstract inputclass isabstract supertyp inputclass supertyp name inputclass name locat inputclass locat packag inputclass packag structuralfeatur inputclass structuralfeatur select r r inputref structuralfeatur outputref outputref km target refer packag inputref packag name inputref name lower upper isord inputref isord isuniqu inputref isuniqu owner outputchild type outputclass iscontain fals opposit outputref outputchild km target class isabstract inputchild isabstract supertyp inputchild supertyp name inputchild name locat inputchild locat packag inputchild packag structuralfeatur inputchild structuralfeatur structuralfeatur outputref outputref km target refer packag inputref packag name inputref name lower upper isord inputref isord isuniqu inputref isuniqu owner inputref owner type outputchild iscontain fals opposit outputref,19
16,16,P15-PartialRolesTotalB-without.atl,"-- @name	 Making partial role total (a)
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		Baudry Julien (jul.baudry<at>gmail.com)
-- @date		2006/08/02
-- @description	The purpose of this transformation is to making a patial role total
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 2.14, page 23
-- @see author of article : K. Lano

module PartialRolesTotalB; -- Module Template
create OUT : KM3Target from IN : KM3;

helper context KM3!Class def: hasChild : Boolean =
	KM3!Class.allInstances()->select(c|c.supertypes->notEmpty())->exists(r|r.supertypes.first() = self)
	;


--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3Target!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
--@end rule Metamodel

--@begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3Target!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
--@end rule Package


--@begin rule Class
rule Class {
	from
		inputC:KM3!Class
		( 		not( inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.upper=1)
					and inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.lower=0)
					and inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.opposite.upper=1)
					and inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.opposite.lower=1)
					and inputC.hasChild
				)
				and
				not( inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.upper=1)
					and inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.lower=1)
					and inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.opposite.upper=1)
					and inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.opposite.lower=0)
					and inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(c|c.type.hasChild)
				)
				and
				not( inputC.supertypes->exists(r|r.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.upper=1))
					and inputC.supertypes->exists(r|r.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.lower=0))
					and inputC.supertypes->exists(r|r.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.opposite.upper=1))
					and inputC.supertypes->exists(r|r.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.opposite.lower=1))
					and inputC.supertypes->notEmpty()
				)
			)
			to
		outputC:KM3Target!Class (
			isAbstract <- inputC.isAbstract,
			supertypes <- inputC.supertypes,
			name <- inputC.name,
			location <- inputC.location,
			package <- inputC.package,
			structuralFeatures <- inputC.structuralFeatures
		)
}
--@end rule Class


--@begin rule Reference
rule Reference {
	from
		inputRef : KM3!Reference
			( 	not( inputRef.upper=1
					and inputRef.lower=0
					and inputRef.opposite.upper=1
					and inputRef.opposite.lower=1
					and inputRef.owner.hasChild
				)
				and
				not( inputRef.upper=1
					and inputRef.lower=1
					and inputRef.opposite.upper=1
					and inputRef.opposite.lower=0
					and inputRef.type.hasChild
				)
			)
	to
		outputRef : KM3Target!Reference (
			package <- inputRef.package,
			name <- inputRef.name,
			lower <- inputRef.lower,
			upper <- inputRef.upper,
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			owner <- inputRef.owner,
			type <- inputRef.type,
			isContainer <- inputRef.isContainer,
			opposite <- inputRef.opposite
		)
}
--@end rule Attribute

--@begin rule Merging
rule PartialRoles {
	from
		inputSuperType : KM3!Class,
		inputChild : KM3!Class,
		inputClass : KM3!Class,
		inputRef : KM3!Reference,
		inputRef2 : KM3!Reference
	( (inputChild.supertypes->includes(inputSuperType)
		and inputRef.owner = inputSuperType
		and inputRef2.owner = inputClass
		and inputRef.upper = 1
		and inputRef.lower = 0
		and not inputRef.isContainer
		and inputRef2.upper = 1
		and inputRef2.lower = 1
		and not inputRef2.isContainer
		and inputRef.opposite=inputRef2
		)
	)
	to
		outputSuperType: KM3Target!Class(
			isAbstract <- inputSuperType.isAbstract,
			supertypes <- inputSuperType.supertypes,
			name <- inputSuperType.name,
			location <- inputSuperType.location,
			package <- inputSuperType.package,
			structuralFeatures <- inputSuperType.structuralFeatures->select(r| r<>inputRef)
			),
		outputClass: KM3Target!Class(
			isAbstract <- inputClass.isAbstract,
			supertypes <- inputClass.supertypes,
			name <- inputClass.name,
			location <- inputClass.location,
			package <- inputClass.package,
			structuralFeatures <- inputClass.structuralFeatures->select(r|r<>inputRef2),
			structuralFeatures <- outputRef2
			),
		outputRef: KM3Target!Reference(
			package <- inputRef.package,
			name <- inputRef.name,
			lower <- 1,
			upper <- 1,
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			owner <- outputChild,
			type <- outputClass,
			isContainer <- false,
			opposite <- outputRef2
			),
		outputChild: KM3Target!Class(
			isAbstract <- inputChild.isAbstract,
			supertypes <- inputChild.supertypes,
			name <- inputChild.name,
			location <- inputChild.location,
			package <- inputChild.package,
			structuralFeatures <- inputChild.structuralFeatures,
			structuralFeatures <- outputRef
			),
		outputRef2: KM3Target!Reference(
			package <- inputRef2.package,
			name <- inputRef2.name,
			lower <- 1,
			upper <- 1,
			isOrdered <- inputRef2.isOrdered,
			isUnique <- inputRef2.isUnique,
			owner <- inputRef2.owner,
			type <- outputChild,
			isContainer <- false,
			opposite <- outputRef
			)		
		
}




",name make partial role total version domain catalogu model transform author baudri julien jul baudri gmail com date descript the purpos transform make patial role total see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul partialrolestotalb modul templat creat out km target in km helper context km class def haschild boolean km class allinst select c c supertyp notempti exist r r supertyp first self begin rule metamodel rule metamodel inputmm km metamodel outputmm km target metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km target packag name inputpkg name content inputpkg content end rule packag begin rule class rule class inputc km class inputc structuralfeatur select r r oclistypeof km refer exist r r upper inputc structuralfeatur select r r oclistypeof km refer exist r r lower inputc structuralfeatur select r r oclistypeof km refer exist r r opposit upper inputc structuralfeatur select r r oclistypeof km refer exist r r opposit lower inputc haschild inputc structuralfeatur select r r oclistypeof km refer exist r r upper inputc structuralfeatur select r r oclistypeof km refer exist r r lower inputc structuralfeatur select r r oclistypeof km refer exist r r opposit upper inputc structuralfeatur select r r oclistypeof km refer exist r r opposit lower inputc structuralfeatur select r r oclistypeof km refer exist c c type haschild inputc supertyp exist r r structuralfeatur select r r oclistypeof km refer exist r r upper inputc supertyp exist r r structuralfeatur select r r oclistypeof km refer exist r r lower inputc supertyp exist r r structuralfeatur select r r oclistypeof km refer exist r r opposit upper inputc supertyp exist r r structuralfeatur select r r oclistypeof km refer exist r r opposit lower inputc supertyp notempti outputc km target class isabstract inputc isabstract supertyp inputc supertyp name inputc name locat inputc locat packag inputc packag structuralfeatur inputc structuralfeatur end rule class begin rule refer rule refer inputref km refer inputref upper inputref lower inputref opposit upper inputref opposit lower inputref owner haschild inputref upper inputref lower inputref opposit upper inputref opposit lower inputref type haschild outputref km target refer packag inputref packag name inputref name lower inputref lower upper inputref upper isord inputref isord isuniqu inputref isuniqu owner inputref owner type inputref type iscontain inputref iscontain opposit inputref opposit end rule attribut begin rule merg rule partialrol inputsupertyp km class inputchild km class inputclass km class inputref km refer inputref km refer inputchild supertyp includ inputsupertyp inputref owner inputsupertyp inputref owner inputclass inputref upper inputref lower inputref iscontain inputref upper inputref lower inputref iscontain inputref opposit inputref outputsupertyp km target class isabstract inputsupertyp isabstract supertyp inputsupertyp supertyp name inputsupertyp name locat inputsupertyp locat packag inputsupertyp packag structuralfeatur inputsupertyp structuralfeatur select r r inputref outputclass km target class isabstract inputclass isabstract supertyp inputclass supertyp name inputclass name locat inputclass locat packag inputclass packag structuralfeatur inputclass structuralfeatur select r r inputref structuralfeatur outputref outputref km target refer packag inputref packag name inputref name lower upper isord inputref isord isuniqu inputref isuniqu owner outputchild type outputclass iscontain fals opposit outputref outputchild km target class isabstract inputchild isabstract supertyp inputchild supertyp name inputchild name locat inputchild locat packag inputchild packag structuralfeatur inputchild structuralfeatur structuralfeatur outputref outputref km target refer packag inputref packag name inputref name lower upper isord inputref isord isuniqu inputref isuniqu owner inputref owner type outputchild iscontain fals opposit outputref,19
17,17,P16-MergingPartialClasses-context.atl,"-- @name		Merge partial classes(with all context)
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		Eric Simon(simon.eric3<at>gmail.com), Régis Chevrel (chevrel.regis <at> gmail.com)
-- @date		2006/08/09
-- @description	Classes may define only part of a coherent concept, other parts may be expressed in different classes and their commonalities have not been recognised. This transformation merges such classes into a single class.
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 2.6, page 22
-- @see author of article : K. Lano

module MergingPartialClasses; -- Module Template
create OUT : KM3 from IN : KM3;

helper context KM3!Reference def: isMerginable : Boolean =
	self.lower = 1 and self.upper = 1 and not self.isContainer
	;

helper def: assoMap : Map(KM3!Reference, Sequence(KM3!Reference)) = Map{};
rule isAlreadyConsidered(ref1 : KM3!Reference, ref2 : KM3!Reference) {

	do {
		if (not thisModule.assoMap.get(ref2).oclIsUndefined()) {
			if (thisModule.assoMap.get(ref2)->includes(ref1)) {
				true;
			}
			else {
			    if (not thisModule.assoMap.get(ref1).oclIsUndefined()) {
					thisModule.assoMap <- thisModule.assoMap.including(ref1,thisModule.assoMap.get(ref1)->including(ref2));
					false;
			    }
				else {
					thisModule.assoMap <- thisModule.assoMap.including(ref1, Sequence{ref2});
					false;
				}
			}
		}
		else  {
				if (not thisModule.assoMap.get(ref1).oclIsUndefined()) {
					thisModule.assoMap <- thisModule.assoMap.including(ref1,thisModule.assoMap.get(ref1)->including(ref2));
					false;
			    }
				else {	
					thisModule.assoMap <- thisModule.assoMap.including(ref1, Sequence{ref2});
					false;
				}
		}
		
	}
}



--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
--@end rule Metamodel

--@begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
--@end rule Package

--@begin rule DataType
rule DataType {
	from
		inputData:KM3!DataType
	to
		outputData:KM3!DataType(
			name <- inputData.name,
			location <- inputData.location
		)
}
--@end rule DataType

--@begin rule EnumLiteral
rule EnumLiteral {
	from
		inputL:KM3!EnumLiteral
	to
		outputL:KM3!EnumLiteral (
			name <- inputL.name,
			location <- inputL.location,
			enum  <- inputL.enum,
			package <- inputL.package
		)
}
--@end rule EnumLiteral

--@begin rule Enumeration 
rule Enumeration {
	from
		inputEnum:KM3!Enumeration
	to
		outputEnum:KM3!Enumeration (
			name <- inputEnum.name,
			location <- inputEnum.location,
			package <- inputEnum.package,
			literals <- inputEnum.literals
		)
}
--@end rule Enumeration 

--@begin rule Class
rule Class {
	from
		inputC:KM3!Class
		(not inputC.structuralFeatures->select(a|a.oclIsTypeOf(KM3!Reference))->exists(r| r.isMerginable and r.opposite.isMerginable))
	to
		outputC:KM3!Class (
			isAbstract <- inputC.isAbstract,
			supertypes <- inputC.supertypes,
			name <- inputC.name,
			location <- inputC.location,
			package <- inputC.package,
			structuralFeatures <- inputC.structuralFeatures
		)
}
--@end rule Class

--@begin rule Attribute
rule Attribute {
	from
		inputAttr : KM3!Attribute
	to
		outputAttr : KM3!Attribute (
			package <- inputAttr.package,
			name <- inputAttr.name,
			lower <- inputAttr.lower,
			upper <- inputAttr.upper,
			isOrdered <- inputAttr.isOrdered,
			isUnique <- inputAttr.isUnique,
			owner <- inputAttr.owner,
			type <- inputAttr.type
		)
}
--@end rule Attribute

--@begin rule Reference
rule Reference {
	from
		inputRef : KM3!Reference
			( not (inputRef.isMerginable and inputRef.opposite.isMerginable))
	to
		outputRef : KM3!Reference (
			package <- inputRef.package,
			name <- inputRef.name,
			lower <- inputRef.lower,
			upper <- inputRef.upper,
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			owner <- inputRef.owner,
			type <- inputRef.type,
			isContainer <- inputRef.isContainer,
			opposite <- inputRef.opposite
		)
}
--@end rule Attribute

--@begin rule Merging
rule Merging {
	from
		inputA : KM3!Reference,
		inputB : KM3!Reference
		(
			inputA.opposite = inputB
			and inputA.isMerginable
			and inputB.isMerginable
			and inputA <> inputB
			and not thisModule.isAlreadyConsidered(inputA, inputB)
		)


	to
		outputA : KM3!Class (
			package <- inputA.owner.package,
			name <- inputA.owner.name->concat(inputB.owner.name),
			isAbstract <- inputA.owner.isAbstract,
			structuralFeatures <- inputA.owner.structuralFeatures->select(b|b.oclIsTypeOf(KM3!Reference))->select(a| not a.isMerginable),
			structuralFeatures <- inputA.owner.structuralFeatures->select(b|b.oclIsTypeOf(KM3!Attribute)),
			structuralFeatures <- inputB.owner.structuralFeatures->select(b|b.oclIsTypeOf(KM3!Reference))->select(a| not a.isMerginable),
			structuralFeatures <- inputB.owner.structuralFeatures->select(b|b.oclIsTypeOf(KM3!Attribute))
		)
}
--@end rule Merging



",name merg partial class context version domain catalogu model transform author eric simon simon eric gmail com r gis chevrel chevrel regi gmail com date descript class may defin part coher concept part may express differ class common recognis this transform merg class singl class see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul mergingpartialclass modul templat creat out km in km helper context km refer def ismergin boolean self lower self upper self iscontain helper def assomap map km refer sequenc km refer map rule isalreadyconsid ref km refer ref km refer thismodul assomap get ref oclisundefin thismodul assomap get ref includ ref true els thismodul assomap get ref oclisundefin thismodul assomap thismodul assomap includ ref thismodul assomap get ref includ ref fals els thismodul assomap thismodul assomap includ ref sequenc ref fals els thismodul assomap get ref oclisundefin thismodul assomap thismodul assomap includ ref thismodul assomap get ref includ ref fals els thismodul assomap thismodul assomap includ ref sequenc ref fals begin rule metamodel rule metamodel inputmm km metamodel outputmm km metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km packag name inputpkg name content inputpkg content end rule packag begin rule datatyp rule datatyp inputdata km datatyp outputdata km datatyp name inputdata name locat inputdata locat end rule datatyp begin rule enumliter rule enumliter inputl km enumliter outputl km enumliter name inputl name locat inputl locat enum inputl enum packag inputl packag end rule enumliter begin rule enumer rule enumer inputenum km enumer outputenum km enumer name inputenum name locat inputenum locat packag inputenum packag liter inputenum liter end rule enumer begin rule class rule class inputc km class inputc structuralfeatur select oclistypeof km refer exist r r ismergin r opposit ismergin outputc km class isabstract inputc isabstract supertyp inputc supertyp name inputc name locat inputc locat packag inputc packag structuralfeatur inputc structuralfeatur end rule class begin rule attribut rule attribut inputattr km attribut outputattr km attribut packag inputattr packag name inputattr name lower inputattr lower upper inputattr upper isord inputattr isord isuniqu inputattr isuniqu owner inputattr owner type inputattr type end rule attribut begin rule refer rule refer inputref km refer inputref ismergin inputref opposit ismergin outputref km refer packag inputref packag name inputref name lower inputref lower upper inputref upper isord inputref isord isuniqu inputref isuniqu owner inputref owner type inputref type iscontain inputref iscontain opposit inputref opposit end rule attribut begin rule merg rule merg inputa km refer inputb km refer inputa opposit inputb inputa ismergin inputb ismergin inputa inputb thismodul isalreadyconsid inputa inputb outputa km class packag inputa owner packag name inputa owner name concat inputb owner name isabstract inputa owner isabstract structuralfeatur inputa owner structuralfeatur select b b oclistypeof km refer select ismergin structuralfeatur inputa owner structuralfeatur select b b oclistypeof km attribut structuralfeatur inputb owner structuralfeatur select b b oclistypeof km refer select ismergin structuralfeatur inputb owner structuralfeatur select b b oclistypeof km attribut end rule merg,19
18,18,P16-MergingPartialClasses-without.atl,"-- @name		Merge partial classes(with only the  elements necessary for the example context)
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		Eric Simon(simon.eric3<at>gmail.com), Régis Chevrel (chevrel.regis <at> gmail.com)
-- @date		2006/08/09
-- @description	Classes may define only part of a coherent concept, other parts may be expressed in different classes and their commonalities have not been recognised. This transformation merges such classes into a single class.
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 2.6, page 22
-- @see author of article : K. Lano

module MergingPartialClasses; -- Module Template
create OUT : KM3 from IN : KM3;

--helper def: rootPackage : KM3!Package =
--	KM3!Package.allInstances()->select(e | e.name <> 'PrimitiveTypes')->first();

helper context KM3!Reference def: isMerginable : Boolean =
	self.lower = 1 and self.upper = 1 and not self.isContainer
	;

helper def: assoMap : Map(KM3!Reference, Sequence(KM3!Reference)) = Map{};
rule isAlreadyConsidered(ref1 : KM3!Reference, ref2 : KM3!Reference) {

	do {
		if (not thisModule.assoMap.get(ref2).oclIsUndefined()) {
			if (thisModule.assoMap.get(ref2)->includes(ref1)) {
				true;
			}
			else {
			    if (not thisModule.assoMap.get(ref1).oclIsUndefined()) {
					thisModule.assoMap <- thisModule.assoMap.including(ref1,thisModule.assoMap.get(ref1)->including(ref2));
					false;
			    }
				else {
					thisModule.assoMap <- thisModule.assoMap.including(ref1, Sequence{ref2});
					false;
				}
			}
		}
		else  {
				if (not thisModule.assoMap.get(ref1).oclIsUndefined()) {
					thisModule.assoMap <- thisModule.assoMap.including(ref1,thisModule.assoMap.get(ref1)->including(ref2));
					false;
			    }
				else {	
					thisModule.assoMap <- thisModule.assoMap.including(ref1, Sequence{ref2});
					false;
				}
		}
		
	}
}



--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
--@end rule Metamodel

--@begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
--@end rule Package

--@begin rule DataType
rule DataType {
	from
		inputData:KM3!DataType
	to
		outputData:KM3!DataType(
			name <- inputData.name,
			location <- inputData.location
		)
}
--@end rule DataType

--@begin rule EnumLiteral
rule EnumLiteral {
	from
		inputL:KM3!EnumLiteral
	to
		outputL:KM3!EnumLiteral (
			name <- inputL.name,
			location <- inputL.location,
			enum  <- inputL.enum,
			package <- inputL.package
		)
}
--@end rule EnumLiteral


--@begin rule Class
rule Class {
	from
		inputC:KM3!Class
		(not inputC.structuralFeatures->select(a|a.oclIsTypeOf(KM3!Reference))->exists(r| r.isMerginable and r.opposite.isMerginable))
	to
		outputC:KM3!Class (
			isAbstract <- inputC.isAbstract,
			supertypes <- inputC.supertypes,
			name <- inputC.name,
			location <- inputC.location,
			package <- inputC.package,
			structuralFeatures <- inputC.structuralFeatures
		)
}
--@end rule Class

--@begin rule Attribute
rule Attribute {
	from
		inputAttr : KM3!Attribute
	to
		outputAttr : KM3!Attribute (
			package <- inputAttr.package,
			name <- inputAttr.name,
			lower <- inputAttr.lower,
			upper <- inputAttr.upper,
			isOrdered <- inputAttr.isOrdered,
			isUnique <- inputAttr.isUnique,
			owner <- inputAttr.owner,
			type <- inputAttr.type
		)
}
--@end rule Attribute

--@begin rule Reference
rule Reference {
	from
		inputRef : KM3!Reference
			( not (inputRef.isMerginable and inputRef.opposite.isMerginable))
	to
		outputRef : KM3!Reference (
			package <- inputRef.package,
			name <- inputRef.name,
			lower <- inputRef.lower,
			upper <- inputRef.upper,
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			owner <- inputRef.owner,
			type <- inputRef.type,
			isContainer <- inputRef.isContainer,
			opposite <- inputRef.opposite
		)
}
--@end rule Attribute

--@begin rule Merging
rule Merging {
	from
		inputA : KM3!Reference,
		inputB : KM3!Reference
		(
			inputA.opposite = inputB
			and inputA.isMerginable
			and inputB.isMerginable
			and inputA <> inputB
			and not thisModule.isAlreadyConsidered(inputA, inputB)
		)


	to
		outputA : KM3!Class (
			package <- inputA.owner.package,
			name <- inputA.owner.name->concat(inputB.owner.name),
			isAbstract <- inputA.owner.isAbstract,
			structuralFeatures <- inputA.owner.structuralFeatures->select(b|b.oclIsTypeOf(KM3!Reference))->select(a| not a.isMerginable),
			structuralFeatures <- inputA.owner.structuralFeatures->select(b|b.oclIsTypeOf(KM3!Attribute)),
			structuralFeatures <- inputB.owner.structuralFeatures->select(b|b.oclIsTypeOf(KM3!Reference))->select(a| not a.isMerginable),
			structuralFeatures <- inputB.owner.structuralFeatures->select(b|b.oclIsTypeOf(KM3!Attribute))
		)
}
--@end rule Merging



",name merg partial class element necessari exampl context version domain catalogu model transform author eric simon simon eric gmail com r gis chevrel chevrel regi gmail com date descript class may defin part coher concept part may express differ class common recognis this transform merg class singl class see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul mergingpartialclass modul templat creat out km in km helper def rootpackag km packag km packag allinst select e e name primitivetyp first helper context km refer def ismergin boolean self lower self upper self iscontain helper def assomap map km refer sequenc km refer map rule isalreadyconsid ref km refer ref km refer thismodul assomap get ref oclisundefin thismodul assomap get ref includ ref true els thismodul assomap get ref oclisundefin thismodul assomap thismodul assomap includ ref thismodul assomap get ref includ ref fals els thismodul assomap thismodul assomap includ ref sequenc ref fals els thismodul assomap get ref oclisundefin thismodul assomap thismodul assomap includ ref thismodul assomap get ref includ ref fals els thismodul assomap thismodul assomap includ ref sequenc ref fals begin rule metamodel rule metamodel inputmm km metamodel outputmm km metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km packag name inputpkg name content inputpkg content end rule packag begin rule datatyp rule datatyp inputdata km datatyp outputdata km datatyp name inputdata name locat inputdata locat end rule datatyp begin rule enumliter rule enumliter inputl km enumliter outputl km enumliter name inputl name locat inputl locat enum inputl enum packag inputl packag end rule enumliter begin rule class rule class inputc km class inputc structuralfeatur select oclistypeof km refer exist r r ismergin r opposit ismergin outputc km class isabstract inputc isabstract supertyp inputc supertyp name inputc name locat inputc locat packag inputc packag structuralfeatur inputc structuralfeatur end rule class begin rule attribut rule attribut inputattr km attribut outputattr km attribut packag inputattr packag name inputattr name lower inputattr lower upper inputattr upper isord inputattr isord isuniqu inputattr isuniqu owner inputattr owner type inputattr type end rule attribut begin rule refer rule refer inputref km refer inputref ismergin inputref opposit ismergin outputref km refer packag inputref packag name inputref name lower inputref lower upper inputref upper isord inputref isord isuniqu inputref isuniqu owner inputref owner type inputref type iscontain inputref iscontain opposit inputref opposit end rule attribut begin rule merg rule merg inputa km refer inputb km refer inputa opposit inputb inputa ismergin inputb ismergin inputa inputb thismodul isalreadyconsid inputa inputb outputa km class packag inputa owner packag name inputa owner name concat inputb owner name isabstract inputa owner isabstract structuralfeatur inputa owner structuralfeatur select b b oclistypeof km refer select ismergin structuralfeatur inputa owner structuralfeatur select b b oclistypeof km attribut structuralfeatur inputb owner structuralfeatur select b b oclistypeof km refer select ismergin structuralfeatur inputb owner structuralfeatur select b b oclistypeof km attribut end rule merg,19
19,19,P17-RaiseSupplier-context.atl,"-- @name		Raise supplier abstraction level
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		SIMON Eric(simon.eric3<at>gmail.com)
-- @date		2006/07/27
-- @description	This transformation strenghthens or weakens an assertion(respectively postcondition and precondition).
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 2.13, page 27
-- @see author of article : K. Lano

module RaiseSupplier; -- Module Template
create OUT : KM3 from IN : KM3;

-- @comment this helper returns the root SuperTypes of an element (it is a recursive helper)
helper context KM3!Class def: getRootSuperTypes : Sequence(KM3!Class) =
	if self.supertypes->isEmpty()
		then Sequence{}	
	else 		self.supertypes->select(c | c.supertypes->notEmpty())
					->iterate(a; acc : Sequence(KM3!Class)=Sequence{} |acc->including(a.getRootSuperTypes))
					->union(
					self.supertypes->select(c | c.supertypes->isEmpty())
					->iterate(a; acc : Sequence(KM3!Class)=Sequence{} | acc->including(a) )
			).flatten()
	endif;
	



--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
--@end rule Metamodel

--@begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
--@end rule Package

--@begin rule DataType
rule DataType {
	from
		inputData:KM3!DataType
	to
		outputData:KM3!DataType(
			name <- inputData.name,
			location <- inputData.location
		)
}
--@end rule DataType

--@begin rule EnumLiteral
rule EnumLiteral {
	from
		inputL:KM3!EnumLiteral
	to
		outputL:KM3!EnumLiteral (
			name <- inputL.name,
			location <- inputL.location,
			enum  <- inputL.enum,
			package <- inputL.package
		)
}
--@end rule EnumLiteral

--@begin rule Enumeration 
rule Enumeration {
	from
		inputEnum:KM3!Enumeration
	to
		outputEnum:KM3!Enumeration (
			name <- inputEnum.name,
			location <- inputEnum.location,
			package <- inputEnum.package,
			literals <- inputEnum.literals
		)
}
--@end rule Enumeration 

--@begin rule Class
rule Class {
	from
		inputC:KM3!Class
			to
		outputC:KM3!Class (
			isAbstract <- inputC.isAbstract,
			supertypes <- inputC.supertypes,
			name <- inputC.name,
			location <- inputC.location,
			package <- inputC.package,
			structuralFeatures <- inputC.structuralFeatures->
				select(r | r.oclIsTypeOf(KM3!Reference))->select(r | r.opposite.oclIsUndefined())->
				iterate(a;acc : Sequence(KM3!Reference) = Sequence{} | 
					if a.type.oclIsTypeOf(KM3!Class)
						then acc->append(a.type.getRootSuperTypes->iterate(b; acc1:Sequence(KM3!Reference) = Sequence{}|
							acc1->append(thisModule.InheritAndAssociation(b,a))))->flatten()
						else acc
						endif),
			structuralFeatures <- inputC.structuralFeatures
				->select(r | r.oclIsTypeOf(KM3!Reference))
				->select(r | not r.opposite.oclIsUndefined()),
			structuralFeatures <- inputC.structuralFeatures
				->select(r | not r.oclIsTypeOf(KM3!Reference))
		)
}
--@end rule Class



--@begin rule Attribute
rule Attribute {
	from
		inputAttr : KM3!Attribute
	to
		outputAttr : KM3!Attribute (
			package <- inputAttr.package,
			name <- inputAttr.name,
			lower <- inputAttr.lower,
			upper <- inputAttr.upper,
			isOrdered <- inputAttr.isOrdered,
			isUnique <- inputAttr.isUnique,
			owner <- inputAttr.owner,
			type <- inputAttr.type
		)
}
--@end rule Attribute

--@begin rule Reference
rule ReferenceWithOpposite {
	from
		inputRef : KM3!Reference
		(not inputRef.opposite.oclIsUndefined())
	to
		outputRef : KM3!Reference (
			package <- inputRef.package,
			name <- inputRef.name,
			lower <- inputRef.lower,
			upper <- inputRef.upper,
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			owner <- inputRef.owner,
			type <- inputRef.type,
			isContainer <- inputRef.isContainer,
			opposite <- inputRef.opposite
		)
}
--@end rule Reference

-- @comment this lazy rule creates a reference for a given supertypes end another reference
lazy rule InheritAndAssociation{
	from
		supertype:KM3!Class,
		reference:KM3!Reference
		
	to
		refChildren : KM3!Reference (
			package <- reference.package,
			name <- reference.name,
			lower <- reference.lower,
			upper <- reference.upper,
			isOrdered <- reference.isOrdered,
			isUnique <- reference.isUnique,
			owner <- reference.owner,
			type <- supertype,
			isContainer <- reference.isContainer
		)
}
",name rais supplier abstract level version domain catalogu model transform author simon eric simon eric gmail com date descript this transform strenghthen weaken assert respect postcondit precondit see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul raisesuppli modul templat creat out km in km comment helper return root supertyp element recurs helper helper context km class def getrootsupertyp sequenc km class self supertyp isempti sequenc els self supertyp select c c supertyp notempti iter acc sequenc km class sequenc acc includ getrootsupertyp union self supertyp select c c supertyp isempti iter acc sequenc km class sequenc acc includ flatten endif begin rule metamodel rule metamodel inputmm km metamodel outputmm km metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km packag name inputpkg name content inputpkg content end rule packag begin rule datatyp rule datatyp inputdata km datatyp outputdata km datatyp name inputdata name locat inputdata locat end rule datatyp begin rule enumliter rule enumliter inputl km enumliter outputl km enumliter name inputl name locat inputl locat enum inputl enum packag inputl packag end rule enumliter begin rule enumer rule enumer inputenum km enumer outputenum km enumer name inputenum name locat inputenum locat packag inputenum packag liter inputenum liter end rule enumer begin rule class rule class inputc km class outputc km class isabstract inputc isabstract supertyp inputc supertyp name inputc name locat inputc locat packag inputc packag structuralfeatur inputc structuralfeatur select r r oclistypeof km refer select r r opposit oclisundefin iter acc sequenc km refer sequenc type oclistypeof km class acc append type getrootsupertyp iter b acc sequenc km refer sequenc acc append thismodul inheritandassoci b flatten els acc endif structuralfeatur inputc structuralfeatur select r r oclistypeof km refer select r r opposit oclisundefin structuralfeatur inputc structuralfeatur select r r oclistypeof km refer end rule class begin rule attribut rule attribut inputattr km attribut outputattr km attribut packag inputattr packag name inputattr name lower inputattr lower upper inputattr upper isord inputattr isord isuniqu inputattr isuniqu owner inputattr owner type inputattr type end rule attribut begin rule refer rule referencewithopposit inputref km refer inputref opposit oclisundefin outputref km refer packag inputref packag name inputref name lower inputref lower upper inputref upper isord inputref isord isuniqu inputref isuniqu owner inputref owner type inputref type iscontain inputref iscontain opposit inputref opposit end rule refer comment lazi rule creat refer given supertyp end anoth refer lazi rule inheritandassoci supertyp km class refer km refer refchildren km refer packag refer packag name refer name lower refer lower upper refer upper isord refer isord isuniqu refer isuniqu owner refer owner type supertyp iscontain refer iscontain,8
20,20,P17-RaiseSupplier-without.atl,"-- @name		Raise supplier abstraction level
-- @version		1.1
-- @domains		Catalogue of Model Transformations
-- @authors		SIMON Eric(simon.eric3<at>gmail.com)
-- @date		2006/07/27
-- @description	This transformation strenghthens or weakens an assertion(respectively postcondition and precondition).
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 2.13, page 27
-- @see author of article : K. Lano-- @authors Eric Simon(simon.eric3<at>gmail.com)

module RaiseSupplier; -- Module Template
create OUT : KM3 from IN : KM3;

helper context KM3!Class def: getRootSuperTypes : Sequence(KM3!Class) =
	if self.supertypes->isEmpty()
		then Sequence{}	
	else 		self.supertypes->select(c | c.supertypes->notEmpty())
					->iterate(a; acc : Sequence(KM3!Class)=Sequence{} |acc->including(a.getRootSuperTypes))
					->union(
					self.supertypes->select(c | c.supertypes->isEmpty())
					->iterate(a; acc : Sequence(KM3!Class)=Sequence{} | acc->including(a) )
			).flatten()
	endif;
	



--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
--@end rule Metamodel

--@begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
--@end rule Package


--@begin rule Class
rule Class {
	from
		inputC:KM3!Class
			to
		outputC:KM3!Class (
			isAbstract <- inputC.isAbstract,
			supertypes <- inputC.supertypes,
			name <- inputC.name,
			location <- inputC.location,
			package <- inputC.package,
			structuralFeatures <- inputC.structuralFeatures->
				select(r | r.oclIsTypeOf(KM3!Reference))->select(r | r.opposite.oclIsUndefined())->
				iterate(a;acc : Sequence(KM3!Reference) = Sequence{} | 
					if a.type.oclIsTypeOf(KM3!Class)
						then acc->append(a.type.getRootSuperTypes->iterate(b; acc1:Sequence(KM3!Reference) = Sequence{}|
							acc1->append(thisModule.Inherit2Association(b,a))))->flatten()
						else acc
						endif),
			structuralFeatures <- inputC.structuralFeatures
				->select(r | r.oclIsTypeOf(KM3!Reference))
				->select(r | not r.opposite.oclIsUndefined()),
			structuralFeatures <- inputC.structuralFeatures
				->select(r | not r.oclIsTypeOf(KM3!Reference))
		)
}
--@end rule Class

--@begin rule Reference
rule ReferenceWithOpposite {
	from
		inputRef : KM3!Reference
		(not inputRef.opposite.oclIsUndefined())
	to
		outputRef : KM3!Reference (
			package <- inputRef.package,
			name <- inputRef.name,
			lower <- inputRef.lower,
			upper <- inputRef.upper,
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			owner <- inputRef.owner,
			type <- inputRef.type,
			isContainer <- inputRef.isContainer,
			opposite <- inputRef.opposite
		)
}
--@end rule Reference

lazy rule Inherit2Association{
	from
		supertype:KM3!Class,
		reference:KM3!Reference
		
	to
		refChildren : KM3!Reference (
			package <- reference.package,
			name <- reference.name,
			lower <- reference.lower,
			upper <- reference.upper,
			isOrdered <- reference.isOrdered,
			isUnique <- reference.isUnique,
			owner <- reference.owner,
			type <- supertype,
			isContainer <- reference.isContainer
		)
}
",name rais supplier abstract level version domain catalogu model transform author simon eric simon eric gmail com date descript this transform strenghthen weaken assert respect postcondit precondit see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano author eric simon simon eric gmail com modul raisesuppli modul templat creat out km in km helper context km class def getrootsupertyp sequenc km class self supertyp isempti sequenc els self supertyp select c c supertyp notempti iter acc sequenc km class sequenc acc includ getrootsupertyp union self supertyp select c c supertyp isempti iter acc sequenc km class sequenc acc includ flatten endif begin rule metamodel rule metamodel inputmm km metamodel outputmm km metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km packag name inputpkg name content inputpkg content end rule packag begin rule class rule class inputc km class outputc km class isabstract inputc isabstract supertyp inputc supertyp name inputc name locat inputc locat packag inputc packag structuralfeatur inputc structuralfeatur select r r oclistypeof km refer select r r opposit oclisundefin iter acc sequenc km refer sequenc type oclistypeof km class acc append type getrootsupertyp iter b acc sequenc km refer sequenc acc append thismodul inherit associ b flatten els acc endif structuralfeatur inputc structuralfeatur select r r oclistypeof km refer select r r opposit oclisundefin structuralfeatur inputc structuralfeatur select r r oclistypeof km refer end rule class begin rule refer rule referencewithopposit inputref km refer inputref opposit oclisundefin outputref km refer packag inputref packag name inputref name lower inputref lower upper inputref upper isord inputref isord isuniqu inputref isuniqu owner inputref owner type inputref type iscontain inputref iscontain opposit inputref opposit end rule refer lazi rule inherit associ supertyp km class refer km refer refchildren km refer packag refer packag name refer name lower refer lower upper refer upper isord refer isord isuniqu refer isuniqu owner refer owner type supertyp iscontain refer iscontain,8
21,21,P18-RedundantClassRemovable.atl,"-- @name		Remove redundant classes 
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		SIMON Eric(simon.eric3<at>gmail.com)
-- @date		2006/07/25
-- @description	Classes may be redundant because they are essentially duplicates of other classes in the model but with a different name (synonyms), or because they are not needed in the system being defined.
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 2.4, page 19
-- @see author of article : K. Lano

module RedundantClassRemovable; -- Module Template
create OUT : UML2Target from IN : UML2;


helper def: assoMap : Map(UML2!Class, Sequence(UML2!Class)) = Map{};
rule isAlreadyConsidered(ref1 : UML2!Class, ref2 : UML2!Class) {

	do {
		if (not thisModule.assoMap.get(ref2).oclIsUndefined()) {
			if (thisModule.assoMap.get(ref2)->includes(ref1)) {
				true;
			}
			else {
			    if (not thisModule.assoMap.get(ref1).oclIsUndefined()) {
					thisModule.assoMap <- thisModule.assoMap.including(ref1,thisModule.assoMap.get(ref1)->including(ref2));
					false;
			    }
				else {
					thisModule.assoMap <- thisModule.assoMap.including(ref1, Sequence{ref2});
					false;
				}
			}
		}
		else  {
				if (not thisModule.assoMap.get(ref1).oclIsUndefined()) {
					thisModule.assoMap <- thisModule.assoMap.including(ref1,thisModule.assoMap.get(ref1)->including(ref2));
					false;
			    }
				else {	
					thisModule.assoMap <- thisModule.assoMap.including(ref1, Sequence{ref2});
					false;
				}
		}
		
	}
}

-- @comment this helper returns a boolean, true if a class can be considered as redundant else false. The criterion to consider that a class is redundant is not optimal, so it must strengthen the criterions according to context.
helper def: isRedundantClass : Set(UML2!Class) =
	UML2!Class->allInstances()->select(c|c.oclIsTypeOf(UML2!Class))->
		iterate(inputC1; acc : Sequence(UML2!Class) = Sequence{} | acc->including(UML2!Class->allInstances()->
		select(c|c.oclIsTypeOf(UML2!Class))->
		iterate(inputC2; acc1 : Sequence(UML2!Class) = Sequence{} | 
		acc1->including(
		if
			(inputC1<> inputC2
			and inputC1.ownedAttribute->size() = inputC2.ownedAttribute->size()
			and inputC1.ownedRule->size() = inputC2.ownedRule->size()
			and inputC1.ownedAttribute->collect(a|a.type)->asSet() = inputC2.ownedAttribute->collect(a|a.type)->asSet()
			and (not thisModule.isAlreadyConsidered(inputC1, inputC2)))
		then
			inputC1
		else 
			Sequence{}
		endif
		)
	)
	)->flatten())->flatten()
	;


-- @begin Model
rule Model {
	from
		inputM : UML2!Model
	to
		outputM : UML2Target!Model (
			name <- inputM.name,
			ownedMember <- inputM.ownedMember->select(c|c.oclIsTypeOf(UML2!Class))->select(c| not thisModule.isRedundantClass->includes(c)),
			ownedMember <- inputM.ownedMember->select(c|not c.oclIsTypeOf(UML2!Class))
		)
}
-- @end Model

-- @begin DataType
rule DataType {
	from 
		inputC : UML2!DataType
	to
		outputC : UML2Target!DataType (
		name <- inputC.name
		)
}
-- @end DataType

-- @begin LiteralNull
rule LiteralNull {
	from 
		inputLN : UML2!LiteralNull
		(if inputLN.owner.oclIsTypeOf(UML2!Constraint)
			then
				not (thisModule.isRedundantClass->
					 includes(inputLN.owner.namespace))
			else
				not (if inputLN.owner.owningAssociation->oclIsUndefined()
						then true
						else inputLN.owner.owningAssociation.member->
							exists(p| thisModule.isRedundantClass->includes(p.type))
						endif)
			endif 
		)
	to
		outputLN : UML2Target!LiteralNull
}
-- @end LiteralNull

-- @begin LiteralInteger
rule LiteralInteger {
	from 
		inputLI : UML2!LiteralInteger
		(if inputLI.owner.oclIsTypeOf(UML2!Constraint)
			then
				not (thisModule.isRedundantClass->
					 includes(inputLI.owner.namespace))
			else
				not (if inputLI.owner.owningAssociation->oclIsUndefined()
						then true
						else inputLI.owner.owningAssociation.member->
							exists(p| thisModule.isRedundantClass->includes(p.type))
						endif)
			endif 
		)
	to
		outputLI : UML2Target!LiteralInteger (
			value <- inputLI.value	
		)
}
-- @end LiteralInteger

-- @begin LiteralUnlimitedNatural
rule LiteralUnlimitedNatural {
	from 
		inputLUN : UML2!LiteralUnlimitedNatural
		(if inputLUN.owner.oclIsTypeOf(UML2!Constraint)
			then
				not (thisModule.isRedundantClass->
					 includes(inputLUN.owner.namespace))
			else
				not (if inputLUN.owner.owningAssociation->oclIsUndefined()
						then true
						else inputLUN.owner.owningAssociation.member->
							exists(p| thisModule.isRedundantClass->includes(p.type))
						endif)
			endif 
		)
	to
		outputLUN : UML2Target!LiteralUnlimitedNatural (
			value <- inputLUN.value	
		)
}
-- @end LiteralUnlimitedNatural

-- @begin LiteralString
rule LiteralString {
	from 
		inputLS : UML2!LiteralString
		(if inputLS.owner.oclIsTypeOf(UML2!Constraint)
			then
				not (thisModule.isRedundantClass->
					 includes(inputLS.owner.namespace))
			else
				not (if inputLS.owner.owningAssociation->oclIsUndefined()
						then true
						else inputLS.owner.owningAssociation.member->
							exists(p| thisModule.isRedundantClass->includes(p.type))
						endif)
			endif 
		)
	to
		outputLS : UML2Target!LiteralString (
			value <- inputLS.value	
		)
}
-- @end LiteralString

-- @begin Association
rule Association {
	from 
		inputA : UML2!Association
		(not inputA.member->exists(p| thisModule.isRedundantClass->includes(p.type)))
	to 
		outputA : UML2Target!Association (
			name <- inputA.name,
			memberEnd <- inputA.memberEnd
	)
}
-- @end Association

-- @begin Property
rule Property {
	from 
		inputP : UML2!Property
		(not (thisModule.isRedundantClass->includes(inputP.class_) 
			or thisModule.isRedundantClass->includes(inputP.type)
			or (if inputP.owningAssociation->oclIsUndefined()
				then false
				else inputP.owningAssociation.member->
			exists(p| thisModule.isRedundantClass->includes(p.type))
			endif)
			))
	to
		outputP : UML2Target!Property (
			owningAssociation <- inputP.owningAssociation,
			name <- inputP.name,
			type <- inputP.type,
			upperValue <- inputP.upperValue,
			lowerValue <- inputP.lowerValue,
			defaultValue <-inputP.defaultValue
		)
}
-- @end Property

-- @begin Constraint
rule Constraint {
	from 
		inputC : UML2!Constraint
		(not thisModule.isRedundantClass->includes(inputC.namespace))
	to
		outputC : UML2Target!Constraint (
			name <-	inputC.name,
			namespace <- inputC.namespace,
			specification <- inputC.specification
		)
}
-- @end Constraint

-- @begin Class
rule Class {
	from 
		inputC : UML2!Class
		(not thisModule.isRedundantClass->includes(inputC))
	to 
		outputC : UML2Target!Class (
			name <- inputC.name,
			ownedOperation <- inputC.ownedOperation,
			nestedClassifier <-  inputC.nestedClassifier,
			isActive <-  inputC.isActive,
			ownedReception <-  inputC.ownedReception,
			ownedAttribute <- inputC.ownedAttribute
		)
}
-- @end Class
",name remov redund class version domain catalogu model transform author simon eric simon eric gmail com date descript class may redund essenti duplic class model differ name synonym need system defin see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul redundantclassremov modul templat creat out uml target in uml helper def assomap map uml class sequenc uml class map rule isalreadyconsid ref uml class ref uml class thismodul assomap get ref oclisundefin thismodul assomap get ref includ ref true els thismodul assomap get ref oclisundefin thismodul assomap thismodul assomap includ ref thismodul assomap get ref includ ref fals els thismodul assomap thismodul assomap includ ref sequenc ref fals els thismodul assomap get ref oclisundefin thismodul assomap thismodul assomap includ ref thismodul assomap get ref includ ref fals els thismodul assomap thismodul assomap includ ref sequenc ref fals comment helper return boolean true class consid redund els fals the criterion consid class redund optim must strengthen criterion accord context helper def isredundantclass set uml class uml class allinst select c c oclistypeof uml class iter inputc acc sequenc uml class sequenc acc includ uml class allinst select c c oclistypeof uml class iter inputc acc sequenc uml class sequenc acc includ inputc inputc inputc ownedattribut size inputc ownedattribut size inputc ownedrul size inputc ownedrul size inputc ownedattribut collect type asset inputc ownedattribut collect type asset thismodul isalreadyconsid inputc inputc inputc els sequenc endif flatten flatten begin model rule model inputm uml model outputm uml target model name inputm name ownedmemb inputm ownedmemb select c c oclistypeof uml class select c thismodul isredundantclass includ c ownedmemb inputm ownedmemb select c c oclistypeof uml class end model begin datatyp rule datatyp inputc uml datatyp outputc uml target datatyp name inputc name end datatyp begin literalnul rule literalnul inputln uml literalnul inputln owner oclistypeof uml constraint thismodul isredundantclass includ inputln owner namespac els inputln owner owningassoci oclisundefin true els inputln owner owningassoci member exist p thismodul isredundantclass includ p type endif endif outputln uml target literalnul end literalnul begin literalinteg rule literalinteg input uml literalinteg input owner oclistypeof uml constraint thismodul isredundantclass includ input owner namespac els input owner owningassoci oclisundefin true els input owner owningassoci member exist p thismodul isredundantclass includ p type endif endif output uml target literalinteg valu input valu end literalinteg begin literalunlimitednatur rule literalunlimitednatur inputlun uml literalunlimitednatur inputlun owner oclistypeof uml constraint thismodul isredundantclass includ inputlun owner namespac els inputlun owner owningassoci oclisundefin true els inputlun owner owningassoci member exist p thismodul isredundantclass includ p type endif endif outputlun uml target literalunlimitednatur valu inputlun valu end literalunlimitednatur begin literalstr rule literalstr inputl uml literalstr inputl owner oclistypeof uml constraint thismodul isredundantclass includ inputl owner namespac els inputl owner owningassoci oclisundefin true els inputl owner owningassoci member exist p thismodul isredundantclass includ p type endif endif outputl uml target literalstr valu inputl valu end literalstr begin associ rule associ inputa uml associ inputa member exist p thismodul isredundantclass includ p type outputa uml target associ name inputa name memberend inputa memberend end associ begin properti rule properti inputp uml properti thismodul isredundantclass includ inputp class thismodul isredundantclass includ inputp type inputp owningassoci oclisundefin fals els inputp owningassoci member exist p thismodul isredundantclass includ p type endif outputp uml target properti owningassoci inputp owningassoci name inputp name type inputp type uppervalu inputp uppervalu lowervalu inputp lowervalu defaultvalu inputp defaultvalu end properti begin constraint rule constraint inputc uml constraint thismodul isredundantclass includ inputc namespac outputc uml target constraint name inputc name namespac inputc namespac specif inputc specif end constraint begin class rule class inputc uml class thismodul isredundantclass includ inputc outputc uml target class name inputc name ownedoper inputc ownedoper nestedclassifi inputc nestedclassifi isact inputc isact ownedrecept inputc ownedrecept ownedattribut inputc ownedattribut end class,13
22,22,P19-Removing-context.atl,"-- @name		Removal of many-many associations (with all context)
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		SIMON Eric(simon.eric3<at>gmail.com)
-- @date		2006/08/02
-- @description	The purpose of this transformation is to substitute a many-many association by an introduction of class with two many-one associations.
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 1.2, page 2
-- @see author of article : K. Lano

module Removing; -- Module Template
create OUT : KM3Target from IN : KM3;

-- @comment this helper allows to know if a reference oswn the properties necessary for the rule association  
helper context KM3!Reference def: isManyToManyNotContainer : Boolean =
	self.lower = 0 and self.upper < 0 and not self.isContainer
	;
-- @comment this helper create a Map which uses in the rule isAlreadyConsidered. 
helper def: assoMap : Map(KM3!Reference, Sequence(KM3!Reference)) = Map{};
-- @comment this rule allows to know if a pair of element is already considered. E.g.: {A,B} and {B,A} => {A,B}. 
rule isAlreadyConsidered(ref1 : KM3!Reference, ref2 : KM3!Reference) {

	do {
		if (not thisModule.assoMap.get(ref2).oclIsUndefined()) {
			if (thisModule.assoMap.get(ref2)->includes(ref1)) {
				true;
			}
			else {
			    if (not thisModule.assoMap.get(ref1).oclIsUndefined()) {
					thisModule.assoMap <- thisModule.assoMap.including(ref1,thisModule.assoMap.get(ref1)->including(ref2));
					false;
			    }
				else {
					thisModule.assoMap <- thisModule.assoMap.including(ref1, Sequence{ref2});
					false;
				}
			}
		}
		else  {
				if (not thisModule.assoMap.get(ref1).oclIsUndefined()) {
					thisModule.assoMap <- thisModule.assoMap.including(ref1,thisModule.assoMap.get(ref1)->including(ref2));
					false;
			    }
				else {	
					thisModule.assoMap <- thisModule.assoMap.including(ref1, Sequence{ref2});
					false;
				}
		}
		
	}
}

-- @begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3Target!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
-- @end rule Metamodel

-- @begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3Target!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
-- @end rule Package

-- @begin rule DataType
rule DataType {
	from
		inputData:KM3!DataType
	to
		outputData:KM3Target!DataType(
			name <- inputData.name,
			location <- inputData.location
		)
}
-- @end rule DataType

-- @begin rule EnumLiteral
rule EnumLiteral {
	from
		inputL:KM3!EnumLiteral
	to
		outputL:KM3Target!EnumLiteral (
			name <- inputL.name,
			location <- inputL.location,
			enum  <- inputL.enum,
			package <- inputL.package
		)
}
-- @end rule EnumLiteral

-- @begin rule Enumeration 
rule Enumeration {
	from
		inputEnum:KM3!Enumeration
	to
		outputEnum:KM3Target!Enumeration (
			name <- inputEnum.name,
			location <- inputEnum.location,
			package <- inputEnum.package,
			literals <- inputEnum.literals
		)
}
-- @end rule Enumeration 



-- @begin rule Class
rule Class {
	from
		inputC:KM3!Class
		(not inputC.structuralFeatures->select(a|a.oclIsTypeOf(KM3!Reference))->exists(r| r.isManyToManyNotContainer and r.opposite.isManyToManyNotContainer))
	to
		outputC:KM3Target!Class (
			isAbstract <- inputC.isAbstract,
			supertypes <- inputC.supertypes,
			name <- inputC.name,
			location <- inputC.location,
			package <- inputC.package,
			structuralFeatures <- inputC.structuralFeatures
		)
}
-- @end rule Class

-- @begin rule Attribute
rule Attribute {
	from
		inputAttr : KM3!Attribute
	to
		outputAttr : KM3Target!Attribute (
			package <- inputAttr.package,
			name <- inputAttr.name,
			lower <- inputAttr.lower,
			upper <- inputAttr.upper,
			isOrdered <- inputAttr.isOrdered,
			isUnique <- inputAttr.isUnique,
			owner <- inputAttr.owner,
			type <- inputAttr.type
		)
}
-- @end rule Attribute

-- @begin rule Reference
rule Reference {
	from
		inputRef : KM3!Reference
			( not (inputRef.isManyToManyNotContainer and inputRef.opposite.isManyToManyNotContainer))
	to
		outputRef : KM3Target!Reference (
			package <- inputRef.package,
			name <- inputRef.name,
			lower <- inputRef.lower,
			upper <- inputRef.upper,
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			owner <- inputRef.owner,
			type <- inputRef.type,
			isContainer <- inputRef.isContainer,
			opposite <- inputRef.opposite
		)
}
-- @end rule Reference

-- @comment This rule takes a pair of Reference and, if  these are not already considered, creates a class with two many-one association.
-- @begin rule Association
rule Association {
	from
		inputA : KM3!Reference,
		inputB : KM3!Reference
		(
			inputA.opposite = inputB
			and inputA.isManyToManyNotContainer
			and inputB.isManyToManyNotContainer
			--	and inputA <> inputB
			and not thisModule.isAlreadyConsidered(inputA, inputB)
		)


	to
		outputA : KM3Target!Class (
			package <- inputA.owner.package,
			name <- inputA.owner.name,
			isAbstract <- inputA.owner.isAbstract,
			structuralFeatures <- inputA.owner.structuralFeatures->select(b|b.oclIsTypeOf(KM3!Reference))->select(a| not a.isManyToManyNotContainer),
			structuralFeatures <- inputA.owner.structuralFeatures->select(b|b.oclIsTypeOf(KM3!Attribute)),
			structuralFeatures <- referenceAC
		),
		outputB : KM3Target!Class (
			package <- inputB.owner.package,
			name <- inputB.owner.name,
			isAbstract <- inputB.owner.isAbstract,
			structuralFeatures <- inputB.owner.structuralFeatures->select(b|b.oclIsTypeOf(KM3!Reference))->select(a| not a.isManyToManyNotContainer),
			structuralFeatures <- inputB.owner.structuralFeatures->select(b|b.oclIsTypeOf(KM3!Attribute)),
			structuralFeatures <- referenceBC
		),
		outputC : KM3Target!Class (
			package <- inputA.owner.package,
			name <- inputA.owner.name->concat(inputB.owner.name),
			isAbstract <- false,
			structuralFeatures <- referenceCA,
			structuralFeatures <- referenceCB
      		
		),
		referenceAC : KM3Target!Reference (
			name <- inputA.name,
			lower <- 1,
			upper <- 1,
			isOrdered <- false,
			isUnique <- false,
			owner <- outputA,
			isContainer <- false,
			opposite <- referenceCA
		),
		referenceCA : KM3Target!Reference (
			name <- outputC.name->concat('1'),
			lower <- 0,
			upper <- 0-1,
			isOrdered <- false,
			isUnique <- false,
			owner <- outputC,
			isContainer <- false,
			opposite <- referenceAC
		),
		referenceBC : KM3Target!Reference (
			name <- inputB.name,
			lower <- 1,
			upper <- 1,
			isOrdered <- false,
			isUnique <- false,
			owner <- outputB,
			isContainer <- false,
			opposite <- referenceCB
		),
		referenceCB : KM3Target!Reference (
			name <- outputC.name->concat('2'),
			lower <- 0,
			upper <- 0-1,
			isOrdered <- false,
			isUnique <- false,
			owner <- outputC,
			isContainer <- false,
			opposite <- referenceBC
		)

}
--@end rule Association


",name remov mani mani associ context version domain catalogu model transform author simon eric simon eric gmail com date descript the purpos transform substitut mani mani associ introduct class two mani one associ see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul remov modul templat creat out km target in km comment helper allow know refer oswn properti necessari rule associ helper context km refer def ismanytomanynotcontain boolean self lower self upper self iscontain comment helper creat map use rule isalreadyconsid helper def assomap map km refer sequenc km refer map comment rule allow know pair element alreadi consid e g a b b a a b rule isalreadyconsid ref km refer ref km refer thismodul assomap get ref oclisundefin thismodul assomap get ref includ ref true els thismodul assomap get ref oclisundefin thismodul assomap thismodul assomap includ ref thismodul assomap get ref includ ref fals els thismodul assomap thismodul assomap includ ref sequenc ref fals els thismodul assomap get ref oclisundefin thismodul assomap thismodul assomap includ ref thismodul assomap get ref includ ref fals els thismodul assomap thismodul assomap includ ref sequenc ref fals begin rule metamodel rule metamodel inputmm km metamodel outputmm km target metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km target packag name inputpkg name content inputpkg content end rule packag begin rule datatyp rule datatyp inputdata km datatyp outputdata km target datatyp name inputdata name locat inputdata locat end rule datatyp begin rule enumliter rule enumliter inputl km enumliter outputl km target enumliter name inputl name locat inputl locat enum inputl enum packag inputl packag end rule enumliter begin rule enumer rule enumer inputenum km enumer outputenum km target enumer name inputenum name locat inputenum locat packag inputenum packag liter inputenum liter end rule enumer begin rule class rule class inputc km class inputc structuralfeatur select oclistypeof km refer exist r r ismanytomanynotcontain r opposit ismanytomanynotcontain outputc km target class isabstract inputc isabstract supertyp inputc supertyp name inputc name locat inputc locat packag inputc packag structuralfeatur inputc structuralfeatur end rule class begin rule attribut rule attribut inputattr km attribut outputattr km target attribut packag inputattr packag name inputattr name lower inputattr lower upper inputattr upper isord inputattr isord isuniqu inputattr isuniqu owner inputattr owner type inputattr type end rule attribut begin rule refer rule refer inputref km refer inputref ismanytomanynotcontain inputref opposit ismanytomanynotcontain outputref km target refer packag inputref packag name inputref name lower inputref lower upper inputref upper isord inputref isord isuniqu inputref isuniqu owner inputref owner type inputref type iscontain inputref iscontain opposit inputref opposit end rule refer comment this rule take pair refer alreadi consid creat class two mani one associ begin rule associ rule associ inputa km refer inputb km refer inputa opposit inputb inputa ismanytomanynotcontain inputb ismanytomanynotcontain inputa inputb thismodul isalreadyconsid inputa inputb outputa km target class packag inputa owner packag name inputa owner name isabstract inputa owner isabstract structuralfeatur inputa owner structuralfeatur select b b oclistypeof km refer select ismanytomanynotcontain structuralfeatur inputa owner structuralfeatur select b b oclistypeof km attribut structuralfeatur referenceac outputb km target class packag inputb owner packag name inputb owner name isabstract inputb owner isabstract structuralfeatur inputb owner structuralfeatur select b b oclistypeof km refer select ismanytomanynotcontain structuralfeatur inputb owner structuralfeatur select b b oclistypeof km attribut structuralfeatur referencebc outputc km target class packag inputa owner packag name inputa owner name concat inputb owner name isabstract fals structuralfeatur referenceca structuralfeatur referencecb referenceac km target refer name inputa name lower upper isord fals isuniqu fals owner outputa iscontain fals opposit referenceca referenceca km target refer name outputc name concat lower upper isord fals isuniqu fals owner outputc iscontain fals opposit referenceac referencebc km target refer name inputb name lower upper isord fals isuniqu fals owner outputb iscontain fals opposit referencecb referencecb km target refer name outputc name concat lower upper isord fals isuniqu fals owner outputc iscontain fals opposit referencebc end rule associ,19
23,23,P19-Removing-without.atl,"-- @name		Removal of many-many associations (with only the  elements necessary for the example context)
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		SIMON Eric(simon.eric3<at>gmail.com)
-- @date		2006/08/02
-- @description	The purpose of this transformation is to substitute a many-many association by an introduction of class with two many-one associations.
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 1.2, page 2
-- @see author of article : K. Lano

module Removing; -- Module Template
create OUT : KM3Target from IN : KM3;

-- @comment this helper allows to know if a reference oswn the properties necessary for the rule association  
helper context KM3!Reference def: isManyToManyNotContainer : Boolean =
	self.lower = 0 and self.upper < 0 and not self.isContainer
	;
-- @comment this helper create a Map which uses in the rule isAlreadyConsidered. 
helper def: assoMap : Map(KM3!Reference, Sequence(KM3!Reference)) = Map{};
-- @comment this rule allows to know if a pair of element is already considered. E.g.: {A,B} and {B,A} => {A,B}. 
rule isAlreadyConsidered(ref1 : KM3!Reference, ref2 : KM3!Reference) {

	do {
		if (not thisModule.assoMap.get(ref2).oclIsUndefined()) {
			if (thisModule.assoMap.get(ref2)->includes(ref1)) {
				true;
			}
			else {
			    if (not thisModule.assoMap.get(ref1).oclIsUndefined()) {
					thisModule.assoMap <- thisModule.assoMap.including(ref1,thisModule.assoMap.get(ref1)->including(ref2));
					false;
			    }
				else {
					thisModule.assoMap <- thisModule.assoMap.including(ref1, Sequence{ref2});
					false;
				}
			}
		}
		else  {
				if (not thisModule.assoMap.get(ref1).oclIsUndefined()) {
					thisModule.assoMap <- thisModule.assoMap.including(ref1,thisModule.assoMap.get(ref1)->including(ref2));
					false;
			    }
				else {	
					thisModule.assoMap <- thisModule.assoMap.including(ref1, Sequence{ref2});
					false;
				}
		}
		
	}
}

-- @begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3Target!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
-- @end rule Metamodel

-- @begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3Target!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
-- @end rule Package

-- @begin rule Class
rule Class {
	from
		inputC:KM3!Class
		(not inputC.structuralFeatures->select(a|a.oclIsTypeOf(KM3!Reference))->exists(r| r.isManyToManyNotContainer and r.opposite.isManyToManyNotContainer))
	to
		outputC:KM3Target!Class (
			isAbstract <- inputC.isAbstract,
			supertypes <- inputC.supertypes,
			name <- inputC.name,
			location <- inputC.location,
			package <- inputC.package,
			structuralFeatures <- inputC.structuralFeatures
		)
}
-- @end rule Class



-- @begin rule Reference
rule Reference {
	from
		inputRef : KM3!Reference
			( not (inputRef.isManyToManyNotContainer and inputRef.opposite.isManyToManyNotContainer))
	to
		outputRef : KM3Target!Reference (
			package <- inputRef.package,
			name <- inputRef.name,
			lower <- inputRef.lower,
			upper <- inputRef.upper,
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			owner <- inputRef.owner,
			type <- inputRef.type,
			isContainer <- inputRef.isContainer,
			opposite <- inputRef.opposite
		)
}
-- @end rule Reference

-- @comment This rule takes a pair of Reference and, if  these are not already considered, creates a class with two many-one association.
-- @begin rule Association
rule Association {
	from
		inputA : KM3!Reference,
		inputB : KM3!Reference
		(
			inputA.opposite = inputB
			and inputA.isManyToManyNotContainer
			and inputB.isManyToManyNotContainer
			--	and inputA <> inputB
			and not thisModule.isAlreadyConsidered(inputA, inputB)
		)


	to
		outputA : KM3Target!Class (
			package <- inputA.owner.package,
			name <- inputA.owner.name,
			isAbstract <- inputA.owner.isAbstract,
			structuralFeatures <- inputA.owner.structuralFeatures->select(b|b.oclIsTypeOf(KM3!Reference))->select(a| not a.isManyToManyNotContainer),
			structuralFeatures <- inputA.owner.structuralFeatures->select(b|b.oclIsTypeOf(KM3!Attribute)),
			structuralFeatures <- referenceAC
		),
		outputB : KM3Target!Class (
			package <- inputB.owner.package,
			name <- inputB.owner.name,
			isAbstract <- inputB.owner.isAbstract,
			structuralFeatures <- inputB.owner.structuralFeatures->select(b|b.oclIsTypeOf(KM3!Reference))->select(a| not a.isManyToManyNotContainer),
			structuralFeatures <- inputB.owner.structuralFeatures->select(b|b.oclIsTypeOf(KM3!Attribute)),
			structuralFeatures <- referenceBC
		),
		outputC : KM3Target!Class (
			package <- inputA.owner.package,
			name <- inputA.owner.name->concat(inputB.owner.name),
			isAbstract <- false,
			structuralFeatures <- referenceCA,
			structuralFeatures <- referenceCB
      		
		),
		referenceAC : KM3Target!Reference (
			name <- inputA.name,
			lower <- 1,
			upper <- 1,
			isOrdered <- false,
			isUnique <- false,
			owner <- outputA,
			isContainer <- false,
			opposite <- referenceCA
		),
		referenceCA : KM3Target!Reference (
			name <- outputC.name->concat('1'),
			lower <- 0,
			upper <- 0-1,
			isOrdered <- false,
			isUnique <- false,
			owner <- outputC,
			isContainer <- false,
			opposite <- referenceAC
		),
		referenceBC : KM3Target!Reference (
			name <- inputB.name,
			lower <- 1,
			upper <- 1,
			isOrdered <- false,
			isUnique <- false,
			owner <- outputB,
			isContainer <- false,
			opposite <- referenceCB
		),
		referenceCB : KM3Target!Reference (
			name <- outputC.name->concat('2'),
			lower <- 0,
			upper <- 0-1,
			isOrdered <- false,
			isUnique <- false,
			owner <- outputC,
			isContainer <- false,
			opposite <- referenceBC
		)

}
--@end rule Association


",name remov mani mani associ element necessari exampl context version domain catalogu model transform author simon eric simon eric gmail com date descript the purpos transform substitut mani mani associ introduct class two mani one associ see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul remov modul templat creat out km target in km comment helper allow know refer oswn properti necessari rule associ helper context km refer def ismanytomanynotcontain boolean self lower self upper self iscontain comment helper creat map use rule isalreadyconsid helper def assomap map km refer sequenc km refer map comment rule allow know pair element alreadi consid e g a b b a a b rule isalreadyconsid ref km refer ref km refer thismodul assomap get ref oclisundefin thismodul assomap get ref includ ref true els thismodul assomap get ref oclisundefin thismodul assomap thismodul assomap includ ref thismodul assomap get ref includ ref fals els thismodul assomap thismodul assomap includ ref sequenc ref fals els thismodul assomap get ref oclisundefin thismodul assomap thismodul assomap includ ref thismodul assomap get ref includ ref fals els thismodul assomap thismodul assomap includ ref sequenc ref fals begin rule metamodel rule metamodel inputmm km metamodel outputmm km target metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km target packag name inputpkg name content inputpkg content end rule packag begin rule class rule class inputc km class inputc structuralfeatur select oclistypeof km refer exist r r ismanytomanynotcontain r opposit ismanytomanynotcontain outputc km target class isabstract inputc isabstract supertyp inputc supertyp name inputc name locat inputc locat packag inputc packag structuralfeatur inputc structuralfeatur end rule class begin rule refer rule refer inputref km refer inputref ismanytomanynotcontain inputref opposit ismanytomanynotcontain outputref km target refer packag inputref packag name inputref name lower inputref lower upper inputref upper isord inputref isord isuniqu inputref isuniqu owner inputref owner type inputref type iscontain inputref iscontain opposit inputref opposit end rule refer comment this rule take pair refer alreadi consid creat class two mani one associ begin rule associ rule associ inputa km refer inputb km refer inputa opposit inputb inputa ismanytomanynotcontain inputb ismanytomanynotcontain inputa inputb thismodul isalreadyconsid inputa inputb outputa km target class packag inputa owner packag name inputa owner name isabstract inputa owner isabstract structuralfeatur inputa owner structuralfeatur select b b oclistypeof km refer select ismanytomanynotcontain structuralfeatur inputa owner structuralfeatur select b b oclistypeof km attribut structuralfeatur referenceac outputb km target class packag inputb owner packag name inputb owner name isabstract inputb owner isabstract structuralfeatur inputb owner structuralfeatur select b b oclistypeof km refer select ismanytomanynotcontain structuralfeatur inputb owner structuralfeatur select b b oclistypeof km attribut structuralfeatur referencebc outputc km target class packag inputa owner packag name inputa owner name concat inputb owner name isabstract fals structuralfeatur referenceca structuralfeatur referencecb referenceac km target refer name inputa name lower upper isord fals isuniqu fals owner outputa iscontain fals opposit referenceca referenceca km target refer name outputc name concat lower upper isord fals isuniqu fals owner outputc iscontain fals opposit referenceac referencebc km target refer name inputb name lower upper isord fals isuniqu fals owner outputb iscontain fals opposit referencecb referencecb km target refer name outputc name concat lower upper isord fals isuniqu fals owner outputc iscontain fals opposit referencebc end rule associ,19
24,24,P2-AssertionModification.atl,"-- @name		AssertionModification
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		SIMON Eric(simon.eric3<at>gmail.com)
-- @date		2006/08/09
-- @description	This transformation strenghthens or weakens an assertion(respectively postcondition and precondition).
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 1.6, page 5
-- @see author of article : K. Lano

module AssertionModification; -- Module Template
create OUT : UML2Target from IN : UML2, Lib : XML;


-- @comment this helper returns the first attribute named ""name""
helper context XML!Element def : getAttr(name : String) : XML!Attribute =
  self.children->
    select (c|c.oclIsTypeOf(XML!Attribute))->
      select(c|c.name = name)->first();

-- @comment this helper returns the value of the first attribute named ""name""
helper context XML!Element def : getAttrVal(name : String) : String =
  self.getAttr(name).value;

-- @comment this helper returns the set of childs for a given type
helper context XML!Element
def : getChildren(type : OclType, name : String) : Sequence(XML!Node) =
  self.children->
    select(e|e.oclIsKindOf(type))->select(e|e.name = name);

-- @comment this helper returns the new assertion contained by the library
helper context UML2!Constraint def: searchInLib : String =
	if self.owner.oclIsTypeOf(UML2!Class)
	then self.ClassExistInLib()
	else if self.owner.oclIsTypeOf(UML2!Association)
		then self.AssociationExistInLib()
		else if self.owner.oclIsTypeOf(UML2!Operation)
			then self.OperationExistInLib()
			else 'Erreur entry Type: either class or association or operation'
			endif
		endif
	endif
	;

-- @comment this helper is called by the helper searchInLib for the constraint is on a class
helper context UML2!Constraint def: ClassExistInLib() : String =
	if XML!Element.allInstances()->select(c|c.name='class')->
		select(c|c.getAttr('package').value = self.owner.package.name 
			and c.getAttr('name').value = self.owner.name 
			and c.getChildren(XML!Element, 'assertion')->
				exists(const|const.getAttr('name') = self.name)
		).first() <> OclUndefined
	then	
		XML!Element.allInstances()->select(c|c.name='class')->
		select(c|c.getAttr('package').value = self.owner.package.name 
			and c.getAttr('name').value = self.owner.name 
			and c.getChildren(XML!Element, 'assertion')->
				exists(const|const.getAttr('name') = self.name)
		).first().getChildren(XML!Element, 'assertion')->
		select(const|const.getAttr('name') = self.name).first().value
	else 'noRule'
	endif
	;

-- @comment this helper is called by the helper searchInLib for the constraint is on an association
helper context UML2!Constraint def: AssociationExistInLib() : String =
	if XML!Element.allInstances()->select(c|c.name='association')->
		select(c|c.getAttr('package').value = self.owner.package.name 
			and c.getAttr('name').value = self.owner.name 
			and c.getChildren(XML!Element, 'assertion')->
				exists(const|const.getAttr('name').value = self.name)
		).first() <> OclUndefined
	then
		XML!Element.allInstances()->select(c|c.name='association')->
		select(c|c.getAttr('package').value = self.owner.package.name 
			and c.getAttr('name').value = self.owner.name 
			and c.getChildren(XML!Element, 'assertion')->
				exists(const|const.getAttr('name').value = self.name)
		).first().getChildren(XML!Element, 'assertion')->
		select(const|const.getAttr('name').value = self.name).first().getAttr('value').value
	else 'noRule'
	endif
	;

-- @comment this helper is called by the helper searchInLib for the constraint is on an operation
helper context UML2!Constraint def: OperationExistInLib() : String =
	if self.owner.precondition->includes(self)
	then
		if XML!Element.allInstances()->select(c|c.name='operation')->
			select(c|c.getAttr('package').value = self.owner.owner.package.name
				and c.getAttr('class').value = self.owner.owner.name
				and c.getChildren(XML!Element, 'precondition')->
			exists(const|const.getAttr('name').value = self.name)
			).first() <> OclUndefined
		then
			XML!Element.allInstances()->select(c|c.name='operation')->
			select(c|c.getAttr('package').value = self.owner.owner.package.name
				and c.getAttr('class').value = self.owner.owner.name
				and c.getChildren(XML!Element, 'precondition')->
			exists(const|const.getAttr('name').value = self.name)
			).first().getChildren(XML!Element, 'precondition')->
			select(const|const.getAttr('name').value = self.name).first().getAttr('value').value
		else 'noRule'
		endif
	else if self.owner.postcondition->includes(self)
			then
				if XML!Element.allInstances()->select(c|c.name='operation')->
				select(c|c.getAttr('package').value = self.owner.owner.package.name
					and c.getAttr('class').value = self.owner.owner.name
					and c.getChildren(XML!Element, 'postcondition')->
					exists(const|const.getAttr('name').value = self.name)
				).first() <> OclUndefined
				then XML!Element.allInstances()->select(c|c.name='operation')->
					select(c|c.getAttr('package').value = self.owner.owner.package.name
						and c.getAttr('class').value = self.owner.owner.name
						and c.getChildren(XML!Element, 'postcondition')->
						exists(const|const.getAttr('name').value = self.name)
					).first().getChildren(XML!Element, 'postcondition')->
					select(const|const.getAttr('name').value = self.name).first().getAttr('value').value
				else 'noRule'
				endif
			else 'noRule'
			endif	
		endif
	;
		
-- @begin Model
rule Model {
	from
		inputM : UML2!Model
	to
		outputM : UML2Target!Model (
			name <- inputM.name,
			ownedMember <- inputM.ownedMember
		)
}
-- @end Model
		
-- @begin DataType
rule DataType {
	from 
		inputC : UML2!DataType
	to
		outputC : UML2Target!DataType (
		name <- inputC.name
		)
}
-- @end DataType

-- @begin LiteralNull
rule LiteralNull {
	from 
		inputLN : UML2!LiteralNull
	to
		outputLN : UML2Target!LiteralNull
}
-- @end LiteralNull

-- @begin LiteralInteger
rule LiteralInteger {
	from 
		inputLI : UML2!LiteralInteger
	to
		outputLI : UML2Target!LiteralInteger (
			value <- inputLI.value	
		)
}
-- @end LiteralInteger

-- @begin LiteralUnlimitedNatural
rule LiteralUnlimitedNatural {
	from 
		inputLUN : UML2!LiteralUnlimitedNatural
	to
		outputLUN : UML2Target!LiteralUnlimitedNatural (
			value <- inputLUN.value	
		)
}
-- @end LiteralUnlimitedNatural

-- @begin LiteralString
rule LiteralString {
	from 
		inputLS : UML2!LiteralString
		(inputLS.owner.OperationExistInLib()='noRule')
	to
		outputLS : UML2Target!LiteralString (
			value <- inputLS.value
		)
}
-- @end LiteralString

-- @begin Association
rule Association {
	from 
		inputA : UML2!Association
	to 
		outputA : UML2Target!Association (
			name <- inputA.name,
			memberEnd <- inputA.memberEnd
	)
}
-- @end Association

-- @begin Property
rule Property {
	from 
		inputP : UML2!Property
	to
		outputP : UML2Target!Property (
			owningAssociation <- inputP.owningAssociation,
			name <- inputP.name,
			type <- inputP.type,
			upperValue <- inputP.upperValue,
			lowerValue <- inputP.lowerValue,
			defaultValue <-inputP.defaultValue
		)
}
-- @end Property

-- @begin Constraint
rule Constraint {
	from 
		inputC : UML2!Constraint
	to
		outputC : UML2Target!Constraint (
			name <-	inputC.name,
			namespace <- inputC.namespace,
			specification <- if inputC.OperationExistInLib()='noRule'
								then inputC.specification
								else thisModule.newRule(inputC)
								endif
		)
}
-- @end Constraint

-- @begin Class
rule Class {
	from 
		inputC : UML2!Class
	to 
		outputC : UML2Target!Class (
			name <- inputC.name,
			ownedOperation <- inputC.ownedOperation,
			nestedClassifier <-  inputC.nestedClassifier,
			isActive <-  inputC.isActive,
			ownedReception <-  inputC.ownedReception,
			ownedAttribute <- inputC.ownedAttribute
		)
}
-- @end Class

-- @begin Operation
rule Operation {
	from 
		inputO : UML2!Operation
	to 
		outputO : UML2Target!Operation (
			name <- inputO.name,
			class_ <- inputO.class_,
			ownedRule <- inputO.ownedRule,
			ownedParameter <- inputO.ownedParameter
		)
}
-- @end Operation

-- @begin Parameter
rule Parameter {
	from 
		inputP : UML2!Parameter
	to 
		outputP : UML2Target!Parameter (
			name <- inputP.name,
			operation <- inputP.operation,
			type <- inputP.type
		)
}
-- @end Parameter

-- @comment this lazy rule replace the oldest assertion by a new
-- @begin newRule
lazy rule newRule {
	from
		inputC : UML2!Constraint
	to
		outputLS : UML2Target!LiteralString (
			value <- inputC.OperationExistInLib()	
		)
}
-- @end newRule
",name assertionmodif version domain catalogu model transform author simon eric simon eric gmail com date descript this transform strenghthen weaken assert respect postcondit precondit see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul assertionmodif modul templat creat out uml target in uml lib xml comment helper return first attribut name name helper context xml element def getattr name string xml attribut self children select c c oclistypeof xml attribut select c c name name first comment helper return valu first attribut name name helper context xml element def getattrv name string string self getattr name valu comment helper return set child given type helper context xml element def getchildren type ocltyp name string sequenc xml node self children select e e ocliskindof type select e e name name comment helper return new assert contain librari helper context uml constraint def searchinlib string self owner oclistypeof uml class self classexistinlib els self owner oclistypeof uml associ self associationexistinlib els self owner oclistypeof uml oper self operationexistinlib els erreur entri type either class associ oper endif endif endif comment helper call helper searchinlib constraint class helper context uml constraint def classexistinlib string xml element allinst select c c name class select c c getattr packag valu self owner packag name c getattr name valu self owner name c getchildren xml element assert exist const const getattr name self name first oclundefin xml element allinst select c c name class select c c getattr packag valu self owner packag name c getattr name valu self owner name c getchildren xml element assert exist const const getattr name self name first getchildren xml element assert select const const getattr name self name first valu els norul endif comment helper call helper searchinlib constraint associ helper context uml constraint def associationexistinlib string xml element allinst select c c name associ select c c getattr packag valu self owner packag name c getattr name valu self owner name c getchildren xml element assert exist const const getattr name valu self name first oclundefin xml element allinst select c c name associ select c c getattr packag valu self owner packag name c getattr name valu self owner name c getchildren xml element assert exist const const getattr name valu self name first getchildren xml element assert select const const getattr name valu self name first getattr valu valu els norul endif comment helper call helper searchinlib constraint oper helper context uml constraint def operationexistinlib string self owner precondit includ self xml element allinst select c c name oper select c c getattr packag valu self owner owner packag name c getattr class valu self owner owner name c getchildren xml element precondit exist const const getattr name valu self name first oclundefin xml element allinst select c c name oper select c c getattr packag valu self owner owner packag name c getattr class valu self owner owner name c getchildren xml element precondit exist const const getattr name valu self name first getchildren xml element precondit select const const getattr name valu self name first getattr valu valu els norul endif els self owner postcondit includ self xml element allinst select c c name oper select c c getattr packag valu self owner owner packag name c getattr class valu self owner owner name c getchildren xml element postcondit exist const const getattr name valu self name first oclundefin xml element allinst select c c name oper select c c getattr packag valu self owner owner packag name c getattr class valu self owner owner name c getchildren xml element postcondit exist const const getattr name valu self name first getchildren xml element postcondit select const const getattr name valu self name first getattr valu valu els norul endif els norul endif endif begin model rule model inputm uml model outputm uml target model name inputm name ownedmemb inputm ownedmemb end model begin datatyp rule datatyp inputc uml datatyp outputc uml target datatyp name inputc name end datatyp begin literalnul rule literalnul inputln uml literalnul outputln uml target literalnul end literalnul begin literalinteg rule literalinteg input uml literalinteg output uml target literalinteg valu input valu end literalinteg begin literalunlimitednatur rule literalunlimitednatur inputlun uml literalunlimitednatur outputlun uml target literalunlimitednatur valu inputlun valu end literalunlimitednatur begin literalstr rule literalstr inputl uml literalstr inputl owner operationexistinlib norul outputl uml target literalstr valu inputl valu end literalstr begin associ rule associ inputa uml associ outputa uml target associ name inputa name memberend inputa memberend end associ begin properti rule properti inputp uml properti outputp uml target properti owningassoci inputp owningassoci name inputp name type inputp type uppervalu inputp uppervalu lowervalu inputp lowervalu defaultvalu inputp defaultvalu end properti begin constraint rule constraint inputc uml constraint outputc uml target constraint name inputc name namespac inputc namespac specif inputc operationexistinlib norul inputc specif els thismodul newrul inputc endif end constraint begin class rule class inputc uml class outputc uml target class name inputc name ownedoper inputc ownedoper nestedclassifi inputc nestedclassifi isact inputc isact ownedrecept inputc ownedrecept ownedattribut inputc ownedattribut end class begin oper rule oper inputo uml oper outputo uml target oper name inputo name class inputo class ownedrul inputo ownedrul ownedparamet inputo ownedparamet end oper begin paramet rule paramet inputp uml paramet outputp uml target paramet name inputp name oper inputp oper type inputp type end paramet comment lazi rule replac oldest assert new begin newrul lazi rule newrul inputc uml constraint outputl uml target literalstr valu inputc operationexistinlib end newrul,13
25,25,P20-RemovingAnAssociationClass.atl,"-- @name		Removal of association classes
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		SIMON Eric(simon.eric3<at>gmail.com)
-- @date		2006/08/02
-- @description	This transformation replaces an association class with a new class and two associations.
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 1.2, page 2
-- @see author of article : K. Lano

module RemovingAnAssociationClass; -- Module Template
create OUT : UML2 from IN : UML2;

-- @begin Model
rule Model {
	from
		inputM : UML2!Model
	to
		outputM : UML2!Model (
			name <- inputM.name,
			ownedMember <- inputM.ownedMember,
			ownedMember <- inputM.ownedMember ->
			select(a | a.oclIsTypeOf(UML2!AssociationClass))->
			collect(c|Sequence {thisModule.resolveTemp(c, 'outputAsso1')})->flatten(),
	  		ownedMember <- inputM.ownedMember ->
	  		select(a | a.oclIsTypeOf(UML2!AssociationClass))->
	  		collect(c|Sequence {thisModule.resolveTemp(c, 'outputAsso2')})->flatten()
		)
}
-- @end Model

-- @begin DataType
rule DataType {
	from 
		inputC : UML2!DataType
	to
		outputC : UML2!DataType (
		name <- inputC.name
		)
}
-- @end DataType

-- @begin LiteralNull
rule LiteralNull {
	from 
		inputLN : UML2!LiteralNull
	to
		outputLN : UML2!LiteralNull
}
-- @end LiteralNull

-- @begin LiteralInteger
rule LiteralInteger {
	from 
		inputLI : UML2!LiteralInteger
	to
		outputLI : UML2!LiteralInteger (
			value <- inputLI.value	
		)
}
-- @end LiteralInteger

-- @begin LiteralUnlimitedNatural
rule LiteralUnlimitedNatural {
	from 
		inputLUN : UML2!LiteralUnlimitedNatural
	to
		outputLUN : UML2!LiteralUnlimitedNatural (
			value <- inputLUN.value	
		)
}
-- @end LiteralUnlimitedNatural

-- @begin Property
rule Property {
	from 
		inputC : UML2!Property
		(
			not (
				inputC.class_.oclIsTypeOf(UML2!AssociationClass)
			and
				inputC.association.oclIsTypeOf(UML2!AssociationClass)
				)
		)
	to
		outputC : UML2!Property (
			name <- inputC.name,
			type <- inputC.type
		)
}
-- @end Property

-- @begin Class
rule Class {
	from 
		inputC : UML2!Class
		(not inputC.oclIsTypeOf(UML2!AssociationClass))
	to 
		outputC : UML2!Class (
			name <- inputC.name,
			ownedOperation <- inputC.ownedOperation,
			nestedClassifier <-  inputC.nestedClassifier,
			isActive <-  inputC.isActive,
			ownedReception <-  inputC.ownedReception,
			ownedAttribute <- inputC.ownedAttribute
		)
}
-- @end Class

-- @comment this rule replace a association class by a new class between two associations.
-- @begin AssociationClass2Class
rule AssociationClass2Class {
	from 
		inputA : UML2!AssociationClass
	to
		outputClass : UML2!Class (
			name <- inputA.name,
			ownedAttribute <- inputA.ownedAttribute->select(a|a.association->oclIsUndefined())
		),
		outputDef1 : UML2! LiteralInteger (
			value <- 1	
		),
		outputPro11 : UML2!Property (
			owningAssociation <- outputAsso1,
			name <- inputA.memberEnd->at(1).name,
			upperValue <- inputA.memberEnd->at(1).upperValue,
			lowerValue <- inputA.memberEnd->at(1).lowerValue,
			defaultValue <- inputA.memberEnd->at(1).defaultValue
		),
		outputPro12 : UML2!Property (
			owningAssociation <- outputAsso1,
			name <- inputA.memberEnd->at(2).type.name->toLower(),
			defaultValue <- outputDef1
		),
		outputAsso1 : UML2!Association(
			memberEnd <- outputPro11,
			memberEnd <- outputPro12
			
		),
		outputDef2 : UML2! LiteralInteger (
			value <- 1	
		),
		outputPro21 : UML2!Property (
			owningAssociation <- outputAsso2,
			name <- inputA.memberEnd->at(2).name,
			upperValue <- inputA.memberEnd->at(2).upperValue,
			lowerValue <- inputA.memberEnd->at(2).lowerValue,
			defaultValue <- inputA.memberEnd->at(2).defaultValue
		),
		outputPro22 : UML2!Property (
			owningAssociation <- outputAsso2,
			name <- inputA.memberEnd->at(1).type.name->toLower(),
			defaultValue <- outputDef2
		),
		outputAsso2 : UML2!Association(
			memberEnd <- outputPro21,
			memberEnd <- outputPro22
		)
}
-- @end	AssociationClass2Class
",name remov associ class version domain catalogu model transform author simon eric simon eric gmail com date descript this transform replac associ class new class two associ see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul removinganassociationclass modul templat creat out uml in uml begin model rule model inputm uml model outputm uml model name inputm name ownedmemb inputm ownedmemb ownedmemb inputm ownedmemb select oclistypeof uml associationclass collect c sequenc thismodul resolvetemp c outputasso flatten ownedmemb inputm ownedmemb select oclistypeof uml associationclass collect c sequenc thismodul resolvetemp c outputasso flatten end model begin datatyp rule datatyp inputc uml datatyp outputc uml datatyp name inputc name end datatyp begin literalnul rule literalnul inputln uml literalnul outputln uml literalnul end literalnul begin literalinteg rule literalinteg input uml literalinteg output uml literalinteg valu input valu end literalinteg begin literalunlimitednatur rule literalunlimitednatur inputlun uml literalunlimitednatur outputlun uml literalunlimitednatur valu inputlun valu end literalunlimitednatur begin properti rule properti inputc uml properti inputc class oclistypeof uml associationclass inputc associ oclistypeof uml associationclass outputc uml properti name inputc name type inputc type end properti begin class rule class inputc uml class inputc oclistypeof uml associationclass outputc uml class name inputc name ownedoper inputc ownedoper nestedclassifi inputc nestedclassifi isact inputc isact ownedrecept inputc ownedrecept ownedattribut inputc ownedattribut end class comment rule replac associ class new class two associ begin associationclass class rule associationclass class inputa uml associationclass outputclass uml class name inputa name ownedattribut inputa ownedattribut select associ oclisundefin outputdef uml literalinteg valu outputpro uml properti owningassoci outputasso name inputa memberend name uppervalu inputa memberend uppervalu lowervalu inputa memberend lowervalu defaultvalu inputa memberend defaultvalu outputpro uml properti owningassoci outputasso name inputa memberend type name tolow defaultvalu outputdef outputasso uml associ memberend outputpro memberend outputpro outputdef uml literalinteg valu outputpro uml properti owningassoci outputasso name inputa memberend name uppervalu inputa memberend uppervalu lowervalu inputa memberend lowervalu defaultvalu inputa memberend defaultvalu outputpro uml properti owningassoci outputasso name inputa memberend type name tolow defaultvalu outputdef outputasso uml associ memberend outputpro memberend outputpro end associationclass class,13
26,26,P21-ForeignKey-context.atl,"-- @name		Replacing association by foreign key
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		Baudry Julien (jul.baudry<at>gmail.com)
-- @date		2006/08/02
-- @description	The purpose of this transformation is to replace an association by a foreign key
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 1.6, page 7
-- @see author of article : K. Lano

module ForeignKey; -- Module Template
create OUT : KM3target from IN : KM3;

----@begin rule Metamodel
--entrypoint rule Metamodel() {
--	do {
--		KM3!Metamodel.allInstances().debug('metamodels');
--		KM3!Package.allInstances().debug('packages');
--		KM3!Class.allInstances().debug('classes');
--		KM3!DataType.allInstances().debug('datatypes');
--	}
--}
----@end rule Metamodel

--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3target!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
--@end rule Metamodel

--@begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3target!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
--@end rule Package

--@begin rule Class
rule Class {
	from
		inputA:KM3!Class
	to
		outputA:KM3target!Class (
			name <- inputA.name,
			isAbstract <- inputA.isAbstract,
			structuralFeatures <- inputA.structuralFeatures
		),
		
		key:KM3target!Attribute (
			name <- inputA.name.toLower()+'Key',
			isOrdered <- false,
			isUnique <- false,
			location <- '',
			lower <- 1,
			upper <- 1,
			type <- KM3!DataType.allInstances()->select(a|a.name = 'Integer')->first(),
			owner <- inputA
		)
}
--@end rule Class

--@begin rule attribute 
rule attribute {
	from
		inputAtt:KM3!Attribute 
	to
		outputAtt:KM3target!Attribute(
			name <- inputAtt.name,
			isOrdered <- inputAtt.isOrdered,
			isUnique <- inputAtt.isUnique,
			location <- inputAtt.location,
			lower <- inputAtt.lower,
			upper <- inputAtt.upper,
			type <- inputAtt.type,
			owner <- inputAtt.owner
			
		)
}
--@end rule attribute

--@begin rule datatype
rule DataType {
from
		inputData:KM3!DataType
	to
		outputData:KM3target!DataType(
			name <- inputData.name,
			location <- inputData.location
		)
}
--@end rule datatype

--@begin foreignkey
rule reference2Key {
	from 
		r:KM3!Reference (
			r.upper = 1	
		)
	to
		key:KM3target!Attribute (
			name <- r.type.name.toLower()+'ForeignKey',
			isOrdered <- false,
			isUnique <- false,
			location <- '',
			lower <- 1,
			upper <- 1,
			type <- KM3!DataType.allInstances()->select(a|a.name = 'Integer')->first(),
			owner <- r.owner
		)
}
--@end foreignkey

--@begin enumeration
rule enumeration {
	from
		inputEnum:KM3!Enumeration 
	to
		outputEnum:KM3target!Enumeration (
			location <- inputEnum.location,
			name  <- inputEnum.name,
			package  <- inputEnum.package
		)

}
--@end enumeration

--@begin literal
rule literal {
	from
		inputEnum:KM3!EnumLiteral
	to
		outputEnum:KM3target!EnumLiteral (
			location <- inputEnum.location,
			name  <- inputEnum.name,
			enum  <- inputEnum.enum
		)

}
--@end literal
",name replac associ foreign key version domain catalogu model transform author baudri julien jul baudri gmail com date descript the purpos transform replac associ foreign key see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul foreignkey modul templat creat out km target in km begin rule metamodel entrypoint rule metamodel km metamodel allinst debug metamodel km packag allinst debug packag km class allinst debug class km datatyp allinst debug datatyp end rule metamodel begin rule metamodel rule metamodel inputmm km metamodel outputmm km target metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km target packag name inputpkg name content inputpkg content end rule packag begin rule class rule class inputa km class outputa km target class name inputa name isabstract inputa isabstract structuralfeatur inputa structuralfeatur key km target attribut name inputa name tolow key isord fals isuniqu fals locat lower upper type km datatyp allinst select name integ first owner inputa end rule class begin rule attribut rule attribut inputatt km attribut outputatt km target attribut name inputatt name isord inputatt isord isuniqu inputatt isuniqu locat inputatt locat lower inputatt lower upper inputatt upper type inputatt type owner inputatt owner end rule attribut begin rule datatyp rule datatyp inputdata km datatyp outputdata km target datatyp name inputdata name locat inputdata locat end rule datatyp begin foreignkey rule refer key r km refer r upper key km target attribut name r type name tolow foreignkey isord fals isuniqu fals locat lower upper type km datatyp allinst select name integ first owner r owner end foreignkey begin enumer rule enumer inputenum km enumer outputenum km target enumer locat inputenum locat name inputenum name packag inputenum packag end enumer begin liter rule liter inputenum km enumliter outputenum km target enumliter locat inputenum locat name inputenum name enum inputenum enum end liter,1
27,27,P21-ForeignKey-without.atl,"-- @name		Replacing association by foreign key
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		Baudry Julien (jul.baudry<at>gmail.com)
-- @date		2006/08/02
-- @description	The purpose of this transformation is to replace an association by a foreign key
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 1.6, page 7
-- @see author of article : K. Lano

module ForeignKey; -- Module Template
create OUT : KM3target from IN : KM3;

--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3target!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
--@end rule Metamodel

--@begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3target!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
--@end rule Package

--@begin rule Class
rule Class {
	from
		inputA:KM3!Class
	to
		outputA:KM3target!Class (
			name <- inputA.name,
			isAbstract <- inputA.isAbstract,
			structuralFeatures <- inputA.structuralFeatures
		)
}
--@end rule Class

--@begin rule datatype
rule DataType {
from
		inputData:KM3!DataType
	to
		outputData:KM3target!DataType(
			name <- inputData.name,
			location <- inputData.location
		)
}
--@end rule datatype

--@begin foreignkey
rule reference2Key {
	from 
		r:KM3!Reference (
			r.upper = 1	
		)
	to
		key:KM3target!Attribute (
			name <- r.type.name.toLower()+'ForeignKey',
			isOrdered <- false,
			isUnique <- false,
			location <- '',
			lower <- 1,
			upper <- 1,
			type <- KM3!DataType.allInstances()->select(a|a.name = 'Integer')->first(),
			owner <- r.owner
		)
}
--@end foreignkey

--@begin rule attribute 
rule attribute {
	from
		inputAtt:KM3!Attribute 
	to
		outputAtt:KM3target!Attribute(
			name <- inputAtt.name,
			isOrdered <- inputAtt.isOrdered,
			isUnique <- inputAtt.isUnique,
			location <- inputAtt.location,
			lower <- inputAtt.lower,
			upper <- inputAtt.upper,
			type <- inputAtt.type,
			owner <- inputAtt.owner
			
		)
}
--@end rule attribute",name replac associ foreign key version domain catalogu model transform author baudri julien jul baudri gmail com date descript the purpos transform replac associ foreign key see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul foreignkey modul templat creat out km target in km begin rule metamodel rule metamodel inputmm km metamodel outputmm km target metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km target packag name inputpkg name content inputpkg content end rule packag begin rule class rule class inputa km class outputa km target class name inputa name isabstract inputa isabstract structuralfeatur inputa structuralfeatur end rule class begin rule datatyp rule datatyp inputdata km datatyp outputdata km target datatyp name inputdata name locat inputdata locat end rule datatyp begin foreignkey rule refer key r km refer r upper key km target attribut name r type name tolow foreignkey isord fals isuniqu fals locat lower upper type km datatyp allinst select name integ first owner r owner end foreignkey begin rule attribut rule attribut inputatt km attribut outputatt km target attribut name inputatt name isord inputatt isord isuniqu inputatt isuniqu locat inputatt locat lower inputatt lower upper inputatt upper type inputatt type owner inputatt owner end rule attribut,1
28,28,P22-Replace-context.atl,"-- @name		Replacing inheritance by association
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		Baudry Julien (jul.baudry<at>gmail.com)
-- @date		2006/08/02
-- @description	The purpose of this transformation is to replace inheritances by associations
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 1.1, page 2
-- @see author of article : K. Lano

module Replace; -- Module Template
create OUT : KM3target from IN : KM3;

--@begin rule Metamodel
--entrypoint rule Metamodel() {
--	do {
--		KM3!Metamodel.allInstances().debug('metamodels');
--		KM3!Package.allInstances().debug('packages');
--		KM3!Class.allInstances().debug('classes');
--	}
--}
--@end rule Metamodel

--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3target!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
--@end rule Metamodel

--@begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3target!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
--@end rule Package

--@begin rule ClassA
rule ClassA {
	from
		inputA:KM3!Class (
			inputA.supertypes.isEmpty()
		)
	to
		outputA:KM3target!Class (
			name <- inputA.name,
			isAbstract <- inputA.isAbstract
		)
}
--@end rule ClassA

--@begin rule ClassB
rule ClassB {
	from
		inputB:KM3!Class (
			not(inputB.supertypes.isEmpty())
		)
	to
		outputB:KM3target!Class (
			name <- inputB.name,
			isAbstract <- inputB.isAbstract,
			structuralFeatures <- inputB.supertypes->iterate(a;acc : Sequence(KM3!StructuralFeature) = Sequence{}|
																acc->including(thisModule.Inherit2Association(a,inputB))
															)
		)
}
--@end rule ClassB

--@begin Inherit2Association
lazy rule Inherit2Association {
	from
		supertype:KM3!Class,
		children:KM3!Class
	to
		refChildren : KM3target!Reference (
			name <- 'inherit'+supertype.name,
			opposite <- refSupertype,
			owner <- children,
			type <- supertype,
			lower <- 1,
			upper <- 1
		),

		refSupertype : KM3target!Reference( 
			name <- 'children'+children.name,
			opposite <- refChildren,
			owner <- supertype,
			type <- children,
			lower <- 1,
			upper <- 1
		)	
}
--@end Inherit2Association

--@begin rule attribute 
rule attribute {
	from
		inputAtt:KM3!Attribute 
	to
		outputAtt:KM3target!Attribute(
			name <- inputAtt.name,
			isOrdered <- inputAtt.isOrdered,
			isUnique <- inputAtt.isUnique,
			location <- inputAtt.location,
			lower <- inputAtt.lower,
			upper <- inputAtt.upper,
			type <- inputAtt.type,
			owner <- inputAtt.owner
			
		)
}
--@end rule attribute

--@begin rule DataType
rule DataType {
from
		inputData:KM3!DataType
	to
		outputData:KM3target!DataType(
			name <- inputData.name,
			location <- inputData.location
		)
}
--@end rule DataType

--@begin reference
rule reference {
	from
		inputRef:KM3!Reference 
	to
		outputRef:KM3target!Reference (
			name <- inputRef.name,
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			location <- inputRef.location,
			lower <- inputRef.lower,
			upper <- inputRef.upper,
			type <- inputRef.type,
			owner <- inputRef.owner,
			opposite <- inputRef.opposite
		)
}
--@end reference

--@begin enumeration
rule enumeration {
	from
		inputEnum:KM3!Enumeration 
	to
		outputEnum:KM3target!Enumeration (
			location <- inputEnum.location,
			name  <- inputEnum.name,
			package  <- inputEnum.package
		)

}
--@end enumeration

--@begin literal
rule literal {
	from
		inputEnum:KM3!EnumLiteral
	to
		outputEnum:KM3target!EnumLiteral (
			location <- inputEnum.location,
			name  <- inputEnum.name,
			enum  <- inputEnum.enum
		)

}
--@end literal",name replac inherit associ version domain catalogu model transform author baudri julien jul baudri gmail com date descript the purpos transform replac inherit associ see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul replac modul templat creat out km target in km begin rule metamodel entrypoint rule metamodel km metamodel allinst debug metamodel km packag allinst debug packag km class allinst debug class end rule metamodel begin rule metamodel rule metamodel inputmm km metamodel outputmm km target metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km target packag name inputpkg name content inputpkg content end rule packag begin rule classa rule classa inputa km class inputa supertyp isempti outputa km target class name inputa name isabstract inputa isabstract end rule classa begin rule classb rule classb inputb km class inputb supertyp isempti outputb km target class name inputb name isabstract inputb isabstract structuralfeatur inputb supertyp iter acc sequenc km structuralfeatur sequenc acc includ thismodul inherit associ inputb end rule classb begin inherit associ lazi rule inherit associ supertyp km class children km class refchildren km target refer name inherit supertyp name opposit refsupertyp owner children type supertyp lower upper refsupertyp km target refer name children children name opposit refchildren owner supertyp type children lower upper end inherit associ begin rule attribut rule attribut inputatt km attribut outputatt km target attribut name inputatt name isord inputatt isord isuniqu inputatt isuniqu locat inputatt locat lower inputatt lower upper inputatt upper type inputatt type owner inputatt owner end rule attribut begin rule datatyp rule datatyp inputdata km datatyp outputdata km target datatyp name inputdata name locat inputdata locat end rule datatyp begin refer rule refer inputref km refer outputref km target refer name inputref name isord inputref isord isuniqu inputref isuniqu locat inputref locat lower inputref lower upper inputref upper type inputref type owner inputref owner opposit inputref opposit end refer begin enumer rule enumer inputenum km enumer outputenum km target enumer locat inputenum locat name inputenum name packag inputenum packag end enumer begin liter rule liter inputenum km enumliter outputenum km target enumliter locat inputenum locat name inputenum name enum inputenum enum end liter,1
29,29,P22-Replace-without.atl,"-- @name		Replacing inheritance by association
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		Baudry Julien (jul.baudry<at>gmail.com)
-- @date		2006/08/02
-- @description	The purpose of this transformation is to replace inheritances by associations
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 1.1, page 2
-- @see author of article : K. Lano

module Replace; -- Module Template
create OUT : KM3 from IN : KM3;

--@begin rule Metamodel
--	For a Metamodel element, another Metamodel element is created :
--			with the same name and location,
--			Linked to the same contents.
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
--@end rule Metamodel

--@begin rule Package
--	For a Package element, another Package element is created :
--			with the same name, 
--			Linked to the same contents.
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
--@end rule Package

--@begin rule Class without supertype
--	This class has no supertypes :
--			We create another class with the same name,
--			Abstract if the source class is abstract. 	
rule ClassA {
	from
		inputA:KM3!Class (
			inputA.supertypes.isEmpty()
		)
	to
		outputA:KM3!Class (
			name <- inputA.name,
			isAbstract <- inputA.isAbstract
		)
}
--@end rule without supertype

--@begin rule Class with supertype
rule ClassB {
	from
		inputB:KM3!Class (
			not(inputB.supertypes.isEmpty())
		)
	to
		outputB:KM3!Class (
			name <- inputB.name,
			isAbstract <- inputB.isAbstract,
			structuralFeatures <- inputB.supertypes->iterate(a;acc : Sequence(KM3!StructuralFeature) = Sequence{}|
																acc->including(thisModule.Inherit2Association(a,inputB))
															)
		)
}
--@end rule Class  with supertype


lazy rule Inherit2Association {
	from
		supertype:KM3!Class,
		children:KM3!Class
	to
		refChildren : KM3!Reference (
			name <- 'inherit'+supertype.name,
			opposite <- refSupertype,
			owner <- children,
			type <- supertype,
			lower <- 1,
			upper <- 1
		),

		refSupertype : KM3!Reference( 
			name <- 'children'+children.name,
			opposite <- refChildren,
			owner <- supertype,
			type <- children,
			lower <- 1,
			upper <- 1
		)	
}",name replac inherit associ version domain catalogu model transform author baudri julien jul baudri gmail com date descript the purpos transform replac inherit associ see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul replac modul templat creat out km in km begin rule metamodel for metamodel element anoth metamodel element creat name locat link content rule metamodel inputmm km metamodel outputmm km metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag for packag element anoth packag element creat name link content rule packag inputpkg km packag outputpkg km packag name inputpkg name content inputpkg content end rule packag begin rule class without supertyp this class supertyp we creat anoth class name abstract sourc class abstract rule classa inputa km class inputa supertyp isempti outputa km class name inputa name isabstract inputa isabstract end rule without supertyp begin rule class supertyp rule classb inputb km class inputb supertyp isempti outputb km class name inputb name isabstract inputb isabstract structuralfeatur inputb supertyp iter acc sequenc km structuralfeatur sequenc acc includ thismodul inherit associ inputb end rule class supertyp lazi rule inherit associ supertyp km class children km class refchildren km refer name inherit supertyp name opposit refsupertyp owner children type supertyp lower upper refsupertyp km refer name children children name opposit refchildren owner supertyp type children lower upper,1
30,30,P23-Class2Relational.atl,"module Class2Relational;
create OUT : Relational from IN : Class;

uses strings;


-- if there is a configuration problem with the library string,
-- delete the two firstToLower() operations and you no longer need the library ""strings""
-- the transfomarion will execute 


-- inheritance not supported yet

-- issue: choose an object-id Type (Integer, String?).
-- We choose Integer here, assuming this type is defined in the source model.

-- global variable
-- context 
helper def: objectIdType : Relational!Type =
	Class!DataType.allInstances()->select(e | e.name = 'Integer')->first();

rule Class2Table {
	from
		c : Class!Class
	to
		out : Relational!Table (
			name <- c.name,
			-- Columns are generated from Attributes in another rule not explicitly called here !
			col <- Sequence {key}->union(c.attr->select(e | not e.multiValued)),
			key <- Set {key}
		),
		key : Relational!Column (
			name <- 'objectId',
			type <- thisModule.objectIdType
		)
}

rule DataType2Type {
	from
		dt : Class!DataType
	to
		out : Relational!Type (
			name <- dt.name
		)
}

rule DataTypeAttribute2Column {
	from
		a : Class!Attribute (
			a.type.oclIsKindOf(Class!DataType) and not a.multiValued
		)
	to
		out : Relational!Column (
			name <- a.name,
			type <- a.type
-- explicit use of implicit tracking links (first expected syntax, then present actual syntax)
--			owner <- [Class2Type.key]a.owner
--			owner <- thisModule.resolveTemp(a.owner, 'key')
		)
}

rule MultiValuedDataTypeAttribute2Column {
	from
		a : Class!Attribute (
			a.type.oclIsKindOf(Class!DataType) and a.multiValued
		)
	to
		out : Relational!Table (
			name <- a.owner.name + '_' + a.name,
			col <- Sequence {id, value}
		),
		id : Relational!Column (
			name <- a.owner.name.firstToLower() + 'Id',
			type <- thisModule.objectIdType
		),
		value : Relational!Column (
			name <- a.name,
			type <- a.type
		)
}

rule ClassAttribute2Column {
	from
		a : Class!Attribute (
			a.type.oclIsKindOf(Class!Class) and not a.multiValued
		)
	to
		foreignKey : Relational!Column (
			name <- a.name + 'Id',
			type <- thisModule.objectIdType
		)
}

rule MultiValuedClassAttribute2Column {
	from
		a : Class!Attribute (
			a.type.oclIsKindOf(Class!Class) and a.multiValued
		)
	to
		t : Relational!Table (
			name <- a.owner.name + '_' + a.name,
			col <- Sequence {id, foreignKey}
		),
		id : Relational!Column (
			name <- a.owner.name.firstToLower() + 'Id',
			type <- thisModule.objectIdType
		),
		foreignKey : Relational!Column (
			name <- a.name + 'Id',
			type <- thisModule.objectIdType
		)
}

",modul class relat creat out relat in class use string configur problem librari string delet two firsttolow oper longer need librari string transfomarion execut inherit support yet issu choos object id type integ string we choos integ assum type defin sourc model global variabl context helper def objectidtyp relat type class datatyp allinst select e e name integ first rule class tabl c class class relat tabl name c name column generat attribut anoth rule explicit call col sequenc key union c attr select e e multivalu key set key key relat column name objectid type thismodul objectidtyp rule datatyp type dt class datatyp relat type name dt name rule datatypeattribut column class attribut type ocliskindof class datatyp multivalu relat column name name type type explicit use implicit track link first expect syntax present actual syntax owner class type key owner owner thismodul resolvetemp owner key rule multivalueddatatypeattribut column class attribut type ocliskindof class datatyp multivalu relat tabl name owner name name col sequenc id valu id relat column name owner name firsttolow id type thismodul objectidtyp valu relat column name name type type rule classattribut column class attribut type ocliskindof class class multivalu foreignkey relat column name name id type thismodul objectidtyp rule multivaluedclassattribut column class attribut type ocliskindof class class multivalu relat tabl name owner name name col sequenc id foreignkey id relat column name owner name firsttolow id type thismodul objectidtyp foreignkey relat column name name id type thismodul objectidtyp,16
31,31,P23-ECore2Class.atl,"module ECore2Class;
create OUT : Class from IN : MOF;

rule Class {
	from
		ic : MOF!EClass
	to
		oc : Class!Class (
			name <- ic.name,
			attr <- ic.eStructuralFeatures,
			super <- ic.eSuperTypes
		)
}

rule Attribute {
	from
		ia : MOF!EAttribute
	to
		oa : Class!Attribute (
			name <- ia.name,
			multiValued <- (ia.upperBound > 1) or (ia.upperBound = 0-1),
			type <- ia.eType
		)
}

rule DataType {
	from
		idt : MOF!EDataType
	to
		odt : Class!DataType (
			name <- idt.name
		)
}

",modul ecor class creat out class in mof rule class ic mof eclass oc class class name ic name attr ic estructuralfeatur super ic esupertyp rule attribut ia mof eattribut oa class attribut name ia name multivalu ia upperbound ia upperbound type ia etyp rule datatyp idt mof edatatyp odt class datatyp name idt name,4
32,32,P24-CPL2SPL.atl,"module CPL2SPL;
create OUT : SPL from IN : CPL;

-- We consider nodes are statements, by default.
helper context CPL!Node def: statement : CPL!Node =
	self;

-- The ""location"" node is not a statement.
helper context CPL!Location def: statement : CPL!Node =
	self.contents.statement;

-- @begin Locations computation
-- By default, locations of an element are locations of its container.
helper context CPL!Element def: locations : Sequence(CPL!Location) =
	self.refImmediateComposite().locations;

-- Locations of the CPL root is the empty sequence.
helper context CPL!CPL def: locations : Sequence(CPL!Location) =
	Sequence {};

-- @see last paragraph of 6.1 just before 6.1.1 of CPL RFC
helper context CPL!Location def: locations : Sequence(CPL!Location) =
	Sequence {self}->union(self.refImmediateComposite().locations);

--helper context CPL!Redirection def: locations : Sequence(CPL!Location) =
--	Sequence {self}->union(self.refImmediateComposite().locations);
-- @end Locations computation

rule CPL2Program {
	from
		s : CPL!CPL
	to
		t : SPL!Program (
			service <- service
		),
		service : SPL!Service (
			name <- 'unnamed',
			declarations <- s.subActions,
			sessions <- dialog
		),
		dialog : SPL!Dialog (
			methods <- Sequence {s.incoming, s.outgoing}
		)
}

rule SubAction2Function {
	from
		s : CPL!SubAction
	to
		t : SPL!LocalFunctionDeclaration (
			name <- s.id,
			returnType <- rt,
			statements <- s.contents.statement
		),
		rt : SPL!SimpleType (
			type <- #response
		)
}

rule Incoming2Method {
	from
		s : CPL!Incoming
	to
		t : SPL!Method (
			type <- rt,
			direction <- #""in"",
			methodName <- mn,
			statements <-
				if s.contents.oclIsUndefined() then
					Sequence {}
				else
					Sequence {s.contents.statement}
				endif
		),
		rt : SPL!SimpleType (
			type <- #response
		),
		mn : SPL!SIPMethodName (
			name <- #INVITE
		)
}

helper context CPL!Proxy def: isSimple : Boolean =
	self.busy.oclIsUndefined() and
	self.noAnswer.oclIsUndefined() and
	self.redirection.oclIsUndefined() and
	self.failure.oclIsUndefined() and
	self.default.oclIsUndefined();

rule Proxy2Return {
	from
		s : CPL!Proxy (
			s.isSimple
		)
	to
		t : SPL!ReturnStat (
			returnedValue <- fwd
		),
		fwd : SPL!ForwardExp (
			isParallel <- s.ordering = 'parallel',
			exp <- exp
		),
		exp : SPL!ConstantExp (
			value <- thisModule.Location2URIConstant(s.locations->first())
		)
}

-- @begin Complex Proxy
rule Proxy2Select {
	from
		s : CPL!Proxy (
			not s.isSimple
		)
	to
		t : SPL!CompoundStat (
			statements <- Sequence {declStat, select}
		),

		-- response r = [parallel] forward <uri>;
		declStat : SPL!DeclarationStat (
			declaration <- decl
		),
		decl : SPL!VariableDeclaration (
			type <- rt,
			name <- 'r',
			initExp <- fwd
		),
		rt : SPL!SimpleType (
			type <- #response
		),
		fwd : SPL!ForwardExp (
			isParallel <- s.ordering = 'parallel',
			exp <- exp
		),
		exp : SPL!ConstantExp (
			value <- thisModule.Location2URIConstant(s.locations->first())
		),

		-- select(r)
		select : SPL!SelectStat (
			matchedExp <- v,
			selectCases <- Sequence {s.busy, s.noAnswer, s.redirection, s.failure},
			selectDefault <- s.default
		),
		v : SPL!Variable (
			source <- decl
		)
}

rule Busy2SelectCase {
	from
		s : CPL!Busy
	to
		t : SPL!SelectCase (
			commentsBefore <- Sequence {'// busy'},
			values <- Sequence {v},
			statements <- Sequence {s.contents.statement}
		),
		v : SPL!ResponseConstant (
			response <- r
		),
		r : SPL!ClientErrorResponse (
			errorKind <- #BUSY_HERE
		)
}

rule NoAnswer2SelectCase {
	from
		s : CPL!NoAnswer
	to
		t : SPL!SelectCase (
			commentsBefore <- Sequence {'// noanswer'},
			values <- Sequence {v},
			statements <- Sequence {s.contents.statement}
		),
		v : SPL!ResponseConstant (
			response <- r
		),
		r : SPL!ClientErrorResponse (
			errorKind <- #REQUEST_TIMEOUT
		)
}

rule Redirection2SelectCase {
	from
		s : CPL!Redirection
	to
		t : SPL!SelectCase (
			commentsBefore <- Sequence {'// redirection'},
			values <- Sequence {v},
			statements <- Sequence {s.contents.statement}
		),
		v : SPL!ResponseConstant (
			response <- r
		),
		r : SPL!RedirectionErrorResponse (
			errorKind <- OclUndefined
		)
}

rule Default2SelectDefault {
	from
		s : CPL!Default
	to
		t : SPL!SelectDefault (
			commentsBefore <- Sequence {'// default'},
			statements <- Sequence {s.contents.statement}
		)
}
-- @end Complex Proxy

rule SubCall2Return {
	from
		s : CPL!SubCall
	to
		t : SPL!ReturnStat (
			returnedValue <- callExp
		),
		callExp : SPL!FunctionCallExp (
			functionCall <- call
		),
		call : SPL!FunctionCall (
			function <- CPL!SubAction.allInstancesFrom('IN')->select(e | e.id = s.ref)->first()
		)
}

rule Redirect2Return {
	from
		s : CPL!Redirect
	to
		t : SPL!ReturnStat (
			returnedValue <- withExp
		),
		withExp : SPL!WithExp (
			exp <- v,
			msgFields <- Sequence {reason, contact}
		),
		v : SPL!ConstantExp (
			value <- rc
		),
		rc : SPL!ResponseConstant (
			response <- rer
		),
		rer : SPL!RedirectionErrorResponse (
			errorKind <- if s.permanent = 'true' then #MOVED_PERMANENTLY else #MOVED_TEMPORARILY endif
		),

		reason : SPL!ReasonMessageField (
			exp <- reasonConstant
		),
			reasonConstant : SPL!ConstantExp (
				value <- reasonString
			),
			reasonString : SPL!StringConstant (
				value <- 'unspecified'
			),

		contact : SPL!HeadedMessageField (
			headerId <- '#contact:',
			exp <- contactConstant
		),
			contactConstant : SPL!ConstantExp (
				value <- thisModule.Location2URIConstant(s.locations->first())
			)
}

-- @begin Switches
rule AddressSwitch2SelectStat {
	from
		s : CPL!AddressSwitch
	to
		t : SPL!SelectStat (
			matchedExp <- v,
			selectCases <- s.addresses->including(s.notPresent),
			selectDefault <- s.otherwise
		),
		v : SPL!SIPHeaderPlace (
			header <-	if s.field = 'origin' then
						#FROM
					else -- s.field = 'destination' or s.field = 'original-destination'
						#TO
					endif
		)
}

rule SwitchedAddress2SelectCase {
	from
		s : CPL!SwitchedAddress
	to
		t : SPL!SelectCase (
			values <- Sequence {v},
			statements <- Sequence {s.contents.statement}
		),
		v : SPL!StringConstant (
			value <- s.is
		)
}

rule Otherwise2SelectDefault {
	from
		s : CPL!Otherwise
	to
		t : SPL!SelectDefault (
			statements <- s.contents.statement
		)
}
-- @end Switches

lazy rule Location2URIConstant {
	from
		s : CPL!Location
	to
		t : SPL!URIConstant (
			uri <- s.url
		)
}

",modul cpl spl creat out spl in cpl we consid node statement default helper context cpl node def statement cpl node self the locat node statement helper context cpl locat def statement cpl node self content statement begin locat comput by default locat element locat contain helper context cpl element def locat sequenc cpl locat self refimmediatecomposit locat locat cpl root empti sequenc helper context cpl cpl def locat sequenc cpl locat sequenc see last paragraph cpl rfc helper context cpl locat def locat sequenc cpl locat sequenc self union self refimmediatecomposit locat helper context cpl redirect def locat sequenc cpl locat sequenc self union self refimmediatecomposit locat end locat comput rule cpl program cpl cpl spl program servic servic servic spl servic name unnam declar subact session dialog dialog spl dialog method sequenc incom outgo rule subact function cpl subact spl localfunctiondeclar name id returntyp rt statement content statement rt spl simpletyp type respons rule incom method cpl incom spl method type rt direct methodnam mn statement content oclisundefin sequenc els sequenc content statement endif rt spl simpletyp type respons mn spl sipmethodnam name invit helper context cpl proxi def issimpl boolean self busi oclisundefin self noanswer oclisundefin self redirect oclisundefin self failur oclisundefin self default oclisundefin rule proxi return cpl proxi issimpl spl returnstat returnedvalu fwd fwd spl forwardexp isparallel order parallel exp exp exp spl constantexp valu thismodul locat uriconst locat first begin complex proxi rule proxi select cpl proxi issimpl spl compoundstat statement sequenc declstat select respons r parallel forward uri declstat spl declarationstat declar decl decl spl variabledeclar type rt name r initexp fwd rt spl simpletyp type respons fwd spl forwardexp isparallel order parallel exp exp exp spl constantexp valu thismodul locat uriconst locat first select r select spl selectstat matchedexp v selectcas sequenc busi noanswer redirect failur selectdefault default v spl variabl sourc decl rule busi selectcas cpl busi spl selectcas commentsbefor sequenc busi valu sequenc v statement sequenc content statement v spl responseconst respons r r spl clienterrorrespons errorkind busi here rule noanswer selectcas cpl noanswer spl selectcas commentsbefor sequenc noanswer valu sequenc v statement sequenc content statement v spl responseconst respons r r spl clienterrorrespons errorkind request timeout rule redirect selectcas cpl redirect spl selectcas commentsbefor sequenc redirect valu sequenc v statement sequenc content statement v spl responseconst respons r r spl redirectionerrorrespons errorkind oclundefin rule default selectdefault cpl default spl selectdefault commentsbefor sequenc default statement sequenc content statement end complex proxi rule subcal return cpl subcal spl returnstat returnedvalu callexp callexp spl functioncallexp functioncal call call spl functioncal function cpl subact allinstancesfrom in select e e id ref first rule redirect return cpl redirect spl returnstat returnedvalu withexp withexp spl withexp exp v msgfield sequenc reason contact v spl constantexp valu rc rc spl responseconst respons rer rer spl redirectionerrorrespons errorkind perman true move perman els move temporarili endif reason spl reasonmessagefield exp reasonconst reasonconst spl constantexp valu reasonstr reasonstr spl stringconst valu unspecifi contact spl headedmessagefield headerid contact exp contactconst contactconst spl constantexp valu thismodul locat uriconst locat first begin switch rule addressswitch selectstat cpl addressswitch spl selectstat matchedexp v selectcas address includ notpres selectdefault otherwis v spl sipheaderplac header field origin from els field destin field origin destin to endif rule switchedaddress selectcas cpl switchedaddress spl selectcas valu sequenc v statement sequenc content statement v spl stringconst valu rule otherwis selectdefault cpl otherwis spl selectdefault statement content statement end switch lazi rule locat uriconst cpl locat spl uriconst uri url,0
33,33,P25-Disaggregation-context.atl,"-- @name		Disaggregation
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		SIMON Eric(simon.eric3<at>gmail.com)
-- @date		2006/07/27
-- @description	This transformation strenghthens or weakens an assertion(respectively postcondition and precondition).
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 2.8, page 23
-- @see author of article : K. Lano

module Disaggregation; -- Module Template
create OUT : KM3 from IN : KM3;

-- @comment this helper returns the metadata ""commentsBefore"" of name : <name>
helper context KM3!Attribute def: getMetadata(name : String) : String =
	let comment : String = self.commentsBefore->select(e | e.startsWith('-- @' + name + ' '))->first() in
	if comment.oclIsUndefined() then
		OclUndefined
	else
		comment.substring(6 + name.size(), comment.size())
	endif;

-- @comment this helper returns the class set of the metadatas
helper context KM3!Class def : getClass : Set(String) =
	KM3!Attribute->allInstances()->select(c|c.commentsBefore->notEmpty())->iterate(a; acc : Set(String) = Set{}| acc->including(a.getMetadata('label')))
	;
--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
-- @end rule Metamodel

-- @begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
-- @end rule Package

-- @begin rule DataType
rule DataType {
	from
		inputData:KM3!DataType
	to
		outputData:KM3!DataType(
			name <- inputData.name,
			location <- inputData.location
		)
}
-- @end rule DataType

-- @begin rule Enumeration 
rule Enumeration {
	from
		inputEnum:KM3!Enumeration
	to
		outputEnum:KM3!Enumeration (
			name <- inputEnum.name,
			location <- inputEnum.location,
			package <- inputEnum.package,
			literals <- inputEnum.literals
		)
}
-- @end rule Enumeration 


--@begin rule EnumLiteral
rule EnumLiteral {
	from
		inputL:KM3!EnumLiteral
	to
		outputL:KM3!EnumLiteral (
			name <- inputL.name,
			location <- inputL.location,
			enum  <- inputL.enum,
			package <- inputL.package
		)
}
--@end rule EnumLiteral

-- @begin rule Class
rule Class {
	from
		inputC:KM3!Class
		(not (inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Attribute))->exists(a|a.commentsBefore->notEmpty())))
	to
		outputC:KM3!Class (
			isAbstract <- inputC.isAbstract,
			supertypes <- inputC.supertypes,
			name <- inputC.name,
			location <- inputC.location,
			package <- inputC.package,
			structuralFeatures <- inputC.structuralFeatures
		)
}
-- @end rule Class

-- @begin rule Attribute
rule Attribute {
	from
		inputAttr : KM3!Attribute
	to
		outputAttr : KM3!Attribute (
			package <- inputAttr.package,
			name <- inputAttr.name,
			lower <- inputAttr.lower,
			upper <- inputAttr.upper,
			isOrdered <- inputAttr.isOrdered,
			isUnique <- inputAttr.isUnique,
			owner <- inputAttr.owner,
			type <- inputAttr.type
		)
}
-- @end rule Attribute

-- @begin rule Reference
rule Reference {
	from
		inputRef : KM3!Reference
			
	to
		outputRef : KM3!Reference (
			package <- inputRef.package,
			name <- inputRef.name,
			lower <- inputRef.lower,
			upper <- inputRef.upper,
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			owner <- inputRef.owner,
			type <- inputRef.type,
			isContainer <- inputRef.isContainer,
			opposite <- inputRef.opposite
		)
}
-- @end rule Attribute

-- @begin rule Disaggregation
rule Disaggregation {
	from
		inputC : KM3!Class
		(inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Attribute))->exists(a|a.commentsBefore->notEmpty()))
	using {
		subClasses : Set(String) = inputC.getClass;		
		}
	to
		outputPrimaryClass : KM3!Class (	
			isAbstract <- inputC.isAbstract,
			supertypes <- inputC.supertypes,
			name <- inputC.name,
			location <- inputC.location,
			package <- inputC.package,
			structuralFeatures <- inputC.structuralFeatures->select(a| not a.oclIsTypeOf(KM3!Attribute)),
			structuralFeatures <- inputC.structuralFeatures->select(a| a.oclIsTypeOf(KM3!Attribute))->select(a|a.commentsBefore->oclIsUndefined()),
			structuralFeatures <- subClasses->iterate(a; acc : Sequence(KM3!Reference)=Sequence{}| acc->append(thisModule.composition(inputC,a)))			
		)
}
-- @end rule Disaggregation

-- @comment this lazy rule creates a auxiliarie class and this link with the root element for each element in the metadata.
-- @begin rule composition
lazy rule composition{
	from
		inputC : KM3!Class,
		Name : String
		
	to
		outputRef1 : KM3!Reference (
			package <- inputC.package,
			name <- 'ref1'+Name,
			lower <- 1,
			upper <- 1,
			isOrdered <- false,
			isUnique <- false,
			owner <- inputC,
			type <- subClass,
			isContainer <- true,
			opposite <- outputRef2
		),
		subClass : KM3!Class (
			isAbstract <- false,
			name <- Name,
			location <- inputC.location,
			package <- inputC.package,
			structuralFeatures <- inputC.structuralFeatures->select(a| a.oclIsTypeOf(KM3!Attribute))->select(a|a.commentsBefore->notEmpty() and a.getMetadata('label') = Name)
		),
		
		outputRef2 : KM3!Reference (
			package <- inputC.package,
			name <- 'ref'+inputC.name,
			lower <- 1,
			upper <- 1,
			isOrdered <- false,
			isUnique <- false,
			owner <- subClass,
			type <- inputC,
			isContainer <- false,
			opposite <- outputRef1
		)
}
-- @end rule composition
",name disaggreg version domain catalogu model transform author simon eric simon eric gmail com date descript this transform strenghthen weaken assert respect postcondit precondit see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul disaggreg modul templat creat out km in km comment helper return metadata commentsbefor name name helper context km attribut def getmetadata name string string let comment string self commentsbefor select e e startswith name first comment oclisundefin oclundefin els comment substr name size comment size endif comment helper return class set metadata helper context km class def getclass set string km attribut allinst select c c commentsbefor notempti iter acc set string set acc includ getmetadata label begin rule metamodel rule metamodel inputmm km metamodel outputmm km metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km packag name inputpkg name content inputpkg content end rule packag begin rule datatyp rule datatyp inputdata km datatyp outputdata km datatyp name inputdata name locat inputdata locat end rule datatyp begin rule enumer rule enumer inputenum km enumer outputenum km enumer name inputenum name locat inputenum locat packag inputenum packag liter inputenum liter end rule enumer begin rule enumliter rule enumliter inputl km enumliter outputl km enumliter name inputl name locat inputl locat enum inputl enum packag inputl packag end rule enumliter begin rule class rule class inputc km class inputc structuralfeatur select r r oclistypeof km attribut exist commentsbefor notempti outputc km class isabstract inputc isabstract supertyp inputc supertyp name inputc name locat inputc locat packag inputc packag structuralfeatur inputc structuralfeatur end rule class begin rule attribut rule attribut inputattr km attribut outputattr km attribut packag inputattr packag name inputattr name lower inputattr lower upper inputattr upper isord inputattr isord isuniqu inputattr isuniqu owner inputattr owner type inputattr type end rule attribut begin rule refer rule refer inputref km refer outputref km refer packag inputref packag name inputref name lower inputref lower upper inputref upper isord inputref isord isuniqu inputref isuniqu owner inputref owner type inputref type iscontain inputref iscontain opposit inputref opposit end rule attribut begin rule disaggreg rule disaggreg inputc km class inputc structuralfeatur select r r oclistypeof km attribut exist commentsbefor notempti use subclass set string inputc getclass outputprimaryclass km class isabstract inputc isabstract supertyp inputc supertyp name inputc name locat inputc locat packag inputc packag structuralfeatur inputc structuralfeatur select oclistypeof km attribut structuralfeatur inputc structuralfeatur select oclistypeof km attribut select commentsbefor oclisundefin structuralfeatur subclass iter acc sequenc km refer sequenc acc append thismodul composit inputc end rule disaggreg comment lazi rule creat auxiliari class link root element element metadata begin rule composit lazi rule composit inputc km class name string outputref km refer packag inputc packag name ref name lower upper isord fals isuniqu fals owner inputc type subclass iscontain true opposit outputref subclass km class isabstract fals name name locat inputc locat packag inputc packag structuralfeatur inputc structuralfeatur select oclistypeof km attribut select commentsbefor notempti getmetadata label name outputref km refer packag inputc packag name ref inputc name lower upper isord fals isuniqu fals owner subclass type inputc iscontain fals opposit outputref end rule composit,8
34,34,P25-Disaggregation-without.atl,"-- @name		Disaggregation
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		SIMON Eric(simon.eric3<at>gmail.com)
-- @date		2006/07/27
-- @description	This transformation strenghthens or weakens an assertion(respectively postcondition and precondition).
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 2.8, page 23
-- @see author of article : K. Lano

module Disaggregation; -- Module Template
create OUT : KM3 from IN : KM3;

helper context KM3!Attribute def: getMetadata(name : String) : String =
	let comment : String = self.commentsBefore->select(e | e.startsWith('-- @' + name + ' '))->first() in
	if comment.oclIsUndefined() then
		OclUndefined
	else
		comment.substring(6 + name.size(), comment.size())
	endif;

helper context KM3!Class def : getClass : Set(String) =
	KM3!Attribute->allInstances()->select(c|c.commentsBefore->notEmpty())->iterate(a; acc : Set(String) = Set{}| acc->including(a.getMetadata('label')))
	;
--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
-- @end rule Metamodel

-- @begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
-- @end rule Package

-- @begin rule DataType
rule DataType {
	from
		inputData:KM3!DataType
	to
		outputData:KM3!DataType(
			name <- inputData.name,
			location <- inputData.location
		)
}
-- @end rule DataType

--@begin rule EnumLiteral
rule EnumLiteral {
	from
		inputL:KM3!EnumLiteral
	to
		outputL:KM3!EnumLiteral (
			name <- inputL.name,
			location <- inputL.location,
			enum  <- inputL.enum,
			package <- inputL.package
		)
}
--@end rule EnumLiteral

-- @begin rule Class
rule Class {
	from
		inputC:KM3!Class
		(not (inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Attribute))->exists(a|a.commentsBefore->notEmpty())))
	to
		outputC:KM3!Class (
			isAbstract <- inputC.isAbstract,
			supertypes <- inputC.supertypes,
			name <- inputC.name,
			location <- inputC.location,
			package <- inputC.package,
			structuralFeatures <- inputC.structuralFeatures
		)
}
-- @end rule Class

-- @begin rule Attribute
rule Attribute {
	from
		inputAttr : KM3!Attribute
	to
		outputAttr : KM3!Attribute (
			package <- inputAttr.package,
			name <- inputAttr.name,
			lower <- inputAttr.lower,
			upper <- inputAttr.upper,
			isOrdered <- inputAttr.isOrdered,
			isUnique <- inputAttr.isUnique,
			owner <- inputAttr.owner,
			type <- inputAttr.type
		)
}
-- @end rule Attribute

-- @begin rule Disaggregation
rule Disaggregation {
	from
		inputC : KM3!Class
		(inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Attribute))->exists(a|a.commentsBefore->notEmpty()))
	using {
		subClasses : Set(String) = inputC.getClass;		
		}
	to
		outputPrimaryClass : KM3!Class (	
			isAbstract <- inputC.isAbstract,
			supertypes <- inputC.supertypes,
			name <- inputC.name,
			location <- inputC.location,
			package <- inputC.package,
			structuralFeatures <- inputC.structuralFeatures->select(a| not a.oclIsTypeOf(KM3!Attribute)),
			structuralFeatures <- inputC.structuralFeatures->select(a| a.oclIsTypeOf(KM3!Attribute))->select(a|a.commentsBefore->oclIsUndefined()),
			structuralFeatures <- subClasses->iterate(a; acc : Sequence(KM3!Reference)=Sequence{}| acc->append(thisModule.composition(inputC,a)))			
		)
}
-- @end rule Disaggregation

lazy rule composition{
	from
		inputC : KM3!Class,
		Name : String
		
	to
		outputRef1 : KM3!Reference (
			package <- inputC.package,
			name <- 'ref1'+Name,
			lower <- 1,
			upper <- 1,
			isOrdered <- false,
			isUnique <- false,
			owner <- inputC,
			type <- subClass,
			isContainer <- true,
			opposite <- outputRef2
		),
		subClass : KM3!Class (
			isAbstract <- false,
			name <- Name,
			location <- inputC.location,
			package <- inputC.package,
			structuralFeatures <- inputC.structuralFeatures->select(a| a.oclIsTypeOf(KM3!Attribute))->select(a|a.commentsBefore->notEmpty() and a.getMetadata('label') = Name)
		),
		
		outputRef2 : KM3!Reference (
			package <- inputC.package,
			name <- 'ref'+inputC.name,
			lower <- 1,
			upper <- 1,
			isOrdered <- false,
			isUnique <- false,
			owner <- subClass,
			type <- inputC,
			isContainer <- false,
			opposite <- outputRef1
		)
}

",name disaggreg version domain catalogu model transform author simon eric simon eric gmail com date descript this transform strenghthen weaken assert respect postcondit precondit see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul disaggreg modul templat creat out km in km helper context km attribut def getmetadata name string string let comment string self commentsbefor select e e startswith name first comment oclisundefin oclundefin els comment substr name size comment size endif helper context km class def getclass set string km attribut allinst select c c commentsbefor notempti iter acc set string set acc includ getmetadata label begin rule metamodel rule metamodel inputmm km metamodel outputmm km metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km packag name inputpkg name content inputpkg content end rule packag begin rule datatyp rule datatyp inputdata km datatyp outputdata km datatyp name inputdata name locat inputdata locat end rule datatyp begin rule enumliter rule enumliter inputl km enumliter outputl km enumliter name inputl name locat inputl locat enum inputl enum packag inputl packag end rule enumliter begin rule class rule class inputc km class inputc structuralfeatur select r r oclistypeof km attribut exist commentsbefor notempti outputc km class isabstract inputc isabstract supertyp inputc supertyp name inputc name locat inputc locat packag inputc packag structuralfeatur inputc structuralfeatur end rule class begin rule attribut rule attribut inputattr km attribut outputattr km attribut packag inputattr packag name inputattr name lower inputattr lower upper inputattr upper isord inputattr isord isuniqu inputattr isuniqu owner inputattr owner type inputattr type end rule attribut begin rule disaggreg rule disaggreg inputc km class inputc structuralfeatur select r r oclistypeof km attribut exist commentsbefor notempti use subclass set string inputc getclass outputprimaryclass km class isabstract inputc isabstract supertyp inputc supertyp name inputc name locat inputc locat packag inputc packag structuralfeatur inputc structuralfeatur select oclistypeof km attribut structuralfeatur inputc structuralfeatur select oclistypeof km attribut select commentsbefor oclisundefin structuralfeatur subclass iter acc sequenc km refer sequenc acc append thismodul composit inputc end rule disaggreg lazi rule composit inputc km class name string outputref km refer packag inputc packag name ref name lower upper isord fals isuniqu fals owner inputc type subclass iscontain true opposit outputref subclass km class isabstract fals name name locat inputc locat packag inputc packag structuralfeatur inputc structuralfeatur select oclistypeof km attribut select commentsbefor notempti getmetadata label name outputref km refer packag inputc packag name ref inputc name lower upper isord fals isuniqu fals owner subclass type inputc iscontain fals opposit outputref,8
35,35,P26-DSL2KM3.atl,"-- DSL to Ecore
-- second transformation : DSL to KM3

module DSL2KM3;
create OUT : KM3 from IN : DSL;

-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- This helper checks if a relation needs to be turn on a class
-- * if self is pointed by an other relationship
-- * if self has supertypes
-- * if self has subtypes
-- * if self has properties
-- CONTEXT: DSL!Relationship 
-- RETURN:  Boolean
helper context DSL!Relationship def: needTurnOnClass() : Boolean =
	let cond : Boolean =
	DSL!Role.allInstances()->iterate(e; acc : Boolean = false |
		acc or (e.type = self or e.source = self))	
		in (cond or
			(not self.properties.isEmpty()
		or (not self.superType.oclIsUndefined()
		or not self.subTypes.isEmpty())));

-- This helper get the roles pointing on a given class
-- CONTEXT: DSL!Class 
-- RETURN:  Sequence(DSL!Role)
helper def: getRoles(c : DSL!Class) : Sequence(DSL!Role) =
    DSL!Role.allInstances()->select(e | e.source = c 
	   	and e.relation.properties.isEmpty() 
		and e.relation.superType.oclIsUndefined()
		and	e.relation.subTypes.isEmpty());

-- This helper get the containmentstyle of the roles 
-- CONTEXT: DSL!Role	
-- RETURN: Boolean (true for embedding, false for reference) 
helper context DSL!Role def: isEmbedding() : Boolean =
    let a : DSL!Role = self.relation.roles.first()
	in if self = a then a.relation.isEmbedding
	else false endif;

-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'Metamodel'.
-- This rule generates the Metamodel, which will content the following packages :
-- * the package containing the model
-- * the PrimitivesTypes package, which contents string, integer and boolean types
rule Metamodel {
	from 
		e : DSL!DomainModel	
	to
		a : KM3!Metamodel(
			contents <- Sequence{b, c}
		),
		b : KM3!Package (
			name <- e.name,
			contents <-
				Sequence{
					e.classifiers
						->select(a |
							a.oclIsTypeOf(DSL!Class) or
							if a.oclIsTypeOf(DSL!Relationship)
							then
								a.needTurnOnClass()
							else
								false
							endif
						),
					e.types
						->select(a | a.oclIsTypeOf(DSL!Enumeration))
				}
			),
		c : KM3!Package (
			name <- 'PrimitiveTypes',
			contents <- e.types->select(a | a.oclIsTypeOf(DSL!SimpleType))
		)		
}

-- Rule 'Class'.
-- This rule generates a KM3!Class corresponding to a DSL!Class
-- and mark his name if it is the Root class
rule Class {
	from 
		e : DSL!Class
	to
		a : KM3!Class(
			name<-e.name,
			isAbstract <- e.isAbstract,
			structuralFeatures<-Set{
				e.properties -> select (c | c.oclIsTypeOf(DSL!ValueProperty) ),			
				thisModule.getRoles(e)
			},
			supertypes <- Set{e.superType}		
		)
}

-- Rule 'Relation2Class'.
-- This rule generates a KM3!Class from a Relationship
-- if it needs
rule Relation2Class {
	from 
	e : DSL!Relationship(
			e.needTurnOnClass()
		)
	to
	a : KM3!Class(
		name<-e.name,
		isAbstract <- e.isAbstract,
		structuralFeatures<- Set{ 
			e.properties -> select (c | c.oclIsTypeOf(DSL!ValueProperty)),			
			e.roles->first()
		},
		supertypes <- Set{e.superType}
	)
}

-- Rule 'SimpleReference'.
-- This rule generates a Reference in a KM3!Class by copying the features
-- of the corresponding DSL!Role
rule SimpleReference {
	from
		r : DSL!Role(
			not r.relation.needTurnOnClass()
		)
	to
		rf : KM3!Reference (
			name <- r.name,
			type <- r.type,
			lower <- r.min,
			upper <- if r.max=0 then 0-1 else 1 endif,
			isOrdered <- r.isOrdered,
			owner <- r.source,
			isContainer <- r.isEmbedding(),
			opposite <- r.relation.roles->select(e | e <> r)->first(),
			isUnique <- false
		)
}

-- Rule 'ComplexReference'.
-- This rule generates two opposites references which will be the link
-- between the new Relationship and his adjoining Classes
rule ComplexReference {
	from
		r : DSL!Role (
			r.relation.needTurnOnClass()
		)
	using {
		oppositeRole : DSL!Role = r.relation.roles->select(e | e <> r)->first();
	}
	to		
		rfInOwner : KM3!Reference (
			name <- r.name,	
			owner <- r.source,
			type <- r.relation,
			opposite <- rfInRelationship,
			lower <- r.min,
			upper <- if r.max=0 
			then 0-1 else 1 endif,
			isOrdered <- r.isOrdered,
			isContainer <- r.isEmbedding(),
			isUnique <- false
		),
		rfInRelationship : KM3!Reference (
			name <- oppositeRole.name,
			owner <- r.relation,			
			type <- r.source,			
			opposite <- rfInOwner,
			lower <- oppositeRole.min,
			upper <- if oppositeRole.max=0 then 0-1 else 1 endif,
			isOrdered <- oppositeRole.isOrdered,
			isContainer <- oppositeRole.isEmbedding(),
			isUnique <- false
		)
}

-- Rule 'Attribute'.
-- This rule generates a KM3!Attribut, corresponding to a DSL!ValueProperty
rule Attribute {
	from
		e : DSL!ValueProperty
	to
		a : KM3!Attribute(
			name <- e.name,
			upper <- 1,
			lower <-1,
			type <- e.type,
			isUnique <- false,
			isOrdered <- false
		)
}

-- Rule 'Enumeration'.
-- This rule generates the KM3!Enumeration corresponding to a DSL!Enumeration
rule Enumeration {
	from 
		e : DSL!Enumeration
	to
		a : KM3!Enumeration(
				name <- e.name,
				literals <- e.literals -> select(a | a.oclIsTypeOf(DSL!EnumerationLiteral))
		)
}

-- Rule 'EnumLiteral'.
-- This rule generates the KM3!EnumLiteral corresponding to a 
-- DSL!EnumerationLiteral
rule EnumLiteral {
	from 
		e : DSL!EnumerationLiteral
	to
		l : KM3!EnumLiteral (
			name <- e.name
		)
}

-- Rule 'Datatype'.
-- This rule generates the KM3!Datatype corresponding to a DSL!SimpleType
rule DataType {
	from 
	t : DSL!SimpleType
	to
	e: KM3!DataType(name<-t.name)
}
",dsl ecor second transform dsl km modul dsl km creat out km in dsl helper this helper check relat need turn class self point relationship self supertyp self subtyp self properti context dsl relationship return boolean helper context dsl relationship def needturnonclass boolean let cond boolean dsl role allinst iter e acc boolean fals acc e type self e sourc self cond self properti isempti self supertyp oclisundefin self subtyp isempti this helper get role point given class context dsl class return sequenc dsl role helper def getrol c dsl class sequenc dsl role dsl role allinst select e e sourc c e relat properti isempti e relat supertyp oclisundefin e relat subtyp isempti this helper get containmentstyl role context dsl role return boolean true embed fals refer helper context dsl role def isembed boolean let dsl role self relat role first self relat isembed els fals endif rule rule metamodel this rule generat metamodel content follow packag packag contain model primitivestyp packag content string integ boolean type rule metamodel e dsl domainmodel km metamodel content sequenc b c b km packag name e name content sequenc e classifi select oclistypeof dsl class oclistypeof dsl relationship needturnonclass els fals endif e type select oclistypeof dsl enumer c km packag name primitivetyp content e type select oclistypeof dsl simpletyp rule class this rule generat km class correspond dsl class mark name root class rule class e dsl class km class name e name isabstract e isabstract structuralfeatur set e properti select c c oclistypeof dsl valueproperti thismodul getrol e supertyp set e supertyp rule relat class this rule generat km class relationship need rule relat class e dsl relationship e needturnonclass km class name e name isabstract e isabstract structuralfeatur set e properti select c c oclistypeof dsl valueproperti e role first supertyp set e supertyp rule simplerefer this rule generat refer km class copi featur correspond dsl role rule simplerefer r dsl role r relat needturnonclass rf km refer name r name type r type lower r min upper r max els endif isord r isord owner r sourc iscontain r isembed opposit r relat role select e e r first isuniqu fals rule complexrefer this rule generat two opposit refer link new relationship adjoin class rule complexrefer r dsl role r relat needturnonclass use oppositerol dsl role r relat role select e e r first rfinown km refer name r name owner r sourc type r relat opposit rfinrelationship lower r min upper r max els endif isord r isord iscontain r isembed isuniqu fals rfinrelationship km refer name oppositerol name owner r relat type r sourc opposit rfinown lower oppositerol min upper oppositerol max els endif isord oppositerol isord iscontain oppositerol isembed isuniqu fals rule attribut this rule generat km attribut correspond dsl valueproperti rule attribut e dsl valueproperti km attribut name e name upper lower type e type isuniqu fals isord fals rule enumer this rule generat km enumer correspond dsl enumer rule enumer e dsl enumer km enumer name e name liter e liter select oclistypeof dsl enumerationliter rule enumliter this rule generat km enumliter correspond dsl enumerationliter rule enumliter e dsl enumerationliter l km enumliter name e name rule datatyp this rule generat km datatyp correspond dsl simpletyp rule datatyp dsl simpletyp e km datatyp name name,18
36,36,P26-DSL2XML.atl,"-- Ecore to DSL
-- second transformation : DSL to XML

module DSL2XML;
create OUT : XML from IN : DSL;

-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- This helper converts boolean to string
-- CONTEXT: Boolean
-- RETURN: String
helper context Boolean def: bool2string() : String =
	if self then 'true' else 'false' endif;

-- This helper get the containmentstyle of a Relationship
-- CONTEXT: DSL!Relationship
-- RETURN: String
helper context DSL!Relationship def : getContainment() : String =
	if self.isEmbedding then 'embedding' else 'reference' endif;

-- This helper stores an integer value used to assign an ID to each generated
-- Task.
-- CONTEXT: thisModule
-- RETURN:  Integer
helper def: curId : Integer = 0; 

-- This helper computes the value to be assigned to the ID field of a
-- generated Task. 
-- It increments the value stored by the ""curId"" helper and returns its
-- new value as a String.
-- CONTEXT: thisModule
-- RETURN:  String
helper def: makeIdentity() : String =
	let i : Integer = thisModule.refSetValue('curId', thisModule.curId + 1).curId 
in '00000000-0000-0000-0000-'+
	if i<=9 then '00000000000'+i.toString()
	else if i<=99 then '0000000000'+i.toString()
		else if i<=999 then	'000000000'+i.toString()
			else '00000000'+i.toString()
	endif endif endif; 

-- This helper converts identity in id
-- CONTEXT: DSL!NamedElement
-- RETURN:  String
helper context DSL!NamedElement def : makeId() : String = 
	let id : String = self.identity in
		'i'+id.substring(1,8)+'z'+id.substring(10,13)
		+'z'+id.substring(15,18)+'z'+id.substring(20,23)
		+'z'+id.substring(25,id.size());

-- This helper generates an new id
-- CONTEXT: thisModule
-- RETURN:  String
helper def : makeId2() : String = 
	let i : Integer = thisModule.refSetValue('curId', thisModule.curId + 1).curId 
	in 'i00000000z0000z0000z0000z'+
	if i<9 then '00000000000'+i.toString()
	else if i<99 then '0000000000'+i.toString()
		else if i<999 then '000000000'+i.toString()
			else '00000000'+i.toString()
	endif endif endif;

-- This helper searchs if a Class is pointed by another
-- CONTEXT: DSL!Class
-- RETURN:  Boolean
helper context DSL!Class def : isType(): Boolean =
DSL!Relationship.allInstances()->
iterate(r; acc : Boolean = false |
		acc or (r.roles.first().type = self));

-- This helper searchs the Class which need to be marked as ""root"" in CompleteDiagram
-- CONTEXT: thisModule
-- RETURN:  Sequence(DSL!Class)
helper def : getRoots : Sequence(DSL!Class)=
	let r1 : Sequence(DSL!Class) =
	DSL!Class.allInstances()->select(e|e.superType.oclIsUndefined() and not e.isType())
	in
	if not r1.isEmpty()	then r1
		else let r2 : Sequence(DSL!Class) =	
		DSL!Class.allInstances()->select(e|e.superType.oclIsUndefined())
		in 
		if not r2.isEmpty() then r2
			else let r3 : Sequence(DSL!Class) =	
			DSL!Class.allInstances()->select(e|not e.isType())
			in 
			if not r3.isEmpty() then r3
				else DSL!Class.allInstances()->first()
			endif
		endif
	endif;	
	
-- This helper stores a list of treated classes
-- CONTEXT: thisModule
-- RETURN: Sequence(KM3!Class)
helper def: Acc : Sequence(KM3!Class) = thisModule.getRoots;

-- This helper computes the definitionlevel of a treeExpression
-- if the class has ever been treated, its definitionlevel is ""use""
-- elsewhere we put it into Acc, and the definitionlevel is ""definition""
-- CONTEXT: context DSL!Class
-- RETURN: String
helper context DSL!Class def : definitionlevel():String =
	if thisModule.Acc->includes(self)
		then 'use'
		else
			let c : DSL!Class =	thisModule.refSetValue('Acc',thisModule.Acc.append(self)).Acc.first()
			in 'definition'
	endif;


-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'DMD'.
-- This rule generates the .dsldm file structure :
-- DMD
-- 	- Model
--		-	MdfMetaData
--		-	Extended
--		-	Enumerations
-- 		-	Relationships
--		-	Concepts
--		-	Trees
--				-	treeNavigator Intrinsic
--				-	treeNavigator CompleteDiagram
--				-	treeNavigator Serialization
--				-	treeNavigator Delete
rule DMD
{
	 from 
	 	d : DSL!DomainModel
	 to 
	 --------------
	 -- Root DMD --
	 --------------
	 	r : XML!Root(
		 	name<-'dmd',--+thisModule.getRoots.toString(),
			value <- '',
			children<-Sequence{xsi,xsd,xmlns,model}
		 ),
		 
	    xsi : XML!Attribute (name<-'xmlns:xsi',value<-'http://www.w3.org/2001/XMLSchema-instance'),
		xsd : XML!Attribute (name<-'xmlns:xsd',value<-'http://www.w3.org/2001/XMLSchema'),
		xmlns : XML!Attribute (name<-'xmlns',value<-'urn:schemas-microsoft-com:dmd'),

	-----------
	-- Model --
	-----------
		model : XML!Element (
		 	name<-'model',
			value <- '',
			children<-Sequence{
		 		name,identity,id,namespace,isLoaded,		 	
		 		mdfmetadata,
				extended,
				enumerations,
				relationships,trees,concepts
				}
		 ),
		name : XML!Attribute (name<-'name',value<-d.name),
		identity: XML!Attribute (name<-'identity',value<-d.identity),
		id: XML!Attribute (name<-'id',value<-d.makeId()),
		namespace: XML!Attribute (name<-'namespace',value<-d.namespace),
		isLoaded: XML!Attribute (name<-'isLoaded',value<-d.isLoaded.bool2string()),

	-----------------
	-- MdfMetaData --
	-----------------
		mdfmetadata: XML!Element (
			name<-'mdfmetadata',
			value <- '',
			children<-Sequence{
				xsitype,accessmodifier,category,
				description,doccomment,localize,
				majorversion,minorversion,alwaysgeneratecollection,
				copyright,stringtable,copyclosure,removeclosure
				}
		),
		xsitype:XML!Attribute (name<-'xsi:type',value<-'modelmdfmetadata'),
		accessmodifier:XML!Attribute (name<-'accessmodifier',value<-'public'),
		category : XML!Attribute(name <- 'category',value <- ''),
		description : XML!Attribute(name <- 'description',value <- ''),
		doccomment : XML!Attribute(name <- 'doccomment',value <- ''),
		localize:XML!Attribute (name<-'localize',value<-'false'),
		majorversion:XML!Attribute (name<-'majorversion',value<-'1'),
		minorversion:XML!Attribute (name<-'minorversion',value<-'0'),
		alwaysgeneratecollection:XML!Attribute (name<-'alwaysgeneratecollection',value<-'false'),
		copyright : XML!Element(name <- 'copyright',value <- ''),
		
		stringtable : XML!Element(name <- 'stringtable',value <- '',children <- Sequence{resxfile,ressfile,use}),
			resxfile : XML!Attribute (name <- 'resxfile',value <- d.name+'.Resource.resx'),
			ressfile : XML!Attribute (name <- 'resourcesfile',value <- d.namespace+'.'+d.name+'.Resource'),
			use : XML!Attribute (name <- 'usefullyqualifiedname',value <- 'false'),
		
		copyclosure : XML!Element(
			name <- 'copyclosure',value <- '',children <- Sequence{cpname,cpdoc}),
			cpname : XML!Attribute (name <- 'name',value <- d.name+'CopyClosure'),
			cpdoc : XML!Attribute (name <- 'doccomment',value <- 'Copy closure visitor filter'),
		
		removeclosure : XML!Element(name <- 'removeclosure',value <- '',children <- Sequence{rmname,rmdoc}),
			rmname : XML!Attribute (name <- 'name',value <- d.name+'RemoveClosure'),
			rmdoc : XML!Attribute (name <- 'doccomment',value <- 'Remove closure visitor filter'),

	--------------
	-- Extended --
	--------------
		extended: XML!Element (name<-'extended',value <- '',children <- extmod),
		extmod : XML!Element (name <- 'model',value <- '',children <- extmodText),
		extmodText : XML!Text (name <- '#text',value <- 'i2b131234z7959z458dz834fz2dc0769ce683'),
	
	------------------
	-- Enumerations --
	------------------
		enumerations : XML!Element (
			name<-'enumerations',
			value <- '',
			children<-d.types->select(c|c.oclIsTypeOf(DSL!Enumeration))				
		),
		
	-------------------
	-- Relationships --
	-------------------
		relationships : XML!Element (
			name<-'relationships',
			value <- '',
			children<-d.classifiers->select(c|c.oclIsTypeOf(DSL!Relationship))
		),
		
	--------------	
	-- Concepts --
	--------------
		concepts : XML!Element (
			name<-'concepts',
			value <- '',
			children<-d.classifiers->select(c|c.oclIsTypeOf(DSL!Class))		
		),
		
	-----------
	-- Trees --
	-----------
		trees : XML!Element (
			name <- 'trees',
			value <- '',
			children <- Sequence{
				treeNavIntr,treeNavDiagram,
				treeNavSeria,treeNavDel
			}
		),
		
	-----------------------------
	-- treeNavigator Intrinsic --
	-----------------------------
		treeNavIntr : XML!Element (
			name <- 'treenavigator',
			value <- '',
			children <- Sequence{
				treeNavIntrna,treeNavIntrIdentity,
				treeNavIntrId,exp,IntrRoot
			}
		),
		treeNavIntrna : XML!Attribute (name <- 'name',value <- 'intrinsic'),
		treeNavIntrId : XML!Attribute (name <- 'id',value <- thisModule.makeId2()),
		treeNavIntrIdentity : XML!Attribute (name <- 'identity',value <- thisModule.makeIdentity()),
		exp : XML!Element (name <- 'expressions',value <- ''),
		IntrRoot : XML!Element(name <- 'roots',value <- ''),
		
	-----------------------------------
	-- treeNavigator CompleteDiagram --
	-----------------------------------
		treeNavDiagram : XML!Element (
			name <- 'treenavigator',
			value <- '',
			children <- Sequence{
				treeNavDiagType,treeNavDiagna,
				treeNavDiagIdentity,treeNavDiagId,
				Diagexp,DiagRoots,DiagSource
			}
		),
		treeNavDiagType : XML!Attribute (name <- 'xsi:type',value <- 'ShadowTreeNavigator'),
		treeNavDiagna : XML!Attribute (name <- 'name',value <- 'completeDiagram'),
		treeNavDiagId : XML!Attribute (name <- 'id',value <- thisModule.makeId2()),
		treeNavDiagIdentity : XML!Attribute (name <- 'identity',value <- thisModule.makeIdentity()),
		Diagexp : XML!Element (name <- 'expressions',value <- ''),
		DiagRoots : XML!Element (name <- 'roots',value <- ''),
		DiagSource : XML!Element (name <- 'source',value <- '',children <- DiagSourceText),
		DiagSourceText : XML!Text (
			name <- '#text',
			value <- thisModule.resolveTemp(d,'treeNavIntrId').value
		),
		
	---------------------------------
	-- treeNavigator Serialization --
	---------------------------------
		treeNavSeria : XML!Element (
			name <- 'treenavigator',
			value <- '',
			children <- Sequence{
				treeNavSeriaType,treeNavSeriana,
				treeNavSeriaIdentity,treeNavSeriaId,
				Seriaexp,SeriaRoots,SeriaSource
			}
		),
		treeNavSeriaType : XML!Attribute (name <- 'xsi:type',value <- 'ShadowTreeNavigator'),
		treeNavSeriana : XML!Attribute (name <- 'name',value <- 'serialization'),
		treeNavSeriaId : XML!Attribute (name <- 'id',value <- thisModule.makeId2()),
		treeNavSeriaIdentity : XML!Attribute (name <- 'identity',value <- thisModule.makeIdentity()),
		Seriaexp : XML!Element (name <- 'expressions',value <- ''),
		SeriaRoots : XML!Element (name <- 'roots',value <- '',children <- SeriaRoot),
		
		SeriaRoot : XML!Element(
			name <- 'root',
			value <- '',
			children <- Sequence {
				SeriaRootname,SeriaRootidentity,SeriaRootid,
				SeriaRootSource,SeriaRootReferenceType
			}
		),
		SeriaRootname : XML!Attribute (
			name <- 'name',
			value <- thisModule.getRoots->first().name
		),
		SeriaRootidentity : XML!Attribute (name <- 'identity',value <- thisModule.makeIdentity()),
		SeriaRootid : XML!Attribute (name <- 'id',value <- thisModule.makeId2()),
		SeriaRootSource : XML!Element (name <- 'source',value <- ''),
		SeriaRootReferenceType : XML!Element (name <- 'referencetype',value <- '',children <- SeriaRootReferenceTypeText),
		SeriaRootReferenceTypeText : XML!Text (
			name <- '#text',
			value <- thisModule.getRoots->first().makeId()
		),
		SeriaSource : XML!Element (name <- 'source',value <- '',children <- SeriaSourceText),
		SeriaSourceText : XML!Text (
			name <- '#text',
			value <- thisModule.resolveTemp(d,'treeNavIntrId').value
		),

	--------------------------
	-- treeNavigator Delete --
	--------------------------
		treeNavDel : XML!Element (
			name <- 'treenavigator',
			value <- '',
			children <- Sequence {
				treeNavDelType,treeNavDelna,
				treeNavDelIdentity,treeNavDelId,
				Delexp,DelRoots,DelSource
			}
		),
		treeNavDelType : XML!Attribute (name <- 'xsi:type',value <- 'ShadowTreeNavigator'),
		treeNavDelna : XML!Attribute (name <- 'name',value <- 'delete'),
		treeNavDelId : XML!Attribute (name <- 'id',value <- thisModule.makeId2()),
		treeNavDelIdentity : XML!Attribute (name <- 'identity',value <- thisModule.makeIdentity()),
		Delexp : XML!Element (name <- 'expressions',value <- ''),
		DelRoots : XML!Element (name <- 'roots',value <- ''),
		DelSource : XML!Element (name <- 'source',value <- '',children <- DelSourceText),
		DelSourceText : XML!Text (
			name <- '#text',
			value <- thisModule.resolveTemp(d,'treeNavIntrId').value
		)
}

-- Rule 'Concept'.
-- This rule generates the Concepts which are :
-- * not subtypes of any class
-- * not abstract
rule Concept{
	from 
		e:DSL!Class (e.superType.oclIsUndefined() and  not e.isAbstract
			and not (thisModule.getRoots->includes(e)))
	to 
	-------------
	-- Concept --
	-------------
		c:XML!Element(
			name<-'concept',
			value <- '',
			children<-Sequence{
				name,identity,namespace,id,
				isLoaded,isAbstract,
				mdfmetadata,valueProperties
			}
		),
		name:XML!Attribute(name<-'name',value<-e.name),
		identity: XML!Attribute (name<-'identity',value<-e.identity),
		id: XML!Attribute (name<-'id',value<-e.makeId()),
		namespace: XML!Attribute (name<-'namespace',value<-e.namespace),
	
		isLoaded: XML!Attribute (name<-'isLoaded',value<-e.isLoaded.bool2string()),
		isAbstract: XML!Attribute (name<-'isAbstract',value<-'false'),
			
	-----------------
	-- MdfMetaData --
	-----------------
		mdfmetadata: XML!Element (
			name<-'mdfmetadata',
			value <- '',
			children<-Sequence{
				xsitype,accessmodifier,category,description,doccomment,
				localize
			}
		),
		xsitype:XML!Attribute (name<-'xsi:type',value<-'conceptorshapemdfmetadata'),
		accessmodifier:XML!Attribute (name<-'accessmodifier',value<-'public'),
		category : XML!Attribute(name <- 'category',value <- ''),
		description : XML!Attribute(name <- 'description',value <- ''),
		doccomment : XML!Attribute(name <- 'doccomment',value <- ''),
		localize : XML!Attribute (name<-'localize',value<-'false'),

	----------------
	-- Properties --
	----------------
		valueProperties: XML!Element (
			name<-'valueProperties',
			value <- '',
			children<-e.properties->asSet()
		)
}

-- Rule 'ConceptRoot'.
-- This rule generates the Concepts which are:
-- * included into the roots list 
-- * not subtypes of any class
-- * not abstract
rule ConceptRoot{
	from 
		e:DSL!Class (e.superType.oclIsUndefined() and  not e.isAbstract
					and (thisModule.getRoots->includes(e)))
	to 
	-------------
	-- Concept --
	-------------
		c:XML!Element(
			name<-'concept',
			value <- '',
			children<-Sequence{
				name,identity,namespace,id,
				isLoaded,isAbstract,
				mdfmetadata,valueProperties
			}
		),
		name:XML!Attribute(name<-'name',value<-e.name),
		identity: XML!Attribute (name<-'identity',value<-e.identity),
		id: XML!Attribute (name<-'id',value<-e.makeId()),
		namespace: XML!Attribute (name<-'namespace',value<-e.namespace),
	
		isLoaded: XML!Attribute (name<-'isLoaded',value<-e.isLoaded.bool2string()),
		isAbstract: XML!Attribute (name<-'isAbstract',value<-'false'),
			
	-----------------
	-- MdfMetaData --
	-----------------
		mdfmetadata: XML!Element (
			name<-'mdfmetadata',
			value <- '',
			children<-Sequence{
				xsitype,accessmodifier,category,description,doccomment,
				localize
			}
		),
		xsitype:XML!Attribute (name<-'xsi:type',value<-'conceptorshapemdfmetadata'),
		accessmodifier:XML!Attribute (name<-'accessmodifier',value<-'public'),
		category : XML!Attribute(name <- 'category',value <- ''),
		description : XML!Attribute(name <- 'description',value <- ''),
		doccomment : XML!Attribute(name <- 'doccomment',value <- ''),
		localize : XML!Attribute (name<-'localize',value<-'false'),

	----------------
	-- Properties --
	----------------
		valueProperties: XML!Element (
			name<-'valueProperties',
			value <- '',
			children<-e.properties->asSet()
		),
		DiagRoot : XML!Element(
			name <- 'root',
			value <- '',
			parent<-thisModule.resolveTemp(e.domainModel,'DiagRoots'),
			children <- Sequence {
				DiagRootname,DiagRootidentity,DiagRootid,
				DiagRootSource,DiagRootReferenceType
			}
		),
		DiagRootname : XML!Attribute (
			name <- 'name',
			parent<- DiagRoot,
			value <- e.name),
		DiagRootidentity : XML!Attribute (
			name <- 'identity',
			parent<- DiagRoot,
			value <- thisModule.makeIdentity()),
		DiagRootid : XML!Attribute (
			name <- 'id',
			parent<- DiagRoot,
			value <- thisModule.makeId2()),
		DiagRootSource : XML!Element (
			name <- 'source',
			parent<- DiagRoot,
			value <- ''),
		DiagRootReferenceType : XML!Element (
			name <- 'referencetype',
			parent<- DiagRoot,value <- '',
			children <- DiagRootReferenceTypeText),
		DiagRootReferenceTypeText : XML!Text (
			name <- '#text',
			value <- e.makeId()
		)
}

-- Rule 'ConceptRootisAbstract'.
-- This rule generates the Concepts which are :
-- * included into the roots list 
-- * not subtypes of any classes
-- * abstract
rule ConceptRootisAbstract{
	from 
		e:DSL!Class (e.superType.oclIsUndefined() and e.isAbstract
			and (thisModule.getRoots->includes(e)))
	to 
	-------------
	-- Concept --
	-------------
		c:XML!Element(
			name<-'concept',
			value <- '',
			children<-Sequence{
				name,identity,namespace,id,
				isLoaded,isAbstract,
				mdfmetadata,valueProperties
			}
		),
		name:XML!Attribute(name<-'name',value<-e.name),
		identity: XML!Attribute (name<-'identity',value<-e.identity),
		id: XML!Attribute (name<-'id',value<-e.makeId()),
		namespace: XML!Attribute (name<-'namespace',value<-e.namespace),
		isLoaded: XML!Attribute (name<-'isLoaded',value<-e.isLoaded.bool2string()),
		isAbstract: XML!Attribute (name<-'isAbstract',value<-'false'
			),
			
	-----------------
	-- MdfMetaData --
	-----------------
		mdfmetadata: XML!Element (
			name<-'mdfmetadata',
			value <- '',
			children<-Sequence{
				xsitype,accessmodifier,category,description,doccomment,
				localize,
				classmodifier
			}
		),
		xsitype:XML!Attribute (name<-'xsi:type',value<-'conceptorshapemdfmetadata'),
		accessmodifier:XML!Attribute (name<-'accessmodifier',value<-'public'),
		category : XML!Attribute(name <- 'category',value <- ''),
		description : XML!Attribute(name <- 'description',value <- ''),
		doccomment : XML!Attribute(name <- 'doccomment',value <- ''),
		localize : XML!Attribute (name<-'localize',value<-'false'),
		classmodifier : XML!Attribute (
			name<-'classmodifier',
			value<-if e.isAbstract then 'abstract' else 'none' endif),

	----------------
	-- Properties --
	----------------
		valueProperties: XML!Element (
			name<-'valueProperties',
			value <- '',
			children<-e.properties->asSet()
		),
		
		DiagRoot : XML!Element(
			name <- 'root',
			value <- '',
			parent<-thisModule.resolveTemp(e.domainModel,'DiagRoots'),
			children <- Sequence {
				DiagRootname,DiagRootidentity,DiagRootid,
				DiagRootSource,DiagRootReferenceType
			}
		),
		DiagRootname : XML!Attribute (
			name <- 'name',
			parent<- DiagRoot,
			value <- e.name),
		DiagRootidentity : XML!Attribute (
			name <- 'identity',
			parent<- DiagRoot,
			value <- thisModule.makeIdentity()),
		DiagRootid : XML!Attribute (
			name <- 'id',
			parent<- DiagRoot,
			value <- thisModule.makeId2()),
		DiagRootSource : XML!Element (
			name <- 'source',
			parent<- DiagRoot,
			value <- ''),
		DiagRootReferenceType : XML!Element (
			name <- 'referencetype',
			parent<- DiagRoot,value <- '',
			children <- DiagRootReferenceTypeText),
		DiagRootReferenceTypeText : XML!Text (
			name <- '#text',
			value <- e.makeId()
		)
}

-- Rule 'Concept'.
-- This rule generates the Concepts which are :
-- * subtypes of some classes
-- * not abstract
rule ConceptHasSuper{
	from 
		e:DSL!Class (not e.superType.oclIsUndefined() and  not e.isAbstract
			and not (thisModule.getRoots->includes(e)))
	to 
	-------------
	-- Concept --
	-------------
		c:XML!Element(
			name<-'concept',
			value <- '',
			children<-Sequence{
				name,identity,namespace,id,
				isLoaded,isAbstract,mdfmetadata,
				superType,valueProperties
				}
		),
		
		name:XML!Attribute(name<-'name',value<-e.name),		
		identity: XML!Attribute (name<-'identity',value<-e.identity),	
		namespace: XML!Attribute (name<-'namespace',value<-e.namespace),		
		id: XML!Attribute (name<-'id',value<-e.makeId()),		
		isLoaded: XML!Attribute (name<-'isLoaded',value<-e.isLoaded.bool2string()),		
		isAbstract: XML!Attribute (name<-'isAbstract',value<-'false'),
		
	-----------------
	-- MdfMetaData --
	-----------------
		mdfmetadata: XML!Element (
			name<-'mdfmetadata',
			value <- '',
			children<-Sequence{
				xsitype,accessmodifier,category,description,doccomment,
				localize
				}
		),
		
		xsitype:XML!Attribute (name<-'xsi:type',value<-'conceptorshapemdfmetadata'),	
		accessmodifier:XML!Attribute (name<-'accessmodifier',value<-'public'),		
		category : XML!Attribute(name <- 'category',value <- ''),		
		description : XML!Attribute(name <- 'description',value <- ''),		
		doccomment : XML!Attribute(name <- 'doccomment',value <- ''),		
		localize:XML!Attribute (name<-'localize',value<-'false'),
				
		superType : XML!Element (name <- 'superType',children <- superTypeText),		
		superTypeText : XML!Text (name <- '#text',value <- e.superType.makeId()),
	
	----------------
	-- Properties --
	----------------
		valueProperties: XML!Element (
			name<-'valueProperties',
			value <- '',
			children<-e.properties->asSet()
		),
		
	---------------------------
	-- inheritanceExpression --
	--------------------------- 
		treeHerite : XML!Element (
			name <- 'treeExpression',
			value <- '',
			parent <- thisModule.resolveTemp(e.domainModel,'exp'),
			children <- Sequence{
				treeHXsiType,treeHName,treeHIdentity,
				treeHId,treeHDef,source,super,sub
			}
		),
		treeHXsiType : XML!Attribute (name <- 'xsi:type',value <- 'InheritanceExpression'),
		treeHName : XML!Attribute(name <- 'name',value <- e.name+'-'+e.superType.name),
		treeHIdentity : XML!Attribute(name <- 'identity',value <- thisModule.makeIdentity()),
		treeHId : XML!Attribute(name <- 'id',value <- thisModule.makeId2()),
		treeHDef : XML!Attribute(name <- 'definitionlevel',value <- 'none'),
		source : XML!Element (name <- 'source',value <- ''),
		super : XML!Element (name <- 'superType',value <- '',children <- superText),
		superText : XML!Text(name<-'#text',value <- e.superType.makeId()),
		sub : XML!Element (name <- 'subType',value <- '',children <- subText),
		subText : XML!Text (name<-'#text',value<-e.makeId()),
		
	----------------------------------
	-- Inheritance Complete Diagram --
	----------------------------------
		DiagtreeExp : XML!Element (
			name <- 'treeExpression',
			value <- '',
			parent <- thisModule.resolveTemp(e.domainModel,'Diagexp'),
			children <- Sequence{
				treeHCDXsiType,treeHCDName,treeHCDIdentity,
				treeHCDid,treeHCDDef,sourceHCD,superCD,subCD
			}
		),
		treeHCDXsiType : XML!Attribute (name <- 'xsi:type',value <- 'InheritanceExpression'),
		treeHCDName : XML!Attribute(name <- 'name',value <- e.name+'-'+e.superType.name),
		treeHCDIdentity : XML!Attribute(name <- 'identity',value <- thisModule.makeIdentity()),
		treeHCDid : XML!Attribute(name <- 'id',value <- thisModule.makeId2()),
		---------------------------------------------------------------------------------------------------------------	
		treeHCDDef : XML!Attribute(name <- 'definitionlevel',value <- e.definitionlevel()),
		sourceHCD : XML!Element (name <- 'source',value <- '',children <- sourceHCDText),
		sourceHCDText : XML!Text (name<-'#text',value <-thisModule.resolveTemp(e,'treeHId').value),
		superCD : XML!Element (name <- 'superType',value <- '',children <- superTextCD),
		superTextCD : XML!Text(name<-'#text',value <- e.superType.makeId()),
		subCD : XML!Element (name <- 'subType',value <- '',children <- subTextCD),
		subTextCD : XML!Text (name<-'#text',value<-e.makeId())
}

-- Rule 'Concept'.
-- This rule generates the Concepts which are :
-- * not subtypes of any classes
-- * abstract
rule ConceptisAbstract{
	from 
		e:DSL!Class (e.superType.oclIsUndefined() and e.isAbstract
			and not (thisModule.getRoots->includes(e)))
	to 
	-------------
	-- Concept --
	-------------
		c:XML!Element(
			name<-'concept',
			value <- '',
			children<-Sequence{
				name,identity,namespace,id,
				isLoaded,isAbstract,
				mdfmetadata,valueProperties
			}
		),
		name:XML!Attribute(name<-'name',value<-e.name),
		identity: XML!Attribute (name<-'identity',value<-e.identity),
		id: XML!Attribute (name<-'id',value<-e.makeId()),
		namespace: XML!Attribute (name<-'namespace',value<-e.namespace),
		isLoaded: XML!Attribute (name<-'isLoaded',value<-e.isLoaded.bool2string()),
		isAbstract: XML!Attribute (name<-'isAbstract',value<-'false'
			),
			
	-----------------
	-- MdfMetaData --
	-----------------
		mdfmetadata: XML!Element (
			name<-'mdfmetadata',
			value <- '',
			children<-Sequence{
				xsitype,accessmodifier,category,description,doccomment,
				localize,
				classmodifier
			}
		),
		xsitype:XML!Attribute (name<-'xsi:type',value<-'conceptorshapemdfmetadata'),
		accessmodifier:XML!Attribute (name<-'accessmodifier',value<-'public'),
		category : XML!Attribute(name <- 'category',value <- ''),
		description : XML!Attribute(name <- 'description',value <- ''),
		doccomment : XML!Attribute(name <- 'doccomment',value <- ''),
		localize : XML!Attribute (name<-'localize',value<-'false'),
		
		classmodifier : XML!Attribute (
			name<-'classmodifier',
			value<-if e.isAbstract then 'abstract' else 'none' endif),

	----------------
	-- Properties --
	----------------
		valueProperties: XML!Element (
			name<-'valueProperties',
			value <- '',
			children<-e.properties->asSet()
		)
}

-- Rule 'Concept'.
-- This rule generates the Concepts which are :
-- * subtypes of some classes
-- * abstract
rule ConceptHasSuperAndisAbstract{
	from 
		e:DSL!Class (not e.superType.oclIsUndefined() and e.isAbstract
			and not (thisModule.getRoots->includes(e))) 
	to 
	-------------
	-- Concept --
	-------------
		c:XML!Element(
			name<-'concept',
			value <- '',
			children<-Sequence{
				name,identity,namespace,id,
				isLoaded,isAbstract,mdfmetadata,
				superType,valueProperties
				}
		),
		
		name:XML!Attribute(name<-'name',value<-e.name),		
		identity: XML!Attribute (name<-'identity',value<-e.identity),	
		namespace: XML!Attribute (name<-'namespace',value<-e.namespace),		
		id: XML!Attribute (name<-'id',value<-e.makeId()),		
		isLoaded: XML!Attribute (name<-'isLoaded',value<-e.isLoaded.bool2string()),		
		isAbstract: XML!Attribute (name<-'isAbstract',value<-'false'),
		
		-----------------
		-- MdfMetaData --
		-----------------
		mdfmetadata: XML!Element (
			name<-'mdfmetadata',
			value <- '',
			children<-Sequence{
				xsitype,accessmodifier,category,description,doccomment,
				localize,
				classmodifier
				}
		),
		
		xsitype:XML!Attribute (name<-'xsi:type',value<-'conceptorshapemdfmetadata'),	
		accessmodifier:XML!Attribute (name<-'accessmodifier',value<-'public'),		
		category : XML!Attribute(name <- 'category',value <- ''),		
		description : XML!Attribute(name <- 'description',value <- ''),		
		doccomment : XML!Attribute(name <- 'doccomment',value <- ''),		
		localize:XML!Attribute (name<-'localize',value<-'false'),
		classmodifier : XML!Attribute (
			name<-'classmodifier',
			value<-if e.isAbstract then 'abstract' else 'none' endif),
		
		
		superType : XML!Element (name <- 'superType',children <- superTypeText),		
		superTypeText : XML!Text (name <- '#text',value <- e.superType.makeId()),
	
	----------------			
	-- Properties --
	----------------
		valueProperties: XML!Element (
			name<-'valueProperties',
			value <- '',
			children<-e.properties->asSet()
		),
		
	---------------------------
	-- inheritanceExpression --
	--------------------------- 
		treeHerite : XML!Element (
			name <- 'treeExpression',
			value <- '',
			parent <- thisModule.resolveTemp(e.domainModel,'exp'),
			children <- Sequence{
				treeHXsiType,treeHName,treeHIdentity,
				treeHId,treeHDef,source,super,sub
			}
		),
		treeHXsiType : XML!Attribute (name <- 'xsi:type',value <- 'InheritanceExpression'),
		treeHName : XML!Attribute(name <- 'name',value <- e.name+'-'+e.superType.name),
		treeHIdentity : XML!Attribute(name <- 'identity',value <- thisModule.makeIdentity()),
		treeHId : XML!Attribute(name <- 'id',value <- thisModule.makeId2()),
		treeHDef : XML!Attribute(name <- 'definitionlevel',value <- 'none'),
		source : XML!Element (name <- 'source',value <- ''),
		super : XML!Element (name <- 'superType',value <- '',children <- superText),
		superText : XML!Text(name<-'#text',value <- e.superType.makeId()),
		sub : XML!Element (name <- 'subType',value <- '',children <- subText),
		subText : XML!Text (name<-'#text',value<-e.makeId()),
		
	----------------------------------
	-- Inheritance Complete Diagram --
	----------------------------------
		DiagtreeExp : XML!Element (
			name <- 'treeExpression',
			value <- '',
			parent <- thisModule.resolveTemp(e.domainModel,'Diagexp'),
			children <- Sequence{
				treeHCDXsiType,treeHCDName,treeHCDIdentity,
				treeHCDid,treeHCDDef,sourceHCD,superCD,subCD
			}
		),
		treeHCDXsiType : XML!Attribute (name <- 'xsi:type',value <- 'InheritanceExpression'),
		treeHCDName : XML!Attribute(name <- 'name',value <- e.name+'-'+e.superType.name),
		treeHCDIdentity : XML!Attribute(name <- 'identity',value <- thisModule.makeIdentity()),
		treeHCDid : XML!Attribute(name <- 'id',value <- thisModule.makeId2()),
		------------------------------------------------------------------------------------------------------------
		treeHCDDef : XML!Attribute(name <- 'definitionlevel',value <-e.definitionlevel() ),	
		sourceHCD : XML!Element (name <- 'source',value <- '',children <- sourceHCDText),
		sourceHCDText : XML!Text (name<-'#text',value <-thisModule.resolveTemp(e,'treeHId').value),
		superCD : XML!Element (name <- 'superType',value <- '',children <- superTextCD),
		superTextCD : XML!Text(name<-'#text',value <- e.superType.makeId()),
		subCD : XML!Element (name <- 'subType',value <- '',children <- subTextCD),
		subTextCD : XML!Text (name<-'#text',value<-e.makeId())
}

-- Rule 'Relationship'.
-- This rule generates the Relationships which are not subtypes of any classes
rule Relationship{
	from 
		e:DSL!Relationship(
			e.superType.oclIsUndefined()
		)
	to 
	------------------
	-- Relationship --
	------------------
		r : XML!Element(
			name<-'relationship',
			value <- '',
			children<-Sequence{
				name,identity,namespace,id,
				isLoaded,isAbstract,mdfmetadata,
				roles,valueProperties
			}	
		),
		name:XML!Attribute(name<-'name',value<-e.name),
		identity: XML!Attribute (name<-'identity',value<-e.identity),
		id: XML!Attribute (name<-'id',value<-e.makeId()),
		namespace: XML!Attribute (name<-'namespace',value<-e.namespace),
		isLoaded: XML!Attribute (name<-'isLoaded',value<-e.isLoaded.bool2string()),
		isAbstract: XML!Attribute (name<-'isAbstract',value<-'false'),
		
		-----------------
		-- MdfMetaData --
		-----------------
		mdfmetadata: XML!Element (
			name<-'mdfmetadata',
			value <- '',
			children<-Sequence{
				xsitype,accessmodifier,category,
				description,doccomment,localize				
			}
		),
		xsitype:XML!Attribute (name<-'xsi:type',value<-'mdfclassmetadata'),
		accessmodifier:XML!Attribute (name<-'accessmodifier',value<-'public'),
		localize:XML!Attribute (name<-'localize',value<-'false'),
		category:XML!Attribute (name<-'category',value <- ''),
		description:XML!Attribute (name<-'description',value <- ''),
		doccomment:XML!Attribute (name<-'doccomment',value <- ''),
		
	-----------
	-- Roles --
	-----------
		roles:XML!Element(
			name<-'roles',
			value <- '',
			children<-e.roles->asSequence()
		),
		
	----------------
	-- Properties --
	----------------
		valueProperties: XML!Element (
			name<-'valueProperties',
			value <- '',
			children<-e.properties->asSequence()
		),
		
	--------------------
	-- RoleExpression --
	--------------------
		treeExp : XML!Element (
			name <- 'treeExpression',
			value <- '',
			parent <- thisModule.resolveTemp(e.domainModel,'exp'),
			children <- Sequence{
				reXsiType,reName,reIdentity,
				reId,reDef,reContainment,source,role
			}
		),
		reXsiType : XML!Attribute(name <- 'xsi:type',value <- 'RoleExpression'),
		reName : XML!Attribute(name <- 'name',value <- 'RoleExpression'+e.name),
		reIdentity : XML!Attribute(name <- 'identity',value <- thisModule.makeIdentity()),
		reId : XML!Attribute(name <- 'id',value <- thisModule.makeId2()),
		reDef : XML!Attribute(name <- 'definitionlevel',value <- 'none'),
		reContainment : XML!Attribute(
			name <- 'containmentstyle',
			value <- e.getContainment()
		),
		source : XML!Element (name <- 'source',value <- ''),
		role : XML!Element (name <- 'role',value <- '',children <- roleText),
		roleText : XML!Text(
			name<-'#text',
			value <- e.roles->first().makeId()
		),
		
	---------------------------------------
	-- Role Expression : completeDiagram --
	---------------------------------------
		DiagtreeExp : XML!Element (
			name <- 'treeExpression',
			value <- '',
			parent <- thisModule.resolveTemp(e.domainModel,'Diagexp'),
			children <- Sequence{
				reCDXsiType,reCDName,DiagreIdentity,
				DiagreId,DiagreDef,DiagreContainment,Diagsource,Diagrole
			}
		),
		reCDXsiType : XML!Attribute(name <- 'xsi:type',value <- 'RoleExpression'),
		reCDName : XML!Attribute(name <- 'name',value <- 'RoleExpression'+e.name),
		DiagreIdentity : XML!Attribute(name <- 'identity',value <- thisModule.makeIdentity()),
		DiagreId : XML!Attribute(name <- 'id',value <- thisModule.makeId2()),
		--------------------------------------------------------------------------------------------------------
		DiagreDef : XML!Attribute(name <- 'definitionlevel',value <- e.roles->first().type.definitionlevel()),
		DiagreContainment : XML!Attribute(name <- 'containmentstyle',value <- 'fromsource'),
		Diagsource : XML!Element (name <- 'source',value <- '',children <- sourceText),
		sourceText : XML!Text(
			name<-'#text',
			value <- thisModule.resolveTemp(e,'reId').value
		),
		Diagrole : XML!Element (
			name <- 'role',
			value <- '',
			children <- DiagroleText
		),
		DiagroleText : XML!Text(
			name<-'#text',
			value <- e.roles->first().makeId()
		)
}

-- Rule 'Relationship'.
-- This rule generates the Relationships which are subtypes of some classes
rule RelationshipHasSuper {
	from 
		e:DSL!Relationship(
			not e.superType.oclIsUndefined()
		)
	to 
	------------------
	-- Relationship --
	------------------
		r : XML!Element(
			name<-'relationship',
			value <- '',
			children<-Sequence{
				name,identity,namespace,id,
				isLoaded,isAbstract,mdfmetadata,
				roles,valueProperties
			}	
		),
		name:XML!Attribute(name<-'name',value<-e.name),
		identity: XML!Attribute (name<-'identity',value<-e.identity),
		id: XML!Attribute (name<-'id',value<-e.makeId()),
		namespace: XML!Attribute (name<-'namespace',value<-e.namespace),
		isLoaded: XML!Attribute (name<-'isLoaded',value<-e.isLoaded.bool2string()),
		isAbstract: XML!Attribute (name<-'isAbstract',value<-'false'),
		
		-----------------
		-- MdfMetaData --
		-----------------
		mdfmetadata: XML!Element (
			name<-'mdfmetadata',
			value <- '',
			children<-Sequence{
				xsitype,accessmodifier,category,
				description,doccomment,localize				
			}
		),
		xsitype:XML!Attribute (name<-'xsi:type',value<-'mdfclassmetadata'),
		accessmodifier:XML!Attribute (name<-'accessmodifier',value<-'public'),
		localize:XML!Attribute (name<-'localize',value<-'false'),
		category:XML!Attribute (name<-'category',value <- ''),
		description:XML!Attribute (name<-'description',value <- ''),
		doccomment:XML!Attribute (name<-'doccomment',value <- ''),

	-----------
	-- Roles --
	-----------
		roles:XML!Element(
			name<-'roles',
			value <- '',
			children<-e.roles->asSequence()
		),
		
	----------------
	-- Properties --
	----------------
		valueProperties: XML!Element (
			name<-'valueProperties',
			value <- '',
			children<-e.properties->asSequence()
		),
		
	--------------------
	-- RoleExpression --
	--------------------
		treeExp : XML!Element (
			name <- 'treeExpression',
			value <- '',
			parent <- thisModule.resolveTemp(e.domainModel,'exp'),
			children <- Sequence{
				reXsiType,reName,reIdentity,
				reId,reDef,reContainment,source,role
			}
		),
		reXsiType : XML!Attribute(name <- 'xsi:type',value <- 'RoleExpression'),
		reName : XML!Attribute(name <- 'name',value <- 'RoleExpression'+e.name),
		reIdentity : XML!Attribute(name <- 'identity',value <- thisModule.makeIdentity()),
		reId : XML!Attribute(name <- 'id',value <- thisModule.makeId2()),
		reDef : XML!Attribute(name <- 'definitionlevel',value <- 'none'),
		reContainment : XML!Attribute(
			name <- 'containmentstyle',	
			value <- e.getContainment()
		),
		source : XML!Element (name <- 'source',value <- ''),
		role : XML!Element (name <- 'role',value <- '',children <- roleText),
			roleText : XML!Text(name<-'#text',value <- e.roles->first().makeId()),

	---------------------------------------
	-- Role Expression : completeDiagram --
	---------------------------------------
		DiagtreeExp : XML!Element (
			name <- 'treeExpression',
			value <- '',
			parent <- thisModule.resolveTemp(e.domainModel,'Diagexp'),
			children <- Sequence{
				reCDXsiType,reCDName,DiagreIdentity,
				DiagreId,DiagreDef,DiagreContainment,Diagsource,Diagrole
			}
		),
		reCDXsiType : XML!Attribute(name <- 'xsi:type',value <- 'RoleExpression'),
		reCDName : XML!Attribute(name <- 'name',value <- 'RoleExpression'+e.name),
		DiagreIdentity : XML!Attribute(name <- 'identity',value <- thisModule.makeIdentity()),
		DiagreId : XML!Attribute(name <- 'id',value <- thisModule.makeId2()),
		--------------------------------------------------------------------------------------------------------
		DiagreDef : XML!Attribute(name <- 'definitionlevel',value <- e.roles.first().type.definitionlevel()),
		DiagreContainment : XML!Attribute(name <- 'containmentstyle',value <- 'fromsource'),
		Diagsource : XML!Element (name <- 'source',value <- '',children <- sourceText),
		sourceText : XML!Text(name<-'#text',value <- thisModule.resolveTemp(e,'reId').value),
		Diagrole : XML!Element (name <- 'role',value <- '',children <- DiagroleText),
		DiagroleText : XML!Text(name<-'#text',value <- e.roles->first().makeId()),	
	
	---------------------------
	-- inheritanceExpression --
	---------------------------
		treeHerite : XML!Element (
			name <- 'treeExpression',
			value <- '',
			parent <- thisModule.resolveTemp(e.domainModel,'exp'),
			children <- Sequence{
				treeHXsiType,treeHName,treeHIdentity,
				treeHId,treeHDef,treeHsource,super,sub
			}
		),
		treeHXsiType : XML!Attribute (name <- 'xsi:type',value <- 'InheritanceExpression'),
		treeHName : XML!Attribute(name <- 'name',value <- e.name+'-'+e.superType.name),
		treeHIdentity : XML!Attribute(name <- 'identity',value <- thisModule.makeIdentity()),
		treeHId : XML!Attribute(name <- 'id',value <- thisModule.makeId2()),
		treeHDef : XML!Attribute(name <- 'definitionlevel',value <- 'none'),
		treeHsource : XML!Element (name <- 'source',value <- ''),
		super : XML!Element (name <- 'superType',value <- '',children <- superText),
		superText : XML!Text(name<-'#text',value <- e.superType.makeId()),
		sub : XML!Element (name <- 'subType',value <- '',children <- subText),
		subText : XML!Text (name<-'#text',value<-e.makeId()),
	
	----------------------------------
	-- Inheritance Complete Diagram --
	----------------------------------
		DiagtreeExp : XML!Element (
			name <- 'treeExpression',
			value <- '',
			parent <- thisModule.resolveTemp(e.domainModel,'Diagexp'),
			children <- Sequence{
				treeHXsiType,treeHName,treeHCDIdentity,
				treeHCDid,treeHCDDef,sourceHCD,superCD,subCD
			}
		),
		treeHCDIdentity : XML!Attribute(name <- 'identity',	value <- thisModule.makeIdentity()),
		treeHCDid : XML!Attribute(name <- 'id',value <- thisModule.makeId2()),
	    --------------------------------------------------------------------------------------------------------
		treeHCDDef : XML!Attribute(name <- 'definitionlevel',value <- e.definitionlevel()),
		sourceHCD : XML!Element (name <- 'source',value <- '',children <- sourceHCDText),
			sourceHCDText : XML!Text (name<-'#text',value <- thisModule.resolveTemp(e,'treeHId').value),
		superCD : XML!Element (name <- 'superType',value <- '',children <- superTextCD),
			superTextCD : XML!Text(name<-'#text',value <- e.superType.makeId()),
		subCD : XML!Element (name <- 'subType',value <- '',children <- subTextCD),
			subTextCD : XML!Text (name<-'#text',value<-e.makeId())
}

-- Rule 'Role'.
-- This rule generates the Roles of a Relationship
rule Role{
	from 
		e : DSL!Role
	to 
	----------
	-- Role --
	----------
		r : XML!Element(
			name<-'role',
			value <- '',
			children<-Sequence{
				name,identity,id,min,max,
				isUnbounded,accepts,mdfmetadata,
				source,type,genProp
			}
		),
		name:XML!Attribute(name<-'name',value<-e.name),
		identity: XML!Attribute (name<-'identity',value<-e.identity),
		id: XML!Attribute (name<-'id',value<-e.makeId()),
		min: XML!Attribute (name<-'min',value<-e.min.toString()),
		max: XML!Attribute (name<-'max',value<-e.max.toString()),
		isUnbounded : XML!Attribute(name <- 'isUnbounded',value <- e.isUnbounded.bool2string()),
		accepts: XML!Attribute (name<-'accepts',value<-e.accepts),
		
		-----------------
		-- MdfMetaData --
		-----------------
		mdfmetadata: XML!Element (
			name<-'mdfmetadata',
			value <- '',
			children<-Sequence{
				xsitype,accessmodifier,category,
				description,doccomment,localize,
				isordered,isnavigable
			}
		),
		xsitype:XML!Attribute (name<-'xsi:type',value<-'rolemdfmetadata'),
		accessmodifier:XML!Attribute (name<-'accessmodifier',value<-'public'),
		category:XML!Attribute (name <- 'category',value <- ''),
		description:XML!Attribute (name <- 'description',value <- ''),
		doccomment:XML!Attribute (name <- 'doccomment',value <- ''),
		localize:XML!Attribute (name<-'localize',value<-'false'),
		isordered:XML!Attribute (name<-'isordered',value<-e.isOrdered.bool2string()),
		isnavigable : XML!Attribute (name <- 'isnavigablefrom',value <- e.isNavigableFrom.bool2string()),
		
	------------
	-- Source --
	------------
		source : XML!Element(name<-'source',value <- '',children<-ts),
			ts : XML!Text(name<-'#text',value<-e.source.makeId()),
			
	----------
	-- Type --
	----------
		type : XML!Element(name<-'type',value <- '',children<-tt),		
			tt : XML!Text(name<-'#text',value<-e.type.makeId()),
			
	-----------------------
	-- GeneratedProperty --
	-----------------------
		genProp : XML!Element (
			name <- 'generatedProperty',
			value <- '',
			children <- Sequence{genName,genIdentity,genRefType}
		),
		genName : XML!Attribute(name <- 'name',value <- e.name),
		genIdentity : XML!Attribute(name <- 'identity',value <- thisModule.makeIdentity()),
		genRefType : XML!Element(name <- 'referenceType',value <- '',children <- refText),
		refText : XML!Text (name <- '#text',value <- e.type.makeId())
}

-- Rule 'SimpleProperty'.
-- This rule generates the Properties of simples types
rule SimpleProperty {
	from 
		e : DSL!ValueProperty (e.type.oclIsTypeOf(DSL!SimpleType))
	to
	--------------
	-- Property --
	--------------
		v : XML!Element(
			name<-'property',
			value <- '',
			children<-Sequence{name,identity,id,mdfmetadata,propertyInfo}
		),
		name : XML!Attribute(name<-'name',value<-e.name),
		identity : XML!Attribute(name<-'identity',value<-e.identity),
		id : XML!Attribute(name<-'id',value<-e.makeId()),
		-----------------
		-- MdfMetaData --
		-----------------
		mdfmetadata: XML!Element (
			name<-'mdfmetadata',
			value <- '',
			children<-Sequence{
				xsitype,accessmodifier,category,
				description,doccomment,localize,
				xpathexpression,reversexpathexpression,
				realattributename,proxyattributename,
				customstorage,allownulls,readwritestate,tag 
			}
		),
		xsitype:XML!Attribute (name<-'xsi:type',value<-'propertymdfmetadata'
		),
		accessmodifier:XML!Attribute (name<-'accessmodifier',value<-'public'),
		category:XML!Attribute (name<-'category',value <- ''),
		description:XML!Attribute (name<-'description',value <- ''),
		doccomment:XML!Attribute (name<-'doccomment',value <- ''),		
		localize:XML!Attribute (name<-'localize',value<-'false'),
		xpathexpression:XML!Attribute (name<-'xpathexpression',value <- ''),
		reversexpathexpression:XML!Attribute (name<-'reversexpathexpression',value <- ''),
		realattributename:XML!Attribute (name<-'realattributename',value <- ''),
		proxyattributename:XML!Attribute (name<-'proxyattributename',value <- ''),
		customstorage:XML!Attribute (name<-'customstorage',value<-'false'),
		allownulls:XML!Attribute (name<-'allownulls',value<-'false'),
		readwritestate:XML!Attribute (name<-'readwritestate',value<-'readwrite'),
		tag:XML!Attribute (name<-'tag',value <- ''),
		
	------------------
	-- PropertyInfo --
	------------------
		propertyInfo: XML!Element (
			name<-'propertyInfo',
			value <- '',
			children<-Sequence{xsitypePI,namePI,identityPI,default,max,min}
		),
		xsitypePI:XML!Attribute (name<-'xsi:type',value<- e.type.name+'PropertyInfo'),
		namePI : XML!Attribute(name<-'name',value <- ''),
		identityPI : XML!Attribute(name<-'identity',value<-thisModule.makeIdentity()),
		default : XML!Attribute(
			name<-'default',
			value <- if e.type.name='String' then ''
					else '0' endif
		),
		max : XML!Attribute(
			name<-'max',
			value <- if e.type.name<>'Double'
					 then '2147483647'
					 else '1.79769313486232E+307'
					 endif),
		min : XML!Attribute(name<-'min',
			value <- if e.type.name<>'Double'
					 then '-2147483647'
					 else '0'
					 endif),
		
	-----------------------------
	-- ValuePropertyExpression --
	-----------------------------
		ValuetreeExp : XML!Element (
			name <- 'treeExpression',
			value <- '',
			children <- Sequence{
				reXsiType,reName,ValuereIdentity,
				ValuereId,Valuesource,property
			},
			parent <- thisModule.resolveTemp(e.owner.domainModel,'Diagexp')
		),
		
		reXsiType : XML!Attribute(name <- 'xsi:type',value <- 'ValuePropertyExpression'),
		reName : XML!Attribute(name <- 'name',value <- e.name),
		ValuereIdentity : XML!Attribute(name <- 'identity',value <- thisModule.makeIdentity()),
		ValuereId : XML!Attribute(name <- 'id',value <- thisModule.makeId2()),
		Valuesource : XML!Element (name <- 'source',value <- ''),
		property : XML!Element (name <- 'property',value <- '',children <- propertyText),
		propertyText : XML!Text(name<-'#text',value <- e.makeId())
}

-- Rule 'EnumerationProperty'.
-- This rule generates the Properties which type is an Enumeration
rule EnumerationProperty {
	from 
		e : DSL!ValueProperty (not e.type.oclIsTypeOf(DSL!SimpleType))
	to
	--------------
	-- Property --
	--------------
		v : XML!Element(
			name<-'property',
			value <- '',
			children<-Sequence{name,identity,id,mdfmetadata,propertyInfo}
		),
		name : XML!Attribute(name<-'name',value<-e.name),
		identity : XML!Attribute(name<-'identity',value<-e.identity),
		id : XML!Attribute(name<-'id',value<-e.makeId()),
		-----------------
		-- MdfMetaData --
		-----------------
		mdfmetadata: XML!Element (
			name<-'mdfmetadata',
			value <- '',
			children<-Sequence{
				xsitype,accessmodifier,category,
				description,doccomment,localize,
				xpathexpression,reversexpathexpression,
				realattributename,proxyattributename,
				customstorage,allownulls,readwritestate,tag 
			}
		),
		xsitype:XML!Attribute (name<-'xsi:type',value<-'propertymdfmetadata'),
		accessmodifier:XML!Attribute (name<-'accessmodifier',value<-'public'),
		category:XML!Attribute (name<-'category',value <- ''),
		description:XML!Attribute (name<-'description',value <- ''),
		doccomment:XML!Attribute (name<-'doccomment',value <- ''),		
		localize:XML!Attribute (name<-'localize',value<-'false'),
		xpathexpression:XML!Attribute (name<-'xpathexpression',value <- ''),
		reversexpathexpression:XML!Attribute (name<-'reversexpathexpression',value <- ''),
		realattributename:XML!Attribute (name<-'realattributename',value <- ''),
		proxyattributename:XML!Attribute (name<-'proxyattributename',value <- ''),
		customstorage:XML!Attribute (name<-'customstorage',value<-'false'),
		allownulls:XML!Attribute (name<-'allownulls',value<-'false'),
		readwritestate:XML!Attribute (name<-'readwritestate',value<-'readwrite'),
		tag:XML!Attribute (name<-'tag',value <- ''),
		
	------------------
	-- PropertyInfo --
	------------------
		propertyInfo: XML!Element (
			name<-'propertyInfo',
			value <- '',
			children<-Sequence{xsitypePI,namePI,identityPI,default,enumeration}
		),
		xsitypePI:XML!Attribute (name<-'xsi:type',value<-'EnumerationPropertyInfo'),
		namePI : XML!Attribute(name<-'name',value <- e.type.name),
		identityPI : XML!Attribute(name<-'identity',value<-thisModule.makeIdentity()),
		default : XML!Attribute(name<-'default',value <-e.type.name+'.'),
		enumeration : XML!Element(name<-'enumeration',children<-enumerationText),
		enumerationText : XML!Text(name<-'#text',value <- e.type.makeId()),
		
	-----------------------------
	-- ValuePropertyExpression --
	-----------------------------
		ValuetreeExp : XML!Element (
			name <- 'treeExpression',
			value <- '',
			children <- Sequence{
				reXsiType,reName,ValuereIdentity,
				ValuereId,Valuesource,property
			},
			parent <- thisModule.resolveTemp(e.owner.domainModel,'Diagexp')
		),
		
		reXsiType : XML!Attribute(name <- 'xsi:type',value <- 'ValuePropertyExpression'),
		reName : XML!Attribute(name <- 'name',value <- e.name),
		ValuereIdentity : XML!Attribute(name <- 'identity',value <- thisModule.makeIdentity()),
		ValuereId : XML!Attribute(name <- 'id',value <- thisModule.makeId2()),
		Valuesource : XML!Element (name <- 'source',value <- ''),
		property : XML!Element (name <- 'property',value <- '',children <- propertyText),
		propertyText : XML!Text(name<-'#text',value <- e.makeId())
}


-- Rule 'Enumeration'.
-- This rule generates an Enumeration
rule Enumeration {
	from 
		e : DSL!Enumeration
	to 
		v : XML!Element(
			name<-'enumeration',
			value <- '',
			children<-Sequence{name,identity,namespace,id,literals}
		),
		name : XML!Attribute(name<-'name',value<-e.name),
		identity : XML!Attribute(name<-'identity',value<-e.identity),
		namespace : XML!Attribute(name<-'namespace',value<-e.namespace),
		id : XML!Attribute(name<-'id',value<-e.makeId()),
		literals: XML!Element(name<-'literals',value <- '',children<-e.literals)		
}

-- Rule 'EnumerationLiteral'.
-- This rule generates an single element of an Enumeration
rule EnumerationLiteral {
	from 
		e : DSL!EnumerationLiteral
	to
		 v : XML!Element(
			name<-'enumerationLiteral',			
			value <- '',
			children<-Sequence{name,identity,value}
		),
		name : XML!Attribute(name<-'name',value<-e.name),
		identity : XML!Attribute(name<-'identity',value<-e.identity),
		value: XML!Attribute (name<-'value',value<-e.value.toString())
}
",ecor dsl second transform dsl xml modul dsl xml creat out xml in dsl helper this helper convert boolean string context boolean return string helper context boolean def bool string string self true els fals endif this helper get containmentstyl relationship context dsl relationship return string helper context dsl relationship def getcontain string self isembed embed els refer endif this helper store integ valu use assign id generat task context thismodul return integ helper def curid integ this helper comput valu assign id field generat task it increment valu store curid helper return new valu string context thismodul return string helper def makeident string let integ thismodul refsetvalu curid thismodul curid curid tostr els tostr els tostr els tostr endif endif endif this helper convert ident id context dsl namedel return string helper context dsl namedel def makeid string let id string self ident id substr z id substr z id substr z id substr z id substr id size this helper generat new id context thismodul return string helper def makeid string let integ thismodul refsetvalu curid thismodul curid curid z z z z tostr els tostr els tostr els tostr endif endif endif this helper search class point anoth context dsl class return boolean helper context dsl class def istyp boolean dsl relationship allinst iter r acc boolean fals acc r role first type self this helper search class need mark root completediagram context thismodul return sequenc dsl class helper def getroot sequenc dsl class let r sequenc dsl class dsl class allinst select e e supertyp oclisundefin e istyp r isempti r els let r sequenc dsl class dsl class allinst select e e supertyp oclisundefin r isempti r els let r sequenc dsl class dsl class allinst select e e istyp r isempti r els dsl class allinst first endif endif endif this helper store list treat class context thismodul return sequenc km class helper def acc sequenc km class thismodul getroot this helper comput definitionlevel treeexpress class ever treat definitionlevel use elsewher put acc definitionlevel definit context context dsl class return string helper context dsl class def definitionlevel string thismodul acc includ self use els let c dsl class thismodul refsetvalu acc thismodul acc append self acc first definit endif rule rule dmd this rule generat dsldm file structur dmd model mdfmetadata extend enumer relationship concept tree treenavig intrins treenavig completediagram treenavig serial treenavig delet rule dmd dsl domainmodel root dmd r xml root name dmd thismodul getroot tostr valu children sequenc xsi xsd xmlns model xsi xml attribut name xmlns xsi valu http www w org xmlschema instanc xsd xml attribut name xmlns xsd valu http www w org xmlschema xmlns xml attribut name xmlns valu urn schema microsoft com dmd model model xml element name model valu children sequenc name ident id namespac isload mdfmetadata extend enumer relationship tree concept name xml attribut name name valu name ident xml attribut name ident valu ident id xml attribut name id valu makeid namespac xml attribut name namespac valu namespac isload xml attribut name isload valu isload bool string mdfmetadata mdfmetadata xml element name mdfmetadata valu children sequenc xsityp accessmodifi categori descript doccom local majorvers minorvers alwaysgeneratecollect copyright stringtabl copyclosur removeclosur xsityp xml attribut name xsi type valu modelmdfmetadata accessmodifi xml attribut name accessmodifi valu public categori xml attribut name categori valu descript xml attribut name descript valu doccom xml attribut name doccom valu local xml attribut name local valu fals majorvers xml attribut name majorvers valu minorvers xml attribut name minorvers valu alwaysgeneratecollect xml attribut name alwaysgeneratecollect valu fals copyright xml element name copyright valu stringtabl xml element name stringtabl valu children sequenc resxfil ressfil use resxfil xml attribut name resxfil valu name resourc resx ressfil xml attribut name resourcesfil valu namespac name resourc use xml attribut name usefullyqualifiednam valu fals copyclosur xml element name copyclosur valu children sequenc cpname cpdoc cpname xml attribut name name valu name copyclosur cpdoc xml attribut name doccom valu copi closur visitor filter removeclosur xml element name removeclosur valu children sequenc rmname rmdoc rmname xml attribut name name valu name removeclosur rmdoc xml attribut name doccom valu remov closur visitor filter extend extend xml element name extend valu children extmod extmod xml element name model valu children extmodtext extmodtext xml text name text valu b z z dz fz dc ce enumer enumer xml element name enumer valu children type select c c oclistypeof dsl enumer relationship relationship xml element name relationship valu children classifi select c c oclistypeof dsl relationship concept concept xml element name concept valu children classifi select c c oclistypeof dsl class tree tree xml element name tree valu children sequenc treenavintr treenavdiagram treenavseria treenavdel treenavig intrins treenavintr xml element name treenavig valu children sequenc treenavintrna treenavintrident treenavintrid exp intrroot treenavintrna xml attribut name name valu intrins treenavintrid xml attribut name id valu thismodul makeid treenavintrident xml attribut name ident valu thismodul makeident exp xml element name express valu intrroot xml element name root valu treenavig completediagram treenavdiagram xml element name treenavig valu children sequenc treenavdiagtyp treenavdiagna treenavdiagident treenavdiagid diagexp diagroot diagsourc treenavdiagtyp xml attribut name xsi type valu shadowtreenavig treenavdiagna xml attribut name name valu completediagram treenavdiagid xml attribut name id valu thismodul makeid treenavdiagident xml attribut name ident valu thismodul makeident diagexp xml element name express valu diagroot xml element name root valu diagsourc xml element name sourc valu children diagsourcetext diagsourcetext xml text name text valu thismodul resolvetemp treenavintrid valu treenavig serial treenavseria xml element name treenavig valu children sequenc treenavseriatyp treenavseriana treenavseriaident treenavseriaid seriaexp seriaroot seriasourc treenavseriatyp xml attribut name xsi type valu shadowtreenavig treenavseriana xml attribut name name valu serial treenavseriaid xml attribut name id valu thismodul makeid treenavseriaident xml attribut name ident valu thismodul makeident seriaexp xml element name express valu seriaroot xml element name root valu children seriaroot seriaroot xml element name root valu children sequenc seriarootnam seriarootident seriarootid seriarootsourc seriarootreferencetyp seriarootnam xml attribut name name valu thismodul getroot first name seriarootident xml attribut name ident valu thismodul makeident seriarootid xml attribut name id valu thismodul makeid seriarootsourc xml element name sourc valu seriarootreferencetyp xml element name referencetyp valu children seriarootreferencetypetext seriarootreferencetypetext xml text name text valu thismodul getroot first makeid seriasourc xml element name sourc valu children seriasourcetext seriasourcetext xml text name text valu thismodul resolvetemp treenavintrid valu treenavig delet treenavdel xml element name treenavig valu children sequenc treenavdeltyp treenavdelna treenavdelident treenavdelid delexp delroot delsourc treenavdeltyp xml attribut name xsi type valu shadowtreenavig treenavdelna xml attribut name name valu delet treenavdelid xml attribut name id valu thismodul makeid treenavdelident xml attribut name ident valu thismodul makeident delexp xml element name express valu delroot xml element name root valu delsourc xml element name sourc valu children delsourcetext delsourcetext xml text name text valu thismodul resolvetemp treenavintrid valu rule concept this rule generat concept subtyp class abstract rule concept e dsl class e supertyp oclisundefin e isabstract thismodul getroot includ e concept c xml element name concept valu children sequenc name ident namespac id isload isabstract mdfmetadata valueproperti name xml attribut name name valu e name ident xml attribut name ident valu e ident id xml attribut name id valu e makeid namespac xml attribut name namespac valu e namespac isload xml attribut name isload valu e isload bool string isabstract xml attribut name isabstract valu fals mdfmetadata mdfmetadata xml element name mdfmetadata valu children sequenc xsityp accessmodifi categori descript doccom local xsityp xml attribut name xsi type valu conceptorshapemdfmetadata accessmodifi xml attribut name accessmodifi valu public categori xml attribut name categori valu descript xml attribut name descript valu doccom xml attribut name doccom valu local xml attribut name local valu fals properti valueproperti xml element name valueproperti valu children e properti asset rule conceptroot this rule generat concept includ root list subtyp class abstract rule conceptroot e dsl class e supertyp oclisundefin e isabstract thismodul getroot includ e concept c xml element name concept valu children sequenc name ident namespac id isload isabstract mdfmetadata valueproperti name xml attribut name name valu e name ident xml attribut name ident valu e ident id xml attribut name id valu e makeid namespac xml attribut name namespac valu e namespac isload xml attribut name isload valu e isload bool string isabstract xml attribut name isabstract valu fals mdfmetadata mdfmetadata xml element name mdfmetadata valu children sequenc xsityp accessmodifi categori descript doccom local xsityp xml attribut name xsi type valu conceptorshapemdfmetadata accessmodifi xml attribut name accessmodifi valu public categori xml attribut name categori valu descript xml attribut name descript valu doccom xml attribut name doccom valu local xml attribut name local valu fals properti valueproperti xml element name valueproperti valu children e properti asset diagroot xml element name root valu parent thismodul resolvetemp e domainmodel diagroot children sequenc diagrootnam diagrootident diagrootid diagrootsourc diagrootreferencetyp diagrootnam xml attribut name name parent diagroot valu e name diagrootident xml attribut name ident parent diagroot valu thismodul makeident diagrootid xml attribut name id parent diagroot valu thismodul makeid diagrootsourc xml element name sourc parent diagroot valu diagrootreferencetyp xml element name referencetyp parent diagroot valu children diagrootreferencetypetext diagrootreferencetypetext xml text name text valu e makeid rule conceptrootisabstract this rule generat concept includ root list subtyp class abstract rule conceptrootisabstract e dsl class e supertyp oclisundefin e isabstract thismodul getroot includ e concept c xml element name concept valu children sequenc name ident namespac id isload isabstract mdfmetadata valueproperti name xml attribut name name valu e name ident xml attribut name ident valu e ident id xml attribut name id valu e makeid namespac xml attribut name namespac valu e namespac isload xml attribut name isload valu e isload bool string isabstract xml attribut name isabstract valu fals mdfmetadata mdfmetadata xml element name mdfmetadata valu children sequenc xsityp accessmodifi categori descript doccom local classmodifi xsityp xml attribut name xsi type valu conceptorshapemdfmetadata accessmodifi xml attribut name accessmodifi valu public categori xml attribut name categori valu descript xml attribut name descript valu doccom xml attribut name doccom valu local xml attribut name local valu fals classmodifi xml attribut name classmodifi valu e isabstract abstract els none endif properti valueproperti xml element name valueproperti valu children e properti asset diagroot xml element name root valu parent thismodul resolvetemp e domainmodel diagroot children sequenc diagrootnam diagrootident diagrootid diagrootsourc diagrootreferencetyp diagrootnam xml attribut name name parent diagroot valu e name diagrootident xml attribut name ident parent diagroot valu thismodul makeident diagrootid xml attribut name id parent diagroot valu thismodul makeid diagrootsourc xml element name sourc parent diagroot valu diagrootreferencetyp xml element name referencetyp parent diagroot valu children diagrootreferencetypetext diagrootreferencetypetext xml text name text valu e makeid rule concept this rule generat concept subtyp class abstract rule concepthassup e dsl class e supertyp oclisundefin e isabstract thismodul getroot includ e concept c xml element name concept valu children sequenc name ident namespac id isload isabstract mdfmetadata supertyp valueproperti name xml attribut name name valu e name ident xml attribut name ident valu e ident namespac xml attribut name namespac valu e namespac id xml attribut name id valu e makeid isload xml attribut name isload valu e isload bool string isabstract xml attribut name isabstract valu fals mdfmetadata mdfmetadata xml element name mdfmetadata valu children sequenc xsityp accessmodifi categori descript doccom local xsityp xml attribut name xsi type valu conceptorshapemdfmetadata accessmodifi xml attribut name accessmodifi valu public categori xml attribut name categori valu descript xml attribut name descript valu doccom xml attribut name doccom valu local xml attribut name local valu fals supertyp xml element name supertyp children supertypetext supertypetext xml text name text valu e supertyp makeid properti valueproperti xml element name valueproperti valu children e properti asset inheritanceexpress treeherit xml element name treeexpress valu parent thismodul resolvetemp e domainmodel exp children sequenc treehxsityp treehnam treehident treehid treehdef sourc super sub treehxsityp xml attribut name xsi type valu inheritanceexpress treehnam xml attribut name name valu e name e supertyp name treehident xml attribut name ident valu thismodul makeident treehid xml attribut name id valu thismodul makeid treehdef xml attribut name definitionlevel valu none sourc xml element name sourc valu super xml element name supertyp valu children supertext supertext xml text name text valu e supertyp makeid sub xml element name subtyp valu children subtext subtext xml text name text valu e makeid inherit complet diagram diagtreeexp xml element name treeexpress valu parent thismodul resolvetemp e domainmodel diagexp children sequenc treehcdxsityp treehcdnam treehcdident treehcdid treehcddef sourcehcd supercd subcd treehcdxsityp xml attribut name xsi type valu inheritanceexpress treehcdnam xml attribut name name valu e name e supertyp name treehcdident xml attribut name ident valu thismodul makeident treehcdid xml attribut name id valu thismodul makeid treehcddef xml attribut name definitionlevel valu e definitionlevel sourcehcd xml element name sourc valu children sourcehcdtext sourcehcdtext xml text name text valu thismodul resolvetemp e treehid valu supercd xml element name supertyp valu children supertextcd supertextcd xml text name text valu e supertyp makeid subcd xml element name subtyp valu children subtextcd subtextcd xml text name text valu e makeid rule concept this rule generat concept subtyp class abstract rule conceptisabstract e dsl class e supertyp oclisundefin e isabstract thismodul getroot includ e concept c xml element name concept valu children sequenc name ident namespac id isload isabstract mdfmetadata valueproperti name xml attribut name name valu e name ident xml attribut name ident valu e ident id xml attribut name id valu e makeid namespac xml attribut name namespac valu e namespac isload xml attribut name isload valu e isload bool string isabstract xml attribut name isabstract valu fals mdfmetadata mdfmetadata xml element name mdfmetadata valu children sequenc xsityp accessmodifi categori descript doccom local classmodifi xsityp xml attribut name xsi type valu conceptorshapemdfmetadata accessmodifi xml attribut name accessmodifi valu public categori xml attribut name categori valu descript xml attribut name descript valu doccom xml attribut name doccom valu local xml attribut name local valu fals classmodifi xml attribut name classmodifi valu e isabstract abstract els none endif properti valueproperti xml element name valueproperti valu children e properti asset rule concept this rule generat concept subtyp class abstract rule concepthassuperandisabstract e dsl class e supertyp oclisundefin e isabstract thismodul getroot includ e concept c xml element name concept valu children sequenc name ident namespac id isload isabstract mdfmetadata supertyp valueproperti name xml attribut name name valu e name ident xml attribut name ident valu e ident namespac xml attribut name namespac valu e namespac id xml attribut name id valu e makeid isload xml attribut name isload valu e isload bool string isabstract xml attribut name isabstract valu fals mdfmetadata mdfmetadata xml element name mdfmetadata valu children sequenc xsityp accessmodifi categori descript doccom local classmodifi xsityp xml attribut name xsi type valu conceptorshapemdfmetadata accessmodifi xml attribut name accessmodifi valu public categori xml attribut name categori valu descript xml attribut name descript valu doccom xml attribut name doccom valu local xml attribut name local valu fals classmodifi xml attribut name classmodifi valu e isabstract abstract els none endif supertyp xml element name supertyp children supertypetext supertypetext xml text name text valu e supertyp makeid properti valueproperti xml element name valueproperti valu children e properti asset inheritanceexpress treeherit xml element name treeexpress valu parent thismodul resolvetemp e domainmodel exp children sequenc treehxsityp treehnam treehident treehid treehdef sourc super sub treehxsityp xml attribut name xsi type valu inheritanceexpress treehnam xml attribut name name valu e name e supertyp name treehident xml attribut name ident valu thismodul makeident treehid xml attribut name id valu thismodul makeid treehdef xml attribut name definitionlevel valu none sourc xml element name sourc valu super xml element name supertyp valu children supertext supertext xml text name text valu e supertyp makeid sub xml element name subtyp valu children subtext subtext xml text name text valu e makeid inherit complet diagram diagtreeexp xml element name treeexpress valu parent thismodul resolvetemp e domainmodel diagexp children sequenc treehcdxsityp treehcdnam treehcdident treehcdid treehcddef sourcehcd supercd subcd treehcdxsityp xml attribut name xsi type valu inheritanceexpress treehcdnam xml attribut name name valu e name e supertyp name treehcdident xml attribut name ident valu thismodul makeident treehcdid xml attribut name id valu thismodul makeid treehcddef xml attribut name definitionlevel valu e definitionlevel sourcehcd xml element name sourc valu children sourcehcdtext sourcehcdtext xml text name text valu thismodul resolvetemp e treehid valu supercd xml element name supertyp valu children supertextcd supertextcd xml text name text valu e supertyp makeid subcd xml element name subtyp valu children subtextcd subtextcd xml text name text valu e makeid rule relationship this rule generat relationship subtyp class rule relationship e dsl relationship e supertyp oclisundefin relationship r xml element name relationship valu children sequenc name ident namespac id isload isabstract mdfmetadata role valueproperti name xml attribut name name valu e name ident xml attribut name ident valu e ident id xml attribut name id valu e makeid namespac xml attribut name namespac valu e namespac isload xml attribut name isload valu e isload bool string isabstract xml attribut name isabstract valu fals mdfmetadata mdfmetadata xml element name mdfmetadata valu children sequenc xsityp accessmodifi categori descript doccom local xsityp xml attribut name xsi type valu mdfclassmetadata accessmodifi xml attribut name accessmodifi valu public local xml attribut name local valu fals categori xml attribut name categori valu descript xml attribut name descript valu doccom xml attribut name doccom valu role role xml element name role valu children e role assequ properti valueproperti xml element name valueproperti valu children e properti assequ roleexpress treeexp xml element name treeexpress valu parent thismodul resolvetemp e domainmodel exp children sequenc rexsityp renam reident reid redef recontain sourc role rexsityp xml attribut name xsi type valu roleexpress renam xml attribut name name valu roleexpress e name reident xml attribut name ident valu thismodul makeident reid xml attribut name id valu thismodul makeid redef xml attribut name definitionlevel valu none recontain xml attribut name containmentstyl valu e getcontain sourc xml element name sourc valu role xml element name role valu children roletext roletext xml text name text valu e role first makeid role express completediagram diagtreeexp xml element name treeexpress valu parent thismodul resolvetemp e domainmodel diagexp children sequenc recdxsityp recdnam diagreident diagreid diagredef diagrecontain diagsourc diagrol recdxsityp xml attribut name xsi type valu roleexpress recdnam xml attribut name name valu roleexpress e name diagreident xml attribut name ident valu thismodul makeident diagreid xml attribut name id valu thismodul makeid diagredef xml attribut name definitionlevel valu e role first type definitionlevel diagrecontain xml attribut name containmentstyl valu fromsourc diagsourc xml element name sourc valu children sourcetext sourcetext xml text name text valu thismodul resolvetemp e reid valu diagrol xml element name role valu children diagroletext diagroletext xml text name text valu e role first makeid rule relationship this rule generat relationship subtyp class rule relationshiphassup e dsl relationship e supertyp oclisundefin relationship r xml element name relationship valu children sequenc name ident namespac id isload isabstract mdfmetadata role valueproperti name xml attribut name name valu e name ident xml attribut name ident valu e ident id xml attribut name id valu e makeid namespac xml attribut name namespac valu e namespac isload xml attribut name isload valu e isload bool string isabstract xml attribut name isabstract valu fals mdfmetadata mdfmetadata xml element name mdfmetadata valu children sequenc xsityp accessmodifi categori descript doccom local xsityp xml attribut name xsi type valu mdfclassmetadata accessmodifi xml attribut name accessmodifi valu public local xml attribut name local valu fals categori xml attribut name categori valu descript xml attribut name descript valu doccom xml attribut name doccom valu role role xml element name role valu children e role assequ properti valueproperti xml element name valueproperti valu children e properti assequ roleexpress treeexp xml element name treeexpress valu parent thismodul resolvetemp e domainmodel exp children sequenc rexsityp renam reident reid redef recontain sourc role rexsityp xml attribut name xsi type valu roleexpress renam xml attribut name name valu roleexpress e name reident xml attribut name ident valu thismodul makeident reid xml attribut name id valu thismodul makeid redef xml attribut name definitionlevel valu none recontain xml attribut name containmentstyl valu e getcontain sourc xml element name sourc valu role xml element name role valu children roletext roletext xml text name text valu e role first makeid role express completediagram diagtreeexp xml element name treeexpress valu parent thismodul resolvetemp e domainmodel diagexp children sequenc recdxsityp recdnam diagreident diagreid diagredef diagrecontain diagsourc diagrol recdxsityp xml attribut name xsi type valu roleexpress recdnam xml attribut name name valu roleexpress e name diagreident xml attribut name ident valu thismodul makeident diagreid xml attribut name id valu thismodul makeid diagredef xml attribut name definitionlevel valu e role first type definitionlevel diagrecontain xml attribut name containmentstyl valu fromsourc diagsourc xml element name sourc valu children sourcetext sourcetext xml text name text valu thismodul resolvetemp e reid valu diagrol xml element name role valu children diagroletext diagroletext xml text name text valu e role first makeid inheritanceexpress treeherit xml element name treeexpress valu parent thismodul resolvetemp e domainmodel exp children sequenc treehxsityp treehnam treehident treehid treehdef treehsourc super sub treehxsityp xml attribut name xsi type valu inheritanceexpress treehnam xml attribut name name valu e name e supertyp name treehident xml attribut name ident valu thismodul makeident treehid xml attribut name id valu thismodul makeid treehdef xml attribut name definitionlevel valu none treehsourc xml element name sourc valu super xml element name supertyp valu children supertext supertext xml text name text valu e supertyp makeid sub xml element name subtyp valu children subtext subtext xml text name text valu e makeid inherit complet diagram diagtreeexp xml element name treeexpress valu parent thismodul resolvetemp e domainmodel diagexp children sequenc treehxsityp treehnam treehcdident treehcdid treehcddef sourcehcd supercd subcd treehcdident xml attribut name ident valu thismodul makeident treehcdid xml attribut name id valu thismodul makeid treehcddef xml attribut name definitionlevel valu e definitionlevel sourcehcd xml element name sourc valu children sourcehcdtext sourcehcdtext xml text name text valu thismodul resolvetemp e treehid valu supercd xml element name supertyp valu children supertextcd supertextcd xml text name text valu e supertyp makeid subcd xml element name subtyp valu children subtextcd subtextcd xml text name text valu e makeid rule role this rule generat role relationship rule role e dsl role role r xml element name role valu children sequenc name ident id min max isunbound accept mdfmetadata sourc type genprop name xml attribut name name valu e name ident xml attribut name ident valu e ident id xml attribut name id valu e makeid min xml attribut name min valu e min tostr max xml attribut name max valu e max tostr isunbound xml attribut name isunbound valu e isunbound bool string accept xml attribut name accept valu e accept mdfmetadata mdfmetadata xml element name mdfmetadata valu children sequenc xsityp accessmodifi categori descript doccom local isord isnavig xsityp xml attribut name xsi type valu rolemdfmetadata accessmodifi xml attribut name accessmodifi valu public categori xml attribut name categori valu descript xml attribut name descript valu doccom xml attribut name doccom valu local xml attribut name local valu fals isord xml attribut name isord valu e isord bool string isnavig xml attribut name isnavigablefrom valu e isnavigablefrom bool string sourc sourc xml element name sourc valu children ts ts xml text name text valu e sourc makeid type type xml element name type valu children tt tt xml text name text valu e type makeid generatedproperti genprop xml element name generatedproperti valu children sequenc gennam genident genreftyp gennam xml attribut name name valu e name genident xml attribut name ident valu thismodul makeident genreftyp xml element name referencetyp valu children reftext reftext xml text name text valu e type makeid rule simpleproperti this rule generat properti simpl type rule simpleproperti e dsl valueproperti e type oclistypeof dsl simpletyp properti v xml element name properti valu children sequenc name ident id mdfmetadata propertyinfo name xml attribut name name valu e name ident xml attribut name ident valu e ident id xml attribut name id valu e makeid mdfmetadata mdfmetadata xml element name mdfmetadata valu children sequenc xsityp accessmodifi categori descript doccom local xpathexpress reversexpathexpress realattributenam proxyattributenam customstorag allownul readwritest tag xsityp xml attribut name xsi type valu propertymdfmetadata accessmodifi xml attribut name accessmodifi valu public categori xml attribut name categori valu descript xml attribut name descript valu doccom xml attribut name doccom valu local xml attribut name local valu fals xpathexpress xml attribut name xpathexpress valu reversexpathexpress xml attribut name reversexpathexpress valu realattributenam xml attribut name realattributenam valu proxyattributenam xml attribut name proxyattributenam valu customstorag xml attribut name customstorag valu fals allownul xml attribut name allownul valu fals readwritest xml attribut name readwritest valu readwrit tag xml attribut name tag valu propertyinfo propertyinfo xml element name propertyinfo valu children sequenc xsitypepi namepi identitypi default max min xsitypepi xml attribut name xsi type valu e type name propertyinfo namepi xml attribut name name valu identitypi xml attribut name ident valu thismodul makeident default xml attribut name default valu e type name string els endif max xml attribut name max valu e type name doubl els e endif min xml attribut name min valu e type name doubl els endif valuepropertyexpress valuetreeexp xml element name treeexpress valu children sequenc rexsityp renam valuereident valuereid valuesourc properti parent thismodul resolvetemp e owner domainmodel diagexp rexsityp xml attribut name xsi type valu valuepropertyexpress renam xml attribut name name valu e name valuereident xml attribut name ident valu thismodul makeident valuereid xml attribut name id valu thismodul makeid valuesourc xml element name sourc valu properti xml element name properti valu children propertytext propertytext xml text name text valu e makeid rule enumerationproperti this rule generat properti type enumer rule enumerationproperti e dsl valueproperti e type oclistypeof dsl simpletyp properti v xml element name properti valu children sequenc name ident id mdfmetadata propertyinfo name xml attribut name name valu e name ident xml attribut name ident valu e ident id xml attribut name id valu e makeid mdfmetadata mdfmetadata xml element name mdfmetadata valu children sequenc xsityp accessmodifi categori descript doccom local xpathexpress reversexpathexpress realattributenam proxyattributenam customstorag allownul readwritest tag xsityp xml attribut name xsi type valu propertymdfmetadata accessmodifi xml attribut name accessmodifi valu public categori xml attribut name categori valu descript xml attribut name descript valu doccom xml attribut name doccom valu local xml attribut name local valu fals xpathexpress xml attribut name xpathexpress valu reversexpathexpress xml attribut name reversexpathexpress valu realattributenam xml attribut name realattributenam valu proxyattributenam xml attribut name proxyattributenam valu customstorag xml attribut name customstorag valu fals allownul xml attribut name allownul valu fals readwritest xml attribut name readwritest valu readwrit tag xml attribut name tag valu propertyinfo propertyinfo xml element name propertyinfo valu children sequenc xsitypepi namepi identitypi default enumer xsitypepi xml attribut name xsi type valu enumerationpropertyinfo namepi xml attribut name name valu e type name identitypi xml attribut name ident valu thismodul makeident default xml attribut name default valu e type name enumer xml element name enumer children enumerationtext enumerationtext xml text name text valu e type makeid valuepropertyexpress valuetreeexp xml element name treeexpress valu children sequenc rexsityp renam valuereident valuereid valuesourc properti parent thismodul resolvetemp e owner domainmodel diagexp rexsityp xml attribut name xsi type valu valuepropertyexpress renam xml attribut name name valu e name valuereident xml attribut name ident valu thismodul makeident valuereid xml attribut name id valu thismodul makeid valuesourc xml element name sourc valu properti xml element name properti valu children propertytext propertytext xml text name text valu e makeid rule enumer this rule generat enumer rule enumer e dsl enumer v xml element name enumer valu children sequenc name ident namespac id liter name xml attribut name name valu e name ident xml attribut name ident valu e ident namespac xml attribut name namespac valu e namespac id xml attribut name id valu e makeid liter xml element name liter valu children e liter rule enumerationliter this rule generat singl element enumer rule enumerationliter e dsl enumerationliter v xml element name enumerationliter valu children sequenc name ident valu name xml attribut name name valu e name ident xml attribut name ident valu e ident valu xml attribut name valu valu e valu tostr,0
37,37,P26-DSLModel2KM2.atl,"module DSLModel2KM2;
create OUT : KM2  from IN1 : DSLModel, IN2 : DSL;

-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- This helper returns a boolean which indicates if the relationship corresponding to the role
-- has a max cardinality > 1
-- CONTEXT : DSLModel!Role
-- RETURN : Boolean
helper context DSLModel!Role def: isMultiple() : Boolean =
	let a : DSL!Role = DSL!Role.allInstances()
		->select ( e | e.relation.name = self.owner.type 
			and e.name = self.name )->first() 
	in if ( a.max = 1 ) then false else true endif;

-- This helper takes a Sequence in parameter and test if a sequence element with the same name 
-- as the context is already in the sequence. It is used by the helper getReferences()
-- CONTEXT : DSLModel!Role
-- RETURN : Boolean
helper context DSLModel!Role def: hasSameName(seq : Sequence(DSLModel!Role)) : Boolean =
	let a : DSLModel!Role =
		seq->select( e | e.name = self.name)->first()
	in if a.oclIsUndefined() then false else true endif;

-- This helper returns a sequence of DSLModel!Role without doublons which corresponds to the references
-- from the context
-- CONTEXT : DSLModel!ModelElement
-- RETURN : Sequence(DSLModel!Role)
helper context DSLModel!ModelElement def : getReferences() : Sequence(DSLModel!Role) =
	self.getLastRole()->iterate(e;acc : Sequence(DSLModel!Role) = Sequence{} | 
		if e.hasSameName(acc)
			then acc
			else acc->including(e)
		endif );

-- This helper makes a Sequence of DSLModel!Role which are used to create properties
-- CONTEXT : ThisModule
-- RETURN : Sequence(DSLModel!Role)
helper def: propertyRoles() : Sequence(DSLModel!Role) =
	let a : Sequence(DSLModel!Role) =
	DSLModel!ModelElement.allInstances()->iterate(e ;
	acc:Sequence(DSLModel!Role)=Sequence{} |
	if ( e.getReferences().size() > 0)
		then acc -> including(e.getReferences())
		else acc 
	endif )in a->flatten();

-- This helper creates a Sequence of DSLModel!Role. It collects all last roles from element links
-- A last role from an ElementLink corresponds to a reference for the context
-- CONTEXT : DSLModel!ModelElement
-- RETURN : Sequence(DSLModel!Role)
helper context DSLModel!ModelElement def: getLastRole() : Sequence(DSLModel!Role) =
	self.referencelinks->iterate(e;acc:Sequence(DSLModel!Role) = Sequence{} |
		acc -> including(e.roles->last()));

-- This helper test if a DSL Relationship is a  ModelElement's ParentLink 
-- CONTEXT : DSL!Relationship
-- RETURN : Boolean
helper context DSL!Role def : isParentLink() : Boolean =
	let s : Sequence(DSLModel!ModelElement) = DSLModel!ModelElement.allInstances()->
	select( a | a.oclIsTypeOf(DSLModel!ModelElement))->select(e | e.parentLink.size()>0 )
	->asSequence()
	in s -> iterate(e;acc : Boolean = false | 
		if e.parentLink = self.relation.name
			then if e.owner.type = self.source.name
					then if e.type = self.type.name 
							then acc = acc and true
							else acc
						endif 	else acc
				endif else acc
		endif );

-- This helper returns the role corresponding to the embedding link
-- CONTEXT : DSLModel!EmbeddingLink
-- RETURN : DSL!Role
helper context DSLModel!EmbeddingLink def:getRole() : DSL!Role =
	let a : DSL!Relationship =
		DSL!Relationship.allInstances()
		->select( e | e.name = self.name )->first()
	in a.roles->select( e | e.source.name = self.owner.type )->first();

-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

rule Model {
	from
		dslm : DSLModel!Model
	to
		km : KM2!Model (
			metamodel <- dslm.domainModel,
			contents <-
				Sequence{
					dslm.contents->select(e | e.oclIsTypeOf(DSLModel!ModelElement) ),
					dslm.contents
						->select(e | e.oclIsTypeOf(DSLModel!ModelElementLink) and
							not e.properties.isEmpty()
						)
				}
		)
}

rule ModelElement {
	from
		me : DSLModel!ModelElement (
			me.oclIsTypeOf(DSLModel!ModelElement)
		)
	to
		kme : KM2!ModelElement (
			name <- me.type,
			id <- me.id,
			properties <- Sequence { 
				me.properties->asSequence(), -- Attributes
				me.embeddinglinks->asSequence(), -- Compositions
				me.getReferences() -- References
			}
		)
}

-- This ModelElement corresponds to the KM3!Class created from a DSL!Relationship
rule ModelElementLink {
	from
		mel : DSLModel!ModelElementLink (
			not mel.properties.isEmpty()
		)
	to
		kme : KM2!ModelElement (
			name <- mel.type,
			id <- mel.id,
			properties <-
				Sequence { 
					mel.properties->asSequence()--,
--					mel.links.debug('roles')
				}
		)
}

rule PropertySetFromEmbeddingLink {
	from
		p : DSLModel!EmbeddingLink (
			p.getRole().max = 0 or p.getRole().max > 1
		)
	to
		kp : KM2!Property (
			name <- p.getRole().name,
			value <- s
		),
		s : KM2!SetVal (
			contents <- e
		),
		e : distinct KM2!ModelElementVal foreach( m in p.elements ) (
				element <- m
		)
}

rule PropertyFromEmbeddingLink {
	from
		p : DSLModel!EmbeddingLink (
			p.getRole().max = 1
		)
	to
		kp : KM2!Property (
			name <- p.getRole().name,
			value <- e
		),
		e : KM2!ModelElementVal (
				element <- p.elements
		)
}

rule PropertySetFromDSLModelRole {
	from
		r : DSLModel!Role (
			if thisModule.propertyRoles().includes(r)
				then r.isMultiple()
				else false
			endif			
		)
	using {
			allroles : Sequence(DSLModel!Role) = r.owner.owner.getLastRole()->select(c | c.name = r.name);
		}
	to
		p : KM2!Property (
			name <- r.name,
			value <- s
		),
		s : KM2!SetVal (
			contents <- rol
		),
		rol : distinct KM2!ModelElementRefVal foreach ( role in allroles ) (
				element <- role.element
		)
}

rule PropertyFromDSLModelRole {
	from
		r : DSLModel!Role (
			if thisModule.propertyRoles().includes(r)
				then not r.isMultiple()
				else false
			endif			
		)
	using {
			role : DSLModel!Role = r.owner.owner.getLastRole()->select(c | c.name = r.name).first();
		}
	to
		p : KM2!Property (
			name <- r.name,
			value <- rol
		),
		rol : KM2!ModelElementRefVal (
			element <- role.element
		)
}

-- Rules to create Simple Properties ( Integer, Double, String, Boolean )

rule StringProperty {
	from
		v : DSLModel!Property (
			v.value.oclIsTypeOf(DSLModel!StringValue)
		)
	to
		p : KM2!Property (
			name <- v.name,
			value <- s
		),
		s : KM2!StringVal (
			value <- v.value.value
		)
}

rule IntegerProperty {
	from
		v : DSLModel!Property (
			v.value.oclIsTypeOf(DSLModel!IntegerValue)
		)
	to
		p : KM2!Property (
			name <- v.name,
			value <- s
		),
		s : KM2!IntegerVal (
			value <- v.value.value
		)
}

rule BooleanProperty {
	from
		v : DSLModel!Property (
			v.value.oclIsTypeOf(DSLModel!BooleanValue)
		)
	to
		p : KM2!Property (
			name <- v.name,
			value <- s
		),
		s : KM2!BooleanVal (
			value <- v.value.value
		)
}
",modul dslmodel km creat out km in dslmodel in dsl helper this helper return boolean indic relationship correspond role max cardin context dslmodel role return boolean helper context dslmodel role def ismultipl boolean let dsl role dsl role allinst select e e relat name self owner type e name self name first max fals els true endif this helper take sequenc paramet test sequenc element name context alreadi sequenc it use helper getrefer context dslmodel role return boolean helper context dslmodel role def hassamenam seq sequenc dslmodel role boolean let dslmodel role seq select e e name self name first oclisundefin fals els true endif this helper return sequenc dslmodel role without doublon correspond refer context context dslmodel modelel return sequenc dslmodel role helper context dslmodel modelel def getrefer sequenc dslmodel role self getlastrol iter e acc sequenc dslmodel role sequenc e hassamenam acc acc els acc includ e endif this helper make sequenc dslmodel role use creat properti context thismodul return sequenc dslmodel role helper def propertyrol sequenc dslmodel role let sequenc dslmodel role dslmodel modelel allinst iter e acc sequenc dslmodel role sequenc e getrefer size acc includ e getrefer els acc endif flatten this helper creat sequenc dslmodel role it collect last role element link a last role elementlink correspond refer context context dslmodel modelel return sequenc dslmodel role helper context dslmodel modelel def getlastrol sequenc dslmodel role self referencelink iter e acc sequenc dslmodel role sequenc acc includ e role last this helper test dsl relationship modelel parentlink context dsl relationship return boolean helper context dsl role def isparentlink boolean let sequenc dslmodel modelel dslmodel modelel allinst select oclistypeof dslmodel modelel select e e parentlink size assequ iter e acc boolean fals e parentlink self relat name e owner type self sourc name e type self type name acc acc true els acc endif els acc endif els acc endif this helper return role correspond embed link context dslmodel embeddinglink return dsl role helper context dslmodel embeddinglink def getrol dsl role let dsl relationship dsl relationship allinst select e e name self name first role select e e sourc name self owner type first rule rule model dslm dslmodel model km km model metamodel dslm domainmodel content sequenc dslm content select e e oclistypeof dslmodel modelel dslm content select e e oclistypeof dslmodel modelelementlink e properti isempti rule modelel dslmodel modelel oclistypeof dslmodel modelel kme km modelel name type id id properti sequenc properti assequ attribut embeddinglink assequ composit getrefer refer this modelel correspond km class creat dsl relationship rule modelelementlink mel dslmodel modelelementlink mel properti isempti kme km modelel name mel type id mel id properti sequenc mel properti assequ mel link debug role rule propertysetfromembeddinglink p dslmodel embeddinglink p getrol max p getrol max kp km properti name p getrol name valu km setval content e e distinct km modelelementv foreach p element element rule propertyfromembeddinglink p dslmodel embeddinglink p getrol max kp km properti name p getrol name valu e e km modelelementv element p element rule propertysetfromdslmodelrol r dslmodel role thismodul propertyrol includ r r ismultipl els fals endif use allrol sequenc dslmodel role r owner owner getlastrol select c c name r name p km properti name r name valu km setval content rol rol distinct km modelelementrefv foreach role allrol element role element rule propertyfromdslmodelrol r dslmodel role thismodul propertyrol includ r r ismultipl els fals endif use role dslmodel role r owner owner getlastrol select c c name r name first p km properti name r name valu rol rol km modelelementrefv element role element rule creat simpl properti integ doubl string boolean rule stringproperti v dslmodel properti v valu oclistypeof dslmodel stringvalu p km properti name v name valu km stringval valu v valu valu rule integerproperti v dslmodel properti v valu oclistypeof dslmodel integervalu p km properti name v name valu km integerv valu v valu valu rule booleanproperti v dslmodel properti v valu oclistypeof dslmodel booleanvalu p km properti name v name valu km booleanv valu v valu valu,0
38,38,P26-KM22DSLModel.atl,"module KM22DSLModel;
create OUT : DSLModel  from IN1 : KM2, IN2 : KM3, IN3 : DSL;

-------------------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

-- This helper returns a Sequence of KM2!Property that corresponds to DSLModel!Property
-- From the name (type) of the CONTEXT it makes a Sequence of KM3!Attribute present in 
-- the metamodel and then select in the CONTEXT properties the corresponding KM2!Property.
-- CONTEXT: KM2!ModelElement
-- RETURN: Sequence(KM2!Property)
helper context KM2!ModelElement def: getProperties() : Sequence(KM2!Property) =
let a : Sequence(KM3!Attribute) =
	KM3!Class.allInstances()->select( c | c.name = self.name )
	->collect(p | p.structuralFeatures)->flatten()
	->select( a | a.oclIsTypeOf(KM3!Attribute))->asSequence()
in
	a->iterate(e;acc : Sequence(KM2!Property) = Sequence{} | 
	if 	self.properties->select( p | p.name = e.name )->first().oclIsUndefined()
		then acc
		else acc -> including(self.properties->select( p | p.name = e.name )->first())
	endif);

-- This helper returns a Sequence of KM2!Property that corresponds to references in the metamodel
-- CONTEXT: KM2!ModelElement
-- RETURN: Sequence(KM2!Property)
helper context KM2!ModelElement def: getPropertyReference() : Sequence(KM2!Property) =
	let a : Sequence(KM3!Reference) =
		KM3!Class.allInstances()->select( c | c.name = self.name )->collect(p | p.structuralFeatures)
		->flatten()->select( a | a.oclIsTypeOf(KM3!Reference) )->select(b | not b.isContainer )->asSequence()
	in
		a->iterate(e;acc : Sequence(KM2!Property) = Sequence{} | 
			if 	self.properties->select( p | p.name = e.name )->first().oclIsUndefined()
				then acc
				else acc -> including(self.properties->select( p | p.name = e.name )->first())
			endif);

-- This helper returns a Sequence of KM2!Property that corresponds to compositions in the metamodel
-- CONTEXT: KM2!ModelElement
-- RETURN: Sequence(KM2!Property)
helper context KM2!ModelElement def: getPropertyContainer() : Sequence(KM2!Property) =
	let a : Sequence(KM3!Reference) =
		KM3!Class.allInstances()->select( c | c.name = self.name )->collect(p | p.structuralFeatures)
		->flatten()->select( a | a.oclIsTypeOf(KM3!Reference) )->select(b | b.isContainer )->asSequence()
	in
		a->iterate(e;acc : Sequence(KM2!Property) = Sequence{} | 
			if 	self.properties->select( p | p.name = e.name )->first().oclIsUndefined()
				then acc
				else acc -> including(self.properties->select( p | p.name = e.name )->first())
			endif);

-- This helper tests if a KM2!Property corresponds to a container reference in the KM3 metamodel
-- CONTEXT: KM2!Property
-- RETURN: Boolean
helper context KM2!Property def: isContainer() : Boolean =
	let a : KM3!Reference =
		KM3!Class.allInstances()->select( c | c.name = self.owner.name )->collect(p | p.structuralFeatures)->flatten()
		->select( a | a.oclIsTypeOf(KM3!Reference))->select( r | r.name = self.name)->first()
	in if a.oclIsUndefined() then false else a.isContainer endif;

-- This helper tests if a KM2!Property corresponds to a reference in the KM3 metamodel
-- CONTEXT: KM2!Property
-- RETURN: Boolean
helper context KM2!Property def: isReference() : Boolean =
	let a : KM3!Reference =
		KM3!Class.allInstances()->select( c | c.name = self.owner.name )->collect(p | p.structuralFeatures)->flatten()
		->select( a | a.oclIsTypeOf(KM3!Reference))->select( r | r.name = self.name)->first()
	in if a.oclIsUndefined() then false else not a.isContainer endif;

-- This helper tests if a KM2!Property is an attribute
-- CONTEXT: KM2!Property
-- RETURN: Boolean
helper context KM2!Property def: isAttribute() : Boolean =
	let a : KM3!Reference =
		KM3!Class.allInstances()->select( c | c.name = self.owner.name )->collect(p | p.structuralFeatures)->flatten()
		->select( a | a.oclIsTypeOf(KM3!Attribute))->select( r | r.name = self.name)->first()
	in if a.oclIsUndefined() then false else true endif;

-- This helper returns a Sequence of KM2!ModelElementRefVal contains in a SetVal or in a Value
-- CONTEXT: KM2!Property
-- RETURN: Sequence(KM2!ModelElementRefVal)
helper context KM2!Property def: getRefVal() : Sequence(KM2!ModelElementRefVal) = 
	if self.value.oclIsTypeOf(KM2!SetVal) then
		self.value.contents->asSequence()
	else
		self.value->asSequence()
	endif;

-- This helper select from a KM2!Property the corresponding DSL!Relationship in DSL metamodel.
-- CONTEXT: KM2!Property
-- RETURN: DSL!Relationship
helper context KM2!Property def: getRelationship() : DSL!Relationship =
	let a : DSL!Role =
		DSL!Role.allInstances()->select(e | e.name = self.name )->first()
	in a.relation;

-- This helper returns a DSL!Role, from a KM2!Property we select the corresponding DSL!Relationship
-- and like a KM2!Property has normally the same name as a DSL!Role it returns the DSL!Role with 
-- different name
-- CONTEXT: KM2!Property
-- RETURN: DSL!Role
helper context KM2!Property def: getOpposite() : DSL!Role =
	self.getRelationship().roles->select( e | e.name <> self.name )->first();

helper def: referenceLinks() : Set(KM2!Property) =
	KM2!Property.allInstances()->select( e | e.isReference() )->asSet().debug('Set of References');

------------------------------------------------------------------------------------------
-- RULES ---------------------------------------------------------------------------------
------------------------------------------------------------------------------------------

rule Model {
	from
		km : KM2!Model
	using {
			allRef : Set(KM2!Property) = thisModule.referenceLinks();
		}
	to
		dm : DSLModel!Model (
			domainModel <- km.metamodel,
			contents <- Sequence{km.contents,mel}
		),
		mel : distinct DSLModel!ModelElementLink foreach ( r in allRef ) (
				type <- r.getRelationship().name--,
--				links <- 
		)
}

rule ModelElement {
	from
		kme : KM2!ModelElement
	to
		me : DSLModel!ModelElement (
			type <- kme.name,
			id <- kme.id,
			properties <- kme.getProperties(),
			embeddinglinks <- kme.getPropertyContainer(),
			referencelinks <- kme.getPropertyReference()
		)
}

-- From a reference property we create an ElementLink for each ModelELementRefVal in the property
rule ReferenceLink {
	from
		kp : KM2!Property (
			kp.isReference()
		)
	to
		e : distinct DSLModel!ReferenceLink foreach (rv in kp.getRefVal()) (
			type <- kp.getRelationship().name,
			roles <- rv
		)
}

rule Role {
	from
		m : KM2!ModelElementRefVal 
	using {
			powner : KM2!Property = if m.owner.oclIsUndefined()
										then m.set.owner
										else m.owner
									endif;
		}
	to
		r1 : DSLModel!Role (
			name <- powner.getOpposite().name,
			element <- powner.owner
		),
		r2 : DSLModel!Role (			
			name <- powner.name,
			element <- m.element,
			owner <- r1.owner
		)
}

rule EmbeddingLink {
	from
		kp : KM2!Property (
			kp.isContainer() 
		)
	to
		p : DSLModel!EmbeddingLink (
			name <- kp.getRelationship().name,
			elements <- if kp.value.oclIsTypeOf(KM2!SetVal) 
							then kp.value.contents->asSequence()->flatten()->collect(d | d.element)->asSequence()
							else kp.value.element 
						endif
		)
}

rule Property {
	from
		kp : KM2!Property(
			kp.isAttribute()
		)
	to
		p : DSLModel!Property (
			name <- kp.name,
			value <- kp.value
		)
}

rule BooleanValue {
	from
		kb : KM2!BooleanVal
	to
		b : DSLModel!BooleanValue(
			value <- kb.value
		)
}

rule StringValue {
	from
		ks : KM2!StringVal
	to
		s : DSLModel!StringValue (
			value <- ks.value
		)
}

rule IntegerValue {
	from
		ki : KM2!IntegerVal
	to
		i : DSLModel!IntegerValue(
			value <- ki.value
		)
}
",modul km dslmodel creat out dslmodel in km in km in dsl helper this helper return sequenc km properti correspond dslmodel properti from name type context make sequenc km attribut present metamodel select context properti correspond km properti context km modelel return sequenc km properti helper context km modelel def getproperti sequenc km properti let sequenc km attribut km class allinst select c c name self name collect p p structuralfeatur flatten select oclistypeof km attribut assequ iter e acc sequenc km properti sequenc self properti select p p name e name first oclisundefin acc els acc includ self properti select p p name e name first endif this helper return sequenc km properti correspond refer metamodel context km modelel return sequenc km properti helper context km modelel def getpropertyrefer sequenc km properti let sequenc km refer km class allinst select c c name self name collect p p structuralfeatur flatten select oclistypeof km refer select b b iscontain assequ iter e acc sequenc km properti sequenc self properti select p p name e name first oclisundefin acc els acc includ self properti select p p name e name first endif this helper return sequenc km properti correspond composit metamodel context km modelel return sequenc km properti helper context km modelel def getpropertycontain sequenc km properti let sequenc km refer km class allinst select c c name self name collect p p structuralfeatur flatten select oclistypeof km refer select b b iscontain assequ iter e acc sequenc km properti sequenc self properti select p p name e name first oclisundefin acc els acc includ self properti select p p name e name first endif this helper test km properti correspond contain refer km metamodel context km properti return boolean helper context km properti def iscontain boolean let km refer km class allinst select c c name self owner name collect p p structuralfeatur flatten select oclistypeof km refer select r r name self name first oclisundefin fals els iscontain endif this helper test km properti correspond refer km metamodel context km properti return boolean helper context km properti def isrefer boolean let km refer km class allinst select c c name self owner name collect p p structuralfeatur flatten select oclistypeof km refer select r r name self name first oclisundefin fals els iscontain endif this helper test km properti attribut context km properti return boolean helper context km properti def isattribut boolean let km refer km class allinst select c c name self owner name collect p p structuralfeatur flatten select oclistypeof km attribut select r r name self name first oclisundefin fals els true endif this helper return sequenc km modelelementrefv contain setval valu context km properti return sequenc km modelelementrefv helper context km properti def getrefv sequenc km modelelementrefv self valu oclistypeof km setval self valu content assequ els self valu assequ endif this helper select km properti correspond dsl relationship dsl metamodel context km properti return dsl relationship helper context km properti def getrelationship dsl relationship let dsl role dsl role allinst select e e name self name first relat this helper return dsl role km properti select correspond dsl relationship like km properti normal name dsl role return dsl role differ name context km properti return dsl role helper context km properti def getopposit dsl role self getrelationship role select e e name self name first helper def referencelink set km properti km properti allinst select e e isrefer asset debug set refer rule rule model km km model use allref set km properti thismodul referencelink dm dslmodel model domainmodel km metamodel content sequenc km content mel mel distinct dslmodel modelelementlink foreach r allref type r getrelationship name link rule modelel kme km modelel dslmodel modelel type kme name id kme id properti kme getproperti embeddinglink kme getpropertycontain referencelink kme getpropertyrefer from refer properti creat elementlink modelelementrefv properti rule referencelink kp km properti kp isrefer e distinct dslmodel referencelink foreach rv kp getrefv type kp getrelationship name role rv rule role km modelelementrefv use powner km properti owner oclisundefin set owner els owner endif r dslmodel role name powner getopposit name element powner owner r dslmodel role name powner name element element owner r owner rule embeddinglink kp km properti kp iscontain p dslmodel embeddinglink name kp getrelationship name element kp valu oclistypeof km setval kp valu content assequ flatten collect element assequ els kp valu element endif rule properti kp km properti kp isattribut p dslmodel properti name kp name valu kp valu rule booleanvalu kb km booleanv b dslmodel booleanvalu valu kb valu rule stringvalu ks km stringval dslmodel stringvalu valu ks valu rule integervalu ki km integerv dslmodel integervalu valu ki valu,0
39,39,P26-KM2Tools.atl,"library KM2Tools; -- Library Template

-- This library contains helpers used by transformation generate with KM32ATL

-- This helper returns the String value from the property with its name in parameter
-- CONTEXT: KM2!ModelElement
-- RETURN: String
helper context KM2!ModelElement def: getStringProperty(name : String) : String =
	self.properties->select( p | p.name = name)->collect( d | d.value)->first().value;

-- This helper returns the Integer value from the property with its name in parameter
-- CONTEXT: KM2!ModelElement
-- RETURN: Integer
helper context KM2!ModelElement def: getIntegerProperty(name : String) : Integer =
	self.properties->select( p | p.name = name)->collect( d | d.value)->first().value;

-- This helper returns the Boolean value from the property with its name in parameter
-- CONTEXT: KM2!ModelElement
-- RETURN: Boolean
helper context KM2!ModelElement def: getBooleanProperty(name : String) : Boolean =
	self.properties->select( p | p.name = name)->collect( d | d.value)->first().value;

-- This helper return a KM2!ModelElement contain in a property with its name in parameter
-- the property must contains a simple value, not a set
-- CONTEXT: KM2!ModelElement
-- RETURN: KM2!ModelElement
helper context KM2!ModelElement def: get(name : String) : KM2!ModelElement =
	self.properties->select(p | p.name = name)->first().value.element;

-- This helper return a Sequence of KM2!ModelElement contain in a property with its name in parameter
-- the property must contains a set value and corresponds to a reference
-- CONTEXT: KM2!ModelElement
-- RETURN: Sequence(KM2!ModelElement)
helper context KM2!ModelElement def: getRefSet(name : String) : Sequence(KM2!ModelElement) =
	self.properties->select(p | p.name = name)->first().value.contents
	->select( e | e.oclIsTypeOf(KM2!ModelElementRefVal) )->collect( d | d.element )->asSequence();

-- This helper return a Sequence of KM2!ModelElement contain in a property with its name in parameter
-- the property must contains a set value and corresponds to a composition (container)
-- CONTEXT: KM2!ModelElement
-- RETURN: Sequence(KM2!ModelElement)
helper context KM2!ModelElement def: getSet(name : String) : Sequence(KM2!ModelElement) =
	self.properties->select(p | p.name = name)->first().value.contents
	->select( e | e.oclIsTypeOf(KM2!ModelElementVal) )->collect( d | d.element )->asSequence();
",librari km tool librari templat this librari contain helper use transform generat km atl this helper return string valu properti name paramet context km modelel return string helper context km modelel def getstringproperti name string string self properti select p p name name collect valu first valu this helper return integ valu properti name paramet context km modelel return integ helper context km modelel def getintegerproperti name string integ self properti select p p name name collect valu first valu this helper return boolean valu properti name paramet context km modelel return boolean helper context km modelel def getbooleanproperti name string boolean self properti select p p name name collect valu first valu this helper return km modelel contain properti name paramet properti must contain simpl valu set context km modelel return km modelel helper context km modelel def get name string km modelel self properti select p p name name first valu element this helper return sequenc km modelel contain properti name paramet properti must contain set valu correspond refer context km modelel return sequenc km modelel helper context km modelel def getrefset name string sequenc km modelel self properti select p p name name first valu content select e e oclistypeof km modelelementrefv collect element assequ this helper return sequenc km modelel contain properti name paramet properti must contain set valu correspond composit contain context km modelel return sequenc km modelel helper context km modelel def getset name string sequenc km modelel self properti select p p name name first valu content select e e oclistypeof km modelelementv collect element assequ,0
40,40,P26-KM32ATL_KM22MM.atl,"module KM32ATL_KM22MM;
create OUT : ATL from IN : KM3;

-------------------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

-- This helper contains KM3!Metamodel
-- CONTEXT: ThisModule
-- RETURN: KM3!Metamodel
helper def: metamodel : KM3!Metamodel = KM3!Metamodel.allInstances()->asSequence()->first();

-- This helper contains the name of the KM3!Package that is not PrimitiveTypes package
-- CONTEXT: ThisModule
-- RETURN: String
helper def: km3PackageName : String = 
	KM3!Package.allInstances()->select( e | e.name <> 'PrimitiveTypes' )->first().name;

-- This helper returns a Set that contains all structural features of a KM3!Class 
-- including those in its supertypes
-- CONTEXT: KM3!Class
-- RETURN: Set(KM3!StructuralFeature)
helper context KM3!Class def: allStructuralFeatures() : Set(KM3!StructuralFeature) =
	self.supertypes->iterate(e; acc : Set(KM3!StructuralFeature) = 
		self.structuralFeatures | acc->union(e.allStructuralFeatures()) );

-- This helper returns a Sequence of KM3!Reference without their opposite
-- CONTEXT: ThisModule
-- RETURN: Sequence(KM3!Reference)
helper def: usedReferences : Sequence(KM3!Reference) =
	KM3!Reference.allInstances()->iterate(e;acc : Sequence(KM3!Reference) = Sequence{} |
		if acc->includes(e.opposite) 
			then acc
			else if e.isOrdered and e.opposite.isContainer 
					then acc
					else if e.isOrdered and (e.upper = 0-1 or e.upper > 1)
							then acc->including(e)
							else if e.isContainer 
									then acc->including(e)
									else acc
								endif
						endif
				endif
		endif );
 
-- This helper returns the name of the corresponding helper in KM2Tools library
-- CONTEXT: KM3!Attribute
-- RETURN: String
helper context KM3!Attribute def: getOperationName() : String =
	if self.type.name = 'String' 
		then 'getStringProperty'
		else if self.type.name = 'Integer' 
				then 'getIntegerProperty'
				else if self.type.name = 'Boolean' 
						then 'getBooleanProperty'
						else ''
					 endif
			 endif
	endif;
------------------------------------------------------------------------------------------
-- RULES ---------------------------------------------------------------------------------
------------------------------------------------------------------------------------------

rule Metamodel {
	from
		m : KM3!Metamodel
	to
		t : ATL!Module (
			name <- 'KM22' + thisModule.km3PackageName,
			outModels <- tm,
			inModels <- sm,
			elements <-
				Sequence{
					KM3!Class.allInstances()
						->select(e | e.package.name <> 'PrimitiveTypes')
						->asSequence()
				},
			libraries <- Sequence{lib},
			isRefining <- false
		),
		sm : ATL!OclModel (
			name <- 'IN',
			metamodel <- mm1
		),
		tm : ATL!OclModel (
			name <- 'OUT',
			metamodel <- mm2
		),
		mm1 : ATL!OclModel (
			name <- 'KM2'
		),
		mm2 : ATL!OclModel (
			name <- thisModule.km3PackageName
		),
		lib : ATL!LibraryRef (
			name <- 'KM2Tools',
			unit <- t
		)
}

rule Class {
	from
		c : KM3!Class (
			c.package.name <> 'PrimitiveTypes'
		)
	using {
		allSfs : Set(KM3!StructuralFeature) = c.allStructuralFeatures();
		allRefs : Set(KM3!Reference) =  allSfs->select(e | e.oclIsTypeOf(KM3!Reference) );
		allAttr : Set(KM3!Attribute) = 	allSfs->select(e | e.oclIsTypeOf(KM3!Attribute) );
	}
	to
		atl : ATL!MatchedRule (
			name <- c.name,
			inPattern <- inPat,
			outPattern <- outPat,
			isRefining <- false,
			isAbstract <- false
		),
		-- InPattern
		inPat : ATL!InPattern (
			elements <- elementin,
			filter <- oc
		),
		-- Filter	
		oc : ATL!OperatorCallExp (
			operationName <- '=',
			source <- noac,
			arguments <- Sequence{s}				
		),
		noac : ATL!NavigationOrAttributeCallExp (
			name <- 'name',
			source <-fv
		),
		fv : ATL!VariableExp (
			name <- 'me',
			referredVariable <- elementin
		),
		s : ATL!StringExp (
			stringSymbol <- c.name
		),
			
		elementin : ATL!SimpleInPatternElement(
			id <- 'me0',
			varName <- 'me',
			type <- intype
		),
		intype : ATL!OclModelElement (
			name <- 'ModelElement',
			model <- thisModule.resolveTemp(thisModule.metamodel,'mm1')
		),
	
		-- OutPattern
		outPat : ATL!OutPattern (
			elements <- elementout
		),
		elementout : ATL!SimpleOutPatternElement (
			varName <- 'c',
			type <- outtype,
			bindings <-
				Sequence{
					allRefs->select(e | thisModule.usedReferences->includes(e)),
					allAttr
				}
		),
		outtype : ATL!OclModelElement (
			name <- c.name,
			model <- thisModule.resolveTemp(thisModule.metamodel,'mm2')
		)
}

rule Attribute {
	from
		a : KM3!Attribute
	to
		b : ATL!Binding (
			propertyName <- a.name,
			value <- oc
		),
		oc : ATL!OperationCallExp (
			operationName <- a.getOperationName(),
			source <- fv,
			arguments <- Sequence {s}
		),
		fv : ATL!VariableExp (
			name <- 'me',
			referredVariable <- thisModule.resolveTemp(a.owner,'elementin')
		),
		s : ATL!StringExp (
			stringSymbol <- a.name
		)
}

rule ReferenceMultiple {
	from
		r : KM3!Reference (
			thisModule.usedReferences->includes(r) and r.upper = 0-1 
		)
	to
		b : ATL!Binding (
			propertyName <- r.name,
			value <- oc
		),
		oc : ATL!OperationCallExp (
			operationName <- if r.isContainer then 'getSet' else 'getRefSet' endif,
			source <- fv,
			arguments <- Sequence {s}
		),
		fv : ATL!VariableExp (
			name <- 'me',
			referredVariable <- thisModule.resolveTemp(r.owner,'elementin')
		),
		s : ATL!StringExp (
			stringSymbol <- r.name
		)
}

rule Reference {
	from
		r : KM3!Reference (
			thisModule.usedReferences->includes(r) and not (r.upper = 0-1)
		)
	to
		b : ATL!Binding (
			propertyName <- r.name,
			value <- oc
		),
		oc : ATL!OperationCallExp (
			operationName <- 'get',
			source <- fv,
			arguments <- Sequence {s}
		),
		fv : ATL!VariableExp (
			name <- 'me',
			referredVariable <- thisModule.resolveTemp(r.owner,'elementin')
		),
		s : ATL!StringExp (
			stringSymbol <- r.name
		)
}
",modul km atl km mm creat out atl in km helper this helper contain km metamodel context thismodul return km metamodel helper def metamodel km metamodel km metamodel allinst assequ first this helper contain name km packag primitivetyp packag context thismodul return string helper def km packagenam string km packag allinst select e e name primitivetyp first name this helper return set contain structur featur km class includ supertyp context km class return set km structuralfeatur helper context km class def allstructuralfeatur set km structuralfeatur self supertyp iter e acc set km structuralfeatur self structuralfeatur acc union e allstructuralfeatur this helper return sequenc km refer without opposit context thismodul return sequenc km refer helper def usedrefer sequenc km refer km refer allinst iter e acc sequenc km refer sequenc acc includ e opposit acc els e isord e opposit iscontain acc els e isord e upper e upper acc includ e els e iscontain acc includ e els acc endif endif endif endif this helper return name correspond helper km tool librari context km attribut return string helper context km attribut def getoperationnam string self type name string getstringproperti els self type name integ getintegerproperti els self type name boolean getbooleanproperti els endif endif endif rule rule metamodel km metamodel atl modul name km thismodul km packagenam outmodel tm inmodel sm element sequenc km class allinst select e e packag name primitivetyp assequ librari sequenc lib isrefin fals sm atl oclmodel name in metamodel mm tm atl oclmodel name out metamodel mm mm atl oclmodel name km mm atl oclmodel name thismodul km packagenam lib atl libraryref name km tool unit rule class c km class c packag name primitivetyp use allsf set km structuralfeatur c allstructuralfeatur allref set km refer allsf select e e oclistypeof km refer allattr set km attribut allsf select e e oclistypeof km attribut atl atl matchedrul name c name inpattern inpat outpattern outpat isrefin fals isabstract fals inpattern inpat atl inpattern element elementin filter oc filter oc atl operatorcallexp operationnam sourc noac argument sequenc noac atl navigationorattributecallexp name name sourc fv fv atl variableexp name referredvari elementin atl stringexp stringsymbol c name elementin atl simpleinpatternel id varnam type intyp intyp atl oclmodelel name modelel model thismodul resolvetemp thismodul metamodel mm outpattern outpat atl outpattern element elementout elementout atl simpleoutpatternel varnam c type outtyp bind sequenc allref select e thismodul usedrefer includ e allattr outtyp atl oclmodelel name c name model thismodul resolvetemp thismodul metamodel mm rule attribut km attribut b atl bind propertynam name valu oc oc atl operationcallexp operationnam getoperationnam sourc fv argument sequenc fv atl variableexp name referredvari thismodul resolvetemp owner elementin atl stringexp stringsymbol name rule referencemultipl r km refer thismodul usedrefer includ r r upper b atl bind propertynam r name valu oc oc atl operationcallexp operationnam r iscontain getset els getrefset endif sourc fv argument sequenc fv atl variableexp name referredvari thismodul resolvetemp r owner elementin atl stringexp stringsymbol r name rule refer r km refer thismodul usedrefer includ r r upper b atl bind propertynam r name valu oc oc atl operationcallexp operationnam get sourc fv argument sequenc fv atl variableexp name referredvari thismodul resolvetemp r owner elementin atl stringexp stringsymbol r name,18
41,41,P26-KM32DSL.atl,"-- Ecore to DSL
-- first transformation : KM3 to DSL

module KM32DSL;
create OUT : DSL from IN : KM3;

-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Those helper store integer values used to assign ID or to difference similar names
-- RETURN:  Integer
helper def: curId : Integer = 0; 
helper def: diff1 : Integer = 0;

-- This helper increments diff1 value
-- CONTEXT: thisModule
-- RETURN:  Integer
helper def: incDiff1() : Integer =
thisModule.refSetValue('diff1', thisModule.diff1+1).diff1; 

helper def: diff2 : Integer = 0;

-- This helper increments diff1 value
-- CONTEXT: thisModule
-- RETURN:  Integer
helper def: incDiff2() : Integer =
thisModule.refSetValue('diff2', thisModule.diff2+1).diff2; 

-- This helper stores the namespace
-- CONTEXT: thisModule
-- RETURN:  String
helper def: Namespace : String = '.DomainModel';

-- This helper sets the namespace
-- CONTEXT: thisModule
-- RETURN:  String
helper context KM3!Package def: setNamespace() : String = 
	thisModule.refSetValue('Namespace', self.name+thisModule.Namespace).Namespace;

-- This helper computes the value to be assigned to the ID field of a
-- generated Task. 
-- It increments the value stored by the ""curId"" helper and returns its
-- new value as a String.
-- CONTEXT: thisModule
-- RETURN: String
helper def: makeIdentity() : String =
	let i : Integer = thisModule.refSetValue('curId', thisModule.curId + 1).curId 
in '10000000-0000-0000-0000-'+
if i<=9 then '00000000000'+i.toString()
	else if i<=99 then '0000000000'+i.toString()
		else if i<=999 then '000000000'+i.toString()
			else '00000000'+i.toString()
			endif
		endif
	endif; 

-- This helper get a list of references which need to be turned
-- into relationship
-- CONTEXT: thisModule
-- RETURN: Sequence(KM3!Reference)
helper def: list:Sequence(KM3!Reference) = 
self.getRefs()->iterate(e; seq : Sequence(KM3!Reference) = Sequence{} |  
 if e.opposite.oclIsUndefined() 
  then seq.append(e)
  else  	
  	if seq->includes(e.opposite) or seq->includes(e)
	then seq 
    else   	
    	if e.isEmbedding() 
		then 
-- EMBEDDING 
			if e.isContainer
			-- e is the first role
			then seq.append(e)
			-- e.opposite is the first role
			else seq.append(e.opposite)
			endif
		else
-- REFERENCE
			seq.append(e)
		endif
	endif
  endif
); 

-- This helper get the list of all references
-- CONTEXT: thisModule
-- RETURN: Sequence(KM3!Reference)
helper def: getRefs() : Sequence(KM3!Reference) = 
	self.getClasses()
		->iterate(e; acc : Sequence(KM3!Reference) = Sequence {} |
			acc->union(e.getRefs())
		);

-- This helper get the list of the references owned by a class
-- CONTEXT: thisModule
-- RETURN: Sequence(KM3!Reference)
helper context KM3!Class def: getRefs() : Sequence(KM3!Reference) = 
	self.structuralFeatures
		->select(e | e.oclIsTypeOf(KM3!Reference))
		->asSequence();

-- This helper get the list of all classes
-- CONTEXT: thisModule
-- RETURN: Sequence(KM3!Class)
helper def: getClasses() : Sequence(KM3!Class) = 
	KM3!Package.allInstances()
		->select(p | p.name<>'PrimitiveTypes')
		->asSequence()
		->first().contents
			->select(e | e.oclIsTypeOf(KM3!Class))
			->asSequence();

-- This helper get the list of all enumerations
-- CONTEXT: thisModule
-- RETURN: Sequence(KM3!Enumeration)
helper context KM3!Package def: getEnumerations() : Sequence(KM3!Enumeration) = 
  self.contents->select(e|e.oclIsTypeOf(KM3!Enumeration))->asSequence(); 

-- This helper get the list of all Datatypes
-- CONTEXT: thisModule
-- RETURN: Sequence(KM3!DataType)
helper context KM3!Package def: getTypes() : Sequence(KM3!DataType) = 
  KM3!DataType.allInstances()->asSequence(); 

-- This helper checks the Unbounded constraint
-- CONTEXT: KM3!Reference
-- RETURN: Boolean
helper context KM3!Reference def: isUnbounded() : Boolean =
self.lower=0 and self.upper=(0-1);	

-- This helper get the type of the relation of the input role
-- CONTEXT: KM3!Reference
-- RETURN: Boolean
helper context KM3!Reference def: isEmbedding() : Boolean =
self.isContainer or 
if not self.opposite.oclIsUndefined() then self.opposite.isContainer
else false endif;

-- This helper checks if the Relationship name we are going to create
-- is ever used
-- CONTEXT: KM3!Reference
-- RETURN: Boolean
helper context KM3!Reference def: notExists() : Boolean =
thisModule.list->
iterate(e; acc : Boolean = true |acc and 
not (self.owner=e.owner and self.type=e.type and self<>e));

-- This helper checks if the Relationship name we are going to create
-- is ever used
-- CONTEXT: KM3!Reference
-- RETURN: Boolean
helper context KM3!Reference def: everUsed() : Boolean =
KM3!Reference.allInstances()->
iterate(e; acc : Boolean = false |acc or 
(self.name=e.name and self.type=e.type and self<>e));

-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'DomainModel'.
-- This rule generates the DomainModel
rule DomainModel {
	from
		e : KM3!Package (
			e.name <> 'PrimitiveTypes'
		)
	to
		d : DSL!DomainModel (
			identity<-thisModule.makeIdentity(),
			namespace <- e.setNamespace(),
			name <- e.name,	
			isLoaded <- true,
			classifiers <-
				Sequence{
					thisModule.getClasses(),
					thisModule.getRefs()
						->select(e | thisModule.list->includes(e))
				},			
			types <-Sequence{e.getEnumerations(),e.getTypes()}
		)				
}

-- Rule 'Class'.
-- This rule generates a DSL!Class and link it to his supertypes,
-- and properties, and generates an identity
rule Class {
	from 
		e : KM3!Class 
	to 
		c : DSL!Class (		
			namespace <- thisModule.Namespace,
			isLoaded <- true,
			superType <- e.supertypes->select(a|a.oclIsTypeOf(KM3!Class))->first(),		
			identity<-thisModule.makeIdentity(),
			name <- e.name,
			isAbstract<-e.isAbstract,
		    properties<-e.structuralFeatures->select(a|a.oclIsTypeOf(KM3!Attribute))
			)
}

-- Rule 'Relationship'.
-- This rule generates a DSL!Relationship and his roles,
-- getting them in the list previously created
rule Relationship {
	from 
		e : KM3!Reference (
		thisModule.list->includes(e) and not e.opposite.oclIsUndefined() 
	)
		to 
		r: DSL!Relationship (
			name<-		
			let link : String =
					if e.isEmbedding()
					then 'has' else 'to' endif
				in 
			let n : String =
				e.owner.name+link+e.type.name
			in
				if e.notExists() then n
				else n+'-'+thisModule.incDiff1().toString()
				 endif
				,
			identity<-thisModule.makeIdentity(),
			namespace <- thisModule.Namespace,
			roles <- Sequence{s,t},
		    isEmbedding<-e.isEmbedding(),
			--default values
			isAbstract<-false,
			isLoaded <- true		
			),
			
		s : DSL!Role (
			identity<-thisModule.makeIdentity(),
			accepts<-'all' ,
			name<-e.name,
			relation<- r,
			source<-e.owner,
			type<-e.type,
			min<-e.lower,
			max<-if e.upper=(0-1) then 0 else e.upper endif,		 
			isOrdered<-e.isOrdered,
			isUnbounded <- e.isUnbounded(),
			isNavigableFrom <- false
			),
			
		t : DSL!Role (
			identity<-thisModule.makeIdentity(),
			accepts<-'all' , 
			name<-e.opposite.name,
			relation<- r,
			source<-e.opposite.owner,
			type<-e.opposite.type,
			min<-e.opposite.lower,
			max<-if e.opposite.upper=(0-1) then 0 else e.opposite.upper endif,		
			isOrdered<-e.opposite.isOrdered,	
			isUnbounded <-e.opposite.isUnbounded(),
			isNavigableFrom <-  false
			)
}

-- Rule 'RelationshipFromSingle'.
-- This rule generates a DSL!Relationship and his roles,
-- if the reference of the list has no opposite
rule RelationshipFromSingle {
	from 
		e : KM3!Reference 
		(
		thisModule.list->includes(e) and e.opposite.oclIsUndefined() 
	)
	to 
		r: DSL!Relationship (
			name<-		
			let link : String =
					if e.isEmbedding()
					then 'has' else 'to' endif
				in 
			let n : String =
				e.owner.name+link+e.type.name
			in
				if e.notExists() then n
				else n+'-'+thisModule.incDiff1().toString()
				 endif
				,
			identity<-thisModule.makeIdentity(),
			namespace <- thisModule.Namespace,
			roles <- Sequence{s,t},
		    isEmbedding<-e.isEmbedding(),
			--default values
			isAbstract<-false,
			isLoaded <- true		
			),
			
		s : DSL!Role (
			identity<-thisModule.makeIdentity(),
			accepts<-'all' ,
			name<-e.name,
			relation<- r,
			source<-e.owner,
			type<-e.type,
			min<-e.lower,
			max<-if e.upper=(0-1) then 0 else e.upper endif,		 
			isOrdered<-e.isOrdered,
			isUnbounded <- e.isUnbounded(),
			isNavigableFrom <- false
			),
			
		t : DSL!Role (
			identity<-thisModule.makeIdentity(),
			accepts<-'all' , 
			name<-if e.everUsed() then
			e.name+thisModule.incDiff2().toString() 
			else e.name endif +'Opposite',
			relation<- r,
			source<-e.type,
			type<-e.owner,
			min<-1,
			max<-1,		
			isOrdered<-false,	
			isUnbounded <-false,
			isNavigableFrom <-  false
			)
}

-- Rule 'ValueProperty'.
-- This rule generates a property
rule ValueProperty {
	from 
		e : KM3!Attribute
	to 
		p : DSL!ValueProperty (
			identity<-thisModule.makeIdentity(),
			name <- e.name,
			type<- e.type
			)		
}	

-- Rule 'Enumeration'.
-- This rule generates an Enumeration
rule Enumeration {
	from 
		e : KM3!Enumeration
	to 
		r : DSL!Enumeration (
			name <- e.name,
			namespace <- thisModule.Namespace,
			identity <- thisModule.makeIdentity(),
			literals <- e.literals->select(a|a.oclIsTypeOf(KM3!EnumLiteral))
		)
}

-- Rule 'EnumerationLiteral'.
-- This rule generates an single element of an Enumeration
rule EnumerationLiteral {
	from 
	e : KM3!EnumLiteral
	to
	r : DSL!EnumerationLiteral(
		name<-e.name,
		identity <- thisModule.makeIdentity(),
		value<-0	
	)
}

-- Rule 'SimpleType'.
-- This rule generates the DSL!SimpleType corresponding to a KM3!Datatype
rule SimpleType {
	from 
	e : KM3!DataType
	to
	t : DSL!SimpleType (name<-if e.name = 'Real' then 'Double' else e.name endif )	
}",ecor dsl first transform km dsl modul km dsl creat out dsl in km helper those helper store integ valu use assign id differ similar name return integ helper def curid integ helper def diff integ this helper increment diff valu context thismodul return integ helper def incdiff integ thismodul refsetvalu diff thismodul diff diff helper def diff integ this helper increment diff valu context thismodul return integ helper def incdiff integ thismodul refsetvalu diff thismodul diff diff this helper store namespac context thismodul return string helper def namespac string domainmodel this helper set namespac context thismodul return string helper context km packag def setnamespac string thismodul refsetvalu namespac self name thismodul namespac namespac this helper comput valu assign id field generat task it increment valu store curid helper return new valu string context thismodul return string helper def makeident string let integ thismodul refsetvalu curid thismodul curid curid tostr els tostr els tostr els tostr endif endif endif this helper get list refer need turn relationship context thismodul return sequenc km refer helper def list sequenc km refer self getref iter e seq sequenc km refer sequenc e opposit oclisundefin seq append e els seq includ e opposit seq includ e seq els e isembed embed e iscontain e first role seq append e e opposit first role els seq append e opposit endif els refer seq append e endif endif endif this helper get list refer context thismodul return sequenc km refer helper def getref sequenc km refer self getclass iter e acc sequenc km refer sequenc acc union e getref this helper get list refer own class context thismodul return sequenc km refer helper context km class def getref sequenc km refer self structuralfeatur select e e oclistypeof km refer assequ this helper get list class context thismodul return sequenc km class helper def getclass sequenc km class km packag allinst select p p name primitivetyp assequ first content select e e oclistypeof km class assequ this helper get list enumer context thismodul return sequenc km enumer helper context km packag def getenumer sequenc km enumer self content select e e oclistypeof km enumer assequ this helper get list datatyp context thismodul return sequenc km datatyp helper context km packag def gettyp sequenc km datatyp km datatyp allinst assequ this helper check unbound constraint context km refer return boolean helper context km refer def isunbound boolean self lower self upper this helper get type relat input role context km refer return boolean helper context km refer def isembed boolean self iscontain self opposit oclisundefin self opposit iscontain els fals endif this helper check relationship name go creat ever use context km refer return boolean helper context km refer def notexist boolean thismodul list iter e acc boolean true acc self owner e owner self type e type self e this helper check relationship name go creat ever use context km refer return boolean helper context km refer def everus boolean km refer allinst iter e acc boolean fals acc self name e name self type e type self e rule rule domainmodel this rule generat domainmodel rule domainmodel e km packag e name primitivetyp dsl domainmodel ident thismodul makeident namespac e setnamespac name e name isload true classifi sequenc thismodul getclass thismodul getref select e thismodul list includ e type sequenc e getenumer e gettyp rule class this rule generat dsl class link supertyp properti generat ident rule class e km class c dsl class namespac thismodul namespac isload true supertyp e supertyp select oclistypeof km class first ident thismodul makeident name e name isabstract e isabstract properti e structuralfeatur select oclistypeof km attribut rule relationship this rule generat dsl relationship role get list previous creat rule relationship e km refer thismodul list includ e e opposit oclisundefin r dsl relationship name let link string e isembed els endif let n string e owner name link e type name e notexist n els n thismodul incdiff tostr endif ident thismodul makeident namespac thismodul namespac role sequenc isembed e isembed default valu isabstract fals isload true dsl role ident thismodul makeident accept name e name relat r sourc e owner type e type min e lower max e upper els e upper endif isord e isord isunbound e isunbound isnavigablefrom fals dsl role ident thismodul makeident accept name e opposit name relat r sourc e opposit owner type e opposit type min e opposit lower max e opposit upper els e opposit upper endif isord e opposit isord isunbound e opposit isunbound isnavigablefrom fals rule relationshipfromsingl this rule generat dsl relationship role refer list opposit rule relationshipfromsingl e km refer thismodul list includ e e opposit oclisundefin r dsl relationship name let link string e isembed els endif let n string e owner name link e type name e notexist n els n thismodul incdiff tostr endif ident thismodul makeident namespac thismodul namespac role sequenc isembed e isembed default valu isabstract fals isload true dsl role ident thismodul makeident accept name e name relat r sourc e owner type e type min e lower max e upper els e upper endif isord e isord isunbound e isunbound isnavigablefrom fals dsl role ident thismodul makeident accept name e everus e name thismodul incdiff tostr els e name endif opposit relat r sourc e type type e owner min max isord fals isunbound fals isnavigablefrom fals rule valueproperti this rule generat properti rule valueproperti e km attribut p dsl valueproperti ident thismodul makeident name e name type e type rule enumer this rule generat enumer rule enumer e km enumer r dsl enumer name e name namespac thismodul namespac ident thismodul makeident liter e liter select oclistypeof km enumliter rule enumerationliter this rule generat singl element enumer rule enumerationliter e km enumliter r dsl enumerationliter name e name ident thismodul makeident valu rule simpletyp this rule generat dsl simpletyp correspond km datatyp rule simpletyp e km datatyp dsl simpletyp name e name real doubl els e name endif,18
42,42,P26-XML2DSL.atl,"-- DSL to Ecore
-- first transformation : XML to DSL

module XML2DSL;
create OUT : DSL from IN : XML;

-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- This helper gets the Attribute who has value name = name and return it to a Boolean
-- CONTEXT: XML!Element
-- RETURN:  Boolean
helper context XML!Element def: getAttrBool(name : String) : Boolean =
	let a : String = 
    self.children->select(c | c.oclIsTypeOf(XML!Attribute) and c.name = name)->first().value
	in if a ='true' then true else false endif;

-- This helper gets the Attribute who has value name = name
-- CONTEXT: XML!Element
-- RETURN:  String
helper context XML!Element def: getAttrVal(name : String) : String =
    self.children->select(c | c.oclIsTypeOf(XML!Attribute) and c.name = name)->first().value;

-- This helper gets the value of the attribute who has value name=name 
-- from a child of self
-- CONTEXT: XML!Element
-- RETURN:  String
helper context XML!Element def: get(child : String,name : String) : String =
    self.children -> select(c | c.oclIsTypeOf(XML!Element) and c.name = child)->collect(d | d.children)->flatten()
	->select(b | b.oclIsTypeOf(XML!Attribute) and b.name = name )->first().value;

-- This helper gets the Type of a property.
-- CONTEXT: XML!Element
-- RETURN:  String
helper context XML!Element def: getType() : String =
	let type : String = self.children->select(c | c.oclIsTypeOf(XML!Element) 
		and c.name = 'propertyInfo')->first().getAttrVal('xsi:type') 
	in	type.substring(1,type.size()-12);

-- This helper stores an integer value used to assign an ID to each generated.
-- CONTEXT: XML!Element
-- RETURN:  String
helper context XML!Element def: getEnumId() : String =
  self.children->select(c | c.oclIsTypeOf(XML!Element) and c.name = 'propertyInfo')
	->first().getText('enumeration');

-- This helper gets Text from an XML!Element who has a child with a name value = name 
-- and with a child XML!Text.
-- CONTEXT: XML!Element
-- RETURN:  String
helper context XML!Element def: getText(name : String) : String =
	let e :Sequence(XML!Element) =
	self.children-> select(m | m.oclIsTypeOf(XML!Element) )
	in
	if e.isEmpty() then '' else
		let r:Sequence(XML!Element) =
	    e->select (f|f.name=name)
		in
		if r.isEmpty() then '' else
			r-> collect(d | d.children )->flatten()
			->select(f | f.oclIsTypeOf(XML!Text) )
			->select ( g | g.name = '#text' )->first().value
		endif
	endif;

-- This helper return a Sequence of XML!Element from a child name of a child names of self
-- CONTEXT: XML!Element
-- RETURN:  Sequence(XML!Element)
helper context XML!Element def: getSeq(names : String,name : String) : Sequence(XML!Element) =
	self.children -> select(m | m.oclIsTypeOf(XML!Element) and m.name = names )
	-> collect(d | d.children )->flatten()->select(m | m.oclIsTypeOf(XML!Element) and m.name = name );

-- This helper say if an XML!Element has a child with value name = name
-- CONTEXT: XML!Element
-- RETURN:  Boolean
helper context XML!Element def: hasChildren(name : String) : Boolean =
	let a : XML!Element =
	self.children-> select(m | m.oclIsTypeOf(XML!Element) and m.name = name )->first()
	in if (a.oclIsTypeOf(XML!Element) and a.name = name) 
		then true else false 
	endif;

-- This helper stores an integer value used to assign an ID to each generated
-- CONTEXT: XML!Element
-- RETURN:  Boolean
--teste si l'element possede un certain XMLattribut
helper context XML!Element def: hasAttr(name : String) : Boolean =
	let a : XML!Attribute =
	self.children-> select(m | m.oclIsTypeOf(XML!Attribute) and m.name = name )->first()
	in if not a.oclIsUndefined()
		then (a.name = name) else false
	endif;

-- This helper indicates if a Classifier is Abstract or not by searching in
-- the child mdfmetada of self
-- CONTEXT: XML!Element
-- RETURN:  Boolean
helper context XML!Element def: isAbstract() : Boolean = 
	let a : XML!Element =
		if self.hasChildren('mdfmetadata')
		then
		self.children->select(n|n.name = 'mdfmetadata')->first()
		else self
		endif
		in
	if a = self
		then false
		else
			if a.hasAttr('classmodifier') 
				then a.getAttrVal('classmodifier') = 'abstract'
				else false 
			endif
	endif;

-- This helper produce a Map of XML!Element corresponding to concept,relationship,enumeration
-- by identity to help majing references
-- CONTEXT: thisModule
-- RETURN:  Map(String, XML!Element)
helper def: dslElementsById : Map(String, XML!Element) =
    XML!Element.allInstances()->iterate(e; acc : Map(String,XML!Element) = Map {} |
        if ((e.name='concept' or e.name='relationship' or e.name ='enumeration') and e.hasAttr('id')) then
             acc->including( e.getAttrVal('id'), e)
        else
             acc
        endif
    );

-- This helper produce a Map of roles, containmentstyle
-- for all the roles of the selected Relationship, we look for it in the map
-- return true for embedding, false for reference
helper context XML!Element def: getContainment() : Boolean =
	let id1: String =self.getSeq('roles','role').first().getAttrVal('id') in
	let id2: String =self.getSeq('roles','role').last().getAttrVal('id') in
	let containmentstyle : Boolean =
	XML!Element.allInstances()->
	select(t|  
	if t.name='role'  
	then if t.parent.name='treeExpression' 
		then (t.parent.getText('role')=id1 or
			t.parent.getText('role')=id2) 
			and	t.parent.getAttrVal('containmentstyle')<>'fromsource'
			and	t.parent.getAttrVal('containmentstyle')<>'reference'
		else false endif 
	else false endif)
	->first().oclIsUndefined()
	in not containmentstyle;
	
-- This helper return a Sequence of XML!Element who are subType of the XML!Element 
-- who has is id = id
-- CONTEXT: thisModule
-- RETURN:  Sequence(XML!Element)
helper def: getSubTypes(id:String): Sequence(XML!Element)=
XML!Element.allInstances()->iterate(e; acc : Sequence(XML!Element) = Sequence {} |
        if ((e.name='concept' or e.name='relationship') and e.hasAttr('superType')) then
			if e.getText('superType')=id 
				then  acc->including(e)
        		else  acc
        	endif else acc 
		endif );

-- This helper return the DSL!SimpleType that match String
-- CONTEXT: thisModule
-- RETURN:  DSL!SimpleType
helper def: findType(s:String) : DSL!SimpleType =
	let a : XML!Element =
		XML!Element.allInstances() -> select(e | if e.name = 'model'
					then if e.parent.name = 'dmd'
						then e.getAttrVal('name') <> 'Core'
						else false endif
					else false
				endif )-> first() 
	in
	if s='String' 
	then thisModule.resolveTemp(a,'str')
	else 
		if s='Integer' or s='Long' 
		then thisModule.resolveTemp(a,'int')
		else 
			if s='Double' 
			then thisModule.resolveTemp(a,'double')
			else thisModule.resolveTemp(a,'bool') 
			endif
		endif
	endif;

-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'DomainModel'.
-- This rule generates the DomainModel, which will content all the relevants 
-- informations of the model
rule DomainModel {
	from
		e : XML!Element (
				if e.name = 'model'
					then if e.parent.name = 'dmd'
						then e.getAttrVal('name') <> 'Core'
						else false endif
					else false
				endif
		)
	to
		d : DSL!DomainModel (
			name <- e.getAttrVal('name'),
			identity <- e.getAttrVal('identity'),		
			namespace <- e.getAttrVal('namespace'),
			isLoaded <- e.getAttrBool('isLoaded'),
			classifiers <- Sequence{
					e.getSeq('concepts','concept'),
					e.getSeq('relationships','relationship')			
					},
			types <- Sequence{e.getSeq('enumerations','enumeration'),str,int,bool,double}
		),
		str : DSL!SimpleType (
			name<-'String'
		),	
		int : DSL!SimpleType (
			name<-'Integer'
		),		
		bool : DSL!SimpleType (
			name<-'Boolean'
		),
		double : DSL!SimpleType (
			name<-'Double'
		)	
}

-- Rule 'Class'.
-- This rule generates a DSL!Class and link it to his supertypes,
-- subtypes and properties
rule Class {
	from 
		e : XML!Element (
			e.name = 'concept'				
		)
	to 
		c : DSL!Class (
			name <- e.getAttrVal('name'),
			identity <- e.getAttrVal('identity'),
			namespace <- e.getAttrVal('namespace'),
			isLoaded <- e.getAttrBool('isLoaded'),
			isAbstract <- e.isAbstract(),
--			properties <- Sequence{e.getSeq('valueProperties','property').append(nm)},
			properties <- Sequence{e.getSeq('valueProperties','property')},
			domainModel <- e.parent.parent,
			superType <- thisModule.dslElementsById.get(e.getText('superType')),
			subTypes<-thisModule.getSubTypes(e.getAttrVal('id'))
		)--,
--		nm : DSL!ValueProperty (
--			name<-'Name',
--			type<-thisModule.findType('String')
--		)
}

-- Rule 'Relationship'.
-- This rule generates a DSL!Relationship and link it to his supertypes,
-- subtypes, roles and properties
rule Relationship {
	from 
		e : XML!Element (
			e.name = 'relationship'
		)
	to 
		r : DSL!Relationship (
			name <- e.getAttrVal('name'),
			identity <- e.getAttrVal('identity'),
			namespace <- e.getAttrVal('namespace'),
			isLoaded <- e.getAttrBool('isLoaded'),
			isAbstract <- e.isAbstract(),
			roles <- e.getSeq('roles','role'),
			domainModel <- e.parent.parent,
			isEmbedding <- e.getContainment(),
			properties <- e.getSeq('valueProperties','property'),
			superType <- thisModule.dslElementsById.get(e.getText('superType')),
			subTypes<-thisModule.getSubTypes(e.getAttrVal('id'))
		)		
}

-- Rule 'Role'.
-- This rule generates a DSL!Role and link it to his ends
rule Role {
	from 
		e : XML!Element (
			if e.name = 'role' 
				then e.parent.name = 'roles'
				else false
			endif			
		)
	to 
		r : DSL!Role (
			name <- e.getAttrVal('name'),
			identity <- e.getAttrVal('identity'),
			source <- thisModule.dslElementsById.get(e.getText('source')),
			type <- thisModule.dslElementsById.get(e.getText('type')),
			relation <- e.parent.parent,
			min<-e.getAttrVal('min').toInteger(),
			max<-e.getAttrVal('max').toInteger(),
			accepts <- e.getAttrVal('accepts'),
			isUnbounded <- e.getAttrBool('isUnbounded'),
			isOrdered <- e.children->select(a | a.oclIsTypeOf(XML!Element) and a.name='mdfmetadata')
						->first().getAttrBool('isordered'),
			isNavigableFrom <- e.children->select(a | a.oclIsTypeOf(XML!Element) and a.name='mdfmetadata')
						->first().getAttrBool('isnavigablefrom')
		)
}

-- Rule 'ValueProperty'.
-- This rule generates a property of a classifier
rule ValueProperty {
	from 
		e : XML!Element (
			if (e.name = 'property') 
				then e.parent.name = 'valueProperties'
				else false
			endif
		)
	to 
		p : DSL!ValueProperty (
			name <- e.getAttrVal('name'),
			identity <- e.getAttrVal('identity'),
			type <- if e.getType()<>'Enumeration' 
						then thisModule.findType(e.getType()) 
						else thisModule.dslElementsById.get(e.getEnumId())
					endif
		)
}	

-- Rule 'Enumeration'.
-- This rule generates an Enumeration
rule Enumeration {
	from 
		e : XML!Element (
			if e.name = 'enumeration' 
				then e.parent.name = 'enumerations'
				else false
			endif			
		)
	to 
		r : DSL!Enumeration (
			name <- e.getAttrVal('name'),
			identity <- e.getAttrVal('identity'),
			namespace <- e.getAttrVal('namespace'),
			literals <- e.getSeq('literals','enumerationLiteral')
		)
}

-- Rule 'EnumerationLiteral'.
-- This rule generates an single element of an Enumeration
rule EnumerationLiteral {
	from 
		e : XML!Element (
			if e.name = 'enumerationLiteral' 
				then e.parent.name = 'literals'
				else false
			endif			
		)
	to 
		r : DSL!EnumerationLiteral (
			name <- e.getAttrVal('name'),
			identity <- e.getAttrVal('identity'),
			value <- e.getAttrVal('value').toInteger()
		)
}
",dsl ecor first transform xml dsl modul xml dsl creat out dsl in xml helper this helper get attribut valu name name return boolean context xml element return boolean helper context xml element def getattrbool name string boolean let string self children select c c oclistypeof xml attribut c name name first valu true true els fals endif this helper get attribut valu name name context xml element return string helper context xml element def getattrv name string string self children select c c oclistypeof xml attribut c name name first valu this helper get valu attribut valu name name child self context xml element return string helper context xml element def get child string name string string self children select c c oclistypeof xml element c name child collect children flatten select b b oclistypeof xml attribut b name name first valu this helper get type properti context xml element return string helper context xml element def gettyp string let type string self children select c c oclistypeof xml element c name propertyinfo first getattrv xsi type type substr type size this helper store integ valu use assign id generat context xml element return string helper context xml element def getenumid string self children select c c oclistypeof xml element c name propertyinfo first gettext enumer this helper get text xml element child name valu name child xml text context xml element return string helper context xml element def gettext name string string let e sequenc xml element self children select oclistypeof xml element e isempti els let r sequenc xml element e select f f name name r isempti els r collect children flatten select f f oclistypeof xml text select g g name text first valu endif endif this helper return sequenc xml element child name child name self context xml element return sequenc xml element helper context xml element def getseq name string name string sequenc xml element self children select oclistypeof xml element name name collect children flatten select oclistypeof xml element name name this helper say xml element child valu name name context xml element return boolean helper context xml element def haschildren name string boolean let xml element self children select oclistypeof xml element name name first oclistypeof xml element name name true els fals endif this helper store integ valu use assign id generat context xml element return boolean test si l element possed un certain xmlattribut helper context xml element def hasattr name string boolean let xml attribut self children select oclistypeof xml attribut name name first oclisundefin name name els fals endif this helper indic classifi abstract search child mdfmetada self context xml element return boolean helper context xml element def isabstract boolean let xml element self haschildren mdfmetadata self children select n n name mdfmetadata first els self endif self fals els hasattr classmodifi getattrv classmodifi abstract els fals endif endif this helper produc map xml element correspond concept relationship enumer ident help maje refer context thismodul return map string xml element helper def dslelementsbyid map string xml element xml element allinst iter e acc map string xml element map e name concept e name relationship e name enumer e hasattr id acc includ e getattrv id e els acc endif this helper produc map role containmentstyl role select relationship look map return true embed fals refer helper context xml element def getcontain boolean let id string self getseq role role first getattrv id let id string self getseq role role last getattrv id let containmentstyl boolean xml element allinst select name role parent name treeexpress parent gettext role id parent gettext role id parent getattrv containmentstyl fromsourc parent getattrv containmentstyl refer els fals endif els fals endif first oclisundefin containmentstyl this helper return sequenc xml element subtyp xml element id id context thismodul return sequenc xml element helper def getsubtyp id string sequenc xml element xml element allinst iter e acc sequenc xml element sequenc e name concept e name relationship e hasattr supertyp e gettext supertyp id acc includ e els acc endif els acc endif this helper return dsl simpletyp match string context thismodul return dsl simpletyp helper def findtyp string dsl simpletyp let xml element xml element allinst select e e name model e parent name dmd e getattrv name core els fals endif els fals endif first string thismodul resolvetemp str els integ long thismodul resolvetemp int els doubl thismodul resolvetemp doubl els thismodul resolvetemp bool endif endif endif rule rule domainmodel this rule generat domainmodel content relev inform model rule domainmodel e xml element e name model e parent name dmd e getattrv name core els fals endif els fals endif dsl domainmodel name e getattrv name ident e getattrv ident namespac e getattrv namespac isload e getattrbool isload classifi sequenc e getseq concept concept e getseq relationship relationship type sequenc e getseq enumer enumer str int bool doubl str dsl simpletyp name string int dsl simpletyp name integ bool dsl simpletyp name boolean doubl dsl simpletyp name doubl rule class this rule generat dsl class link supertyp subtyp properti rule class e xml element e name concept c dsl class name e getattrv name ident e getattrv ident namespac e getattrv namespac isload e getattrbool isload isabstract e isabstract properti sequenc e getseq valueproperti properti append nm properti sequenc e getseq valueproperti properti domainmodel e parent parent supertyp thismodul dslelementsbyid get e gettext supertyp subtyp thismodul getsubtyp e getattrv id nm dsl valueproperti name name type thismodul findtyp string rule relationship this rule generat dsl relationship link supertyp subtyp role properti rule relationship e xml element e name relationship r dsl relationship name e getattrv name ident e getattrv ident namespac e getattrv namespac isload e getattrbool isload isabstract e isabstract role e getseq role role domainmodel e parent parent isembed e getcontain properti e getseq valueproperti properti supertyp thismodul dslelementsbyid get e gettext supertyp subtyp thismodul getsubtyp e getattrv id rule role this rule generat dsl role link end rule role e xml element e name role e parent name role els fals endif r dsl role name e getattrv name ident e getattrv ident sourc thismodul dslelementsbyid get e gettext sourc type thismodul dslelementsbyid get e gettext type relat e parent parent min e getattrv min tointeg max e getattrv max tointeg accept e getattrv accept isunbound e getattrbool isunbound isord e children select oclistypeof xml element name mdfmetadata first getattrbool isord isnavigablefrom e children select oclistypeof xml element name mdfmetadata first getattrbool isnavigablefrom rule valueproperti this rule generat properti classifi rule valueproperti e xml element e name properti e parent name valueproperti els fals endif p dsl valueproperti name e getattrv name ident e getattrv ident type e gettyp enumer thismodul findtyp e gettyp els thismodul dslelementsbyid get e getenumid endif rule enumer this rule generat enumer rule enumer e xml element e name enumer e parent name enumer els fals endif r dsl enumer name e getattrv name ident e getattrv ident namespac e getattrv namespac liter e getseq liter enumerationliter rule enumerationliter this rule generat singl element enumer rule enumerationliter e xml element e name enumerationliter e parent name liter els fals endif r dsl enumerationliter name e getattrv name ident e getattrv ident valu e getattrv valu tointeg,0
43,43,P26-XML2DSLModel.atl,"module XML2DSLModel; -- Module Template
create OUT : DSLModel  from IN1 : XML, IN2 : DSL;

-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- This helper recovers the Domainmodel name
-- CONTEXT : thisModule
-- RETURN : String
helper def : getDomainModelName() : String =
	DSL!DomainModel.allInstances()->select( e | e.oclIsTypeOf(DSL!DomainModel))->first().name;

-- This helper recover the namespace of the Domainmodel
-- CONTEXT : thisModule
-- RETURN : String
helper def : getNamespace() : String = 	DSL!DomainModel.allInstances()->select( e | e.oclIsTypeOf(DSL!DomainModel))->first().namespace+'.';

-- This helper subtitute the namespace to elements type
-- CONTEXT : thisModule
-- RETURN : String
helper def : subNamespace(type : String) : String =	type.substring(thisModule.getNamespace().size()+1,type.size());

-- This helper gets the Attribute who has value name = name and return it to a Boolean
-- CONTEXT: XML!Element
-- RETURN:  Boolean
helper context XML!Element def: getAttrBool(name : String) : Boolean =
	let a : String = 
    self.children->select(c | c.oclIsTypeOf(XML!Attribute) and c.name = name)->first().value
	in if a ='true' then true else false endif;

-- This helper gets the Attribute who has value name = name
-- CONTEXT: XML!Element
-- RETURN:  String
helper context XML!Element def: getAttrVal(name : String) : String =  
	self.children->select(c | c.oclIsTypeOf(XML!Attribute) and c.name = name)->first().value;

-- This helper tests if the XML!Element has an attribute with the name in parameter
-- CONTEXT: XML!Element
-- RETURN:  Boolean
helper context XML!Element def: hasAttr(name : String) : Boolean =
	let a : XML!Attribute =
	self.children-> select(m | m.oclIsTypeOf(XML!Attribute) and m.name = name )->first()
	in if (a.oclIsTypeOf(XML!Attribute) )
		then ( a.name = name) else false 
	endif;

-- This helper produce a Map of XML!Element corresponding to om:ModelElement 
-- by identity to help making references
-- CONTEXT: thisModule
-- RETURN:  Map(String, XML!Element)
helper def: ModelElementsById : Map(String, XML!Element) =
    XML!Element.allInstances()->iterate(e; acc : Map(String,XML!Element) = Map {} |
        if ((e.name='om:ModelElement') and e.hasAttr('Id')) then
             acc->including( e.getAttrVal('Id'), e)
        else
             acc
        endif
    );

-- This helper produce a Map of XML!Element corresponding to om:ElementLink
-- by identity to help making references
-- CONTEXT: thisModule
-- RETURN:  Map(String, XML!Element)
helper def: ElementLinksById : Map(String, XML!Element) =
    XML!Element.allInstances()->iterate(e; acc : Map(String,XML!Element) = Map {} |
        if ((e.name='om:ElementLink') and e.hasAttr('Id')) then
             acc->including( e.getAttrVal('Id'), e)
        else
             acc
        endif
    );

-- This helper recognize the XML!Element with a Type Attribute who terminate by Diagram
-- CONTEXT: XML!Element
-- RETURN:  Boolean
helper context XML!Element def: isElementDiagram() : Boolean =
	let a : String = self.getAttrVal('Type') in 
	let b : String = a.substring(a.size()- 6,a.size()) in 
	if ( b = 'Diagram' ) then true else false endif;
	
-- This helper return the XML!Element named om:ModelElemnt which is the Element whith a type 
-- that terminate by Diagram
-- CONTEXT: thisModule
-- RETURN:  XML!Element
helper def : elementToAvoid() : XML!Element = 
	 XML!Element.allInstances()->select(e | e.oclIsTypeOf(XML!Element) and e.name = 'om:ModelElement' )->
	 select( d | d.isElementDiagram() )->first();

-- This helper recognize the XML!Element who are children of e
-- CONTEXT: XML!Element
-- RETURN:  Boolean
helper context XML!Element def: isChildrenOf(e : XML!Element) : Boolean =
	let a : Boolean =
		if self.parent.oclIsKindOf(XML!Element)
			then if self.parent = e 
					then true 
					else self.parent.isChildrenOf(e) 
				endif
			else false
		endif
	in a;

-- This Module test if an XML!Element has the same Id has an ElementLink
-- CONTEXT : XML!Element
-- RETURN : Boolean
helper context XML!Element def : isElementLink() : Boolean =
	let a : Sequence(XML!Element) = 
	  XML!Element.allInstances()->select(e | e.name = 'om:ElementLink' )
	  ->select( b | b.getAttrVal('Id')=self.getAttrVal('Id'))->asSequence()
	in not a.isEmpty();

-- This helper collects in a Sequence all ElementLinks that have the same Id as the parameter
-- CONTEXT : thisModule
-- RETURN : Sequence(XML!Element)
helper  def: getElementLinks(id : String) : Sequence(XML!Element) =
	XML!Element.allInstances()->select(m | m.oclIsTypeOf(XML!Element) and m.name = 'om:ElementLink')
	->select( n | n.getAttrVal('Type') <> 'Microsoft.VisualStudio.Modeling.SubjectHasPresentation' ) 
	->iterate(e ; acc:Sequence(XML!Element) =  Sequence{} | 
		if e.getAttrVal('Id') = id
			then acc->including(e)
			else acc
		endif
	);

-- Those rules test the type of a property by matching it with the metamodel
-- CONTEXT : XML!Element
-- RETURN : Boolean
helper context XML!Element def : isString() : Boolean =
	let a : DSL!ValueProperty =
		DSL!Classifier.allInstances()->select( e | e.name = thisModule.subNamespace(self.parent.getAttrVal('Type')))
		->collect( d | d.properties)->flatten()->select( p | p.name = self.getAttrVal('Name'))->first()
	in if a.oclIsUndefined() then false else a.type.name = 'String' endif;

helper context XML!Element def : isBoolean() : Boolean =
	let a : DSL!ValueProperty =
		DSL!Classifier.allInstances()->select( e | e.name = thisModule.subNamespace(self.parent.getAttrVal('Type')))
		->collect( d | d.properties)->flatten()->select( p | p.name = self.getAttrVal('Name'))->first()
	in if a.oclIsUndefined() then false else a.type.name = 'Boolean' endif;

helper context XML!Element def : isInteger() : Boolean =
	let a : DSL!ValueProperty =
		DSL!Classifier.allInstances()->select( e | e.name = thisModule.subNamespace(self.parent.getAttrVal('Type')))
		->collect( d | d.properties)->flatten()->select( p | p.name = self.getAttrVal('Name'))->first()
	in if a.oclIsUndefined() then false else a.type.name = 'Integer' endif;

-- This helper returns a Sequence that containing all the value from attribute ParentLink 
-- from the context children 
-- CONTEXT : XML!Element
-- RETURN : Sequence(String)
helper context XML!Element def: getParentLinks() : Sequence(String) =
	self.children->select(m | m.oclIsTypeOf(XML!Element) )->select( n | n.name = 'om:ModelElement')
	->iterate(e;acc : Sequence(String) = Sequence{} |
	acc -> including(thisModule.subNamespace(e.getAttrVal('ParentLink'))) );	

-- This helper takes a String in parameter that corresponds to the value of an attribute ParentLink and returns
-- a Sequence of XML!Element that have this value
-- CONTEXT : XML!Element
-- RETURN : Sequence(XML!Element)
helper context XML!Element def: SequenceFromParentLink(pl : String) : Sequence(XML!Element) =
	self.children->select( e | e.oclIsTypeOf(XML!Element) and e.name = 'om:ModelElement' )
	->select( a | thisModule.subNamespace(a.getAttrVal('ParentLink')) = pl)->asSequence();

-- This helper creates a Sequence of Sequence of XML!Element by placing in a Sequence the XML!Element that have 
-- the same attribute ParentLink
-- CONTEXT : XML!Element
-- RETURN : Sequence(Sequence(XML!Element))
helper context XML!Element def: SequenceOfSequence( allpl : Set(String) ) : Sequence(Sequence(XML!Element)) =
	allpl->iterate(e;acc : Sequence(Sequence(XML!Element)) = Sequence{} | 
		acc -> including( self.SequenceFromParentLink(e) ) );

-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

rule Model {
	from 
		e : XML!Root
	to
		mm : DSLModel!Model(
			domainModel <- thisModule.getDomainModelName(),
			contents <-
				e.children
					->select(a | a.oclIsTypeOf(XML!Element) and
						(
						if a.name='om:ModelElement'
						then if a = thisModule.elementToAvoid()
							then false
							else not a.isChildrenOf(thisModule.elementToAvoid())
							endif
						else false
						endif
						)
					)->asSequence()
		)
}

rule ModelElement {
	from 
	e : XML!Element (
			if e.name='om:ModelElement'
				then if e = thisModule.elementToAvoid()
					then false
						else if e.isChildrenOf(thisModule.elementToAvoid())
								then false
								else not e.isElementLink()
							endif
					endif
				else false
			endif
		)
	using {
			allEmbeddingLinks : Set(String) = 
					e.getParentLinks()->asSet();
			allchilds : Sequence (Sequence(XML!Element)) = 
					e.SequenceOfSequence(allEmbeddingLinks);
	}
	to
	me : DSLModel!ModelElement (
		type <- thisModule.subNamespace(e.getAttrVal('Type')),
		id <- e.getAttrVal('Id'),
		properties <-
			e.children
				->select(c | c.oclIsTypeOf(XML!Element) and
--					c.name='om:Property'
					(
					if c.name='om:Property'
					then if c.parent.name='om:ModelElement'
						then if c.isChildrenOf(thisModule.elementToAvoid())
							then false
							else (c.isString() or c.isBoolean() or c.isInteger())
							endif
						else false
						endif
					else false
					endif
					)
				),
		embeddinglinks <- Sequence{p},
		referencelinks <-
			e.children
				->select(l | l.oclIsTypeOf(XML!Element) and 
--					l.name = 'om:ElementLink'
					(
					if l.name='om:ElementLink'
				  	then if l.isChildrenOf(thisModule.elementToAvoid())
						then false
						else l.getAttrVal('Type') <> 'Microsoft.VisualStudio.Modeling.SubjectHasPresentation'
						endif
					else false
					endif
					)
				)
	),
	p : distinct DSLModel!EmbeddingLink foreach ( pl in allEmbeddingLinks ) (
		name <- pl,
		elements <- allchilds
	)
}

rule ReferenceLink {
	from
		e:XML!Element (
		  if e.name='om:ElementLink'
		  	then if e.isChildrenOf(thisModule.elementToAvoid())
					then false
					else e.getAttrVal('Type') <> 'Microsoft.VisualStudio.Modeling.SubjectHasPresentation'
				endif
				else false
			endif
		)
	to
		el : DSLModel!ReferenceLink (
			type <- thisModule.subNamespace(e.getAttrVal('Type')),
			id <- e.getAttrVal('Id'),
			roles <- e.children->select(m | m.oclIsTypeOf(XML!Element) and m.name = 'om:Role')->asSequence(),
			modelElement <- thisModule.ModelElementsById.get(e.getAttrVal('Id'))
		)
}

rule ModelElementLink {
	from
		e : XML!Element (
			if e.name='om:ModelElement'
				then if e = thisModule.elementToAvoid()
					then false
						else if e.isChildrenOf(thisModule.elementToAvoid())
								then false
								else e.isElementLink()
							endif
					endif
				else false
			endif
		)
	to
		el : DSLModel!ModelElementLink (
			type <- thisModule.subNamespace(e.getAttrVal('Type')),
			id <- e.getAttrVal('Id'),
			properties <- e.children->select(c | c.oclIsTypeOf(XML!Element) and c.name='om:Property'),
			links <- thisModule.getElementLinks(e.getAttrVal('Id'))
		)
}

rule Role {
	from
		e : XML!Element (
			if e.name = 'om:Role'
				then if e.parent.getAttrVal('Type') <> 'Microsoft.VisualStudio.Modeling.SubjectHasPresentation'
						then if e.isChildrenOf(thisModule.elementToAvoid())
								then false
								else true
							endif
						else false
					endif
				else false
			endif
		)
	to
		r : DSLModel!Role (
			name <- e.getAttrVal('Name'),
			owner <- e.parent,
			element <- thisModule.ModelElementsById.get(e.getAttrVal('Id'))
		)
}

rule StringProperty {
	from 
		e:XML!Element (
		if e.name='om:Property'
			then  if e.parent.name='om:ModelElement'
					then if e.isChildrenOf(thisModule.elementToAvoid())
							then false
							else e.isString()
						endif
					else false
				endif
			else false
		endif
	)
	to
	p : DSLModel!Property(
		name<-e.getAttrVal('Name'),
		value <- v
	),
	v : DSLModel!StringValue (
		value <- e.getAttrVal('Value')
	)
}

rule BooleanProperty {
	from 
		e:XML!Element (
		if e.name='om:Property'
			then  if e.parent.name='om:ModelElement'
					then if e.isChildrenOf(thisModule.elementToAvoid())
							then false
							else e.isBoolean()
						endif
					else false
				endif
			else false
		endif
	)
	to
	p : DSLModel!Property(
		name<-e.getAttrVal('Name'),
		value <- v
	),
	v : DSLModel!BooleanValue (
		value <- e.getAttrBool('Value')
	)
}

rule IntegerProperty {
	from 
		e:XML!Element (
		if e.name='om:Property'
			then  if e.parent.name='om:ModelElement'
					then if e.isChildrenOf(thisModule.elementToAvoid())
							then false
							else e.isInteger()
						endif
					else false
				endif
			else false
		endif
	)
	to
	p : DSLModel!Property(
		name<-e.getAttrVal('Name'),
		value <- v
	),
	v : DSLModel!IntegerValue (
		value <- e.getAttrVal('Value').toInteger()
	)
}
",modul xml dslmodel modul templat creat out dslmodel in xml in dsl helper this helper recov domainmodel name context thismodul return string helper def getdomainmodelnam string dsl domainmodel allinst select e e oclistypeof dsl domainmodel first name this helper recov namespac domainmodel context thismodul return string helper def getnamespac string dsl domainmodel allinst select e e oclistypeof dsl domainmodel first namespac this helper subtitut namespac element type context thismodul return string helper def subnamespac type string string type substr thismodul getnamespac size type size this helper get attribut valu name name return boolean context xml element return boolean helper context xml element def getattrbool name string boolean let string self children select c c oclistypeof xml attribut c name name first valu true true els fals endif this helper get attribut valu name name context xml element return string helper context xml element def getattrv name string string self children select c c oclistypeof xml attribut c name name first valu this helper test xml element attribut name paramet context xml element return boolean helper context xml element def hasattr name string boolean let xml attribut self children select oclistypeof xml attribut name name first oclistypeof xml attribut name name els fals endif this helper produc map xml element correspond om modelel ident help make refer context thismodul return map string xml element helper def modelelementsbyid map string xml element xml element allinst iter e acc map string xml element map e name om modelel e hasattr id acc includ e getattrv id e els acc endif this helper produc map xml element correspond om elementlink ident help make refer context thismodul return map string xml element helper def elementlinksbyid map string xml element xml element allinst iter e acc map string xml element map e name om elementlink e hasattr id acc includ e getattrv id e els acc endif this helper recogn xml element type attribut termin diagram context xml element return boolean helper context xml element def iselementdiagram boolean let string self getattrv type let b string substr size size b diagram true els fals endif this helper return xml element name om modelelemnt element whith type termin diagram context thismodul return xml element helper def elementtoavoid xml element xml element allinst select e e oclistypeof xml element e name om modelel select iselementdiagram first this helper recogn xml element children e context xml element return boolean helper context xml element def ischildrenof e xml element boolean let boolean self parent ocliskindof xml element self parent e true els self parent ischildrenof e endif els fals endif this modul test xml element id elementlink context xml element return boolean helper context xml element def iselementlink boolean let sequenc xml element xml element allinst select e e name om elementlink select b b getattrv id self getattrv id assequ isempti this helper collect sequenc elementlink id paramet context thismodul return sequenc xml element helper def getelementlink id string sequenc xml element xml element allinst select oclistypeof xml element name om elementlink select n n getattrv type microsoft visualstudio model subjecthaspresent iter e acc sequenc xml element sequenc e getattrv id id acc includ e els acc endif those rule test type properti match metamodel context xml element return boolean helper context xml element def isstr boolean let dsl valueproperti dsl classifi allinst select e e name thismodul subnamespac self parent getattrv type collect properti flatten select p p name self getattrv name first oclisundefin fals els type name string endif helper context xml element def isboolean boolean let dsl valueproperti dsl classifi allinst select e e name thismodul subnamespac self parent getattrv type collect properti flatten select p p name self getattrv name first oclisundefin fals els type name boolean endif helper context xml element def isinteg boolean let dsl valueproperti dsl classifi allinst select e e name thismodul subnamespac self parent getattrv type collect properti flatten select p p name self getattrv name first oclisundefin fals els type name integ endif this helper return sequenc contain valu attribut parentlink context children context xml element return sequenc string helper context xml element def getparentlink sequenc string self children select oclistypeof xml element select n n name om modelel iter e acc sequenc string sequenc acc includ thismodul subnamespac e getattrv parentlink this helper take string paramet correspond valu attribut parentlink return sequenc xml element valu context xml element return sequenc xml element helper context xml element def sequencefromparentlink pl string sequenc xml element self children select e e oclistypeof xml element e name om modelel select thismodul subnamespac getattrv parentlink pl assequ this helper creat sequenc sequenc xml element place sequenc xml element attribut parentlink context xml element return sequenc sequenc xml element helper context xml element def sequenceofsequ allpl set string sequenc sequenc xml element allpl iter e acc sequenc sequenc xml element sequenc acc includ self sequencefromparentlink e rule rule model e xml root mm dslmodel model domainmodel thismodul getdomainmodelnam content e children select oclistypeof xml element name om modelel thismodul elementtoavoid fals els ischildrenof thismodul elementtoavoid endif els fals endif assequ rule modelel e xml element e name om modelel e thismodul elementtoavoid fals els e ischildrenof thismodul elementtoavoid fals els e iselementlink endif endif els fals endif use allembeddinglink set string e getparentlink asset allchild sequenc sequenc xml element e sequenceofsequ allembeddinglink dslmodel modelel type thismodul subnamespac e getattrv type id e getattrv id properti e children select c c oclistypeof xml element c name om properti c name om properti c parent name om modelel c ischildrenof thismodul elementtoavoid fals els c isstr c isboolean c isinteg endif els fals endif els fals endif embeddinglink sequenc p referencelink e children select l l oclistypeof xml element l name om elementlink l name om elementlink l ischildrenof thismodul elementtoavoid fals els l getattrv type microsoft visualstudio model subjecthaspresent endif els fals endif p distinct dslmodel embeddinglink foreach pl allembeddinglink name pl element allchild rule referencelink e xml element e name om elementlink e ischildrenof thismodul elementtoavoid fals els e getattrv type microsoft visualstudio model subjecthaspresent endif els fals endif el dslmodel referencelink type thismodul subnamespac e getattrv type id e getattrv id role e children select oclistypeof xml element name om role assequ modelel thismodul modelelementsbyid get e getattrv id rule modelelementlink e xml element e name om modelel e thismodul elementtoavoid fals els e ischildrenof thismodul elementtoavoid fals els e iselementlink endif endif els fals endif el dslmodel modelelementlink type thismodul subnamespac e getattrv type id e getattrv id properti e children select c c oclistypeof xml element c name om properti link thismodul getelementlink e getattrv id rule role e xml element e name om role e parent getattrv type microsoft visualstudio model subjecthaspresent e ischildrenof thismodul elementtoavoid fals els true endif els fals endif els fals endif r dslmodel role name e getattrv name owner e parent element thismodul modelelementsbyid get e getattrv id rule stringproperti e xml element e name om properti e parent name om modelel e ischildrenof thismodul elementtoavoid fals els e isstr endif els fals endif els fals endif p dslmodel properti name e getattrv name valu v v dslmodel stringvalu valu e getattrv valu rule booleanproperti e xml element e name om properti e parent name om modelel e ischildrenof thismodul elementtoavoid fals els e isboolean endif els fals endif els fals endif p dslmodel properti name e getattrv name valu v v dslmodel booleanvalu valu e getattrbool valu rule integerproperti e xml element e name om properti e parent name om modelel e ischildrenof thismodul elementtoavoid fals els e isinteg endif els fals endif els fals endif p dslmodel properti name e getattrv name valu v v dslmodel integervalu valu e getattrv valu tointeg,0
44,44,P26-XML2Text.atl,"query XML2Text = XML!Root.allInstances()
		->asSequence()
		->first().toString2('').writeTo('C:\\Example.dsldm');


helper context XML!Element def: toString2(indent : String) : String =
	let na : Sequence(XML!Node) =
		self.children->select(e | not e.oclIsKindOf(XML!Attribute)) in
	let a : Sequence(XML!Node) =
		self.children->select(e | e.oclIsKindOf(XML!Attribute)) in
	indent + '<' + self.name + 
	a->iterate(e; acc : String = '' |
		acc + ' ' + e.toString2()
	) +
	if na->size() > 0 then
		'>'
		+ na->iterate(e; acc : String = '' |
			acc + 
			if e.oclIsKindOf(XML!Text) then
				''
			else
				'\r\n'
			endif
			+ e.toString2(indent + '  ')
		) +
		if na->first().oclIsKindOf(XML!Text) then
			'</' + self.name + '>'
			else
				'\r\n' + indent + '</' + self.name + '>'
		endif
	else
		'/>'
	endif;

	
helper context XML!Attribute def: toString2() : String =
	self.name + '=\""' + self.value + '\""';


helper context XML!Text def: toString2() : String =
	self.value;
",queri xml text xml root allinst assequ first tostr writeto c exampl dsldm helper context xml element def tostr indent string string let na sequenc xml node self children select e e ocliskindof xml attribut let sequenc xml node self children select e e ocliskindof xml attribut indent self name iter e acc string acc e tostr na size na iter e acc string acc e ocliskindof xml text els r n endif e tostr indent na first ocliskindof xml text self name els r n indent self name endif els endif helper context xml attribut def tostr string self name self valu helper context xml text def tostr string self valu,5
45,45,P27-RedundantInheritance-context.atl,"-- @name		Remove redundant inheritance
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		Baudry Julien (jul.baudry<at>gmail.com)
-- @date		2006/08/02
-- @description	The purpose of this transformation is to remove redundant inheritance.
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 2.3, page 15
-- @see author of article : K. Lano

module RedundantInheritance; 
create OUT : KM3target from IN : KM3;

--helper context KM3!Class def: getAllSuperTypes : Sequence(KM3!Class) =
--    if self.supertypes->isEmpty()
--        then Sequence {}
--    	else	
--   				self.supertypes->iterate(a; acc:Sequence(KM3!Class)=self.supertypes|
--														 a.getSuperTypes->iterate(b; bcc:Sequence(KM3!Class)=acc|bcc->append(b)))
--    endif;
--    
helper context KM3!Class def : getSuperTypes : Sequence(KM3!Class) =
	self.supertypes->iterate(a; acc:Sequence(KM3!Class)=Sequence{}|
						if self.getAllSuperTypes->count(a)>1											
						then acc->union(Sequence{})
						else acc->append(a)
						endif 
	);

helper context KM3!Class def: getAllSuperTypes : Sequence(KM3!Class) =
	if self.supertypes->isEmpty()
		then Sequence{}	
	else 		self.supertypes->select(c | c.supertypes->notEmpty())
					->iterate(a; acc : Sequence(KM3!Class)=Sequence{} |(acc->including(a.getSuperTypes)))
					->union(
					self.supertypes->iterate(a; acc : Sequence(KM3!Class)=Sequence{} | acc->including(a))
			).flatten()
	endif;
	
--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3target!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
--@end rule Metamodel

--@begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3target!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
--@end rule Package

--@begin rule Class
rule Class {
	from
		inputA:KM3!Class 
	to
		outputA:KM3target!Class (
			name <- inputA.name,
			isAbstract <- inputA.isAbstract,
			structuralFeatures <- inputA.structuralFeatures,
			supertypes <- inputA.getSuperTypes
		)
}
--@end rule Class

--@begin rule attribute 
rule attribute {
	from
		inputAtt:KM3!Attribute 
	to
		outputAtt:KM3target!Attribute(
			name <- inputAtt.name,
			isOrdered <- inputAtt.isOrdered,
			isUnique <- inputAtt.isUnique,
			location <- inputAtt.location,
			lower <- inputAtt.lower,
			upper <- inputAtt.upper,
			type <- inputAtt.type,
			owner <- inputAtt.owner
			
		)
}
--@end rule attribute

--@begin rule DataType
rule DataType {
from
		inputData:KM3!DataType
	to
		outputData:KM3target!DataType(
			name <- inputData.name,
			location <- inputData.location
		)
}
--@end rule DataType

--@begin reference
rule reference {
	from
		inputRef:KM3!Reference 
	to
		outputRef:KM3target!Reference (
			name <- inputRef.name,
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			location <- inputRef.location,
			lower <- inputRef.lower,
			upper <- inputRef.upper,
			type <- inputRef.type,
			owner <- inputRef.owner,
			opposite <- inputRef.opposite
		)
}
--@end reference

--@begin enumeration
rule enumeration {
	from
		inputEnum:KM3!Enumeration 
	to
		outputEnum:KM3target!Enumeration (
			location <- inputEnum.location,
			name  <- inputEnum.name,
			package  <- inputEnum.package
		)

}
--@end enumeration

--@begin literal
rule literal {
	from
		inputEnum:KM3!EnumLiteral
	to
		outputEnum:KM3target!EnumLiteral (
			location <- inputEnum.location,
			name  <- inputEnum.name,
			enum  <- inputEnum.enum
		)

}
--@end literal",name remov redund inherit version domain catalogu model transform author baudri julien jul baudri gmail com date descript the purpos transform remov redund inherit see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul redundantinherit creat out km target in km helper context km class def getallsupertyp sequenc km class self supertyp isempti sequenc els self supertyp iter acc sequenc km class self supertyp getsupertyp iter b bcc sequenc km class acc bcc append b endif helper context km class def getsupertyp sequenc km class self supertyp iter acc sequenc km class sequenc self getallsupertyp count acc union sequenc els acc append endif helper context km class def getallsupertyp sequenc km class self supertyp isempti sequenc els self supertyp select c c supertyp notempti iter acc sequenc km class sequenc acc includ getsupertyp union self supertyp iter acc sequenc km class sequenc acc includ flatten endif begin rule metamodel rule metamodel inputmm km metamodel outputmm km target metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km target packag name inputpkg name content inputpkg content end rule packag begin rule class rule class inputa km class outputa km target class name inputa name isabstract inputa isabstract structuralfeatur inputa structuralfeatur supertyp inputa getsupertyp end rule class begin rule attribut rule attribut inputatt km attribut outputatt km target attribut name inputatt name isord inputatt isord isuniqu inputatt isuniqu locat inputatt locat lower inputatt lower upper inputatt upper type inputatt type owner inputatt owner end rule attribut begin rule datatyp rule datatyp inputdata km datatyp outputdata km target datatyp name inputdata name locat inputdata locat end rule datatyp begin refer rule refer inputref km refer outputref km target refer name inputref name isord inputref isord isuniqu inputref isuniqu locat inputref locat lower inputref lower upper inputref upper type inputref type owner inputref owner opposit inputref opposit end refer begin enumer rule enumer inputenum km enumer outputenum km target enumer locat inputenum locat name inputenum name packag inputenum packag end enumer begin liter rule liter inputenum km enumliter outputenum km target enumliter locat inputenum locat name inputenum name enum inputenum enum end liter,8
46,46,P27-RedundantInheritance-without.atl,"-- @name		Remove redundant inheritance
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		Baudry Julien (jul.baudry<at>gmail.com)
-- @date		2006/08/02
-- @description	The purpose of this transformation is to remove redundant inheritance.
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 2.3, page 15
-- @see author of article : K. Lano

module RedundantInheritance; 
create OUT : KM3target from IN : KM3;

-- helper getSuperTypes
-- OUT : Sequence(KM3!Class)
-- Corresponds to all the direct or indirect supertypes of the class. 
-- If a class inherit from another class by two different ways, it appears two times in the sequence.
helper context KM3!Class def : getSuperTypes : Sequence(KM3!Class) =
	self.supertypes->iterate(a; acc:Sequence(KM3!Class)=Sequence{}|
						if self.getAllSuperTypes->count(a)>1											
						then acc->union(Sequence{})
						else acc->append(a)
						endif 
	);

-- helper getAllSuperTypes
helper context KM3!Class def: getAllSuperTypes : Sequence(KM3!Class) =
	if self.supertypes->isEmpty()
		then Sequence{}	
	else 		self.supertypes->select(c | c.supertypes->notEmpty())
					->iterate(a; acc : Sequence(KM3!Class)=Sequence{} |(acc->including(a.getSuperTypes)))
					->union(
					self.supertypes->iterate(a; acc : Sequence(KM3!Class)=Sequence{} | acc->including(a))
			).flatten()
	endif;
	
--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3target!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
--@end rule Metamodel

--@begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3target!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
--@end rule Package

--@begin rule Class
rule Class {
	from
		inputA:KM3!Class 
	to
		outputA:KM3target!Class (
			name <- inputA.name,
			isAbstract <- inputA.isAbstract,
			structuralFeatures <- inputA.structuralFeatures,
			supertypes <- inputA.getSuperTypes
		)
}
--@end rule Class",name remov redund inherit version domain catalogu model transform author baudri julien jul baudri gmail com date descript the purpos transform remov redund inherit see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul redundantinherit creat out km target in km helper getsupertyp out sequenc km class correspond direct indirect supertyp class if class inherit anoth class two differ way appear two time sequenc helper context km class def getsupertyp sequenc km class self supertyp iter acc sequenc km class sequenc self getallsupertyp count acc union sequenc els acc append endif helper getallsupertyp helper context km class def getallsupertyp sequenc km class self supertyp isempti sequenc els self supertyp select c c supertyp notempti iter acc sequenc km class sequenc acc includ getsupertyp union self supertyp iter acc sequenc km class sequenc acc includ flatten endif begin rule metamodel rule metamodel inputmm km metamodel outputmm km target metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km target packag name inputpkg name content inputpkg content end rule packag begin rule class rule class inputa km class outputa km target class name inputa name isabstract inputa isabstract structuralfeatur inputa structuralfeatur supertyp inputa getsupertyp end rule class,1
47,47,P28-EMF2KM3.atl,"-- Transforms an Ecore metamodel into a KM3 metamodel.
module EMF2KM3;
create OUT : KM3 from IN : MOF;

uses strings;

helper def: metamodel : KM3!Metamodel = OclUndefined;

-- The Metamodel root element is created in an imperative rule because there
-- is no corresponding root element in Ecore metamodels.
entrypoint rule Metamodel() {
	to
		t : KM3!Metamodel
	do {
		thisModule.metamodel <- t;
	}
}

rule Package {
	from
		ip : MOF!EPackage
	to
		op : KM3!Package (
			name <- ip.name,
			metamodel <-	if ip.eSuperPackage.oclIsUndefined() then
						thisModule.metamodel
					else
						OclUndefined
					endif,
			contents <- ip.eClassifiers
		)
}

rule PrimitiveType {
	from
		idt : MOF!EDataType (
			-- we do not want to transform enumerations here
			idt.oclIsTypeOf(MOF!EDataType)
		)
	to
		odt : KM3!DataType (
			name <- idt.name
		)
}

rule Reference {
	from
		ir : MOF!EReference
	to
		oref : KM3!Reference (
			name <- ir.name,
			type <- ir.eType,
			lower <- ir.lowerBound,
			upper <- ir.upperBound,
			isOrdered <- ir.ordered,
			opposite <- ir.eOpposite,
			isContainer <- ir.containment
		)
}

rule Class {
	from
		ic : MOF!EClass
	to
		oc : KM3!Class (
			name <- ic.name,
			structuralFeatures <- ic.eStructuralFeatures,
			operations <- ic.eOperations,
			supertypes <- ic.eSuperTypes,
			isAbstract <- ic.""abstract""
		)
}

rule Attribute {
	from
		ia : MOF!EAttribute
	to
		oa : KM3!Attribute (
			name <- ia.name,
			type <- ia.eType,
			lower <- ia.lowerBound,
			upper <- ia.upperBound,
			isOrdered <- ia.ordered,
			isUnique <- if ia.upperBound = 1 then false else ia.""unique"" endif
		)
}

rule Enumeration {
	from
		ie : MOF!EEnum
	to
		oe : KM3!Enumeration (
			name <- ie.name
		)
}

rule EnumLiteral {
	from
		iel : MOF!EEnumLiteral
	to
		oel : KM3!EnumLiteral (
			name <- iel.name,
			enum <- iel.eEnum
		)
}

rule Operation {
	from
		io : MOF!EOperation
	to
		oo : KM3!Operation (
			name <- io.name,
			parameters <- io.eParameters,
			type <- io.eType
		)
}

rule Parameter {
	from
		ip : MOF!EParameter
	to
		op : KM3!Parameter (
			name <- ip.name,
			type <- ip.eType
		)
}

",transform ecor metamodel km metamodel modul emf km creat out km in mof use string helper def metamodel km metamodel oclundefin the metamodel root element creat imper rule correspond root element ecor metamodel entrypoint rule metamodel km metamodel thismodul metamodel rule packag ip mof epackag op km packag name ip name metamodel ip esuperpackag oclisundefin thismodul metamodel els oclundefin endif content ip eclassifi rule primitivetyp idt mof edatatyp want transform enumer idt oclistypeof mof edatatyp odt km datatyp name idt name rule refer ir mof erefer oref km refer name ir name type ir etyp lower ir lowerbound upper ir upperbound isord ir order opposit ir eopposit iscontain ir contain rule class ic mof eclass oc km class name ic name structuralfeatur ic estructuralfeatur oper ic eoper supertyp ic esupertyp isabstract ic abstract rule attribut ia mof eattribut oa km attribut name ia name type ia etyp lower ia lowerbound upper ia upperbound isord ia order isuniqu ia upperbound fals els ia uniqu endif rule enumer ie mof eenum oe km enumer name ie name rule enumliter iel mof eenumliter oel km enumliter name iel name enum iel eenum rule oper io mof eoper oo km oper name io name paramet io eparamet type io etyp rule paramet ip mof eparamet op km paramet name ip name type ip etyp,18
48,48,P29-equivalenceOfAttributeAndAssociations.atl,"-- @name		Equivalence of attributes and associations
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		Baudry Julien (jul.baudry<at>gmail.com)
-- @date		2006/08/02
-- @description	The purpose of this transformation is to replace association by equivalent attributes.
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 1.5, page 4
-- @see author of article : K. Lano

module UML2Transformations; -- Module Template
create OUT : UML2target from IN : UML2;

helper context UML2!Class def : getProperties : Sequence(UML2!Properties) =
		UML2!Association.allInstances()->select(a|a.endType->includes(self))
				->iterate(a;acc : Sequence(UML2!Property) = Sequence {}|
							acc->including(a.ownedEnd->select(p|p.type <> self)
										->first()))
	;

--@begin rule model
rule model {
	from
		inputModel : UML2!Model 
	to
		outputModel : UML2target!Model (
			name <- inputModel.name,
			visibility <- inputModel.visibility,
			packageableElement_visibility <- inputModel.packageableElement_visibility,
			ownedMember <-inputModel.ownedMember
		)
}
--@end rule model

--@begin rule class
rule class {
	from
		inputClass : UML2!Class 
	to
		outputClass : UML2target!Class (
			name <- inputClass.name,
			visibility <- inputClass.visibility,
			packageableElement_visibility <- inputClass.packageableElement_visibility,
			isAbstract <- inputClass.isAbstract,
			isLeaf <- inputClass.isLeaf,
			isActive <- inputClass.isActive,
			ownedAttribute <- inputClass.getProperties->union(inputClass.ownedAttribute)	
		)
}
--@end rule class

--@begin rule property
rule property {
	from
		inputProperty : UML2!Property 
	to
		outputProperty : UML2target!Property (
			isDerived <- inputProperty.isDerived,
			isDerivedUnion <- inputProperty.isDerivedUnion,
			isLeaf <- inputProperty.isLeaf,
			isOrdered <- inputProperty.isOrdered,
			isReadOnly <- inputProperty.isReadOnly,
			isStatic <- inputProperty.isStatic,
			isUnique <- inputProperty.isUnique,
			name <- inputProperty.name,
			visibility <- inputProperty.visibility,
			lowerValue <- inputProperty.lowerValue,
			upperValue <- inputProperty.upperValue
		)
}
--@end rule property

--@begin literal null
rule literalNull {
	from 
		inputLiteral : UML2!LiteralNull
	to 
		outputLiteral : UML2target!LiteralNull (
			name <- inputLiteral.name,
			value <- inputLiteral.value
		)
}
--@end literal null

--@begin literal integer 
rule literalInteger {
	from 
		inputLiteral : UML2!LiteralInteger
	to 
		outputLiteral : UML2target!LiteralInteger (
			name <- inputLiteral.name,
			value <- inputLiteral.value
		)
}
--@end literal integer

--@begin literal unlimited natural 
rule literalUnlimitedNatural {
	from 
		inputLiteral : UML2!LiteralUnlimitedNatural
	to 
		outputLiteral : UML2target!LiteralUnlimitedNatural (
			name <- inputLiteral.name,
			value <- inputLiteral.value
		)	
}
--@end literal unlimited natural
",name equival attribut associ version domain catalogu model transform author baudri julien jul baudri gmail com date descript the purpos transform replac associ equival attribut see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul uml transform modul templat creat out uml target in uml helper context uml class def getproperti sequenc uml properti uml associ allinst select endtyp includ self iter acc sequenc uml properti sequenc acc includ ownedend select p p type self first begin rule model rule model inputmodel uml model outputmodel uml target model name inputmodel name visibl inputmodel visibl packageableel visibl inputmodel packageableel visibl ownedmemb inputmodel ownedmemb end rule model begin rule class rule class inputclass uml class outputclass uml target class name inputclass name visibl inputclass visibl packageableel visibl inputclass packageableel visibl isabstract inputclass isabstract isleaf inputclass isleaf isact inputclass isact ownedattribut inputclass getproperti union inputclass ownedattribut end rule class begin rule properti rule properti inputproperti uml properti outputproperti uml target properti isderiv inputproperti isderiv isderivedunion inputproperti isderivedunion isleaf inputproperti isleaf isord inputproperti isord isreadon inputproperti isreadon isstat inputproperti isstat isuniqu inputproperti isuniqu name inputproperti name visibl inputproperti visibl lowervalu inputproperti lowervalu uppervalu inputproperti uppervalu end rule properti begin liter null rule literalnul inputliter uml literalnul outputliter uml target literalnul name inputliter name valu inputliter valu end liter null begin liter integ rule literalinteg inputliter uml literalinteg outputliter uml target literalinteg name inputliter name valu inputliter valu end liter integ begin liter unlimit natur rule literalunlimitednatur inputliter uml literalunlimitednatur outputliter uml target literalunlimitednatur name inputliter name valu inputliter valu end liter unlimit natur,13
49,49,P3-ATL2BindingDebugger.atl,"module ATL2BindingDebugger;
create OUT : ATL refining IN : ATL;

-- We copy the ATL!Module to make sure the whole program is actually copied even if it contains no binding.
rule Module {
	from
		s : ATL!Module
	to
		t : ATL!Module (
			name <- s.name,
			libraries <- s.libraries,
			isRefining <- s.isRefining,
			inModels <- s.inModels,
			outModels <- s.outModels,
			elements <- s.elements
		)
}

-- We change the value of each binding so that it calls the OclAny.debug(msg : String)
-- operation with information about the current rule, target element and property name
-- as a message.
rule Binding {
	from
		s : ATL!Binding
	to
		t : ATL!Binding (
			propertyName <- s.propertyName,
			value <- debugger
		),
		debugger : ATL!OperationCallExp (
			source <- s.value,
			operationName <- 'debug',
			arguments <- Sequence {arg}
		),
		arg : ATL!StringExp (
			stringSymbol <- s.outPatternElement.outPattern.""rule"".name + '.' +
					s.outPatternElement.varName + '.' +
					s.propertyName
		)
}

",modul atl bindingdebugg creat out atl refin in atl we copi atl modul make sure whole program actual copi even contain bind rule modul atl modul atl modul name name librari librari isrefin isrefin inmodel inmodel outmodel outmodel element element we chang valu bind call oclani debug msg string oper inform current rule target element properti name messag rule bind atl bind atl bind propertynam propertynam valu debugg debugg atl operationcallexp sourc valu operationnam debug argument sequenc arg arg atl stringexp stringsymbol outpatternel outpattern rule name outpatternel varnam propertynam,3
50,50,P3-sample-ATL-0.2(Debug).atl,"module ATL2BindingDebugger;
create OUT : ATL refining IN : ATL;

-- We copy the ATL!Module to make sure the whole program is actually copied even if it contains no binding.
rule Module {
  from
    s : ATL!Module
  to
    t : ATL!Module (
      name <- s.name.debug('Module.t.name'),
      libraries <- s.libraries.debug('Module.t.libraries'),
      isRefining <- s.isRefining.debug('Module.t.isRefining'),
      inModels <- s.inModels.debug('Module.t.inModels'),
      outModels <- s.outModels.debug('Module.t.outModels'),
      elements <- s.elements.debug('Module.t.elements')
    )
}

-- We change the value of each binding so that it calls the OclAny.debug(msg : String)
-- operation with information about the current rule, target element and property name
-- as a message.
rule Binding {
  from
    s : ATL!Binding
  to
    t : ATL!Binding (
      propertyName <- s.propertyName.debug('Binding.t.propertyName'),
      value <- debugger.debug('Binding.t.value')
    ),
    debugger : ATL!OperationCallExp (
      source <- s.value.debug('Binding.debugger.source'),
      operationName <- 'debug'.debug('Binding.debugger.operationName'),
      arguments <- Sequence {arg}.debug('Binding.debugger.arguments')
    ),
    arg : ATL!StringExp (
      stringSymbol <- (s.outPatternElement.outPattern.""rule"".name + '.' + s.outPatternElement.varName + '.' + s.propertyName).debug('Binding.arg.stringSymbol')
    )
}
",modul atl bindingdebugg creat out atl refin in atl we copi atl modul make sure whole program actual copi even contain bind rule modul atl modul atl modul name name debug modul name librari librari debug modul librari isrefin isrefin debug modul isrefin inmodel inmodel debug modul inmodel outmodel outmodel debug modul outmodel element element debug modul element we chang valu bind call oclani debug msg string oper inform current rule target element properti name messag rule bind atl bind atl bind propertynam propertynam debug bind propertynam valu debugg debug bind valu debugg atl operationcallexp sourc valu debug bind debugg sourc operationnam debug debug bind debugg operationnam argument sequenc arg debug bind debugg argument arg atl stringexp stringsymbol outpatternel outpattern rule name outpatternel varnam propertynam debug bind arg stringsymbol,3
51,51,P3-sample-ATL-0.2.atl,"module ATL2BindingDebugger;
create OUT : ATL refining IN : ATL;

-- We copy the ATL!Module to make sure the whole program is actually copied even if it contains no binding.
rule Module {
  from
    s : ATL!Module
  to
    t : ATL!Module (
      name <- s.name,
      libraries <- s.libraries,
      isRefining <- s.isRefining,
      inModels <- s.inModels,
      outModels <- s.outModels,
      elements <- s.elements
    )
}

-- We change the value of each binding so that it calls the OclAny.debug(msg : String)
-- operation with information about the current rule, target element and property name
-- as a message.
rule Binding {
  from
    s : ATL!Binding
  to
    t : ATL!Binding (
      propertyName <- s.propertyName,
      value <- debugger
    ),
    debugger : ATL!OperationCallExp (
      source <- s.value,
      operationName <- 'debug',
      arguments <- Sequence {arg}
    ),
    arg : ATL!StringExp (
      stringSymbol <- s.outPatternElement.outPattern.""rule"".name + '.' + s.outPatternElement.varName + '.' + s.propertyName
    )
}
",modul atl bindingdebugg creat out atl refin in atl we copi atl modul make sure whole program actual copi even contain bind rule modul atl modul atl modul name name librari librari isrefin isrefin inmodel inmodel outmodel outmodel element element we chang valu bind call oclani debug msg string oper inform current rule target element properti name messag rule bind atl bind atl bind propertynam propertynam valu debugg debugg atl operationcallexp sourc valu operationnam debug argument sequenc arg arg atl stringexp stringsymbol outpatternel outpattern rule name outpatternel varnam propertynam,3
52,52,P30-DXF2Code.atl,"--
-- Written in January 2005 by Peter Rosenthal
--


query DXF2Code = DXF!DXF.allInstances()->collect(e | 
	('999\n' + 
	'This is DFX file has been generated with ATL\n' +
	'0\n' +
	'SECTION\n' +
	'2\n' +
	'ENTITIES\n' +
	e.toString() +
	'0\nENDSEC\n0\nEOF')
	.writeTo('C:/Documents and Settings/rosenthal/Mes documents/atlas/runtime-workspace/geometricalTransformations/myOut.dxf'));

 helper context DXF!DXF def: toString() : String = 
 	self.meshes->iterate(e; acc : String = '' |
		acc + e.toString());
 	
 helper context DXF!Mesh def: toString() : String =  	
	'0\n3DFACE\n' +
 	'8\n' + self.name + '\n' +
	(self.points->iterate(e; acc : String = '' |
		acc  + e.toString()));
 
 helper context DXF!Point def: toString() : String =
 	'1' + self.name->substring(2,2)  +
	 '\n' +
 	self.x->toString()+ '\n' +
	
	'2' + self.name->substring(2,2) +
	 '\n' +
 	self.y->toString()+ '\n'+
	
	'3' + self.name->substring(2,2) +
	 '\n' +
 	self.z->toString()+ '\n'
	;",written januari peter rosenth queri dxf code dxf dxf allinst collect e n this dfx file generat atl n n section n n entiti n e tostr nendsec n neof writeto c document set rosenth mes document atlas runtim workspac geometricaltransform myout dxf helper context dxf dxf def tostr string self mesh iter e acc string acc e tostr helper context dxf mesh def tostr string n dface n n self name n self point iter e acc string acc e tostr helper context dxf point def tostr string self name substr n self x tostr n self name substr n self tostr n self name substr n self z tostr n,15
53,53,P30-GeometricalTransformations.atl,"--
-- Written in January and in February 2005 by Peter Rosenthal
--

module GeometricalTransformations;

create OUT : DXF2 from IN1 : DXF1, IN2 : GeoTrans;

uses GeometryLib;



helper  def : getRealParam( command : GeoTrans!GeoTransfo , paramName : String ) : Real =
	if (command.params->select(c | c.name = paramName)->size()=0) then
		0.0
	else
		(command.params->select(c | c.name = paramName)->first()).param
	endif;

-- calculates the gravity center (=average) of all points of a mesh
helper  def: getNewGC(s : DXF1!Mesh) : TupleType(x : Real, y : Real, z : Real) =
	let nbPoints : Integer = s.points->size() in
	Tuple {
		x = s.points->iterate(e; acc : Real = 0.0 | acc + e.x) / nbPoints,
		y = s.points->iterate(e; acc : Real = 0.0 | acc + e.y) / nbPoints,
		z = s.points->iterate(e; acc : Real = 0.0 | acc + e.z) / nbPoints
	};

helper def : execute( point : DXF1!Point, -- calculatedSoFar
					  a : TupleType(x : Real, y : Real, z : Real), 
					  command : GeoTrans!GeoTransfo) : 
					TupleType(x : Real, y : Real, z : Real) =

	if (command.name='explode') then -- false: explode has to be run as rotate
		let p : Real = thisModule.getRealParam(command, 'factor') in 
			thisModule.explode( p , a )
	else
		if (command.name='rotate') then
			let rotationAngle : TupleType(x : Real, y : Real, z : Real) = 
				Tuple { x = thisModule.getRealParam(command, 'rotationX'),
						y = thisModule.getRealParam(command, 'rotationY'),
						z = thisModule.getRealParam(command, 'rotationZ')} in 
				thisModule.rotate( rotationAngle , thisModule.getNewGC(point.mesh) , a )
		else
			if (command.name='moveForward') then
				let vector : TupleType(x : Real, y : Real, z : Real) = 
				Tuple { x = thisModule.getRealParam(command, 'x'),
						y = thisModule.getRealParam(command, 'y'),
						z = thisModule.getRealParam(command, 'z')} in 
					thisModule.moveForward( a, vector )
			else
					if (command.name='moveBackward') then
						let vector : TupleType(x : Real, y : Real, z : Real) = 
							Tuple { x = thisModule.getRealParam(command, 'x'),
									y = thisModule.getRealParam(command, 'y'),
									z = thisModule.getRealParam(command, 'z')} in 
							thisModule.moveBackward( a, vector )
					else
						a
					endif
			endif
		endif	
	endif;

helper def : doCommands( a : DXF1!Point,
						 calculated : TupleType(x : Real, y : Real, z : Real), 
						 command : GeoTrans!GeoTransfo) 
						: TupleType(x : Real, y : Real, z : Real) =	
						
	if command.superGeoTransfo.oclIsUndefined() then
		thisModule.execute(a, calculated, command)
	else
		let newlyCalculated :  DXF1!Point	 = 
			thisModule.doCommands(a, calculated, command.superGeoTransfo) in
		thisModule.execute(a,newlyCalculated, command)
	endif;

helper context DXF1!Point def  : getPoint() : 
	TupleType(x : Real, y : Real, z : Real)  =
	
	Tuple { x = self.x,
			y = self.y,
			z = self.z
	};
	
rule DXF2DXF {
	from
		f : DXF1!DXF
	to
		out : DXF2!DXF (
			meshes <- f.meshes
		)
}
	
rule Mesh {
	from
		mesh : DXF1!Mesh
	to 
		out : DXF2!Mesh (
		 	name <- mesh.name,
			points <- mesh.points
		)
}
				
rule Point {
	from
		point :	DXF1!Point
	using {
		c : TupleType(x : Real, y : Real, z : Real) = 
				-- getting the root command g of the geometric transformation commands
				let g : GeoTrans!GeoTransfo = 
					GeoTrans!GeoTransfo->
						allInstances()->
							select(t| t.subGeoTransfos->size() = 0 )->first()
				in 
				-- executing the sequence of geometric transformation commands on this particular point
				-- starting with the root command
					thisModule.doCommands( point, point.getPoint(), g );
	}
	to
		out : DXF2!Point (
		 	name <- point.name,
			x <- c.x,
			y <- c.y,
			z <- c.z				
	)
}

",written januari februari peter rosenth modul geometricaltransform creat out dxf in dxf in geotran use geometrylib helper def getrealparam command geotran geotransfo paramnam string real command param select c c name paramnam size els command param select c c name paramnam first param endif calcul graviti center averag point mesh helper def getnewgc dxf mesh tupletyp x real real z real let nbpoint integ point size tupl x point iter e acc real acc e x nbpoint point iter e acc real acc e nbpoint z point iter e acc real acc e z nbpoint helper def execut point dxf point calculatedsofar tupletyp x real real z real command geotran geotransfo tupletyp x real real z real command name explod fals explod run rotat let p real thismodul getrealparam command factor thismodul explod p els command name rotat let rotationangl tupletyp x real real z real tupl x thismodul getrealparam command rotationx thismodul getrealparam command rotationi z thismodul getrealparam command rotationz thismodul rotat rotationangl thismodul getnewgc point mesh els command name moveforward let vector tupletyp x real real z real tupl x thismodul getrealparam command x thismodul getrealparam command z thismodul getrealparam command z thismodul moveforward vector els command name movebackward let vector tupletyp x real real z real tupl x thismodul getrealparam command x thismodul getrealparam command z thismodul getrealparam command z thismodul movebackward vector els endif endif endif endif helper def docommand dxf point calcul tupletyp x real real z real command geotran geotransfo tupletyp x real real z real command supergeotransfo oclisundefin thismodul execut calcul command els let newlycalcul dxf point thismodul docommand calcul command supergeotransfo thismodul execut newlycalcul command endif helper context dxf point def getpoint tupletyp x real real z real tupl x self x self z self z rule dxf dxf f dxf dxf dxf dxf mesh f mesh rule mesh mesh dxf mesh dxf mesh name mesh name point mesh point rule point point dxf point use c tupletyp x real real z real get root command g geometr transform command let g geotran geotransfo geotran geotransfo allinst select subgeotransfo size first execut sequenc geometr transform command particular point start root command thismodul docommand point point getpoint g dxf point name point name x c x c z c z,0
54,54,P30-GeometryLib.atl,"--
-- Written in January 2005 by Peter Rosenthal
--

library GeometryLib;

helper def: PIDiv180 : Real = 0.017453292519943295769236907684886;
	
helper def : rotate( rotationAngle : TupleType(x : Real, y : Real, z : Real),
					pointOfOrigin : TupleType(x : Real, y : Real, z : Real), 
					rotationPoint : TupleType(x : Real, y : Real, z : Real))
					: TupleType(x : Real, y : Real, z : Real) =
	
	let rotationPointO : TupleType(x : Real, y : Real, z : Real) = 
		rotationPoint in
--		thisModule.moveBackward(rotationPoint, pointOfOrigin ) in
	let XRadAng : Real = rotationAngle.x * thisModule.PIDiv180 in
	let YRadAng : Real = rotationAngle.y * thisModule.PIDiv180 in
	let ZRadAng : Real = rotationAngle.z * thisModule.PIDiv180 in
  
	let SinX : Real = XRadAng.sin() in
	let SinY : Real = YRadAng.sin() in
	let SinZ : Real = ZRadAng.sin() in

	let CosX : Real = XRadAng.cos() in
	let CosY : Real = YRadAng.cos() in
	let CosZ : Real = ZRadAng.cos() in

	let TempY : Real = rotationPointO.y * CosY - rotationPointO.z * SinY in
	let TempZ : Real = rotationPointO.y * SinY + rotationPointO.z * CosY in
	let TempX : Real = rotationPointO.x * CosX - TempZ * SinX in

	let Nz : Real = rotationPointO.x * SinX + TempZ * CosX in
	let Nx : Real = TempX * CosZ - TempY * SinZ in
	let Ny : Real = TempX * SinZ + TempY * CosZ in
 
	let rotated : TupleType(x : Real, y : Real, z : Real) = 
		Tuple {x = Nx, y = Ny, z = Nz} in
--		thisModule.moveForward(Tuple {x = Nx, y = Ny, z = Nz}, pointOfOrigin) in
	rotated;


helper def : moveForward(	a : TupleType(x : Real, y : Real, z : Real),
				 		b : TupleType(x : Real, y : Real, z : Real)) :
				 	 		TupleType(x : Real, y : Real, z : Real) =

	Tuple {
		x = a.x + b.x,
		y = a.y + b.y,
		z = a.z + b.z
	};

helper def : moveBackward(	a : TupleType(x : Real, y : Real, z : Real),
				 	b : TupleType(x : Real, y : Real, z : Real)) :
				 		TupleType(x : Real, y : Real, z : Real) =

	Tuple {
		x = a.x - b.x,
		y = a.y - b.y,
		z = a.z - b.z
	};	

helper def: sign(s : Real): Real =	-- returns absolute value
	if ( s < 0.0) then 
		0-1.0 
	else
		1.0
	endif;

helper def : explode( explosionFactor : Real, e : TupleType(x : Real, y : Real, z : Real) ) : TupleType(x : Real, y : Real, z : Real) =
	Tuple {
		x = e.x * (1 + explosionFactor / ( e.x +  thisModule.sign(e.x)) * thisModule.sign(e.x)),
		y = e.y * (1 + explosionFactor / ( e.y +  thisModule.sign(e.y)) * thisModule.sign(e.y)),		
		z = e.z * (1 + explosionFactor / ( e.z +  thisModule.sign(e.z)) * thisModule.sign(e.z))	
	};
",written januari peter rosenth librari geometrylib helper def pidiv real helper def rotat rotationangl tupletyp x real real z real pointoforigin tupletyp x real real z real rotationpoint tupletyp x real real z real tupletyp x real real z real let rotationpointo tupletyp x real real z real rotationpoint thismodul movebackward rotationpoint pointoforigin let xradang real rotationangl x thismodul pidiv let yradang real rotationangl thismodul pidiv let zradang real rotationangl z thismodul pidiv let sinx real xradang sin let sini real yradang sin let sinz real zradang sin let cosx real xradang cos let cosi real yradang cos let cosz real zradang cos let tempi real rotationpointo cosi rotationpointo z sini let tempz real rotationpointo sini rotationpointo z cosi let tempx real rotationpointo x cosx tempz sinx let nz real rotationpointo x sinx tempz cosx let nx real tempx cosz tempi sinz let ny real tempx sinz tempi cosz let rotat tupletyp x real real z real tupl x nx ny z nz thismodul moveforward tupl x nx ny z nz pointoforigin rotat helper def moveforward tupletyp x real real z real b tupletyp x real real z real tupletyp x real real z real tupl x x b x b z z b z helper def movebackward tupletyp x real real z real b tupletyp x real real z real tupletyp x real real z real tupl x x b x b z z b z helper def sign real real return absolut valu els endif helper def explod explosionfactor real e tupletyp x real real z real tupletyp x real real z real tupl x e x explosionfactor e x thismodul sign e x thismodul sign e x e explosionfactor e thismodul sign e thismodul sign e z e z explosionfactor e z thismodul sign e z thismodul sign e z,11
55,55,P30-XML2DXF.atl,"--
-- Written in January 2005 by Peter Rosenthal
--

module XML2DXF;
create OUT : DXF from IN : XML;

helper context XML!Element def: getAttrVal(name : String) : String =
	if (self.children->select(c | c.oclIsKindOf(XML!Attribute) and c.name = name)->size()=0) then
		''
	else
		self.children->select(c | c.oclIsKindOf(XML!Attribute) and c.name = name)->first().value
	endif
;


rule DXF {
	from
		e : XML!Element (
			e.name = 'DXF'		
		)
	to
		out : DXF!DXF (
			meshes <-  e.children->select( c | c.name = 'Mesh' )
		)
}

rule Point {
	from
		e : XML!Element (
			e.name = 'Point'		
		)
	to
		out : DXF!Point (
			name <- e.getAttrVal('name'),
			x <- e.getAttrVal('x').toReal(),
			y <- e.getAttrVal('y').toReal(),
			z <- e.getAttrVal('z').toReal()
		)
}


rule Mesh {
	from
		e : XML!Element (
			e.name = 'Mesh'		
		)
	to
		out : DXF!Mesh (
			name <- e.getAttrVal('name'),
			points <- e.children
		)
}
",written januari peter rosenth modul xml dxf creat out dxf in xml helper context xml element def getattrv name string string self children select c c ocliskindof xml attribut c name name size els self children select c c ocliskindof xml attribut c name name first valu endif rule dxf e xml element e name dxf dxf dxf mesh e children select c c name mesh rule point e xml element e name point dxf point name e getattrv name x e getattrv x toreal e getattrv toreal z e getattrv z toreal rule mesh e xml element e name mesh dxf mesh name e getattrv name point e children,5
56,56,P30-XML2GeoTrans.atl,"--
-- Written in January 2005 by Peter Rosenthal
--

module XML2GeoTrans;
create OUT : GeoTrans from IN : XML;

helper context XML!Element def: getAttrVal(name : String) : String =
	if (self.children->select(c | c.oclIsKindOf(XML!Attribute) and c.name = name)->size()=0) then
		''
	else
		self.children->select(c | c.oclIsKindOf(XML!Attribute) and c.name = name)->first().value
	endif
;

rule GeoTransfos {
	from
		e : XML!Element (
			e.name = 'GeoTransfos'		
		)
	to
		out : GeoTrans!GeoTransfos (
			name <- e.getAttrVal('name'),
			transfos <-  e.children->select( c | c.name = 'GeoTransfo' )
		)
}

rule GeoTransfo {
	from
		e : XML!Element (
			e.name = 'GeoTransfo'		
		)
	to
		out : GeoTrans!GeoTransfo (
			name <- e.getAttrVal('name'),
			subGeoTransfos <-  e.children->select( c | c.name = 'GeoTransfo' ),
			params <-  e.children->select( c | c.name = 'Param' )
		--	freeze <- e.getAttrVal('freeze')			
		)
}

rule Param {
	from
		e : XML!Element (
			e.name = 'Param'		
		)
	to
		out : GeoTrans!Param (
			name <- e.getAttrVal('name'),
			param <- e.getAttrVal('param').toReal()
			
		)
}
",written januari peter rosenth modul xml geotran creat out geotran in xml helper context xml element def getattrv name string string self children select c c ocliskindof xml attribut c name name size els self children select c c ocliskindof xml attribut c name name first valu endif rule geotransfo e xml element e name geotransfo geotran geotransfo name e getattrv name transfo e children select c c name geotransfo rule geotransfo e xml element e name geotransfo geotran geotransfo name e getattrv name subgeotransfo e children select c c name geotransfo param e children select c c name param freez e getattrv freez rule param e xml element e name param geotran param name e getattrv name param e getattrv param toreal,5
57,57,P31-Grafcet2PetriNet.atl,"module Grafcet2PetriNet;
create OUT : PetriNet from IN : Grafcet;

-- The PetriNet rule generates a PetriNet element from the input Grafcet element. 
-- Name of the generated PetriNet element is copied from the one of the input Grafcet.
-- Its set of Elements corresponds to Elements generated by Place and Transition rules.
-- And its set of Arcs corresponds to Connections generated by PlaceToTransition and TransitionToPlace rules.
rule PetriNet {
	from
		g : Grafcet!Grafcet
	to
		p : PetriNet!PetriNet
		(
			location <- g.location,
			name <- g.name,
			elements <- g.elements,
			arcs <- g.connections
		)
}

-- The Place rule generates a Place element from the input Step element. 
-- Name of the generated Place element is copied from the one of the input Step.
-- Its set of incomingArcs corresponds to incomingConnections generated by TransitionToPlace rule.
-- And its set of outgoingArc corresponds to outgoingConnections generated by PlaceToTransition rule.
rule Place {
	from
		g : Grafcet!Step
	to
		p : PetriNet!Place
		(
			location <- g.location,
			name <- g.name,
			net <- g.grafcet,
			incomingArc <- g.incomingConnections,
			outgoingArc <- g.outgoingConnections
		)
}

-- The Transition rule generates a Transition element from the input Transition element. 
-- Name of the generated Transition element is copied from the one of the input Transition.
-- Its set of incomingArcs corresponds to incomingConnections generated by PlaceToTransition rule.
-- And its set of outgoingArc corresponds to outgoingConnections generated by TransitionToPlace rule.
rule Transition {
	from
		g : Grafcet!Transition
	to
		p : PetriNet!Transition
		(
			location <- g.location,
			name <- g.name,
			net <- g.grafcet,
			incomingArc <- g.incomingConnections,
			outgoingArc <- g.outgoingConnections
		)
}

-- The PlaceToTransition rule generates a PlaceToTransition element from the input StepToTransition element. 
-- Name of the generated PlaceToTransition element is copied from the one of the input StepToTransition.
-- Its from and to references are also copied from the ones of the input StepToTransition.
rule PlaceToTransition {
	from
		g : Grafcet!StepToTransition
	to
		p : PetriNet!PlaceToTransition
		(
			location <- g.location,
			name <- g.name,
			net <- g.grafcet,
			""from"" <- g.""from"",
			""to"" <- g.""to""
		)
}

-- The TransitionToPlace rule generates a TransitionToPlace element from the input TransitionToStep element. 
-- Name of the generated TransitionToPlace element is copied from the one of the input TransitionToStep.
-- Its from and to references are also copied from the ones of the input TransitionToStep.
rule TransitionToPlace {
	from
		g : Grafcet!TransitionToStep
	to
		p : PetriNet!TransitionToPlace
		(
			location <- g.location,
			name <- g.name,
			net <- g.grafcet,
			""from"" <- g.""from"",
			""to"" <- g.""to""
		)
}
",modul grafcet petrinet creat out petrinet in grafcet the petrinet rule generat petrinet element input grafcet element name generat petrinet element copi one input grafcet it set element correspond element generat place transit rule and set arc correspond connect generat placetotransit transitiontoplac rule rule petrinet g grafcet grafcet p petrinet petrinet locat g locat name g name element g element arc g connect the place rule generat place element input step element name generat place element copi one input step it set incomingarc correspond incomingconnect generat transitiontoplac rule and set outgoingarc correspond outgoingconnect generat placetotransit rule rule place g grafcet step p petrinet place locat g locat name g name net g grafcet incomingarc g incomingconnect outgoingarc g outgoingconnect the transit rule generat transit element input transit element name generat transit element copi one input transit it set incomingarc correspond incomingconnect generat placetotransit rule and set outgoingarc correspond outgoingconnect generat transitiontoplac rule rule transit g grafcet transit p petrinet transit locat g locat name g name net g grafcet incomingarc g incomingconnect outgoingarc g outgoingconnect the placetotransit rule generat placetotransit element input steptotransit element name generat placetotransit element copi one input steptotransit it refer also copi one input steptotransit rule placetotransit g grafcet steptotransit p petrinet placetotransit locat g locat name g name net g grafcet g g the transitiontoplac rule generat transitiontoplac element input transitiontostep element name generat transitiontoplac element copi one input transitiontostep it refer also copi one input transitiontostep rule transitiontoplac g grafcet transitiontostep p petrinet transitiontoplac locat g locat name g name net g grafcet g g,3
58,58,P31-PetriNet2Grafcet.atl,"module PetriNet2Grafcet;
create OUT : Grafcet from IN : PetriNet;

-- The Grafcet rule generates a Grafcet element from the input Petri Net element. 
-- Name of the generated Grafcet element is copied from the one of the input Petri Net.
-- Its set of Elements corresponds to Elements generated by Step and Transition rules.
-- And its set of Connections corresponds to Arcs generated by StepToTransition and TransitionToStep rules.
rule Grafcet {
	from
		p : PetriNet!PetriNet
		
	to	g : Grafcet!Grafcet
		(
			location <- p.location,
			name <- p.name,
			elements <- p.elements,
			connections <- p.arcs
		)
}

-- The Step rule generates a Step element from the input Place element. 
-- Name of the generated Step element is copied from the one of the input Place.
-- Its set of incomingConnections corresponds to incomingArcs generated by TransitionToStep rule.
-- And its set of outgoingConnections corresponds to outgoingArc generated by StepToTransition rule.
rule Step {
	from
		p : PetriNet!Place
	to
		g : Grafcet!Step
		(
			location <- p.location,
			name <- p.name,
			grafcet <- p.net,
			isInitial <- false,
			isActive <- false,
			incomingConnections <- p.incomingArc,
			outgoingConnections <- p.outgoingArc
		)
}

-- The Transition rule generates a Transition element from the input Transition element. 
-- Name of the generated Transition element is copied from the one of the input Transition.
-- Its set of incomingConnections corresponds to incomingArcs generated by StepToTransition rule.
-- And its set of outgoingConnections corresponds to outgoingArc generated by TransitionToStep rule.
rule Transition {
	from
		p : PetriNet!Transition
		
	to
		g : Grafcet!Transition
		(
			location <- p.location,
			name <- p.name,
			grafcet <- p.net,
			incomingConnections <- p.incomingArc,
			outgoingConnections <- p.outgoingArc
		)
}

-- The StepToTransition rule generates a StepToTransition element from the input PlaceToTransition element. 
-- Name of the generated StepToTransition element is copied from the one of the input PlaceToTransition.
-- Its from and to references are also copied from the ones of the input PlaceToTransition.
rule StepToTransition {
	from
		p : PetriNet!PlaceToTransition
	to
		g : Grafcet!StepToTransition
		(
		 	location <- p.location,
			name <- p.name,
			grafcet <- p.net,
			""from"" <- p.""from"",
			""to"" <- p.""to""
		)
}

-- The TransitionToStep rule generates a TransitionToStep element from the input TransitionToPlace element. 
-- Name of the generated TransitionToStep element is copied from the one of the input TransitionToPlace.
-- Its from and to references are also copied from the ones of the input TransitionToPlace.
rule TransitionToStep {
	from
		p : PetriNet!TransitionToPlace
	to
		g : Grafcet!TransitionToStep
		(
		 	location <- p.location,
			name <- p.name,
			grafcet <- p.net,
			""from"" <- p.""from"",
			""to"" <- p.""to""
		)
}
",modul petrinet grafcet creat out grafcet in petrinet the grafcet rule generat grafcet element input petri net element name generat grafcet element copi one input petri net it set element correspond element generat step transit rule and set connect correspond arc generat steptotransit transitiontostep rule rule grafcet p petrinet petrinet g grafcet grafcet locat p locat name p name element p element connect p arc the step rule generat step element input place element name generat step element copi one input place it set incomingconnect correspond incomingarc generat transitiontostep rule and set outgoingconnect correspond outgoingarc generat steptotransit rule rule step p petrinet place g grafcet step locat p locat name p name grafcet p net isiniti fals isact fals incomingconnect p incomingarc outgoingconnect p outgoingarc the transit rule generat transit element input transit element name generat transit element copi one input transit it set incomingconnect correspond incomingarc generat steptotransit rule and set outgoingconnect correspond outgoingarc generat transitiontostep rule rule transit p petrinet transit g grafcet transit locat p locat name p name grafcet p net incomingconnect p incomingarc outgoingconnect p outgoingarc the steptotransit rule generat steptotransit element input placetotransit element name generat steptotransit element copi one input placetotransit it refer also copi one input placetotransit rule steptotransit p petrinet placetotransit g grafcet steptotransit locat p locat name p name grafcet p net p p the transitiontostep rule generat transitiontostep element input transitiontoplac element name generat transitiontostep element copi one input transitiontoplac it refer also copi one input transitiontoplac rule transitiontostep p petrinet transitiontoplac g grafcet transitiontostep locat p locat name p name grafcet p net p p,3
59,59,P31-PetriNet2PNML.atl,"module PetriNet2PNML;
create OUT : PNML from IN : PetriNet;

-- The PNMLDocument rule generates a PNMLDocument  and the NetElement which corresponds to the input PetriNet element. 
-- Name of the generated NetElement is copied from the one of the input PetriNet, by creating a PNML Name composed of a PNML Label which value is initialized by the PetriNet name.
-- Its set of Contents corresponds to the union of the PetriNet Elements and Arcs.
rule PNMLDocument {
	from
		e : PetriNet!PetriNet
	to	
		n : PNML!PNMLDocument
		(
			location <- e.location,
			xmlns <- uri,
			nets <- net			
		),
		uri : PNML!URI
		(
			value <- 'http://www.informatik.hu-berlin.de/top/pnml/ptNetb'
		),
		net : PNML!NetElement
		(
			name <- name,
			location <- e.location,
			id <- e.location,
			type <- type_uri,
			contents <- e.elements.union(e.arcs)
		),
		name : PNML!Name
		(
			labels <- label
		),
		label : PNML!Label
		(
			text <- e.name
		),
		type_uri : PNML!URI
		(
			value <- 'http://www.informatik.hu-berlin.de/top/pntd/ptNetb'
		)
}

-- The Place rule generates a Place corresponds to the input PetriNet Place element. 
-- Name of the generated Place is copied from the one of the input Place, by creating a PNML Name composed of a PNML Label which value is initialized by the PetriNet Place name.
rule Place {
	from
		e : PetriNet!Place
	to
		n : PNML!Place
		(
			name <- name,
			id <- e.name,
			location <- e.location			
		),
		name : PNML!Name
		(
			labels <- label
		),
		label : PNML!Label
		(
			text <- e.name
		)
}

-- The Transition rule generates a Transition corresponds to the input PetriNet Transition element. 
-- Name of the generated Transition is copied from the one of the input Transition, by creating a PNML Name composed of a PNML Label which value is initialized by the PetriNet Transition name.
rule Transition {
	from
		e : PetriNet!Transition
	to
		n : PNML!Transition
		(
			name <- name,
			id <- e.name,
			location <- e.location
		),
		name : PNML!Name
		(
			labels <- label
		),
		label : PNML!Label
		(
			text <- e.name
		)
}

-- The Arc rule generates a Arc corresponds to the input PetriNet Arc element (TransitionToPlace and PlaceToTransition). 
-- Name of the generated Arc is copied from the one of the input Arc, by creating a PNML Name composed of a PNML Label which value is initialized by the PetriNet Arc name.
-- Its source and target references are also copied from the input Arc and correspond respectively to the from and to references.
rule Arc {
	from
		e : PetriNet!Arc
	to
		n : PNML!Arc
		(
			name <- name,
			location <- e.location,
			id <- e.name,
			source <- e.""from"",
			target <- e.""to""
		),
		name : PNML!Name
		(
			labels <- label
		),
		label : PNML!Label
		(
			text <- e.name
		)
}",modul petrinet pnml creat out pnml in petrinet the pnmldocument rule generat pnmldocument netel correspond input petrinet element name generat netel copi one input petrinet creat pnml name compos pnml label valu initi petrinet name it set content correspond union petrinet element arc rule pnmldocument e petrinet petrinet n pnml pnmldocument locat e locat xmlns uri net net uri pnml uri valu http www informatik hu berlin de top pnml ptnetb net pnml netel name name locat e locat id e locat type type uri content e element union e arc name pnml name label label label pnml label text e name type uri pnml uri valu http www informatik hu berlin de top pntd ptnetb the place rule generat place correspond input petrinet place element name generat place copi one input place creat pnml name compos pnml label valu initi petrinet place name rule place e petrinet place n pnml place name name id e name locat e locat name pnml name label label label pnml label text e name the transit rule generat transit correspond input petrinet transit element name generat transit copi one input transit creat pnml name compos pnml label valu initi petrinet transit name rule transit e petrinet transit n pnml transit name name id e name locat e locat name pnml name label label label pnml label text e name the arc rule generat arc correspond input petrinet arc element transitiontoplac placetotransit name generat arc copi one input arc creat pnml name compos pnml label valu initi petrinet arc name it sourc target refer also copi input arc correspond respect refer rule arc e petrinet arc n pnml arc name name locat e locat id e name sourc e target e name pnml name label label label pnml label text e name,3
60,60,P31-PNML2PetriNet.atl,"module PNML2PetriNet;
create OUT : PetriNet from IN : PNML;

-- The PetriNet rule generates a PetriNet which corresponds to the input NetElement included in the PNMLDocument. 
-- Name of the generated PetriNet is copied from the one of the input NetElement, by recovering the value of the PNML Label included in the PNML Name of the NetElement.
-- Its set of Elements is the corresponding set named elementsSet calculated in the using clause.
-- And its set of Arcs is the corresponding set named arcsSet calculated in the using clause.
rule PetriNet {
	from
		n : PNML!PNMLDocument
	using{
			elementsSet : Set(PetriNet!Element) =
				PNML!NetContentElement.allInstances();
	
			arcsSet : Set(PetriNet!Arc) =
				PNML!Arc.allInstances();			
		}
	to
		p : PetriNet!PetriNet
		(
			location <- n.location,
			name <- n.nets.first().name.labels.first().text,
			elements <- elementsSet,
			arcs <- arcsSet
		)
}

-- The Place rule generates a Place which corresponds to the input Place. 
-- Name of the generated Place is copied from the one of the input Place , by recovering the value of the PNML Label included in the PNML Name of the PNML Place.
rule Place {
	from
		n : PNML!Place
	to
		p : PetriNet!Place
		(
			location <- n.location,
			name <- n.name.labels.first().text,
			net <- n.net.document
		)
}

-- The Transition rule generates a Transition which corresponds to the input Transition . 
-- Name of the generated Transition is copied from the one of the input Transition , by recovering the value of the PNML Label included in the PNML Name of the PNML Transition .
rule Transition {
	from
		n : PNML!Transition
	to
		p : PetriNet!Transition
		(
			location <- n.location,
			name <- n.name.labels.first().text,
			net <- n.net.document
		)
}

-- The PlaceToTransition rule generates a PlaceToTransition which corresponds to the input Arc which has a Place for source and a Transition for Target. 
-- Name of the generated PlaceToTransition is copied from the one of the input Arc, by recovering the value of the PNML Label included in the PNML Name of the PNML Arc.
-- Its from and to references are also copied from the input Arc and correspond respectively to the source and target references.
rule PlaceToTransition {
	from
		n : PNML!Arc 
		(	-- arc source must be a place and arc target a transition
			n.source.oclIsKindOf(PNML!Place) and n.target.oclIsKindOf(PNML!Transition)
		)
	to
		p : PetriNet!PlaceToTransition
		(
			location <- n.location,
			name <- n.name.labels.first().text,
			net <- n.net.document,
			""from"" <- n.source,
			""to"" <- n.target
		)
}

-- The TransitionToPlace rule generates a TransitionToPlace which corresponds to the input Arc which has a Transition for source and a Place for Target.
-- Name of the generated TransitionToPlace is copied from the one of the input Arc, by recovering the value of the PNML Label included in the PNML Name of the PNML Arc.
-- Its from and to references are also copied from the input Arc and correspond respectively to the source and target references.
rule TransitionToPlace {
	from
		n : PNML!Arc 
		(	-- arc source must be a transition and arc target a place
			n.source.oclIsKindOf(PNML!Transition) and n.target.oclIsKindOf(PNML!Place)
		)
	to
		p : PetriNet!TransitionToPlace
		(
			location <- n.location,
			name <- n.name.labels.first().text,
			net <- n.net.document,
			""from"" <- n.source,
			""to"" <- n.target
		)
}",modul pnml petrinet creat out petrinet in pnml the petrinet rule generat petrinet correspond input netel includ pnmldocument name generat petrinet copi one input netel recov valu pnml label includ pnml name netel it set element correspond set name elementsset calcul use claus and set arc correspond set name arcsset calcul use claus rule petrinet n pnml pnmldocument use elementsset set petrinet element pnml netcontentel allinst arcsset set petrinet arc pnml arc allinst p petrinet petrinet locat n locat name n net first name label first text element elementsset arc arcsset the place rule generat place correspond input place name generat place copi one input place recov valu pnml label includ pnml name pnml place rule place n pnml place p petrinet place locat n locat name n name label first text net n net document the transit rule generat transit correspond input transit name generat transit copi one input transit recov valu pnml label includ pnml name pnml transit rule transit n pnml transit p petrinet transit locat n locat name n name label first text net n net document the placetotransit rule generat placetotransit correspond input arc place sourc transit target name generat placetotransit copi one input arc recov valu pnml label includ pnml name pnml arc it refer also copi input arc correspond respect sourc target refer rule placetotransit n pnml arc arc sourc must place arc target transit n sourc ocliskindof pnml place n target ocliskindof pnml transit p petrinet placetotransit locat n locat name n name label first text net n net document n sourc n target the transitiontoplac rule generat transitiontoplac correspond input arc transit sourc place target name generat transitiontoplac copi one input arc recov valu pnml label includ pnml name pnml arc it refer also copi input arc correspond respect sourc target refer rule transitiontoplac n pnml arc arc sourc must transit arc target place n sourc ocliskindof pnml transit n target ocliskindof pnml place p petrinet transitiontoplac locat n locat name n name label first text net n net document n sourc n target,3
61,61,P31-PNML2XML.atl,"module PNML2XML;
create OUT : XML from IN : PNML;

-- The getRoot helper, is a constant helper. It seeks the root element of PNML model : the PNML document.
-- This helper allows to link elements and their parents, thanks to a resolveTemp instruction.
-- CONTEXT: n/a
-- RETURN: PNML!PNMLDocument
helper def: getRoot() : PNML!PNMLDocument =
	PNML!PNMLDocument.allInstances()->asSequence()->first();


-- The Root rule generates the XML Root element as well as a collection of attributes and elements and Text node from the input PNMLDocument element. The generated Root element is a pnml tag that has an xmlns Attribute and a net Element as children. 
-- Value of the xmlns attribute is copied from the PNMLDocument. The net Element has an id and a type Attribute, a name sub-Element.The id attribute and the type attribute are also copied from the input element.
-- Finally, the name Element contains a text Element, which itself contains a Text node whose value corresponds to the name of the input PNMLDocument element.
rule Root {
	from
		n : PNML!PNMLDocument
	to
		e : XML!Root
		(
			name <- 'pnml',
			-- value = name of the net contained by this document
			value <- n.nets.first().name.labels.first().text,
			children <- Sequence {document_name, document_xmlns, document_net}
		),
		document_name : XML!Element
		(
			name <- 'name',
			parent <- n,
			children <- document_text
		),
		document_text : XML!Element
		(
			name <- 'text',
			parent <- document_name,
			children <- document_xml_text
		),
		document_xml_text : XML!Text
		(
			value <- n.nets.first().name.labels.first().text,
			parent <- document_text
		),		
		document_xmlns : XML!Attribute
		(
			name <- 'xmlns',
			value <- n.xmlns.value,
			parent <- n
		),
		document_net : XML!Element
		(
			name <-'net',
			value <- n.nets.first().name.labels.first().text,
			parent <- n,
			children <- Sequence {net_name, net_id, net_type}
		),
		net_name : XML!Element
		(
			name <- 'name',
			parent <- document_net,
			children <- net_text
		),
		net_text : XML!Element
		(
			name <- 'text',
			parent <- net_name,
			children <- net_xml_text
		),
		net_xml_text : XML!Text
		(
			value <- n.nets.first().name.labels.first().text,
			parent <- net_text
		),
		net_id : XML!Attribute
		(
			name <- 'id',
			value <- n.nets.first().id,
			parent <- document_net
		),
		net_type : XML!Attribute
		(
			name <-'type',
			value <- n.nets.first().type.value,
			parent <- document_net
		)
}

-- The Place rule generates three XML Elements, one XML Attribute and one XML Text for each PNML Place input element.
-- The first generated Element, place, is a place tag which accepts an id Attribute as well as a child name Element. The value of the id attribute corresponds to the one of the PNML Place.
-- The generated name Element accepts a text Element as child. This last one has a child which is a Text node. Its value corresponds to the name of the input Place.
rule Place {
	from
		n : PNML!NetContentElement
		(
			n.oclIsKindOf(PNML!Place)
		)		
	to
		place : XML!Element
		(
			name <- 'place',
			value <- n.name.labels.first().text,
			parent <- thisModule.resolveTemp(thisModule.getRoot(), 'document_net'),
			children <- Sequence{place_id, place_name}
		),
		place_id : XML!Attribute
		(
			name <- 'id',
			value <- n.id,
			parent <- n
		),
		place_name : XML!Element
		(
			name <- 'name',
			parent <- n,
			children <- place_text
		),
		place_text : XML!Element
		(
			name <- 'text',
			parent <- place_name,
			children <- place_xml_text
		),
		place_xml_text : XML!Text
		(
			value <- n.name.labels.first().text,
			parent <- place_text
		)

}

-- The Transition rule generates three XML Elements, one XML Attribute and one XML Text for each PNML Transition input element.
-- The first generated Element, transition, is a transition tag which accepts an id Attribute as well as a child name Element. The value of the id attribute corresponds to the one of the PNML Transition. 
-- The generated name Element accepts a text Element as child. This last one has a child which is a Text node. Its value corresponds to the name of the input Transition.
rule Transition {
	from
		n : PNML!NetContentElement
		(
			n.oclIsKindOf(PNML!Transition)
		)
	to
		transition : XML!Element
		(
			name <- 'transition',
			value <- n.name.labels.first().text,
			parent <- thisModule.resolveTemp(thisModule.getRoot(), 'document_net'),
			children <- Sequence{transition_id, transition_name}
		),
		transition_id : XML!Attribute
		(
			name <- 'id',
			value <- n.id,
			parent <- n
		),
		transition_name : XML!Element
		(
			name <- 'name',
			parent <- n,
			children <- transition_text
		),
		transition_text : XML!Element
		(
			name <- 'text',
			parent <- transition_name,
			children <- transition_xml_text
		),
		transition_xml_text : XML!Text
		(
			value <- n.name.labels.first().text,
			parent <- transition_text
		)
		
}

-- The Arc rule generates three XML Elements, three XML Attributes and one XML Text for each PNML Arc input element.
-- The generated Element is an arc tag that has three Attribute children: id, source and target, as well as a child name Element. The value of the id attribute corresponds to the one of the PNML Arc. Values of the source and target attributes respectively correspond to the id of the source and the id of the target of the input Arc.
-- The generated name Element accepts a text Element as child. This last one has a child which is a Text node. Its value corresponds to the name of the input Transition.
rule Arc {
	from
		n : PNML!Arc
	to
		arc : XML!Element
		(
			name <- 'arc',
			value <- n.name.labels.first().text,
			parent <- thisModule.resolveTemp(thisModule.getRoot(), 'document_net'),
			children <- Sequence {arc_name, arc_id, source, target}
		),
		arc_id : XML!Attribute
		(
			name <- 'id',
			value <- n.id,
			parent <- n
		),
		arc_name : XML!Element
		(
			name <- 'name',
			parent <- n,
			children <- arc_text
		),
		arc_text : XML!Element
		(
			name <- 'text',
			parent <- arc_name,
			children <- arc_xml_text
		),
		arc_xml_text : XML!Text
		(
			value <- n.name.labels.first().text,
			parent <- arc_text
		),
		-- source and target attribute are initialised by the id of the element pointed
		source : XML!Attribute
		(
			name <- 'source',
			value <- n.source.id,
			parent <- n
		),
		target : XML!Attribute
		(
			name <- 'target',
			value <- n.target.id,
			parent <- n
		)
}",modul pnml xml creat out xml in pnml the getroot helper constant helper it seek root element pnml model pnml document this helper allow link element parent thank resolvetemp instruct context n return pnml pnmldocument helper def getroot pnml pnmldocument pnml pnmldocument allinst assequ first the root rule generat xml root element well collect attribut element text node input pnmldocument element the generat root element pnml tag xmlns attribut net element children valu xmlns attribut copi pnmldocument the net element id type attribut name sub element the id attribut type attribut also copi input element final name element contain text element contain text node whose valu correspond name input pnmldocument element rule root n pnml pnmldocument e xml root name pnml valu name net contain document valu n net first name label first text children sequenc document name document xmlns document net document name xml element name name parent n children document text document text xml element name text parent document name children document xml text document xml text xml text valu n net first name label first text parent document text document xmlns xml attribut name xmlns valu n xmlns valu parent n document net xml element name net valu n net first name label first text parent n children sequenc net name net id net type net name xml element name name parent document net children net text net text xml element name text parent net name children net xml text net xml text xml text valu n net first name label first text parent net text net id xml attribut name id valu n net first id parent document net net type xml attribut name type valu n net first type valu parent document net the place rule generat three xml element one xml attribut one xml text pnml place input element the first generat element place place tag accept id attribut well child name element the valu id attribut correspond one pnml place the generat name element accept text element child this last one child text node it valu correspond name input place rule place n pnml netcontentel n ocliskindof pnml place place xml element name place valu n name label first text parent thismodul resolvetemp thismodul getroot document net children sequenc place id place name place id xml attribut name id valu n id parent n place name xml element name name parent n children place text place text xml element name text parent place name children place xml text place xml text xml text valu n name label first text parent place text the transit rule generat three xml element one xml attribut one xml text pnml transit input element the first generat element transit transit tag accept id attribut well child name element the valu id attribut correspond one pnml transit the generat name element accept text element child this last one child text node it valu correspond name input transit rule transit n pnml netcontentel n ocliskindof pnml transit transit xml element name transit valu n name label first text parent thismodul resolvetemp thismodul getroot document net children sequenc transit id transit name transit id xml attribut name id valu n id parent n transit name xml element name name parent n children transit text transit text xml element name text parent transit name children transit xml text transit xml text xml text valu n name label first text parent transit text the arc rule generat three xml element three xml attribut one xml text pnml arc input element the generat element arc tag three attribut children id sourc target well child name element the valu id attribut correspond one pnml arc valu sourc target attribut respect correspond id sourc id target input arc the generat name element accept text element child this last one child text node it valu correspond name input transit rule arc n pnml arc arc xml element name arc valu n name label first text parent thismodul resolvetemp thismodul getroot document net children sequenc arc name arc id sourc target arc id xml attribut name id valu n id parent n arc name xml element name name parent n children arc text arc text xml element name text parent arc name children arc xml text arc xml text xml text valu n name label first text parent arc text sourc target attribut initialis id element point sourc xml attribut name sourc valu n sourc id parent n target xml attribut name target valu n target id parent n,11
62,62,P31-XML2PNML.atl,"module XML2PNML;
create OUT : PNML from IN : XML;

-- The getAttrVal helper, returns the value of an attribute (identified by its name, passed as a parameter) of the contextual XML Element.
-- For this purpose, its collects, among the children of this contextual Element, the Attribute whose name matches the name passed in parameter.
-- The helper returns the value of the first matched attribute.
-- CONTEXT: XML!Element
-- RETURN: String
helper context XML!Element def: getAttrVal(name : String) : String =
	let a : Sequence(XML!Attribute) = self.children->select(c | c.oclIsTypeOf(XML!Attribute) and c.name = name) in
	if a.isEmpty() then 
		''
	else
		a.first().value
	endif;

-- The getName() helper returns the name of a net or a place XML Element.
-- To this end, it first gets, among its Element children, the one named name.
-- It then gets the text XML Element child of this new node, and finally returns the value associated with it.
-- CONTEXT: XML!Element
-- RETURN: String
helper context XML!Element def : getName() : String =
	self.children->select(c | c.oclIsTypeOf(XML!Element) and c.name = 'name')->first().children
		->select(d | d.oclIsTypeOf(XML!Element) and d.name = 'text')->first().children
		->select(e | e.oclIsKindOf(XML!Text))->first().value;

-- The getLink helper, collects all instances of xml element and search the one whose id matches the id passed in parameter.
-- The helper returns the first xml element of the collection.
-- CONTEXT: n/a
-- RETURN: XML!Element
helper def: getLink(id : String) : XML!Element =
	XML!Element.allInstances()->select(z | z.getAttrVal('id') = id)->first();


-- The PNMLDocument rule generates a PNMLDocument from the input XML Root Element.
rule PNMLDocument {
	from
		x : XML!Root
	to
		document : PNML!PNMLDocument
		(
			xmlns <- uri
		),
		uri : PNML!URI
		(
			value <- x.getAttrVal('xmlns')
		)
}

-- The Net rule generates a NetElement from each net XML Element input element. 
-- Name of the generated NetElement is computed by calling the getName helper. 
-- Its set of Places, Transitions and Arcs are initialized by the other rules.
-- The link to its parent, the PNMLDocument, is also created.
rule Net {
	from
		x : XML!Element
		(
			x.name = 'net'
		)
	to
		net_element : PNML!NetElement
		(
			name <- named_element,
			type <- type_uri,
			-- pointer on the root element
			document <- x.parent
		),
		type_uri : PNML!URI
		(
			value <- x.getAttrVal('type')
		),
		named_element : PNML!Name
		(
			labels <- label
		),
		label : PNML!Label
		(
			text <- x.getName()
		)
}

-- The Place rule generates a PNML Place for each place XML Element. 
-- Name of the generated Place is computed by a call to the getName helper. 
-- Its id is copied from the one of the input XML Element.
-- The link to its parent, the NetElement, is also created.
rule Place {
	from
		x : XML!Element
		(
			x.name = 'place'
		)
	to
		n : PNML!Place
		(
			name <- named_element,
			-- pointer on the net element
			net <- x.parent,
			id <- x.getAttrVal('id'),
			location <- ''
		),
		named_element : PNML!Name
		(
			labels <- label
		),
		label : PNML!Label
		(
			text <- x.getName()
		)
}

-- The Transition rule generates a PNML Transition for each transition XML Element. 
-- Name of the generated Transition is computed by a call to the getName helper. 
-- Its id is copied from the one of the input XML Element.
-- The link to its parent, the NetElement, is also created.
rule Transition {
	from
		x : XML!Element
		(
			x.name = 'transition'
		)
	to
		n : PNML!Transition
		(
			name <- named_element,
			-- pointer on the net element
			net <- x.parent,
			id <- x.getAttrVal('id')		
		),
		named_element : PNML!Name
		(
			labels <- label
		),
		label : PNML!Label
		(
			text <- x.getName()
		)
}

-- The Arc rule generates a PNML Arc for each arc XML Element. 
-- Name of the generated Arc is computed by a call to the getName helper. 
-- Its id is copied from the one of the input XML Element.
-- Its source (obtained by means of the getLink helper) corresponds to the XML Element which id is contained in the child attribute named source. Idem for the target.
-- The link to its parent, the NetElement, is also created.
rule Arc {
	from
		x : XML!Element
		(
			x.name = 'arc'
		)
	to
		n : PNML!Arc
		(
			name <- named_element,
			id <- x.getAttrVal('id'),
			net <- x.parent,
			-- seek of the element pointed by the source id contained in the xml file
			source <- thisModule.getLink(
				(x.children->select(c | c.oclIsKindOf(XML!Attribute) and c.name = 'source')->first().value)	
			),
			-- seek of the element pointed by the target id contained in the xml file
			target <- thisModule.getLink(
				(x.children->select(c | c.oclIsKindOf(XML!Attribute) and c.name = 'target')->first().value)	
			)
			
		),
		named_element : PNML!Name
		(
			labels <- label
		),
		label : PNML!Label
		(
			text <- x.getName()
		)
}
",modul xml pnml creat out pnml in xml the getattrv helper return valu attribut identifi name pass paramet contextu xml element for purpos collect among children contextu element attribut whose name match name pass paramet the helper return valu first match attribut context xml element return string helper context xml element def getattrv name string string let sequenc xml attribut self children select c c oclistypeof xml attribut c name name isempti els first valu endif the getnam helper return name net place xml element to end first get among element children one name name it get text xml element child new node final return valu associ context xml element return string helper context xml element def getnam string self children select c c oclistypeof xml element c name name first children select oclistypeof xml element name text first children select e e ocliskindof xml text first valu the getlink helper collect instanc xml element search one whose id match id pass paramet the helper return first xml element collect context n return xml element helper def getlink id string xml element xml element allinst select z z getattrv id id first the pnmldocument rule generat pnmldocument input xml root element rule pnmldocument x xml root document pnml pnmldocument xmlns uri uri pnml uri valu x getattrv xmlns the net rule generat netel net xml element input element name generat netel comput call getnam helper it set place transit arc initi rule the link parent pnmldocument also creat rule net x xml element x name net net element pnml netel name name element type type uri pointer root element document x parent type uri pnml uri valu x getattrv type name element pnml name label label label pnml label text x getnam the place rule generat pnml place place xml element name generat place comput call getnam helper it id copi one input xml element the link parent netel also creat rule place x xml element x name place n pnml place name name element pointer net element net x parent id x getattrv id locat name element pnml name label label label pnml label text x getnam the transit rule generat pnml transit transit xml element name generat transit comput call getnam helper it id copi one input xml element the link parent netel also creat rule transit x xml element x name transit n pnml transit name name element pointer net element net x parent id x getattrv id name element pnml name label label label pnml label text x getnam the arc rule generat pnml arc arc xml element name generat arc comput call getnam helper it id copi one input xml element it sourc obtain mean getlink helper correspond xml element id contain child attribut name sourc idem target the link parent netel also creat rule arc x xml element x name arc n pnml arc name name element id x getattrv id net x parent seek element point sourc id contain xml file sourc thismodul getlink x children select c c ocliskindof xml attribut c name sourc first valu seek element point target id contain xml file target thismodul getlink x children select c c ocliskindof xml attribut c name target first valu name element pnml name label label label pnml label text x getnam,0
63,63,P31-XML2Text.atl,"query XML2Text = XML!Root.allInstances()
	->asSequence()
	->first().toString2('').writeTo('C:\\... Complete this path ...\\Grafcet-PetriNet\\Models\\XML2Text_example.xml');

helper context XML!Element def: toString2(indent : String) : String =
	let na : Sequence(XML!Node) =
		self.children->select(e | not e.oclIsKindOf(XML!Attribute)) in
	let a : Sequence(XML!Node) =
		self.children->select(e | e.oclIsKindOf(XML!Attribute)) in
	indent + '<' + self.name + 
	a->iterate(e; acc : String = '' |
		acc + ' ' + e.toString2()
	) +
	if na->size() > 0 then
		'>'
		+ na->iterate(e; acc : String = '' |
			acc + 
			if e.oclIsKindOf(XML!Text) then
				''
			else
				'\r\n'
			endif
			+ e.toString2(indent + '  ')
		) +
		if na->first().oclIsKindOf(XML!Text) then
			'</' + self.name + '>'
			else
				'\r\n' + indent + '</' + self.name + '>'
		endif
	else
		'/>'
	endif;

helper context XML!Attribute def: toString2() : String =
	self.name + '=\""' + self.value + '\""';

helper context XML!Text def: toString2() : String =
	self.value;",queri xml text xml root allinst assequ first tostr writeto c complet path grafcet petrinet model xml text exampl xml helper context xml element def tostr indent string string let na sequenc xml node self children select e e ocliskindof xml attribut let sequenc xml node self children select e e ocliskindof xml attribut indent self name iter e acc string acc e tostr na size na iter e acc string acc e ocliskindof xml text els r n endif e tostr indent na first ocliskindof xml text self name els r n indent self name endif els endif helper context xml attribut def tostr string self name self valu helper context xml text def tostr string self valu,5
64,64,P32-IEEE1471_2_MoDAF.atl,"--@name			IEEE1471_2_MoDAF 
--@version		1.1	
--@domains		Architectural Description of Complex Systems
--@authors		Albin Jossic (jossic.albin<at>gmail.com) 
--@date			2006/05/16	
--@description	It is a conceptual transformation between IEEE1471 Conceptual Model and MoDAF Architecture View. IEEE-1471 is a terminology that dfines View and Viewpoints concepts about Architectural Descriptions. MoDAF is an Architecture framework specifies by the British Ministry of Defense that is based on the IEEE1471 terminology.
--@see			IEEE1471ConceptualModel.km3
--@see			MoDAF-AV.km3
--@see			""Recommended Practice for Architectural description of Softwrare-Intensive Systems"", IEEE Std 1471-2000, IEEE, 2000.
--@see			http://modaf.modelfutures.com/m3/


module IEEE1471_2_MoDAF; 
create OUT : MoDAF  from IN : IEEE1471 ;

--@begin helper rationale
helper def : rationale : 
	String =
		Sequence{} -> union(IEEE1471!Rationale.allInstances()) -> first().name
		+  ', ' +
		Sequence{} -> union(IEEE1471!Rationale.allInstances()) -> first().content 
	;
--@end helper rationale

--@begin IEEE1471Model 2 MoDAFModel
rule IEEE1471Model2MoDAFModel {
	from
		mFrom : IEEE1471!IEEE1471Model
	to
		mTo : MoDAF!MoDAFModel(
			name <- mFrom.name,
			content <- mFrom.content,
			enterprise <- mFrom.system,
			environment <- mFrom.environment,
			operationalMissions <- mFrom.missions,
			architectures <- mFrom.architecture,
			architecturalDescription <- mFrom.architecturalDescription,
			stakeholders <- mFrom.stakeholders,
			architecturalFrameworks <- mFrom.libraryViewpoints -> append(default)
		),
		default : MoDAF!ArchitecturalFramework (
			name <- 'Undefined Architectural Framework',
			ownedMember <- Sequence{} 
				-> union(IEEE1471!Viewpoint.allInstances()) 
				-> select(vp | vp.hasSource.oclIsUndefined())
		)		
}
--@end Mission 2 OperationalMission

--@begin System 2 Enterprise
rule System2Enterprise {
	from
		eFrom : IEEE1471!System
	to
		eTo : MoDAF!Enterprise(
			name <- eFrom.name,
			content <- eFrom.content,
			fulfills <- eFrom.fulfills,
			inhabits <- eFrom.inhabits
		)		
}
--@end System 2 Enterprise

--@begin Environment 2 Environment
rule Environment2Environment {
	from
		eFrom : IEEE1471!Environment
	to
		eTo : MoDAF!Environment(
			name <- eFrom.name,
			content <- eFrom.content,
			influences <- eFrom.influences
		)		
}
--@end Environment 2 Environment

--@begin Mission 2 OperationalMission
rule Mission2OperationalMission {
	from
		eFrom : IEEE1471!Mission
	to
		eTo : MoDAF!OperationalMission(
			name <- eFrom.name,
			content <- eFrom.content		
		)		
}
--@end Mission 2 OperationalMission

--@begin Architecture 2 Architecture
rule Architecture2Architecture {
	from
		eFrom : IEEE1471!Architecture
	to
		eTo : MoDAF!Architecture(
			name <- eFrom.name,
			content <- eFrom.content,
			enterprise <- Sequence{}
				->union(IEEE1471!System.allInstances())
				-> first(),
			describedBy <- eFrom.describedBy
		)		
}
--@end Architecture 2 Architecture

--@begin ArchitecturalDescription 2 ArchitecturalDescription
rule AD2AD {
	from
		eFrom : IEEE1471!ArchitecturalDescription
	to
		eTo : MoDAF!ArchitecturalDescription(
			name <- eFrom.name,
			content <- eFrom.content,
			products <- eFrom.organizedBy,
			purpose <- thisModule.rationale,
			viewpoints <- eFrom.selects
		)		
}
--@end ArchitecturalDescription 2 ArchitecturalDescription

--@begin Stakeholder 2 Stakeholder
rule Stakeholder2Stakeholder {
	from
		eFrom : IEEE1471!Stakeholder
	to
		eTo : MoDAF!Stakeholder(
			name <- eFrom.name,
			content <- eFrom.content		
		)		
}
--@end Stakeholder 2 Stakeholder

--@begin Viewpoint 2 View
rule Viewpoint2View {
	from
		eFrom : IEEE1471!Viewpoint
	to
		eTo : MoDAF!View(
			name <- eFrom.name,
			content <- eFrom.content,
			viewName <- eFrom.name,
			viewDescription <- eFrom.content,
			framework <-
				if eFrom.hasSource.oclIsUndefined()
				then 'Undefined'
				else eFrom.hasSource.name	
				endif,
			usedToCover <- eFrom.usedToCover,
			definingFramework <- eFrom.hasSource			
		)		
}
--@end Viewpoint 2 View

--@begin View 2 ArchitecturalProduct
rule View2ArchitecturalProduct {
	from
		eFrom : IEEE1471!View
	to
		eTo : MoDAF!ArchitecturalProduct(
			name <- eFrom.name,
			content <- eFrom.content,
			description <- eFrom.name + ', ' + eFrom.content,
			definingView <- eFrom.conformsTo,
			addresses <- eFrom.conformsTo.usedToCover,
			architecturalElements <- eFrom.consitsOf
		)		
}
--@end View 2 ArchitecturalProduct

--@begin Model 2 Elements
rule Model2Element {
	from
		eFrom : IEEE1471!Model
	to
		eTo : MoDAF!Elements(
			name <- eFrom.name,
			content <- eFrom.content
		)		
}
--@end Model 2 Elements

--@begin Concern 2 Concern
rule Concern2Concern {
	from
		eFrom : IEEE1471!Concern
	to
		eTo : MoDAF!Concern(
			name <- eFrom.name,
			content <- eFrom.content		
		)		
}
--@end Concern 2 Concern

--@begin LibraryViewpoint 2 ArchitecturalFramework
rule LibraryViewpoint2ArchitecturalFramework {
	from
		eFrom : IEEE1471!LibraryViewpoint
	to
		eTo : MoDAF!ArchitecturalFramework(
			name <- eFrom.name,
			content <- eFrom.content,
			ownedMember <- Sequence{}
				-> select(e | e.isOCLTypeOf(IEEE1471!Viewpoint))
				-> select(vp | vp.hasSource=eFrom)	
		)		
}
--@end LibraryViewpoint 2 ArchitecturalFramework

--@begin StakeholderHasConcern
rule StakeholderHasConcern {
	from
		stakeholder : IEEE1471!Stakeholder,
		concern : IEEE1471!Concern
		(
			stakeholder.has.includes(concern)
			and
			concern.isImportantTo.includes(stakeholder)				
		)
	to
		shhc : MoDAF!StakeholderHasConcern (
			client <- stakeholder,
			supplier <- concern,
			owner <- thisModule.resolveTemp(
					  	Sequence{} -> union(IEEE1471!IEEE1471Model.allInstances()) -> first(),
						'mTo'
					)
			--other solution for owner : owner <- Sequence{}->union(IEEE1471!IEEE1471Model.allInstances())->first()
		)
}
--@end StakeholderHasConcern",name ieee modaf version domain architectur descript complex system author albin jossic jossic albin gmail com date descript it conceptu transform ieee conceptu model modaf architectur view ieee terminolog dfine view viewpoint concept architectur descript modaf architectur framework specifi british ministri defens base ieee terminolog see ieee conceptualmodel km see modaf av km see recommend practic architectur descript softwrar intens system ieee std ieee see http modaf modelfutur com modul ieee modaf creat out modaf in ieee begin helper rational helper def rational string sequenc union ieee rational allinst first name sequenc union ieee rational allinst first content end helper rational begin ieee model modafmodel rule ieee model modafmodel mfrom ieee ieee model mto modaf modafmodel name mfrom name content mfrom content enterpris mfrom system environ mfrom environ operationalmiss mfrom mission architectur mfrom architectur architecturaldescript mfrom architecturaldescript stakehold mfrom stakehold architecturalframework mfrom libraryviewpoint append default default modaf architecturalframework name undefin architectur framework ownedmemb sequenc union ieee viewpoint allinst select vp vp hassourc oclisundefin end mission operationalmiss begin system enterpris rule system enterpris efrom ieee system eto modaf enterpris name efrom name content efrom content fulfil efrom fulfil inhabit efrom inhabit end system enterpris begin environ environ rule environ environ efrom ieee environ eto modaf environ name efrom name content efrom content influenc efrom influenc end environ environ begin mission operationalmiss rule mission operationalmiss efrom ieee mission eto modaf operationalmiss name efrom name content efrom content end mission operationalmiss begin architectur architectur rule architectur architectur efrom ieee architectur eto modaf architectur name efrom name content efrom content enterpris sequenc union ieee system allinst first describedbi efrom describedbi end architectur architectur begin architecturaldescript architecturaldescript rule ad ad efrom ieee architecturaldescript eto modaf architecturaldescript name efrom name content efrom content product efrom organizedbi purpos thismodul rational viewpoint efrom select end architecturaldescript architecturaldescript begin stakehold stakehold rule stakehold stakehold efrom ieee stakehold eto modaf stakehold name efrom name content efrom content end stakehold stakehold begin viewpoint view rule viewpoint view efrom ieee viewpoint eto modaf view name efrom name content efrom content viewnam efrom name viewdescript efrom content framework efrom hassourc oclisundefin undefin els efrom hassourc name endif usedtocov efrom usedtocov definingframework efrom hassourc end viewpoint view begin view architecturalproduct rule view architecturalproduct efrom ieee view eto modaf architecturalproduct name efrom name content efrom content descript efrom name efrom content definingview efrom conformsto address efrom conformsto usedtocov architecturalel efrom consitsof end view architecturalproduct begin model element rule model element efrom ieee model eto modaf element name efrom name content efrom content end model element begin concern concern rule concern concern efrom ieee concern eto modaf concern name efrom name content efrom content end concern concern begin libraryviewpoint architecturalframework rule libraryviewpoint architecturalframework efrom ieee libraryviewpoint eto modaf architecturalframework name efrom name content efrom content ownedmemb sequenc select e e isocltypeof ieee viewpoint select vp vp hassourc efrom end libraryviewpoint architecturalframework begin stakeholderhasconcern rule stakeholderhasconcern stakehold ieee stakehold concern ieee concern stakehold includ concern concern isimportantto includ stakehold shhc modaf stakeholderhasconcern client stakehold supplier concern owner thismodul resolvetemp sequenc union ieee ieee model allinst first mto solut owner owner sequenc union ieee ieee model allinst first end stakeholderhasconcern,9
65,65,P33-PrimaryKey-context.atl,"-- @name		Introducing Primary key
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		Baudry Julien (jul.baudry<at>gmail.com)
-- @date		2006/08/02
-- @description	The purpose of this transformation is to introduce a primary key in each class
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 1.6, page 6
-- @see author of article : K. Lano

module PrimaryKey; 
create OUT : KM3target from IN : KM3;

----@begin rule Metamodel
--entrypoint rule Metamodel() {
--	do {
--		KM3!Metamodel.allInstances().debug('metamodels');
--		KM3!Package.allInstances().debug('packages');
--		KM3!Class.allInstances().debug('classes');
--		KM3!DataType.allInstances().debug('datatypes');
--	}
--}
----@end rule Metamodel

--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3target!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
--@end rule Metamodel

--@begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3target!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
--@end rule Package

--@begin rule Class
rule Class {
	from
		inputA:KM3!Class 
	to
		outputA:KM3target!Class (
			name <- inputA.name,
			isAbstract <- inputA.isAbstract,
			structuralFeatures <- inputA.structuralFeatures,
			supertypes <- inputA.supertypes
		),

		key:KM3target!Attribute (
			name <- inputA.name.toLower()+'Key',
			isOrdered <- false,
			isUnique <- false,
			location <- '',
			lower <- 1,
			upper <- 1,
			type <- KM3!DataType.allInstances()->select(a|a.name = 'Integer')->first(),
			owner <- outputA
		)
}
--@end rule Class

--@begin rule attribute 
rule attribute {
	from
		inputAtt:KM3!Attribute 
	to
		outputAtt:KM3target!Attribute(
			name <- inputAtt.name,
			isOrdered <- inputAtt.isOrdered,
			isUnique <- inputAtt.isUnique,
			location <- inputAtt.location,
			lower <- inputAtt.lower,
			upper <- inputAtt.upper,
			type <- inputAtt.type,
			owner <- inputAtt.owner
			
		)
}
--@end rule attribute

--@begin rule DataType
rule DataType {
from
		inputData:KM3!DataType
	to
		outputData:KM3target!DataType(
			name <- inputData.name,
			location <- inputData.location
		)
}
--@end rule DataType

--@begin reference
rule reference {
	from
		inputRef:KM3!Reference 
	to
		outputRef:KM3target!Reference (
			name <- inputRef.name,
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			location <- inputRef.location,
			lower <- inputRef.lower,
			upper <- inputRef.upper,
			type <- inputRef.type,
			owner <- inputRef.owner,
			opposite <- inputRef.opposite
		)
}
--@end reference

--@begin enumeration
rule enumeration {
	from
		inputEnum:KM3!Enumeration 
	to
		outputEnum:KM3target!Enumeration (
			location <- inputEnum.location,
			name  <- inputEnum.name,
			package  <- inputEnum.package
		)

}
--@end enumeration

--@begin literal
rule literal {
	from
		inputEnum:KM3!EnumLiteral
	to
		outputEnum:KM3target!EnumLiteral (
			location <- inputEnum.location,
			name  <- inputEnum.name,
			enum  <- inputEnum.enum
		)

}
--@end literal",name introduc primari key version domain catalogu model transform author baudri julien jul baudri gmail com date descript the purpos transform introduc primari key class see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul primarykey creat out km target in km begin rule metamodel entrypoint rule metamodel km metamodel allinst debug metamodel km packag allinst debug packag km class allinst debug class km datatyp allinst debug datatyp end rule metamodel begin rule metamodel rule metamodel inputmm km metamodel outputmm km target metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km target packag name inputpkg name content inputpkg content end rule packag begin rule class rule class inputa km class outputa km target class name inputa name isabstract inputa isabstract structuralfeatur inputa structuralfeatur supertyp inputa supertyp key km target attribut name inputa name tolow key isord fals isuniqu fals locat lower upper type km datatyp allinst select name integ first owner outputa end rule class begin rule attribut rule attribut inputatt km attribut outputatt km target attribut name inputatt name isord inputatt isord isuniqu inputatt isuniqu locat inputatt locat lower inputatt lower upper inputatt upper type inputatt type owner inputatt owner end rule attribut begin rule datatyp rule datatyp inputdata km datatyp outputdata km target datatyp name inputdata name locat inputdata locat end rule datatyp begin refer rule refer inputref km refer outputref km target refer name inputref name isord inputref isord isuniqu inputref isuniqu locat inputref locat lower inputref lower upper inputref upper type inputref type owner inputref owner opposit inputref opposit end refer begin enumer rule enumer inputenum km enumer outputenum km target enumer locat inputenum locat name inputenum name packag inputenum packag end enumer begin liter rule liter inputenum km enumliter outputenum km target enumliter locat inputenum locat name inputenum name enum inputenum enum end liter,1
66,66,P33-PrimaryKey-without.atl,"-- @name		Introducing Primary key
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		Baudry Julien (jul.baudry<at>gmail.com)
-- @date		2006/08/02
-- @description	The purpose of this transformation is to introduce a primary key in each class
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 1.6, page 6
-- @see author of article : K. Lano

module PrimaryKey; 
create OUT : KM3target from IN : KM3;

--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3target!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
--@end rule Metamodel

--@begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3target!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
--@end rule Package

--@begin rule Class
rule Class {
	from
		inputA:KM3!Class 
	to
		outputA:KM3target!Class (
			name <- inputA.name,
			isAbstract <- inputA.isAbstract,
			structuralFeatures <- inputA.structuralFeatures
		),

		key:KM3target!Attribute (
			name <- inputA.name.toLower()+'Key',
			isOrdered <- false,
			isUnique <- false,
			location <- '',
			lower <- 1,
			upper <- 1,
			type <- KM3!DataType.allInstances()->select(a|a.name = 'Integer')->first(),
			owner <- outputA
		)
}
--@end rule Class

--@begin rule reference
rule DataType {
from
		inputData:KM3!DataType
	to
		outputData:KM3target!DataType(
			name <- inputData.name,
			location <- inputData.location
		)
}
--@end rule reference
",name introduc primari key version domain catalogu model transform author baudri julien jul baudri gmail com date descript the purpos transform introduc primari key class see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul primarykey creat out km target in km begin rule metamodel rule metamodel inputmm km metamodel outputmm km target metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km target packag name inputpkg name content inputpkg content end rule packag begin rule class rule class inputa km class outputa km target class name inputa name isabstract inputa isabstract structuralfeatur inputa structuralfeatur key km target attribut name inputa name tolow key isord fals isuniqu fals locat lower upper type km datatyp allinst select name integ first owner outputa end rule class begin rule refer rule datatyp inputdata km datatyp outputdata km target datatyp name inputdata name locat inputdata locat end rule refer,1
67,67,P34-introducingAnInterface.atl,"-- @name	 Introducing an interface
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		Baudry Julien (jul.baudry<at>gmail.com)
-- @date		2006/08/02
-- @description	The purpose of this transformation is introduce an interface to each reference
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 2.6, page 16
-- @see author of article : K. Lano

module UML2Transformations; -- Module Template
create OUT : UML2target from IN : UML2, MODEL : XML;

-- helper getOperations
-- IN :  UML2!Class, UML2!Class
-- OUT : Sequence(UML2!Operation)
-- this helper returns in a sequence the operations of the class 'class' use by the class 'sub	class'
helper context UML2!Property def: getOperations(class : UML2!Class,subClass : UML2!Class) : Sequence(UML2!Operation) =
	XML!Root.allInstances()->asSequence()->first().children
											->select(a|a.name = class.name)->first().children
											->select(a|(a.name = subClass.name)and((a.children->select(a|a.name='model')->first().value)=subClass.package.name))
											->first().children
											->select(a|a.oclIsTypeOf(XML!Element));
																

--@begin rule model
rule model {
	from
		inputModel : UML2!Model 
	to
		outputModel : UML2target!Model (
			name <- inputModel.name,
			visibility <- inputModel.visibility,
			packageableElement_visibility <- inputModel.packageableElement_visibility,
			ownedMember <-inputModel.ownedMember
		)
}
--@end rule model

--@begin rule class
rule class {
	from
		inputClass : UML2!Class 
	to
		outputClass : UML2target!Class (
			name <- inputClass.name,
			visibility <- inputClass.visibility,
			packageableElement_visibility <- inputClass.packageableElement_visibility,
			isAbstract <- inputClass.isAbstract,
			isLeaf <- inputClass.isLeaf,
			isActive <- inputClass.isActive,
			ownedAttribute <- inputClass.ownedAttribute,
			ownedOperation <- inputClass.ownedOperation
		)
}
--@end rule class

--@begin association
rule association {
	from 
		inputAssoc : UML2!Association 
	to
		outputAssoc : UML2target!Association (
				isAbstract <- inputAssoc.isAbstract,
				isDerived <- inputAssoc.isDerived,
				isLeaf <- inputAssoc.isLeaf,
				ownedEnd <- inputAssoc.ownedEnd,
				memberEnd <- inputAssoc.memberEnd,
				name <- inputAssoc.name,
				packageableElement_visibility <- inputAssoc.packageableElement_visibility,
				visibility <- inputAssoc.visibility
		)
}	

--@end association

--@begin rule property
rule property {
	from
		inputProperty : UML2!Property 
	to
		outputProperty : UML2target!Property (
			isDerived <- inputProperty.isDerived,
			isDerivedUnion <- inputProperty.isDerivedUnion,
			isLeaf <- inputProperty.isLeaf,
			isOrdered <- inputProperty.isOrdered,
			isReadOnly <- inputProperty.isReadOnly,
			isStatic <- inputProperty.isStatic,
			isUnique <- inputProperty.isUnique,
			name <- inputProperty.name,
			visibility <- inputProperty.visibility,
			lowerValue <- inputProperty.lowerValue,
			upperValue <- inputProperty.upperValue,
			type <- outputInterface
		),
		outputInterface : UML2target!Interface (
			name <- inputProperty.name+'_interface_'+inputProperty.association.name,
			ownedOperation <- inputProperty.getOperations(inputProperty.association.endType->excluding(inputProperty.type)->first(),
																							inputProperty.type)
																							->iterate (a; acc : Sequence(UML2target!Operation) = Sequence{}|
																												acc->including(thisModule.operationXML(a)))
		),
		outputImplementation : UML2target!Implementation (
			name <- inputProperty.name+'_implementation_'+inputProperty.association.name,
			contract <- outputInterface,
			implementingClassifier <- inputProperty.type
		)
}
--@end rule property

--@begin literal null
rule literalNull {
	from 
		inputLiteral : UML2!LiteralNull
	to 
		outputLiteral : UML2target!LiteralNull (
			name <- inputLiteral.name,
			value <- inputLiteral.value
		)
}
--@end literal null

--@begin literal integer 
rule literalInteger {
	from 
		inputLiteral : UML2!LiteralInteger
	to 
		outputLiteral : UML2target!LiteralInteger (
			name <- inputLiteral.name,
			value <- inputLiteral.value
		)
}
--@end literal integer

--@begin literal unlimited natural 
rule literalUnlimitedNatural {
	from 
		inputLiteral : UML2!LiteralUnlimitedNatural
	to 
		outputLiteral : UML2target!LiteralUnlimitedNatural (
			name <- inputLiteral.name,
			value <- inputLiteral.value
		)	
}
--@end literal unlimited natural

--@begin operation
rule operation {
	from
		inputOperation : UML2!Operation
	to
		outputOperation : UML2target!Operation (
			isAbstract <- inputOperation.isAbstract,
			isLeaf <- inputOperation.isLeaf,
			isOrdered <- inputOperation.isOrdered,
			isQuery <- inputOperation.isQuery,
			isStatic <- inputOperation.isStatic,
			isUnique <- inputOperation.isUnique,
			name <- inputOperation.name,
			visibility <- inputOperation.visibility
		)
}
--@end operation

--@begin operationXML
lazy rule operationXML {
	from
		inputElement : XML!Element
	to
		outputOperation : UML2target!Operation (
			name <- inputElement.name
		)
}
--@end operationXML
",name introduc interfac version domain catalogu model transform author baudri julien jul baudri gmail com date descript the purpos transform introduc interfac refer see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul uml transform modul templat creat out uml target in uml model xml helper getoper in uml class uml class out sequenc uml oper helper return sequenc oper class class use class sub class helper context uml properti def getoper class uml class subclass uml class sequenc uml oper xml root allinst assequ first children select name class name first children select name subclass name children select name model first valu subclass packag name first children select oclistypeof xml element begin rule model rule model inputmodel uml model outputmodel uml target model name inputmodel name visibl inputmodel visibl packageableel visibl inputmodel packageableel visibl ownedmemb inputmodel ownedmemb end rule model begin rule class rule class inputclass uml class outputclass uml target class name inputclass name visibl inputclass visibl packageableel visibl inputclass packageableel visibl isabstract inputclass isabstract isleaf inputclass isleaf isact inputclass isact ownedattribut inputclass ownedattribut ownedoper inputclass ownedoper end rule class begin associ rule associ inputassoc uml associ outputassoc uml target associ isabstract inputassoc isabstract isderiv inputassoc isderiv isleaf inputassoc isleaf ownedend inputassoc ownedend memberend inputassoc memberend name inputassoc name packageableel visibl inputassoc packageableel visibl visibl inputassoc visibl end associ begin rule properti rule properti inputproperti uml properti outputproperti uml target properti isderiv inputproperti isderiv isderivedunion inputproperti isderivedunion isleaf inputproperti isleaf isord inputproperti isord isreadon inputproperti isreadon isstat inputproperti isstat isuniqu inputproperti isuniqu name inputproperti name visibl inputproperti visibl lowervalu inputproperti lowervalu uppervalu inputproperti uppervalu type outputinterfac outputinterfac uml target interfac name inputproperti name interfac inputproperti associ name ownedoper inputproperti getoper inputproperti associ endtyp exclud inputproperti type first inputproperti type iter acc sequenc uml target oper sequenc acc includ thismodul operationxml outputimplement uml target implement name inputproperti name implement inputproperti associ name contract outputinterfac implementingclassifi inputproperti type end rule properti begin liter null rule literalnul inputliter uml literalnul outputliter uml target literalnul name inputliter name valu inputliter valu end liter null begin liter integ rule literalinteg inputliter uml literalinteg outputliter uml target literalinteg name inputliter name valu inputliter valu end liter integ begin liter unlimit natur rule literalunlimitednatur inputliter uml literalunlimitednatur outputliter uml target literalunlimitednatur name inputliter name valu inputliter valu end liter unlimit natur begin oper rule oper inputoper uml oper outputoper uml target oper isabstract inputoper isabstract isleaf inputoper isleaf isord inputoper isord isqueri inputoper isqueri isstat inputoper isstat isuniqu inputoper isuniqu name inputoper name visibl inputoper visibl end oper begin operationxml lazi rule operationxml inputel xml element outputoper uml target oper name inputel name end operationxml,13
68,68,P35-JavaSource2Table.atl,"-- @path JavaSource=/JavaSource2Table/JavaSource.ecore
-- @path Table=/JavaSource2Table/Table.ecore

module JavaSource2Table;
create OUT : Table from IN : JavaSource;

-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- This helper builds the sequence of all method definitions in all existing 
-- classes.
-- Built sequence is ordered according to the couple (class_name, method_name).
-- RETURN:	Sequence(JavaSource!MethodDefinition)
helper def: allMethodDefs : Sequence(JavaSource!MethodDefinition) =
	JavaSource!MethodDefinition.allInstances()
		->sortedBy(e | e.class.name + '_' + e.name);

-- This helper builds the content of the table cell associated with the context
-- MethodDefinition (row) and the input MethodDefinition (column).
-- The computed value corresponds to the number of calls of the second method
-- within the first method definition.
-- CONTEXT:	JavaSource!MethodDefinition
-- IN:		JavaSource!MethodDefinition
-- RETURN:	String
helper context JavaSource!MethodDefinition
	def : computeContent(col : JavaSource!MethodDefinition) : String =
	self.invocations
		->select(i | i.method.name = col.name
					and i.method.class.name = col.class.name)
		->size();

-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'Main'
-- This rule generates the Table as well as its first row.
-- First row cells contain the different defined method, in the format
-- 'class_name.method_name', ordered by the value of the build string.
rule Main {
	from
		s : JavaSource!JavaSource
		
	to
		-- Table is composed of the first row + data rows
		t : Table!Table (
			rows <-
				Sequence{first_row,
						 thisModule.allMethodDefs
						 	->collect(e | thisModule.resolveTemp(e, 'row'))
						 }
		),
		-- First row is composed of the first column + title columns
		first_row : Table!Row (
--			cells <- Sequence{first_col, title_cols}
			cells <- Sequence{first_col, thisModule.allMethodDefs -> 
				collect(md | thisModule.TitleCols(md))} -> flatten()
		),
		-- First column empty
		first_col : Table!Cell (
			content <- ''
		)
		
		-- Former version, with distinct ... foreach
		-- 
		--Title cols = 'class_name.method_name'
		--title_cols : distinct Table!Cell
		--				foreach(mDef in thisModule.allMethodDefs)(
		--	content <- mDef.class.name + '.' + mDef.name
		--)
}

unique lazy rule TitleCols {
	from
		md: JavaSource!MethodDefinition
	to
		tFilled: Table!Cell (
			content <- md.class.name + '.' + md.name
		)
}

-- Rule 'MethodDefinition'
-- This rule generates the content of the table, including the first cell of
-- each row, which identifies a method (format 'class_name.method_name').
rule MethodDefinition {
	from
		m : JavaSource!MethodDefinition

	to
		-- Rows are composed of the first (title) cell + data cells
		row : Table!Row (
			cells <- Sequence{title_cel, thisModule.allMethodDefs ->
				collect(md | thisModule.DataCells(md, m))} -> flatten()
		),
		-- Title cell = 'class_name.method_name'
		title_cel : Table!Cell (
			content <- m.class.name + '.' + m.name
		)
		-- Data cells = nb of calls of each method within a method definition
--		cels : distinct Table!Cell foreach(mDef in thisModule.allMethodDefs)(
--			content <- m.computeContent(mDef).toString()
--		)
}

lazy rule DataCells {
	from
		md: JavaSource!MethodDefinition,
		m: JavaSource!MethodDefinition
	to
		cell: Table!Cell (
			content <- m.computeContent(md).toString()
		)
}

",path javasourc javasourc tabl javasourc ecor path tabl javasourc tabl tabl ecor modul javasourc tabl creat out tabl in javasourc helper this helper build sequenc method definit exist class built sequenc order accord coupl class name method name return sequenc javasourc methoddefinit helper def allmethoddef sequenc javasourc methoddefinit javasourc methoddefinit allinst sortedbi e e class name e name this helper build content tabl cell associ context methoddefinit row input methoddefinit column the comput valu correspond number call second method within first method definit context javasourc methoddefinit in javasourc methoddefinit return string helper context javasourc methoddefinit def computecont col javasourc methoddefinit string self invoc select method name col name method class name col class name size rule rule main this rule generat tabl well first row first row cell contain differ defin method format class name method name order valu build string rule main javasourc javasourc tabl compos first row data row tabl tabl row sequenc first row thismodul allmethoddef collect e thismodul resolvetemp e row first row compos first column titl column first row tabl row cell sequenc first col titl col cell sequenc first col thismodul allmethoddef collect md thismodul titlecol md flatten first column empti first col tabl cell content former version distinct foreach titl col class name method name titl col distinct tabl cell foreach mdef thismodul allmethoddef content mdef class name mdef name uniqu lazi rule titlecol md javasourc methoddefinit tfill tabl cell content md class name md name rule methoddefinit this rule generat content tabl includ first cell row identifi method format class name method name rule methoddefinit javasourc methoddefinit row compos first titl cell data cell row tabl row cell sequenc titl cel thismodul allmethoddef collect md thismodul datacel md flatten titl cell class name method name titl cel tabl cell content class name name data cell nb call method within method definit cel distinct tabl cell foreach mdef thismodul allmethoddef content computecont mdef tostr lazi rule datacel md javasourc methoddefinit javasourc methoddefinit cell tabl cell content computecont md tostr,11
69,69,P36-ATLCopier.atl,"module Copy;
create OUT : MM from IN : MM;

rule CopyTest {
  from
    s : MM!Test
    (
      s.oclIsTypeOf(MM!Test)
    )
  to
    t : MM!Test (
      name <- s.name,
      description <- s.description
    )
}
",modul copi creat out mm in mm rule copytest mm test oclistypeof mm test mm test name name descript descript,3
70,70,P36-KM32ATLCopier.atl,"module KM32ATLCopier;
create OUT : ATL from IN : KM3;

helper context KM3!Package def: allClasses() : Sequence(KM3!Class) =
	self.contents->select(e |
		e.oclIsKindOf(KM3!Package)
	)->iterate(e; acc : Sequence(KM3!Class) = self.contents->select(e |
							e.oclIsKindOf(KM3!Class)
						)->iterate(e; acc : Sequence(KM3!Class) = Sequence {} |
							acc->including(e)
						) |
		acc->union(e.allClasses())
	);

helper context KM3!Metamodel def: allClasses() : Sequence(KM3!Class) =
	self.contents->iterate(e; acc : Sequence(KM3!Class) = Sequence {} |
		acc->union(e.allClasses())
	);

helper def: metamodel : KM3!Metamodel = KM3!Metamodel.allInstances()->asSequence()->first();

-- Creates an ATL transformation module from a KM3 metamodel.
rule Metamodel {
	from
		s : KM3!Metamodel
	to
		mm : ATL!OclModel (
			name <- 'MM'
		),
		t : ATL!Module (
			name <- 'Copy',
			outModels <- Sequence {tm},
			inModels <- Sequence {sm},
			isRefining <- false,
			elements <- s.allClasses()->select(e | not e.isAbstract)
		),
		sm : ATL!OclModel (
			name <- 'IN',
			metamodel <- mm
		),
		tm : ATL!OclModel (
			name <- 'OUT',
			metamodel <- mm
		)
}

helper context KM3!Class def: allStructuralFeatures() : Set(KM3!StructuralFeature) =
	self.supertypes->iterate(e; acc : Set(KM3!StructuralFeature) = self.structuralFeatures |
		acc->union(e.allStructuralFeatures())
	);

-- Creates a copy rule for each non-abstract class in the KM3 metamodel.
rule Class {
	from
		s : KM3!Class (
			not s.isAbstract
		)
	using {
		allSfs : Set(KM3!StructuralFeature) = s.allStructuralFeatures();
		-- selecting features to keep
		sfs : Set(KM3!StructuralFeature) =
			allSfs->select(e |
				if e.oclIsKindOf(KM3!Attribute) then
					true
				else	-- e.oclIsKindOf(KM3!Reference)
					if e.opposite.oclIsUndefined() then
						true
					else
						if e.opposite.isOrdered then
							false
						else
							true
						endif
					endif
				endif
			);
	}
	to
		t : ATL!MatchedRule (
			isAbstract <- false,
			isRefining <- false,
			name <- 'Copy' + s.name,
			inPattern <- ip,
			outPattern <- op
		),

		-- Creating the source pattern with a filter enforcing
		-- that matched elements must have the class s for type.
		ip : ATL!InPattern (
			elements <- Sequence {ipe},
			filter <- f
		),
		ipe : ATL!SimpleInPatternElement (
			varName <- 's',
			type <- ipet
		),
		ipet : ATL!OclModelElement (
			name <- s.name,
			model <- thisModule.metamodel
		),
		f : ATL!OperationCallExp (
			operationName <- 'oclIsTypeOf',
			source <- fv,
			arguments <- Sequence {ft}
		),
		fv : ATL!VariableExp (
			name <- 's',
			referredVariable <- ipe
		),
		ft : ATL!OclModelElement (
			name <- s.name,
			model <- thisModule.metamodel
		),

		-- Creating the target pattern.
		op : ATL!OutPattern (
			elements <- Sequence {ope}
		),
		ope : ATL!SimpleOutPatternElement (
			varName <- 't',
			type <- opet,
			bindings <- b
		),
		opet : ATL!OclModelElement (
			name <- s.name,
			model <- thisModule.metamodel
		),

		-- Now generating the bindings for each structural feature that needs
		-- to be initialized in the rule.
		b : distinct ATL!Binding foreach(sf in sfs) (
			propertyName <- sf.name,
			value <- v
		),
		v : distinct ATL!NavigationOrAttributeCallExp foreach(sf in sfs) (
			name <- sf.name,
			source <- src
		),
		src : distinct ATL!VariableExp foreach(sf in sfs) (
			name <- 's',
			referredVariable <- ipe
		)
}

",modul km atlcopi creat out atl in km helper context km packag def allclass sequenc km class self content select e e ocliskindof km packag iter e acc sequenc km class self content select e e ocliskindof km class iter e acc sequenc km class sequenc acc includ e acc union e allclass helper context km metamodel def allclass sequenc km class self content iter e acc sequenc km class sequenc acc union e allclass helper def metamodel km metamodel km metamodel allinst assequ first creat atl transform modul km metamodel rule metamodel km metamodel mm atl oclmodel name mm atl modul name copi outmodel sequenc tm inmodel sequenc sm isrefin fals element allclass select e e isabstract sm atl oclmodel name in metamodel mm tm atl oclmodel name out metamodel mm helper context km class def allstructuralfeatur set km structuralfeatur self supertyp iter e acc set km structuralfeatur self structuralfeatur acc union e allstructuralfeatur creat copi rule non abstract class km metamodel rule class km class isabstract use allsf set km structuralfeatur allstructuralfeatur select featur keep sfs set km structuralfeatur allsf select e e ocliskindof km attribut true els e ocliskindof km refer e opposit oclisundefin true els e opposit isord fals els true endif endif endif atl matchedrul isabstract fals isrefin fals name copi name inpattern ip outpattern op creat sourc pattern filter enforc match element must class type ip atl inpattern element sequenc ipe filter f ipe atl simpleinpatternel varnam type ipet ipet atl oclmodelel name name model thismodul metamodel f atl operationcallexp operationnam oclistypeof sourc fv argument sequenc ft fv atl variableexp name referredvari ipe ft atl oclmodelel name name model thismodul metamodel creat target pattern op atl outpattern element sequenc ope ope atl simpleoutpatternel varnam type opet bind b opet atl oclmodelel name name model thismodul metamodel now generat bind structur featur need initi rule b distinct atl bind foreach sf sfs propertynam sf name valu v v distinct atl navigationorattributecallexp foreach sf sfs name sf name sourc src src distinct atl variableexp foreach sf sfs name referredvari ipe,18
71,71,P37-DOT2Text.atl,"query DOT2Text = DOT!Graph.allInstances()->asSequence()->first().toString2().writeTo('./runtime-workbench-workspace/KM32DOT/example.dot');

helper context DOT!Graph def: toString2() : String =
	let subs : Sequence(DOT!SubGraph) = self.nodes->select(
		e | e.oclIsKindOf(DOT!SubGraph)) in
	let nod : Sequence(DOT!Node) = self.nodes->select(
		e | e.oclIsKindOf(DOT!Node)) in
	self.type +  ' ' + '\""' + self.name +'\""' + ' ' + '{\r\n' +
	'graph[' +
		if self.rankDir.oclIsUndefined() then
			''
		else
			'rankdir=' + self.rankDir + ','
		endif +
		if self.labeljust.oclIsUndefined() then
			''
		else
			'labeljust=' + self.labeljust + ','
		endif +
		if self.labelloc.oclIsUndefined() then
			''
		else
			'labelloc=' + self.labelloc + ','
		endif +
		if self.nodeSeparation.oclIsUndefined() then
			''
		else
			'nodeSep=' + self.nodeSeparation.toString() + ','
		endif +
		if self.compound.oclIsUndefined() then
			''
		else
			'compound=' + self.compound.toString()
		endif +
		'];\r\n' +
		subs->iterate(e; acc : String = '' |
			acc + ' ' + e.toString2()
		) +
		if nod->size() > 0 then
			nod->iterate(e; acc : String = '' |
				acc + ' ' + e.toString2()
			)
		else
			''
		endif
		+ '\r\n}';
		
helper context DOT!SubGraph def: toString2() : String = 
	let subs : Sequence(DOT!SubGraph) = self.nodes->select(
		e | e.oclIsKindOf(DOT!SubGraph)) in
	let nod : Sequence(DOT!Node) = self.nodes->select(
		e | e.oclIsKindOf(DOT!Node)) in
	'subgraph ' + '\""' + self.name + '\""' + '{\r\n' +
		if self.labelloc.oclIsUndefined() then
			''
		else
			'labelloc=' + self.labelloc + '\r\n'
		endif +
		if self.color.oclIsUndefined() then
			''
		else
			'color=' + self.color + '\r\n'
		endif +
		if self.label.oclIsUndefined() then
			''
		else
			'label=' + self.label.content + '\r\n'
		endif +
		if nod->size() > 0 then
			nod->iterate(e; acc : String = '' |
				acc + ' ' + e.toString2()
			)
		else
			''
		endif +
		if subs->size() > 0 then
			subs->iterate(e; acc : String = '' |
				acc + ' ' + e.toString2()
			)
		else
			''
		endif +
		'\r\n}';

helper context DOT!Node def: toString2() : String = 
	'node' + '[shape=' + self.shape.name + '];\r\n' +
		self.name + 
		if self.shape.label.oclIsUndefined() then
			''
		else
			'[label=' + self.shape.label.toString2() + ']'
		endif + '\r\n' +
		if self.refers->size() > 0 then
			self.refers->iterate(e; acc : String = '' |
				acc + ' ' + e.toString2()
			)
		else
			''
		endif +
		';\r\n';

helper context DOT!DirectedArc def: toString2() : String = 
	self.fromNode.name + '->' + self.toNode.name +
		'[' + 
		if self.arrowHead.oclIsUndefined() then
			''
		else
			'arrowhead=' +
			if self.arrowHead.isPlain then
				'o'
			else
				''
			endif + 
			if self.arrowHead.clipping = 'right' then
				'r'
			else
				if self.arrowHead.clipping = 'left' then
					'l'
				else
					''
				endif
			endif +
			self.arrowHead.name + ','
		endif +
		if self.arrowTail.oclIsUndefined() then
			''
		else
			'arrowtail=' + 
			if self.arrowTail.isPlain then
				'o'
			else
				''
			endif + 
			if self.arrowTail.clipping = 'right' then
				'r'
			else
				if self.arrowTail.clipping = 'left' then
					'l'
				else
					''
				endif
			endif +
			self.arrowTail.name + ','
		endif +
		if self.headlabel.oclIsUndefined() then
			''
		else
			'headlabel=\""' + self.headlabel.content + '\"",'
		endif +
		if self.taillabel.oclIsUndefined() then
			''
		else
			'taillabel=\""' + self.taillabel.content + '\"",'
		endif +
		if self.group.oclIsUndefined() then
			''
		else
			'group=' + self.group + ','
		endif +
		if self.minlen.oclIsUndefined() then
			''
		else
			'minlen=' + self.minlen.toString() + ','
		endif +
		if self.constraint.oclIsUndefined() then
			''
		else
			'constraint=' + self.constraint.toString() + ','
		endif +
		']\r\n';
		
helper context DOT!SimpleLabel def: toString2() : String = 
	'\""' + self.content + '\""';",queri dot text dot graph allinst assequ first tostr writeto runtim workbench workspac km dot exampl dot helper context dot graph def tostr string let sub sequenc dot subgraph self node select e e ocliskindof dot subgraph let nod sequenc dot node self node select e e ocliskindof dot node self type self name r n graph self rankdir oclisundefin els rankdir self rankdir endif self labeljust oclisundefin els labeljust self labeljust endif self labelloc oclisundefin els labelloc self labelloc endif self nodesepar oclisundefin els nodesep self nodesepar tostr endif self compound oclisundefin els compound self compound tostr endif r n sub iter e acc string acc e tostr nod size nod iter e acc string acc e tostr els endif r n helper context dot subgraph def tostr string let sub sequenc dot subgraph self node select e e ocliskindof dot subgraph let nod sequenc dot node self node select e e ocliskindof dot node subgraph self name r n self labelloc oclisundefin els labelloc self labelloc r n endif self color oclisundefin els color self color r n endif self label oclisundefin els label self label content r n endif nod size nod iter e acc string acc e tostr els endif sub size sub iter e acc string acc e tostr els endif r n helper context dot node def tostr string node shape self shape name r n self name self shape label oclisundefin els label self shape label tostr endif r n self refer size self refer iter e acc string acc e tostr els endif r n helper context dot directedarc def tostr string self fromnod name self tonod name self arrowhead oclisundefin els arrowhead self arrowhead isplain els endif self arrowhead clip right r els self arrowhead clip left l els endif endif self arrowhead name endif self arrowtail oclisundefin els arrowtail self arrowtail isplain els endif self arrowtail clip right r els self arrowtail clip left l els endif endif self arrowtail name endif self headlabel oclisundefin els headlabel self headlabel content endif self taillabel oclisundefin els taillabel self taillabel content endif self group oclisundefin els group self group endif self minlen oclisundefin els minlen self minlen tostr endif self constraint oclisundefin els constraint self constraint tostr endif r n helper context dot simplelabel def tostr string self content,5
72,72,P37-KM32DOT.atl,"module KM32DOT;
create OUT: DOT from IN: KM3;

-- Parameters

	-- DiagramType
	-- Specifies what kind of diagram shall be rendered: a Generalization one, 
	-- or one based on composition links, or a standard one.
	-- Possible values:	'None' | 'Generalization' | 'Composition'
helper def: DiagramType(): String = 'None';

	-- Mode
	-- Specifies what association type shall be used so as to compute the
	-- layout of the diagram
	-- Possible values:	'All' | 'Generalization' | 'Composition' | 'Reference'
helper def: Mode(): String = 'All';

	-- Invisible
	-- Specifies whether the associations not used in the computation of the
	-- layout have yet to be rendered. For example, if Invisible = true and
	-- Mode = Generalization, the diagram will be rendered as if only
	-- generalization links did matter. If Invisible = false, then only
	-- generalization links are drawn, but the layout is the same as if
	-- Possible values:	true | false
helper def: Invisible(): Boolean = false;

	-- MinimumArcLength
	-- Specifies the minimum length of an association, in inches.
	-- Possible values:	any positive integer value
helper def: MinimumArcLength(): Integer = 2;

	-- MinimumNodeSeparation
	-- Specifies the minimum distance between two nodes, in inches.
	-- Possible values:	any positive real value
helper def: MinimumNodeSeparation(): Real = 0.75;

	-- RankingDirection
	-- Specifies the direction in which the diagram should be rendered. Most
	-- class diagrams are rendered with the value 'BT'
	-- Possible values:	'BT' | 'TB' | 'LR' | 'RL' (Bottom to Top, 
	-- 	Top to Bottom, Left to Right, Right to Left)
helper def: RankingDirection(): String = 'BT';

helper def: LabelJustification(): String = 'l';

helper def: LabelLocation(): String = 't';

	-- DataTypeHeader
	-- The name of a datatype should begin with <<DataType>>
helper def: DataTypeHeader(): String = '&#171;DataType&#187;\\n';

-- End Parameters

-- HELPERS
	-- DiagramMode
	-- Returns whether the DiagramMode parameter is the one tried or not
	-- IN:	mode: String
	-- OUT:	Boolean
helper def: DiagramMode(mode: String): Boolean =
	mode = thisModule.Mode();

	-- getDataTypeHead
	-- Returns the name of the datatype, with its header
	-- IN:	N/A
	-- OUT: String
helper context KM3!DataType def: getDataTypeHead(): String =
	thisModule.DataTypeHeader() + self.name;

	-- getLabel
	-- Returns the correct SimpleLabel content for a KM3 Class:
	--	Name | Attributes | Operations
	-- IN:	N/A
	-- OUT: String
helper context KM3!Class def: getLabel(): String =
	'{' + self.getName() + '|' 
	+ self.getAttributes() + '|' 
	+ self.getOperations() + '}';

	-- getName
	-- Returns the name of the class. If the class is abstract, the name
	-- is put between slashes
	-- IN:	N/A
	-- OUT:	String
helper context KM3!Class def: getName(): String = 
	if self.isAbstract then
		'/' + self.name + '/'
	else
		self.name
	endif;

	-- getAttributes
	-- Returns the list of attributes of the class, with one attribute per line
	-- and the correct multiplicities, using the getMultiplicity helper.
	-- IN:	N/A
	-- OUT:	String
helper context KM3!Class def: getAttributes(): String =
	let attributes : Sequence(KM3!Attribute) = self.structuralFeatures->
		select( e |
		e.oclIsKindOf(KM3!Attribute)) in
	if attributes->notEmpty() then
		attributes->iterate( e; acc: String = '' |
			acc + if acc = '' then '' else '\\n' endif +
			e.name + e.getMultiplicity() + ' : ' + e.type.name
		)
	else
		' '
	endif;

	-- getOperations
	-- Returns the list of operation of the class, with one operation per line,
	-- their parameters and return type.
	-- IN:	N/A
	-- OUT:	String
helper context KM3!Class def: getOperations(): String =
	let operations : Sequence(KM3!Operation) = self.operations in
	if operations->notEmpty() then
		operations->iterate( e; acc: String = '' |
			acc + e.name + e.getParameters() +
			if e.type.oclIsUndefined() then
				''
			else
				' : ' 	+ e.type.name
			endif + '\\n')
	else
		' '
	endif;

	-- getMultiplicity
	-- Returns the multiplicity of the element
	-- IN:	N/A
	-- OUT:	String
helper context KM3!TypedElement def: getMultiplicity(): String =
	if self.lower = 0 then
		if self.upper = 0-1 then
			'[*]'
		else
			'[' + self.lower.toString() + '-' + self.upper.toString() + ']'
		endif
	else
		if self.upper = 1 then
			''
		else
			if self.upper = 0-1 then
				'[' + self.lower.toString() + '-' + '*]'
			else
				'[' + self.lower.toString() + self.upper.toString() + ']'
			endif
		endif
	endif;

	-- getParameters
	-- Returns the parameters of the current operation, with their types,
	-- and separated with commas.
	-- IN:	N/A
	-- OUT:	String
helper context KM3!Operation def: getParameters(): String =
	let parameters : Sequence(KM3!Parameters) = self.parameters in
	'(' + parameters->iterate( e; acc: String = '' |
		acc + 
		if e.name = parameters->last().name then
			e.name + ' : ' + e.type.name
		else
			e.name + ' : ' + e.type.name + ','
		endif)
	+ ')';

	-- relationsList
	-- This helper is used so as to match a reference only once. Indeed, in 
	-- KM3, if the relation is bidirectionnal, it is referenced in both its
	-- edge classes.
	-- It puts the container class the second part of the returned tuple.
	-- IN:	N/A
	-- OUT:	Sequence(Tuple (reference, opposite reference))
helper def: relationsList: Sequence(
	TupleType(ref: KM3!Reference, opposite : KM3!Reference)) =
	let references: Sequence(KM3!Reference) = KM3!Reference.allInstances()->
	reject( e |
		e.opposite.oclIsUndefined()) in
	references->iterate( e; 
		acc: Sequence(TupleType(ref: KM3!Reference, opposite: KM3!Reference)) =
		Sequence{} |
			if acc->excludes(Tuple{ref = e, opposite = e.opposite}) then
				if acc->excludes(Tuple{ref = e.opposite, opposite = e}) then
					if e.opposite.isContainer then
						acc->append(Tuple{ref = e, opposite = e.opposite})
					else
						acc->append(Tuple{ref = e.opposite, opposite = e})
					endif
				else
					acc
				endif
			else
				acc
			endif);
-- END HELPERS

-- RULES
	-- Metamodel2Graph
	-- Transforms a KM3 Metamodel element into a DOT oriented graph element,
	-- using many parameters defined at the beginning of this transformation.
	-- The Graph elements contains then contents of the KM3 Metamodel element.
rule Metamodel2Graph {
	from
		m: KM3!Metamodel
	to
		out: DOT!Graph (
			type <- 'digraph',
			name <- 'KM3 Model in DOT',
			rankDir <- thisModule.RankingDirection(),
			labeljust <- thisModule.LabelJustification(),
			labelloc <- thisModule.LabelLocation(),
			compound <- true,
			concentrate <- thisModule.DiagramMode('Generalization') and 
			not thisModule.Invisible(),
			nodeSeparation <- thisModule.MinimumNodeSeparation(),
			nodes <- m.contents
		)
}

	-- Package
	-- Transforms a Package into a SubGraph that will be rendered within a 
	-- black box (because its name begins with 'cluster_' and its color is set
	-- at black). It may contain nodes or subgraphs, dot supports nested 
	-- subgraphs, and KM3 supports nested packages.
rule Package {
	from
		p: KM3!Package
	to
		out: DOT!SubGraph (
			name <- 'cluster_' + p.name,
			label <- SubGraphLabel,
			color <- 'black',
			labelloc <- thisModule.LabelLocation(),
			nodes <- p.contents
		),
		SubGraphLabel: DOT!SimpleLabel (
			content <- p.name
		)
}

	-- Datatypes
	-- Transforms a Datatype into a Record Node using the datatype header
rule Datatypes {
	from
		d: KM3!DataType
	to
		out: DOT!Node (
			name <- d.name,
			shape <- NodeShape
		),
		NodeShape: DOT!RecordNodeShape (
			name <- 'record',
			label <- NodeLabel
		),
		NodeLabel: DOT!SimpleLabel (
			content <- '{' + d.getDataTypeHead() +  '|' + '}'	
		)
}

	-- ClassWithSupertypesGeneralizationsDrawn2Node
	-- Transforms a class into a node, and creates the generalization arcs
	-- foreach superclass
rule ClassWithSupertypesGeneralizationsDrawn2Node {
	from
		c: KM3!Class (
			not(c.supertypes->oclIsUndefined())	and 
			(thisModule.Invisible() or 
			(thisModule.DiagramMode('Generalization') or 
			thisModule.DiagramMode('All')))
		)
	to
		out: DOT!Node (
			name <- c.name,
			shape <- nodeShape,
			refers <- Sequence {c.structuralFeatures->select( e |
					e.oclIsKindOf(KM3!Reference))}->append(supertypeClasses)
		),
		nodeShape: DOT!RecordNodeShape (
			name <- 'record',
			label <- NodeLabel
		),
		NodeLabel : DOT!SimpleLabel (
			content <- c.getLabel()	
		),
		supertypeClasses: distinct DOT!DirectedArc 
		foreach(super in c.supertypes) (
			constraint <- (thisModule.DiagramType() = 'Generalization' or
				thisModule.DiagramType() = 'None'),
			style <- if thisModule.DiagramMode('Generalization') or 
			thisModule.DiagramMode('All') then 'none' else 'invis' endif,
			fromNode <- c,
			toNode <- super,
			group <- super.name,
			minlen <- thisModule.MinimumArcLength(),
			arrowHead <- arrowHeadShape
		),
		arrowHeadShape: distinct DOT!ArrowShape 
		foreach(super in c.supertypes) (
			name <- 'normal',
			isPlain <- true
		)
}

	-- ClassWithSupertypesGeneralizationsNotDrawn2Node
	-- Transforms a class into a node, and does not create the generalization 
	-- arcs either because it has no superclass, or because the parameters set 
	-- for the transformation imply not drawing any generalization arc
rule ClassWithSupertypesGeneralizationsNotDrawn2Node {
	from
		c: KM3!Class (
			c.supertypes->oclIsUndefined() or
			(not(c.supertypes->oclIsUndefined()) and 
			(thisModule.Invisible() or 
			not(thisModule.DiagramMode('Generalization') or 
			thisModule.DiagramMode('All'))))
		)
	to
		out: DOT!Node (
			name <- c.name,
			shape <- nodeShape,
			refers <- Sequence {c.structuralFeatures->select( e |
					e.oclIsKindOf(KM3!Reference))}
		),
		nodeShape: DOT!RecordNodeShape (
			name <- 'record',
			label <- NodeLabel
		),
		NodeLabel : DOT!SimpleLabel (
			content <- c.getLabel()	
		)
}

	-- Reference2OneWayArc
	-- Transforms a one way reference into a unidirectional arc, with the
	-- proper arrowhead and arrowtail (there may be one way compositions for
	-- instance), and with its role and multiplicity
rule Reference2OneWayArc {
	from
		r: KM3!Reference (
			r.opposite.oclIsUndefined()	and 
			(thisModule.Invisible() or 
			(if r.isContainer then
				thisModule.DiagramMode('Composition')
			else thisModule.DiagramMode('Reference') 
			endif or 
			thisModule.DiagramMode('All')))
		)
	to
		out: DOT!DirectedArc (
			fromNode <- r.owner,
			toNode <- r.type,
			arrowHead <- arrowHeadShape,
			arrowTail <- arrowTailShape,
			group <- r.type.name,
			style <- if thisModule.DiagramMode('All') or
			thisModule.DiagramMode('Reference') then 'none' else
				if thisModule.DiagramMode('Composition') and
				r.isContainer then 'none' else
				'invis' endif endif,
			minlen <- thisModule.MinimumArcLength(),
			headlabel <- ArcHeadLabel,
			constraint <- (r.isContainer 
				and (thisModule.DiagramType() = 'Composition' or
				thisModule.DiagramType() = 'None'))
		),
		ArcHeadLabel : DOT!SimpleLabel (
			content <-  r.name + r.getMultiplicity() + if r.isOrdered then
					'{ordered}'
				else
					''
				endif
		),
		arrowHeadShape: DOT!ArrowShape (
			name <- 'vee',
			isPlain <- false,
			clipping <- 'none'
		),
		arrowTailShape: DOT!ArrowShape (
			name <- if r.isContainer then 'diamond' else 'none' endif,
			isPlain <- false,
			clipping <- 'none'
		)
}

	-- Reference2Arc
	-- Transforms a bidirectional reference into a bidirectional arc, with its
	-- roles, multiplicities and arrowshapes.
rule Reference2Arc {
	from
		r: KM3!Reference (
			if not(r.opposite.oclIsUndefined()) then
				thisModule.relationsList->includes(
					Tuple{ref = r, opposite = r.opposite}) and
					(thisModule.Invisible() or 
					(if r.isContainer or r.opposite.isContainer then
						thisModule.DiagramMode('Composition')
					else
						thisModule.DiagramMode('Reference')
					endif
					or thisModule.DiagramMode('All')))
			else
				false
			endif
		)
	to
		out: DOT!DirectedArc (
			fromNode <- r.owner,
			toNode <- r.type,
			group <- r.type.name,
			minlen <- thisModule.MinimumArcLength(),
			arrowHead <- arrowHeadShape,
			arrowTail <- arrowTailShape,
			taillabel <- ArcTailLabel,
			style <- if thisModule.DiagramMode('All') or
			thisModule.DiagramMode('Reference') then 'none' else
				if thisModule.DiagramMode('Composition') 
				and (r.isContainer or r.opposite.isContainer) then 'none' else
				'invis' endif endif,
			constraint <- ((r.isContainer or r.opposite.isContainer) and 
				(thisModule.DiagramType() = 'Composition' or
				thisModule.DiagramType() = 'None')),
			headlabel <- ArcHeadLabel
		),
		ArcHeadLabel : DOT!SimpleLabel (
			content <- r.name + r.getMultiplicity() + if r.isOrdered then
					'{ordered}'
				else
					''
				endif
		),
		ArcTailLabel : DOT!SimpleLabel (
			content <- r.opposite.name + r.opposite.getMultiplicity() + 
				if r.opposite.isOrdered then
					'{ordered}'
				else
					''
				endif	
		),
		arrowHeadShape: DOT!ArrowShape (
			name <- if r.opposite.isContainer then 'diamond' else 'none' endif,
			isPlain <- false,
			clipping <- 'none'
		),
		arrowTailShape: DOT!ArrowShape (
			name <- if r.isContainer then 'diamond' else 'none' endif,
			isPlain <- false,
			clipping <- 'none'
		)
}

-- END RULES
",modul km dot creat out dot in km paramet diagramtyp specifi kind diagram shall render general one one base composit link standard one possibl valu none general composit helper def diagramtyp string none mode specifi associ type shall use comput layout diagram possibl valu all general composit refer helper def mode string all invis specifi whether associ use comput layout yet render for exampl invis true mode general diagram render general link matter if invis fals general link drawn layout possibl valu true fals helper def invis boolean fals minimumarclength specifi minimum length associ inch possibl valu posit integ valu helper def minimumarclength integ minimumnodesepar specifi minimum distanc two node inch possibl valu posit real valu helper def minimumnodesepar real rankingdirect specifi direct diagram render most class diagram render valu bt possibl valu bt tb lr rl bottom top top bottom left right right left helper def rankingdirect string bt helper def labeljustif string l helper def labelloc string datatypehead the name datatyp begin datatyp helper def datatypehead string datatyp n end paramet helper diagrammod return whether diagrammod paramet one tri in mode string out boolean helper def diagrammod mode string boolean mode thismodul mode getdatatypehead return name datatyp header in n a out string helper context km datatyp def getdatatypehead string thismodul datatypehead self name getlabel return correct simplelabel content km class name attribut oper in n a out string helper context km class def getlabel string self getnam self getattribut self getoper getnam return name class if class abstract name put slash in n a out string helper context km class def getnam string self isabstract self name els self name endif getattribut return list attribut class one attribut per line correct multipl use getmultipl helper in n a out string helper context km class def getattribut string let attribut sequenc km attribut self structuralfeatur select e e ocliskindof km attribut attribut notempti attribut iter e acc string acc acc els n endif e name e getmultipl e type name els endif getoper return list oper class one oper per line paramet return type in n a out string helper context km class def getoper string let oper sequenc km oper self oper oper notempti oper iter e acc string acc e name e getparamet e type oclisundefin els e type name endif n els endif getmultipl return multipl element in n a out string helper context km typedel def getmultipl string self lower self upper els self lower tostr self upper tostr endif els self upper els self upper self lower tostr els self lower tostr self upper tostr endif endif endif getparamet return paramet current oper type separ comma in n a out string helper context km oper def getparamet string let paramet sequenc km paramet self paramet paramet iter e acc string acc e name paramet last name e name e type name els e name e type name endif relationslist this helper use match refer inde km relat bidirectionn referenc edg class it put contain class second part return tupl in n a out sequenc tupl refer opposit refer helper def relationslist sequenc tupletyp ref km refer opposit km refer let refer sequenc km refer km refer allinst reject e e opposit oclisundefin refer iter e acc sequenc tupletyp ref km refer opposit km refer sequenc acc exclud tupl ref e opposit e opposit acc exclud tupl ref e opposit opposit e e opposit iscontain acc append tupl ref e opposit e opposit els acc append tupl ref e opposit opposit e endif els acc endif els acc endif end helper rule metamodel graph transform km metamodel element dot orient graph element use mani paramet defin begin transform the graph element contain content km metamodel element rule metamodel graph km metamodel dot graph type digraph name km model dot rankdir thismodul rankingdirect labeljust thismodul labeljustif labelloc thismodul labelloc compound true concentr thismodul diagrammod general thismodul invis nodesepar thismodul minimumnodesepar node content packag transform packag subgraph render within black box name begin cluster color set black it may contain node subgraph dot support nest subgraph km support nest packag rule packag p km packag dot subgraph name cluster p name label subgraphlabel color black labelloc thismodul labelloc node p content subgraphlabel dot simplelabel content p name datatyp transform datatyp record node use datatyp header rule datatyp km datatyp dot node name name shape nodeshap nodeshap dot recordnodeshap name record label nodelabel nodelabel dot simplelabel content getdatatypehead classwithsupertypesgeneralizationsdrawn node transform class node creat general arc foreach superclass rule classwithsupertypesgeneralizationsdrawn node c km class c supertyp oclisundefin thismodul invis thismodul diagrammod general thismodul diagrammod all dot node name c name shape nodeshap refer sequenc c structuralfeatur select e e ocliskindof km refer append supertypeclass nodeshap dot recordnodeshap name record label nodelabel nodelabel dot simplelabel content c getlabel supertypeclass distinct dot directedarc foreach super c supertyp constraint thismodul diagramtyp general thismodul diagramtyp none style thismodul diagrammod general thismodul diagrammod all none els invi endif fromnod c tonod super group super name minlen thismodul minimumarclength arrowhead arrowheadshap arrowheadshap distinct dot arrowshap foreach super c supertyp name normal isplain true classwithsupertypesgeneralizationsnotdrawn node transform class node creat general arc either superclass paramet set transform impli draw general arc rule classwithsupertypesgeneralizationsnotdrawn node c km class c supertyp oclisundefin c supertyp oclisundefin thismodul invis thismodul diagrammod general thismodul diagrammod all dot node name c name shape nodeshap refer sequenc c structuralfeatur select e e ocliskindof km refer nodeshap dot recordnodeshap name record label nodelabel nodelabel dot simplelabel content c getlabel refer onewayarc transform one way refer unidirect arc proper arrowhead arrowtail may one way composit instanc role multipl rule refer onewayarc r km refer r opposit oclisundefin thismodul invis r iscontain thismodul diagrammod composit els thismodul diagrammod refer endif thismodul diagrammod all dot directedarc fromnod r owner tonod r type arrowhead arrowheadshap arrowtail arrowtailshap group r type name style thismodul diagrammod all thismodul diagrammod refer none els thismodul diagrammod composit r iscontain none els invi endif endif minlen thismodul minimumarclength headlabel archeadlabel constraint r iscontain thismodul diagramtyp composit thismodul diagramtyp none archeadlabel dot simplelabel content r name r getmultipl r isord order els endif arrowheadshap dot arrowshap name vee isplain fals clip none arrowtailshap dot arrowshap name r iscontain diamond els none endif isplain fals clip none refer arc transform bidirect refer bidirect arc role multipl arrowshap rule refer arc r km refer r opposit oclisundefin thismodul relationslist includ tupl ref r opposit r opposit thismodul invis r iscontain r opposit iscontain thismodul diagrammod composit els thismodul diagrammod refer endif thismodul diagrammod all els fals endif dot directedarc fromnod r owner tonod r type group r type name minlen thismodul minimumarclength arrowhead arrowheadshap arrowtail arrowtailshap taillabel arctaillabel style thismodul diagrammod all thismodul diagrammod refer none els thismodul diagrammod composit r iscontain r opposit iscontain none els invi endif endif constraint r iscontain r opposit iscontain thismodul diagramtyp composit thismodul diagramtyp none headlabel archeadlabel archeadlabel dot simplelabel content r name r getmultipl r isord order els endif arctaillabel dot simplelabel content r opposit name r opposit getmultipl r opposit isord order els endif arrowheadshap dot arrowshap name r opposit iscontain diamond els none endif isplain fals clip none arrowtailshap dot arrowshap name r iscontain diamond els none endif isplain fals clip none end rule,18
73,73,P38-KM32EMF.atl,"module KM32EMF;
create OUT : MOF from IN : KM3;

uses strings;

helper context KM3!Package def: getMetadata(name : String) : String =
	let comment : String = self.commentsBefore->select(e | e.startsWith('-- @' + name + ' '))->first() in
	if comment.oclIsUndefined() then
		OclUndefined
	else
		comment.substring(6 + name.size(), comment.size())
	endif;

rule Package {
	from
		e : KM3!Package
	to
		c : MOF!EPackage (
			name <- e.name,
			eClassifiers <- e.contents->select(e | e.oclIsKindOf(KM3!Classifier)),
			eSubpackages <- e.contents->select(e | e.oclIsKindOf(KM3!Package)),
			nsURI <- e.getMetadata('nsURI'),
			nsPrefix <- e.getMetadata('nsPrefix')
		)
}

rule PrimitiveType {
	from
		e : KM3!DataType
	to
		c : MOF!EDataType (
			name <- e.name
		)
}

rule Reference {
	from
		e : KM3!Reference
	to
		c : MOF!EReference (
			name <- e.name,
			eType <- e.type,
			lowerBound <- e.lower,
			upperBound <- e.upper,
			ordered <- e.isOrdered,
			eOpposite <- e.opposite,
			containment <- e.isContainer
		)
}

rule Class {
	from
		e : KM3!Class
	to
		c : MOF!EClass (
			name <- e.name,
			eStructuralFeatures <- e.structuralFeatures,
			eOperations <- e.operations,
			eSuperTypes <- e.supertypes,
			""abstract"" <- e.isAbstract
		)
}

rule PrimitiveAttribute {
	from
		e : KM3!Attribute (
			e.type.oclIsKindOf(KM3!DataType) or
			e.type.oclIsKindOf(KM3!Enumeration)
		)
	to
		c : MOF!EAttribute (
			name <- e.name,
			eType <- e.type,
			lowerBound <- e.lower,
			upperBound <- e.upper,
			ordered <- e.isOrdered,
			""unique"" <- e.isUnique
		)
}

rule NonPrimitiveAttribute {
	from
		e : KM3!Attribute (
			not (e.type.oclIsKindOf(KM3!DataType) or
			e.type.oclIsKindOf(KM3!Enumeration))
		)
	to
		c : MOF!EReference (
			name <- e.name,
			eType <- e.type,
			lowerBound <- e.lower,
			upperBound <- e.upper,
			ordered <- e.isOrdered,
			containment <- true
		)
}

rule Enumeration {
	from
		e : KM3!Enumeration
	to
		c : MOF!EEnum (
			name <- e.name,
			eLiterals <- e.literals
		)
}

rule EnumLiteral {
	from
		e : KM3!EnumLiteral
	to
		c : MOF!EEnumLiteral (
			name <- e.name,
			value <- e.enum.literals->indexOf(e)
		)
}

rule Operation {
	from
		io : KM3!Operation
	to
		oo : MOF!EOperation (
			name <- io.name,
			eParameters <- io.parameters,
			eType <- io.type
		)
}

rule Parameter {
	from
		ip : KM3!Parameter
	to
		op : MOF!EParameter (
			name <- ip.name,
			eType <- ip.type
		)
}

",modul km emf creat out mof in km use string helper context km packag def getmetadata name string string let comment string self commentsbefor select e e startswith name first comment oclisundefin oclundefin els comment substr name size comment size endif rule packag e km packag c mof epackag name e name eclassifi e content select e e ocliskindof km classifi esubpackag e content select e e ocliskindof km packag nsuri e getmetadata nsuri nsprefix e getmetadata nsprefix rule primitivetyp e km datatyp c mof edatatyp name e name rule refer e km refer c mof erefer name e name etyp e type lowerbound e lower upperbound e upper order e isord eopposit e opposit contain e iscontain rule class e km class c mof eclass name e name estructuralfeatur e structuralfeatur eoper e oper esupertyp e supertyp abstract e isabstract rule primitiveattribut e km attribut e type ocliskindof km datatyp e type ocliskindof km enumer c mof eattribut name e name etyp e type lowerbound e lower upperbound e upper order e isord uniqu e isuniqu rule nonprimitiveattribut e km attribut e type ocliskindof km datatyp e type ocliskindof km enumer c mof erefer name e name etyp e type lowerbound e lower upperbound e upper order e isord contain true rule enumer e km enumer c mof eenum name e name eliter e liter rule enumliter e km enumliter c mof eenumliter name e name valu e enum liter indexof e rule oper io km oper oo mof eoper name io name eparamet io paramet etyp io type rule paramet ip km paramet op mof eparamet name ip name etyp ip type,18
74,74,P39-KM32Measure.atl,"--@atlcompiler	atl2006
--@name			KM32Measure
--@version		2.1
--@domains		KM3, measurement data, metrics
--@authors		Eric Vepa (evepa <at> sodius.com) for SODIUS (www.sodius.com)
--@date			2007/08/02
--@description	This transformation is used to collect measurement data on a KM3 metamodel, using libraries implementing some metrics (MOOD, MOOD2, MOOSE, EMOOSE  and QMOOD).
--@see			Baroni, A.L.: Formal Definition of Object-Oriented Design Metrics. Master Thesis, Vrije University, Brussel, Belgium, 2002.

module KM32Measure; -- Module Template
create OUT : Measure from IN : KM3;

uses FLAME4KM3;
uses MOOD4KM3;
uses EMOOSE4KM3;
uses QMOOD4KM3;

--@begin attribute helpers measureLevel
--@comments Defines the measure level among {#package,#class}. 
--@comments The package level allows measures on packages.
--@comments The class level allows measures on packages and classes.
helper def : measureLevel : Measure!ElementKind = #class;
--@end attribute helper measureLevel

--@begin attribute helper root
--@comments The root measure set.
helper def : root : Measure!RootMeasureSet = OclUndefined;
--@end attribute helper root

--@begin attribute helper MetricByName
--@comments The map of metrics by name.
helper def : MetricByName : Map(String, Measure!Metric) = Map{};
--@end attribute helper MetricByName

--@begin entrypoint rule Metrics
--@comments Registers the MOOD, MOOD2, MOOSE, EMOOSE and QMOOD metrics implemented in libraries.
entrypoint rule Metrics() {
	to
		root : Measure!RootMeasureSet (
			modelType <- #KM3
		)
	do {
		thisModule.root <- root;
		
		if ((thisModule.measureLevel = #package) or
			(thisModule.measureLevel = #class)) {
			-- ==================================================
			-- MOOD Metrics : Intra-Specification Level Metrics =
			-- ==================================================
			root.categories <-
				thisModule.Category('MOOD','Metrics for Object-Oriented Design');
			thisModule.Metric('MOOD','AIF','Attributes Inheritance Factor');
			thisModule.Metric('MOOD','RIF','References Inheritance Factor');
			thisModule.Metric('MOOD','CCF','Class Coupling Factor');
			thisModule.Metric('MOOD','ICF','Internal Coupling Factor');
				
			-- ===================================================
			-- MOOD2 Metrics : Intra-Specification Level Metrics =
			-- ===================================================
			root.categories <-
				thisModule.Category('MOOD2',
					'Metrics for Object-Oriented Design 2');
			thisModule.Metric('MOOD2','IIF','Internal Inheritance Factor');
		}
		
		if (thisModule.measureLevel = #class) {
			-- ===============
			-- MOOSE Metrics =
			-- ===============
			root.categories <-
				thisModule.Category('MOOSE',
				'Metrics for Object-Oriented Software Engineering');
			thisModule.Metric('MOOSE','WRC','Weighted References per Class');
			thisModule.Metric('MOOSE','DIT','Depth of Inheritance Tree');
			thisModule.Metric('MOOSE','NOC','Number of Children');
			thisModule.Metric('MOOSE','CBO','Coupling Between Objects');
		
			-- ================
			-- EMOOSE Metrics =
			-- ================
			root.categories <-
				thisModule.Category('EMOOSE','Extended MOOSE');
			thisModule.Metric('EMOOSE','SIZE2','Number of local Attributes ' +
				'and References defined in the Class');
		}
		
		if ((thisModule.measureLevel = #package) or
			(thisModule.measureLevel = #class)) {
			-- ===============
			-- QMOOD Metrics =
			-- ===============
			root.categories <-
				thisModule.Category('QMOOD',
				'Quality Model for Object-Oriented Design');		
			thisModule.Metric('QMOOD','DSC','Design Size in Classes');
			thisModule.Metric('QMOOD','NOH','Number of Hierarchies');
			thisModule.Metric('QMOOD','NIC','Number of Independent Classes');
			thisModule.Metric('QMOOD','NSI','Number of Single Inheritance');
			thisModule.Metric('QMOOD','NMI','Number of Multiple Inheritance');
			thisModule.Metric('QMOOD','NNC','Number of Internal Classes');
			thisModule.Metric('QMOOD','NAC','Number of Abstract Classes');
			thisModule.Metric('QMOOD','NLC','Number of Leaf Classes');
			thisModule.Metric('QMOOD','ADI','Average Depth of Inheritance');
			thisModule.Metric('QMOOD','AWI','Average Width of Inheritance');
			thisModule.Metric('QMOOD','ANA','Average Number of Ancestors');
		}
			
		if (thisModule.measureLevel = #class) {			
			thisModule.Metric('QMOOD','MAA','Measure of Attribute Abstraction');
			thisModule.Metric('QMOOD','MRA','Measure of Reference Abstraction');
			thisModule.Metric('QMOOD','MOA','Measure of Aggregation');
			thisModule.Metric('QMOOD','MRM','Modeled Relationship Measure');
			thisModule.Metric('QMOOD','NOA','Number of Ancestors');
			thisModule.Metric('QMOOD','NOR','Number of References');
			thisModule.Metric('QMOOD','NOD','Number of Attributes');
			thisModule.Metric('QMOOD','NAD','Number of Abstract Data Types');
			thisModule.Metric('QMOOD','CSM','Class Size Metric');
			thisModule.Metric('QMOOD','DCC','Direct Class Coupling');
			thisModule.Metric('QMOOD','MCC','Maximum Class Coupling');
			thisModule.Metric('QMOOD','DAC','Direct Attribute Based Coupling');
			thisModule.Metric('QMOOD','DRC','Direct Reference Based Coupling');
			thisModule.Metric('QMOOD','CCD','Class Complexity Based on Data');
		}
	}
}
--@end entrypoint rule Metrics

--@begin rule Package2MeasureSet
--@comments Collects measurement data on a package (measureLevel must be set to #package or #class).
rule Package2MeasureSet {
	from
		ne : KM3!Package (
			(thisModule.measureLevel = #package) or
			(thisModule.measureLevel = #class)
		)
	to
		ms : Measure!MeasureSet (
			elementName <-
				if ne.CN() > 0
					then ne.name.debug('Processing metrics on package')
					else ne.name
				endif,
	   		elementType <- #package,
			subsets <- ne.contents
		)
	do {
		if (ne.package.oclIsUndefined()) {
			thisModule.root.measureSets <- ms;
		}
		
		if (ne.CN() > 0) {
			-- ==================================================
			-- MOOD Metrics : Intra-Specification Level Metrics =
			-- ==================================================
			ms.measures <- thisModule.PercentageMeasure('AIF',ne.AIF());
			ms.measures <- thisModule.PercentageMeasure('RIF',ne.RIF());
			ms.measures <- thisModule.PercentageMeasure('CCF',ne.CCF());
			ms.measures <- thisModule.PercentageMeasure('ICF',ne.ICF());
				
			-- =============================================================
			-- MOOD2 Metrics : Intra and Inter-Specification Level Metrics =
			-- =============================================================
			ms.measures <- thisModule.PercentageMeasure('IIF',ne.IIF());
		
			-- ===============
			-- QMOOD Metrics =
			-- ===============
			ms.measures <- thisModule.IntegerMeasure('DSC',ne.DSC());
			ms.measures <- thisModule.IntegerMeasure('NOH',ne.NOH());
			ms.measures <- thisModule.IntegerMeasure('NIC',ne.NIC());
			ms.measures <- thisModule.IntegerMeasure('NSI',ne.NSI());
			ms.measures <- thisModule.IntegerMeasure('NMI',ne.NMI());
			ms.measures <- thisModule.IntegerMeasure('NNC',ne.NNC());
			ms.measures <- thisModule.IntegerMeasure('NAC',ne.NAC());
			ms.measures <- thisModule.IntegerMeasure('NLC',ne.NLC());
			ms.measures <- thisModule.DoubleMeasure('ADI',ne.ADI());
			ms.measures <- thisModule.DoubleMeasure('AWI',ne.AWI());
			ms.measures <- thisModule.DoubleMeasure('ANA',ne.ANA());
		}
	}
}
--@end rule Package2MeasureSet

--@begin rule Class2MeasureSet
--@comments Collects measurement data on a class (measureLevel must be set to #class).
rule Class2MeasureSet {
	from
		ne : KM3!Class (
			thisModule.measureLevel = #class
		)
	to
		ms : Measure!MeasureSet (
			elementName <- ne.name.debug('Processing metrics on class'),
	   		elementType <- #class
		)
	do {
		-- ===============
		-- MOOSE Metrics =
		-- ===============
		ms.measures <- thisModule.IntegerMeasure('WRC',ne.WRC());
		ms.measures <- thisModule.IntegerMeasure('DIT',ne.DIT());
		ms.measures <- thisModule.IntegerMeasure('NOC',ne.NOC());
		ms.measures <- thisModule.IntegerMeasure('CBO',ne.CBO());
	
		-- ================
		-- EMOOSE Metrics =
		-- ================
		ms.measures <- thisModule.IntegerMeasure('SIZE2',ne.SIZE2());
	
		-- ===============
		-- QMOOD Metrics =
		-- ===============
		ms.measures <- thisModule.PercentageMeasure('MAA',ne.MAA());
		ms.measures <- thisModule.PercentageMeasure('MRA',ne.MRA());
		ms.measures <- thisModule.IntegerMeasure('MOA',ne.MOA());
		ms.measures <- thisModule.IntegerMeasure('MRM',ne.MRM());
		ms.measures <- thisModule.IntegerMeasure('NOA',ne.NOA());
		ms.measures <- thisModule.IntegerMeasure('NOR',ne.NOR());
		ms.measures <- thisModule.IntegerMeasure('NOD',ne.NOD());
		ms.measures <- thisModule.IntegerMeasure('NAD',ne.NAD());
		ms.measures <- thisModule.IntegerMeasure('CSM',ne.CSM());
		ms.measures <- thisModule.IntegerMeasure('DCC',ne.DCC());
		ms.measures <- thisModule.IntegerMeasure('MCC',ne.MCC());
		ms.measures <- thisModule.IntegerMeasure('DAC',ne.DAC());
		ms.measures <- thisModule.IntegerMeasure('DRC',ne.DRC());
		ms.measures <- thisModule.IntegerMeasure('CCD',ne.CCD());
	}
}
--@end rule Class2MeasureSet
		
--@begin called rule Category
--@comments Creates a category for metric classification with a name and a description.
rule Category(name : String, desc : String) {
	to
		cat : Measure!Category (
			name <- name,
			desc <- desc
		)
	do {
		cat;
	}
}
--@end called rule Category
		
--@begin called rule Metric
--@comments Creates a metric for a category with a name and a description (the default preferred value for the metric is set to not equal to zero ['!=0']).
rule Metric(catName : String, name : String, desc : String) {
	to
		metric : Measure!Metric (
			name <- name,
			desc <- desc,
			preferredValue <- '!=0',
			category <- thisModule.root.categories->
				select(cat|cat.name = catName)->first()
		)
	do {
		thisModule.MetricByName <-
			thisModule.MetricByName.including(metric.name,metric);
	}
}
--@end called rule Metric
		
--@begin called rule MetricWithPreferredValue
--@comments Creates a metric for a category with a name, a description and a preferred value for the metric (an operator [<, <=, =, !=, >=, >] followed by a number).
rule MetricWithPreferredValue(catName : String, name : String, desc : String, preferredValue : String) {
	to
		metric : Measure!Metric (
			name <- name,
			desc <- desc,
			preferredValue <- preferredValue,
			category <- thisModule.root.categories->
				select(cat|cat.name = catName)->first()
		)
	do {
		thisModule.MetricByName <-
			thisModule.MetricByName.including(metric.name,metric);
	}
}
--@end called rule MetricWithPreferredValue
		
--@begin called rule IntegerMeasure
--@comments Stores an Integer measure for the metric which name and value are given.
rule IntegerMeasure(name : String, value : Integer) {
	to
		meas : Measure!IntegerMeasure (
			metric <- thisModule.MetricByName.get(name),
			value <- value
		)
	do {
		meas;
	}
}
--@end called rule IntegerMeasure
		
--@begin called rule DoubleMeasure
--@comments Stores a Double measure for the metric which name and value are given.
rule DoubleMeasure(name : String, value : Real) {
	to
		meas : Measure!DoubleMeasure (
			metric <- thisModule.MetricByName.get(name),
			value <- value
		)
	do {
		meas;
	}
}
--@end called rule DoubleMeasure
		
--@begin called rule PercentageMeasure
--@comments Stores a Percentage measure for the metric which name and value are given.
rule PercentageMeasure(name : String, value : Real) {
	to
		meas : Measure!PercentageMeasure (
			metric <- thisModule.MetricByName.get(name),
			value <- value
		)
	do {
		meas;
	}
}
--@end called rule PercentageMeasure",atlcompil atl name km measur version domain km measur data metric author eric vepa evepa sodius com sodius www sodius com date descript this transform use collect measur data km metamodel use librari implement metric mood mood moos emoos qmood see baroni a l formal definit object orient design metric master thesi vrije univers brussel belgium modul km measur modul templat creat out measur in km use flame km use mood km use emoos km use qmood km begin attribut helper measurelevel comment defin measur level among packag class comment the packag level allow measur packag comment the class level allow measur packag class helper def measurelevel measur elementkind class end attribut helper measurelevel begin attribut helper root comment the root measur set helper def root measur rootmeasureset oclundefin end attribut helper root begin attribut helper metricbynam comment the map metric name helper def metricbynam map string measur metric map end attribut helper metricbynam begin entrypoint rule metric comment regist mood mood moos emoos qmood metric implement librari entrypoint rule metric root measur rootmeasureset modeltyp km thismodul root root thismodul measurelevel packag thismodul measurelevel class mood metric intra specif level metric root categori thismodul categori mood metric object orient design thismodul metric mood aif attribut inherit factor thismodul metric mood rif refer inherit factor thismodul metric mood ccf class coupl factor thismodul metric mood icf intern coupl factor mood metric intra specif level metric root categori thismodul categori mood metric object orient design thismodul metric mood iif intern inherit factor thismodul measurelevel class moos metric root categori thismodul categori moos metric object orient softwar engin thismodul metric moos wrc weight refer per class thismodul metric moos dit depth inherit tree thismodul metric moos noc number children thismodul metric moos cbo coupl between object emoos metric root categori thismodul categori emoos extend moos thismodul metric emoos size number local attribut refer defin class thismodul measurelevel packag thismodul measurelevel class qmood metric root categori thismodul categori qmood qualiti model object orient design thismodul metric qmood dsc design size class thismodul metric qmood noh number hierarchi thismodul metric qmood nic number independ class thismodul metric qmood nsi number singl inherit thismodul metric qmood nmi number multipl inherit thismodul metric qmood nnc number intern class thismodul metric qmood nac number abstract class thismodul metric qmood nlc number leaf class thismodul metric qmood adi averag depth inherit thismodul metric qmood awi averag width inherit thismodul metric qmood ana averag number ancestor thismodul measurelevel class thismodul metric qmood maa measur attribut abstract thismodul metric qmood mra measur refer abstract thismodul metric qmood moa measur aggreg thismodul metric qmood mrm model relationship measur thismodul metric qmood noa number ancestor thismodul metric qmood nor number refer thismodul metric qmood nod number attribut thismodul metric qmood nad number abstract data type thismodul metric qmood csm class size metric thismodul metric qmood dcc direct class coupl thismodul metric qmood mcc maximum class coupl thismodul metric qmood dac direct attribut base coupl thismodul metric qmood drc direct refer base coupl thismodul metric qmood ccd class complex base data end entrypoint rule metric begin rule packag measureset comment collect measur data packag measurelevel must set packag class rule packag measureset ne km packag thismodul measurelevel packag thismodul measurelevel class ms measur measureset elementnam ne cn ne name debug process metric packag els ne name endif elementtyp packag subset ne content ne packag oclisundefin thismodul root measureset ms ne cn mood metric intra specif level metric ms measur thismodul percentagemeasur aif ne aif ms measur thismodul percentagemeasur rif ne rif ms measur thismodul percentagemeasur ccf ne ccf ms measur thismodul percentagemeasur icf ne icf mood metric intra inter specif level metric ms measur thismodul percentagemeasur iif ne iif qmood metric ms measur thismodul integermeasur dsc ne dsc ms measur thismodul integermeasur noh ne noh ms measur thismodul integermeasur nic ne nic ms measur thismodul integermeasur nsi ne nsi ms measur thismodul integermeasur nmi ne nmi ms measur thismodul integermeasur nnc ne nnc ms measur thismodul integermeasur nac ne nac ms measur thismodul integermeasur nlc ne nlc ms measur thismodul doublemeasur adi ne adi ms measur thismodul doublemeasur awi ne awi ms measur thismodul doublemeasur ana ne ana end rule packag measureset begin rule class measureset comment collect measur data class measurelevel must set class rule class measureset ne km class thismodul measurelevel class ms measur measureset elementnam ne name debug process metric class elementtyp class moos metric ms measur thismodul integermeasur wrc ne wrc ms measur thismodul integermeasur dit ne dit ms measur thismodul integermeasur noc ne noc ms measur thismodul integermeasur cbo ne cbo emoos metric ms measur thismodul integermeasur size ne size qmood metric ms measur thismodul percentagemeasur maa ne maa ms measur thismodul percentagemeasur mra ne mra ms measur thismodul integermeasur moa ne moa ms measur thismodul integermeasur mrm ne mrm ms measur thismodul integermeasur noa ne noa ms measur thismodul integermeasur nor ne nor ms measur thismodul integermeasur nod ne nod ms measur thismodul integermeasur nad ne nad ms measur thismodul integermeasur csm ne csm ms measur thismodul integermeasur dcc ne dcc ms measur thismodul integermeasur mcc ne mcc ms measur thismodul integermeasur dac ne dac ms measur thismodul integermeasur drc ne drc ms measur thismodul integermeasur ccd ne ccd end rule class measureset begin call rule categori comment creat categori metric classif name descript rule categori name string desc string cat measur categori name name desc desc cat end call rule categori begin call rule metric comment creat metric categori name descript default prefer valu metric set equal zero rule metric catnam string name string desc string metric measur metric name name desc desc preferredvalu categori thismodul root categori select cat cat name catnam first thismodul metricbynam thismodul metricbynam includ metric name metric end call rule metric begin call rule metricwithpreferredvalu comment creat metric categori name descript prefer valu metric oper follow number rule metricwithpreferredvalu catnam string name string desc string preferredvalu string metric measur metric name name desc desc preferredvalu preferredvalu categori thismodul root categori select cat cat name catnam first thismodul metricbynam thismodul metricbynam includ metric name metric end call rule metricwithpreferredvalu begin call rule integermeasur comment store integ measur metric name valu given rule integermeasur name string valu integ mea measur integermeasur metric thismodul metricbynam get name valu valu mea end call rule integermeasur begin call rule doublemeasur comment store doubl measur metric name valu given rule doublemeasur name string valu real mea measur doublemeasur metric thismodul metricbynam get name valu valu mea end call rule doublemeasur begin call rule percentagemeasur comment store percentag measur metric name valu given rule percentagemeasur name string valu real mea measur percentagemeasur metric thismodul metricbynam get name valu valu mea end call rule percentagemeasur,14
75,75,P4-ATL-WFR.atl,"module ATL_WFR;
create OUT : Problem from IN : ATL;


-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- This helper provides a set containing the name of the IteratorExp elements
-- that accepts a single Iterator.
-- CONTEXT:	thisModule
-- RETURN:	Set(String)
helper def: singleIteratorExps : Set(String) =
	Set{
		'isUnique', 'any', 'one', 'collect', 'select',
		'reject', 'collectNested', 'sortedBy'
	};


-- This helper provides a set containing the name of the IteratorExp elements
-- for which several Iterators may be declared according to the OCL spec.
-- CONTEXT:	thisModule
-- RETURN:	Set(String)
helper def: multiIteratorExps : Set(String) = Set{'exists', 'forAll'};


-- This helper computes the set of existing CollectionType elements within the
-- input ATL Unit.
-- CONTEXT:	thisModule
-- RETURN:	Set(ATL!CollectionType)
helper def: collectionTypes : Set(ATL!CollectionType) =
	ATL!CollectionType.allInstances();


-- This helper computes a sequence containing all the OclModel elements that
-- are used in the input ATL Unit.
-- CONTEXT:	thisModule
-- RETURN:	Sequence(ATL!OclModel)
helper def: allModels : Sequence(ATL!OclModel) =
	let atlModule : ATL!Module =
		ATL!Module.allInstances()->asSequence()->first()
	in
	Sequence{
		atlModule.inModels,
		atlModule.outModels
	}->flatten();


-- This helper computes the Query element that corresponds to the input ATL
-- Unit. If the input ATL Unit corresponds to a Module (eg a transformation),
-- the computed value is OclUndefined.
-- CONTEXT:	thisModule
-- RETURN:	ATL!Query
helper def: queryElt : ATL!Query =
	ATL!Query.allInstances()->asSequence()->first();


-- This helper computes a sequence containing all the Binding elements that
-- are defined in the input ATL Unit.
-- CONTEXT:	thisModule
-- RETURN:	Sequence(ATL!Binding)
helper def: allBindings : Sequence(ATL!Binding) =
	ATL!Binding.allInstances()->asSequence();


-- This helper computes a sequence containing all the Pattern elements that
-- are defined in the input ATL Unit.
-- CONTEXT:	thisModule
-- RETURN:	Sequence(ATL!InPattern)
helper def: allInPatterns : Sequence(ATL!InPattern) =
	ATL!InPattern.allInstances()->asSequence();


-- This helper computes a sequence containing all the InPatternElement elements
-- that are defined in the input ATL Unit.
-- CONTEXT:	thisModule
-- RETURN:	Sequence(ATL!InPatternElement)
helper def: allInPatternElts : Sequence(ATL!InPatternElement) =
	ATL!InPatternElement.allInstances()->asSequence();


-- This helper computes a sequence containing all the OutPatternElement
-- elements that are defined in the input ATL Unit.
-- CONTEXT:	thisModule
-- RETURN:	Sequence(ATL!OutPatternElement)
helper def: allOutPatternElts : Sequence(ATL!OutPatternElement) =
	ATL!OutPatternElement.allInstances()->asSequence();


-- This helper computes a sequence containing all the Rule elements that are
-- defined in the input ATL Unit. If the input Unit is a query, the computed
-- sequence is empty.
-- CONTEXT:	thisModule
-- RETURN:	Sequence(ATL!Rule)
helper def: allRules : Sequence(ATL!Rule) =
	ATL!Rule.allInstances()->asSequence();


-- This helper computes a sequence containing all the Helper elements that are
-- defined in the input ATL Unit.
-- CONTEXT:	thisModule
-- RETURN:	Sequence(ATL!Helper)
helper def: allHelpers : Sequence(ATL!Helper) =
	ATL!Helper.allInstances()->asSequence();


-- This helper computes a sequence containing all the LoopExp elements that are
-- defined in the input ATL Unit.
-- CONTEXT:	thisModule
-- RETURN:	Sequence(ATL!LoopExp)
helper def: allLoopExps : Sequence(ATL!LoopExp) =
	ATL!LoopExp.allInstances()->asSequence();


-- This helper computes a sequence containing all the IterateExp elements that
-- are defined in the input ATL Unit.
-- CONTEXT:	thisModule
-- RETURN:	Sequence(ATL!IterateExp)
helper def: allIterateExps : Sequence(ATL!IterateExp) =
	ATL!IterateExp.allInstances()->asSequence();


-- This helper computes a sequence containing all the VariableDeclaration
-- elements that are associated with the contextual Rule. These declarations
-- can be of 3 different kinds:
--  * the variables declared for the rule;
--  * the OutPatternElements of the rule;
--  * the InPatternElements of the rule if this last is a MatchedRule.
-- CONTEXT:	ATL!Rule
-- RETURN:	Sequence(ATL!VariableDeclaration)
helper context ATL!Rule
	def: namedElements : Sequence(ATL!VariableDeclaration) =
	Sequence{
		if self.oclIsTypeOf(ATL!MatchedRule)
		then
			self.inPattern.elements->asSequence()
		else
			Sequence{}
		endif,
		self.variables->asSequence(),
		self.outPattern.elements->asSequence()
	}->flatten();


-- This helper computes the Rule element in which the contextual PatterElement
-- is declared. This is achieved by returning the Rule referred by the ""rule""
-- reference of the Pattern that conatins the contexual PatternElement. This 
-- last one is accessed through the ""outPattern"" reference if the contextual
-- PatternElement is an OutPatternElement, throught the ""inPattern"" if it is
-- an InPatternElement.
-- CONTEXT:	ATL!PatternElement
-- RETURN:	ATL!Rule
helper context ATL!PatternElement def: ""rule"" : ATL!Rule =
	if self.oclIsKindOf(ATL!OutPatternElement)
	then
		self.outPattern.""rule""
	else
		self.inPattern.""rule""
	endif;


-- This helper returns the immediate composite (container) of the contextual
-- VariableDeclaration.
-- If the ""letExp"" reference of the contextual VariableDeclaration is not
-- undefined, the helper returns the pointed LetExp.
-- Otherwise, if the ""letExp"" reference of the contextual VD is not undefined,
-- the helper returns the pointed IterateExp.
-- Otherwise, if the contextual VD is an InPatternElement, the helper returns
-- the InPattern in which it is contained.
-- Otherwise, if the contextual VD is an OutPatternElement, the helper returns
-- the OutPattern in which it is contained.
-- Otherwise, if there exists a LoopExp element that contains the contextual VD
-- as an iterator, the helper returns this LoopExp.
-- Otherwise, if there exists an IterateExp element that contains the contextual
-- VD as its result, the helper returns this IterateExp.
-- Otherwise, if there exists a Rule element that contains the contextual VD
-- as a rule variable iterator, the helper returns this Rule element.
-- Otherwise, the helper returns OclUndefined as a default value.
-- CONTEXT:	ATL!VariableDeclaration
-- RETURN:	ATL!Element
helper context ATL!VariableDeclaration def: immediateComposite : ATL!Element =
	if not self.letExp.oclIsUndefined() then
		self.letExp
	else if not self.baseExp.oclIsUndefined() then
		self.baseExp
	else if thisModule.allInPatternElts->exists(e | e = self) then
		thisModule.allInPatternElts->select(e | e = self)->first().inPattern
	else if thisModule.allOutPatternElts->exists(e | e = self) then
		thisModule.allOutPatternElts->select(e | e = self)->first().outPattern
	else if thisModule.allLoopExps
				->exists(l | l.iterators->exists(e | self = e))	then
		thisModule.allLoopExps
			->select(l | l.iterators->exists(e | self = e))->first()
	else if thisModule.allIterateExps->exists(e | self = e.result) then
		thisModule.allIterateExps->select(e | self = e.result)->first()
	else if thisModule.allRules
				->exists(r | r.variables->exists(e | self = e)) then
		thisModule.allRules
			->select(r | r.variables->exists(e | self = e))
			->first()
	else OclUndefined
	endif endif	endif endif endif endif endif;


-- This helper returns the immediate composite (container) of the contextual
-- OclExpression.
-- If the one of the ""ifExp1"", ""ifExp2"" and ""ifExp3"" references of the
-- contextual OclExpression is not undefined, the helper returns the pointed
-- IfExp.
-- Otherwise, if its ""attribute"" is not undefined, the helper returns the
-- pointed Attribute.
-- Otherwise, if its ""operation"" is not undefined, the helper returns the
-- pointed Operation.
-- Otherwise, if its ""initializedVariable"" is not undefined, the helper returns
-- the pointed VariableDeclaration.
-- Otherwise, if its ""parentOperation"" is not undefined, the helper returns the
-- pointed OperationCallExp.
-- Otherwise, if its ""loopExp"" is not undefined, the helper returns the pointed
-- LoopExp.
-- Otherwise, if its ""letExp"" is not undefined, the helper returns the
-- pointed LetExp.
-- Otherwise, if its ""collection"" is not undefined, the helper returns the
-- pointed CollectionExp.
-- Otherwise, if its ""appliedProperty"" is not undefined, the helper returns the
-- pointed PropertyCallExp.
-- Otherwise, if its ""operation"" is not undefined, the helper returns the
-- pointed Operation.
-- Otherwise, if there exists an InPattern that has the contextual OclExp as
-- filter, the helper returns this InPattern.
-- Otherwise, if there exists a Binding that has the contextual OclExp as
-- value, the helper returns this Binding.
-- Otherwise, if there exists a Query that has the contextual OclExp as body,
-- the helper returns this Query.
-- Otherwise, the helper retuns OclUndefined as default value.
-- CONTEXT:	ATL!OclExpression
-- RETURN:	ATL!Element
helper context ATL!OclExpression def: immediateComposite : ATL!Element =
	if not self.ifExp1.oclIsUndefined() then self.ifExp1
	else if not self.ifExp2.oclIsUndefined() then self.ifExp2
	else if not self.ifExp3.oclIsUndefined() then self.ifExp3
	else if not self.""attribute"".oclIsUndefined() then self.""attribute""
	else if not self.""operation"".oclIsUndefined() then self.""operation""
	else if not self.initializedVariable.oclIsUndefined()
		then self.initializedVariable
	else if not self.parentOperation.oclIsUndefined() then self.parentOperation
	else if not self.loopExp.oclIsUndefined() then self.loopExp
	else if not self.letExp.oclIsUndefined() then self.letExp
	else if not self.collection.oclIsUndefined() then self.collection
	else if not self.appliedProperty.oclIsUndefined() then self.appliedProperty
	else if thisModule.allInPatterns->exists(e | e.filter = self)
		then thisModule.allInPatterns->select(e | e.filter = self)->first()
	else if thisModule.allBindings->exists(e | e.value = self)
		then thisModule.allBindings->select(e | e.value = self)->first()
	else
		if not thisModule.queryElt.oclIsUndefined()
		then
			if thisModule.queryElt.body = self
			then
				thisModule.queryElt
			else
				OclUndefined
			endif
		else
			OclUndefined
		endif
	endif endif endif endif endif endif endif
	endif endif endif endif endif endif;


-- This helper computes a sequence containing the VariableDeclarations that
-- precede the contextual VariableDeclaration in its namespace.
-- If the contextual VariableDeclaration is a PatternElement, the helper only
-- returns this VD.
-- Otherwise, it computes the container of the contextual VD. If the container
-- is a LetExp, it returns a Sequence composed of the VD, and the results of
-- the calls of the getUpD helper on the calculated container.
-- If the container is an IteratorExp, the helper returns a Sequence composed
-- of the VD and the results of the call of getUpD on the computed container.
-- If the container is an IterateExp, the helper a Sequence containing the same
-- elements that the one computed for an IteratorExp.
-- Otherwise, the helper returns the only contextual VD as default value.
-- CONTEXT:	ATL!VariableDeclaration
-- RETURN:	Sequence(ATL!VariableDeclaration)
helper context ATL!VariableDeclaration
	def: getDeclarations() : Sequence(ATL!VariableDeclaration) =
	if self.oclIsKindOf(ATL!PatternElement)
	then
		Sequence{self}
	else
		let container : ATL!Element = self.immediateComposite in
		if container.oclIsTypeOf(ATL!LetExp)
		then
			Sequence{
				self,
				container.getUpD()
			}->flatten()
		else
			if container.oclIsTypeOf(ATL!IteratorExp)
			then
				Sequence{
					self,
					container.getUpD()
				}->flatten()
			else
				if container.oclIsTypeOf(ATL!IterateExp)
				then
					Sequence{
						self,
						container.getUpD()
					}->flatten()
				else
					Sequence{
						self
					}->flatten()
				endif
			endif
		endif
	endif;


-- This helper computes a sequence containing the VariableDeclarations that are
-- defined higher than the contextual OclExpression in its namespace tree.
-- The helper first computes the container of the contextual OclExp. If this
-- container is undefined, it retuns an empty sequence.
-- Otherwise, if this container is not an OclExpression:
--  * If the container is a RuleVariableDeclaration, the helper returns a
--    sequence containing all the named elements of the rule that contains this
--    InPattern.
--  * If the container is a Binding, the helper returns a sequence containing
--    all the named elements of the rule that contains this Binding.
-- Otherwise, if the computed container is an OclExpression:
--  * If the container is a LetExp, the helper returns a sequence composed of
--    the LetExp variable and the result of its recursive call on the LetExp.
--  * If the container is an IfExp, the helper returns a sequence composed of
--    the result of its recursive call on the IfExp.
--  * If the container is an IteratorExp, if the contextual OclExp is the
--    source of the IteratorExp then the helper returns the result of its
--    recursive call on the IteratorExp, else it returns this result with the
--    ""iterators"" elements of the IteratorExp.
--  * If the container is an IterateExp, the helper returns the same sequences
--    that for an IteratorExp, with the additional ""result"" element in case the
--    contextual OclExp is not the source of the IterateExp.
-- Otherwise, the helper returns an empty sequence as default value.
-- CONTEXT:	ATL!OclExpression
-- RETURN:	Sequence(ATL!VariableDeclaration)
helper context ATL!OclExpression
	def: getUpD() : Sequence(ATL!VariableDeclaration) =
	let container : ATL!Element = self.immediateComposite in
	if container.oclIsUndefined() then
		Sequence{}
	else if not container.oclIsKindOf(ATL!OclExpression) then
		if container.oclIsTypeOf(ATL!RuleVariableDeclaration)
		then
			Sequence{
				container.""rule"".namedElements
			}->flatten()
		else
			if container.oclIsTypeOf(ATL!Binding)
			then
				Sequence{
					container.outPatternElement.""rule"".namedElements
				}->flatten()
			else
				Sequence{}
			endif
		endif
	else if container.oclIsTypeOf(ATL!LetExp) then
		Sequence{
			container.variable,
			container.getUpD()
		}->flatten()
	else if container.oclIsTypeOf(ATL!IfExp) then
		Sequence{
			container.getUpD()
		}->flatten()
	else if container.oclIsTypeOf(ATL!IteratorExp) then
		if container.source = self
		then
			Sequence{
				container.getUpD()
			}->flatten()
		else
			Sequence{
				container.iterators,
				container.getUpD()
			}->flatten()
		endif
	else if container.oclIsTypeOf(ATL!IterateExp) then
		if container.source = self
		then
			Sequence{
				container.getUpD()
			}->flatten()
		else
			Sequence{
				container.iterators,
				container.result,
				container.getUpD()
			}->flatten()
		endif
	else Sequence{}
	endif endif endif endif endif endif;


-- This helper computes a sequence containing the VariableDeclarations that are
-- defined lower than the contextual OclExpression in its namespace tree.
-- If the contextual OclExpression is a LetExp, the helper returns a sequence
-- composed of the LetExp variable and the result of its recursive call on the
-- ""in_"" reference of the LetExp.
-- Otherwise, if the contextual OclExpression is a IfExp, the helper returns a
-- sequence composed of the results of its recursive calls on the ""condition"",
-- ""thenExpression"" and ""elseExpression"" references of the IfExp.
-- Otherwise, if the contextual OclExpression is an IteratorExp, the helper
-- returns a sequence composed of the IteratorExp iterators along with the
-- results of its recursive calls on the ""source"" and the ""body"" references
-- of the IteratorExp.
-- Otherwise, if the contextual OclExpression is an IterateExp, the helper
-- returns the sequence returned for an IteratorExp with its additional result
-- element.
-- Otherwise, the helper returns an empty sequence as default value.
-- CONTEXT:	ATL!OclExpression
-- RETURN:	Sequence(ATL!VariableDeclaration)
--helper context ATL!OclExpression
--	def: getDownD() : Sequence(ATL!VariableDeclaration) =
--	if self.oclIsTypeOf(ATL!LetExp) then
--		Sequence{
--			self.variable,
--			self.in_.getDownD()
--		}->flatten()
--	else if self.oclIsTypeOf(ATL!IfExp) then
--		Sequence{
--			self.condition.getDownD(),
--			self.thenExpression.getDownD(),
--			self.elseExpression.getDownD()
--		}->flatten()
--	else if self.oclIsTypeOf(ATL!IteratorExp) then
--		Sequence{
--			self.iterators,
--			self.source.getDownD(),
--			self.body.getDownD()
--		}->flatten()
--	else if self.oclIsTypeOf(ATL!IterateExp) then
--		Sequence{
--			self.iterators,
--			self.result,
--			self.source.getDownD(),
--			self.body.getDownD()
--		}->flatten()
--	else Sequence{}
--	endif endif endif endif;


-- This helper returns the root composite (container) of the contextual
-- OclExpression. For this purpose, the helper first computes the immediate
-- composite of the contextual OclExpression.
-- If this container is undefined, the helper returns OclUndefined.
-- Otherwise, if it is a kind of OclExpression, the helper returns the value
-- provided by its recursive call on the computed container.
-- Finally, if this container is not an OclExpression, the root composite has
-- been reached (Binding/InPattern/Operation/Query/Attribute) and is returned.
-- CONTEXT:	ATL!OclExpression
-- RETURN:	ATL!Element
helper context ATL!OclExpression def: getRootComposite() : ATL!Element =
	let container : ATL!Element = self.immediateComposite
	in
	if container.oclIsUndefined()
	then
		OclUndefined
	else
		if container.oclIsKindOf(ATL!OclExpression)
		then
			container.getRootComposite()
		else
			container
		endif
	endif;


-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'FreeVariableIsSelfOrThisModule'
-- This rule generates an 'error' Problem for each VariableDeclaration that has
-- no composite, and whose name is different from both 'self' and 'thisModule'.
-- The VariableExps that have not been previously declared in an ATL file are
-- associated with a new VariableDeclaration without any composite in the
-- correspoding ATL model.
rule FreeVariableIsSelfOrThisModule {
	from
		s : ATL!VariableDeclaration (
			s.immediateComposite.oclIsUndefined() and
			s.varName <> 'self' and s.varName <> 'thisModule'
		)
	to
		t : Problem!Problem (
			severity <- #error,
			location <-
				if s.variableExp->isEmpty()
				then
					s.location
				else
					s.variableExp->first().location
				endif,
			description <- 'variable \'' + s.varName + '\' undefined'
		)
}

-- Rule 'ModelNameIsUnique'
-- This rule generates an 'error' Problem when there exists models that have
-- the same name that the checked model.
rule ModelNameIsUnique {
	from
		s : ATL!OclModel (
			thisModule.allModels->exists(e | e.name = s.name and e <> s)
		)
	to
		t : Problem!Problem (
			severity <- #error,
			location <- s.location,
			description <- 'model \'' + s.name + '\' already defined'
		)
}

-- Rule 'RuleNameIsUnique'
-- This rule generates an 'error' Problem when there exists rules that have
-- the same name that the checked rule.
rule RuleNameIsUnique {
	from
		s : ATL!Rule (
			thisModule.allRules->exists(e | e.name = s.name and e <> s)
		)
	to
		t : Problem!Problem (
			severity <- #error,
			location <- s.location,
			description <- 'rule \'' + s.name + '\' already defined'
		)
}

-- Rule 'HelperSignatureIsUnique'
-- This rule generates an 'error' Problem when there exists helpers that have
-- the same signature that the checked helper.
-- Note that in current implementation, the helper signature corresponds to the
-- name and the context of the helper.
rule HelperSignatureIsUnique {
	from
		s : ATL!Helper (
			thisModule.allHelpers
				->exists(e |
					e <> s and
					s.definition.feature.name = e.definition.feature.name and
					(
					 if not s.definition.context_.oclIsUndefined()
					 then
					 	if not e.definition.context_.oclIsUndefined()
					 	then
						if not s.definition.context_.context_.name.oclIsUndefined()
							then
							if not e.definition.context_.context_.name.oclIsUndefined()
								then
									s.definition.context_.context_.name = e.definition.context_.context_.name
								else
									false
								endif
							else
								e.definition.context_.context_.name.oclIsUndefined()
							endif
						else
							false
						endif
					 else
					 	e.definition.context_.oclIsUndefined()
					 endif
					 )
				)
		)
	to
		t : Problem!Problem (
			severity <- #error,
			location <- s.location,
			description <- 'helper \'' + s.definition.feature.name
							+ '\' already defined'
		)
}

-- Rule 'BindingNameIsUniqueInPattern'
-- This rule generates an 'error' Problem when there exists, in a same pattern,
-- bindings that have the same name that the checked binding.
rule BindingNameIsUniqueInPattern {
	from
		s : ATL!Binding (
			s.outPatternElement.bindings
				->exists(e | e.propertyName = s.propertyName and e <> s)
		)
	to
		t : Problem!Problem (
			severity <- #error,
			location <- s.location,
			description <-
				'binding \'' + s.propertyName + '\' already defined in pattern'
		)
}

-- Rule 'PatternNameIsUniqueInRule'
-- This rule generates an 'error' Problem when there exists, in a same rule,
-- some named elements (InPatternElement/OutPatternElement/
-- RuleVariableDeclaration) that have the same name that the checked pattern.
rule PatternNameIsUniqueInRule {
	from
		s : ATL!PatternElement (
			s.""rule"".namedElements
				->exists(e | e.varName = s.varName and e <> s)
		)
	to
		t : Problem!Problem (
			severity <- #error,
			location <- s.location,
			description <-
				'pattern or variable named \''
				+ s.varName	+ '\' already defined in rule'
		)
}

-- Rule 'VariableNameIsUniqueInRule'
-- This rule generates an 'error' Problem when there exists, in a same rule,
-- some named elements (InPatternElement/OutPatternElement/
-- RuleVariableDeclaration) that have the same name that the checked rule
-- variable declaration.
rule VariableNameIsUniqueInRule {
	from
		s : ATL!RuleVariableDeclaration (
			s.""rule"".namedElements
				->exists(e | e.varName = s.varName and e <> s)
		)
	to
		t : Problem!Problem (
			severity <- #error,
			location <- s.location,
			description <-
				'pattern or variable named \'' + s.varName
				+ '\' already defined in rule'
		)
}

-- Rule 'NoHelperWithCollectionAsContext'
-- This rule generates an 'error' Problem for each Helper defined with a
-- collection type as context.
-- Note that this problem is due to the limitations of the current
-- implementation
rule NoHelperWithCollectionAsContext {
	from
		s : ATL!Helper (
			if s.definition.context_.oclIsUndefined()
			then
				false
			else
				thisModule.collectionTypes
					->exists(e | s.definition.context_.context_ = e)
			endif
		)
	to
		t : Problem!Problem (
			severity <- #error,
			location <- s.location,
			description <-
				'helper \'' + s.definition.feature.name
					+ '\': current implementation does not '
					+ 'support helpers with collection context'
		)
}

-- Rule 'NoSelfOrThisModuleVariableDeclaration'
-- This rule generates an 'error' Problem for each declaration of a variable
-- named 'self' or 'thisModule' in the ATL program.
-- Considered variable declarations must have a non-undefined immediate
-- composite since the input ATL model may already include a 'self' and a
-- 'thisModule' VD without any immediate composite that correspond to the
-- global declarations of the 'self' and 'thisModule' variables.
rule NoSelfOrThisModuleVariableDeclaration {
	from
		s : ATL!VariableDeclaration (
			not s.immediateComposite.oclIsUndefined() and
			(s.varName = 'self' or s.varName = 'thisModule')
		)
	to
		t : Problem!Problem (
			severity <- #error,
			location <- s.location,
			description <-
				'helper \'' + s.varName	+ '\' is not valid variable name'
		)
}

-- Rule 'NoSelfVariableInRule'
-- This rule generates an 'error' Problem for each 'self' variable expression
-- that is contained by a rule element.
rule NoSelfVariableInRule {
	from
		s : ATL!VariableExp (
--			s.referredVariable.varName = 'self' and 
--			(
--				let rComp : ATL!Element = s.getRootComposite() in
--				rComp.oclIsTypeOf(ATL!Binding) or
--				rComp.oclIsTypeOf(ATL!InPattern)
--			)
			if s.referredVariable.oclIsUndefined()
			then
				false
			else
				s.referredVariable.varName = 'self' and 
				(
					let rComp : ATL!Element = s.getRootComposite() in
					rComp.oclIsTypeOf(ATL!Binding) or
					rComp.oclIsTypeOf(ATL!InPattern)
				)
			endif
		)
	to
		t : Problem!Problem (
			severity <- #error,
			location <- s.location,
			description <-
				'rule \'' + s.referredVariable.varName
				+ '\': use of the \'self\' variable prohibited in rules'
		)
}

-- Rule 'NoResolveTempInSourcePattern'
-- This rule generates an 'error' Problem for each call of the
-- 'thisModule.resolveTemp()' operation within a source pattern of a rule.
rule NoResolveTempInSourcePattern {
	from
		s : ATL!OperationCallExp (
			s.operationName = 'resolveTemp' and
			(
				if s.source.oclIsTypeOf(ATL!VariableExp)
				then
					if s.source.referredVariable.oclIsUndefined()
					then
						false
					else
						s.source.referredVariable.varName = 'thisModule'
					endif
				else
					false
				endif
			) and
			s.getRootComposite().oclIsTypeOf(ATL!InPattern)
		)
	to
		t : Problem!Problem (
			severity <- #error,
			location <- s.location,
			description <-
				'rule \'' + s.getRootComposite().""rule"".name
				+ '\': use of \'thisModule.resolveTemp()\' function '
				+ 'is prohibited in source patterns'
		)
}

-- Rule 'NoResolveTempInModuleAttribute'
-- This rule generates an 'error' Problem for each call of the
-- 'thisModule.resolveTemp()' operation within a model attribute.
rule NoResolveTempInModuleAttribute {
	from
		s : ATL!OperationCallExp (
			s.operationName = 'resolveTemp' and
			(
				if s.source.oclIsTypeOf(ATL!VariableExp)
				then
					if s.source.referredVariable.oclIsUndefined()
					then
						false
					else
						s.source.referredVariable.varName = 'thisModule'
					endif
				else
					false
				endif
			) and
			s.getRootComposite().oclIsTypeOf(ATL!Attribute)
		)
	to
		t : Problem!Problem (
			severity <- #error,
			location <- s.location,
			description <-
				'attribute \'' + s.getRootComposite().name
				+ '\': use of \'thisModule.resolveTemp()\' function '
				+ 'is prohibited in attributes'
		)
}

-- Rule 'ProhibitedMultiIteratorCollectionOperation'
-- This rule generates an 'error' Problem for each IteratorExp of the
-- singleIteratorExps set that is associated with several Iterators.
rule ProhibitedMultiIteratorCollectionOperation {
	from
		s : ATL!IteratorExp (
			thisModule.singleIteratorExps->exists(e | s.name = e) and
			s.iterators->size() > 1
		)
	to
		t : Problem!Problem (
			severity <- #error,
			location <- s.location,
			description <-
				'iterator \'' + s.name
				+ '\' may have at most one iterator variable'
		)
}

-- Rule 'UnsupportedMultiIteratorCollectionOperation'
-- This rule generates an 'error' Problem for each IteratorExp of the
-- multiIteratorExps set that is associated with several Iterators.
-- Note that this problem is due to limitations of the current implementation.
rule UnsupportedMultiIteratorCollectionOperation {
	from
		s : ATL!IteratorExp (
			thisModule.multiIteratorExps->exists(e | s.name = e) and
			s.iterators->size() > 1
		)
	to
		t : Problem!Problem (
			severity <- #error,
			location <- s.location,
			description <-
				'with current implementation, iterator \'' + s.name
				+ '\' may have at most one iterator variable'
		)
}

-- Rule 'ParameterNameIsUniqueInOperation'
-- This rule generates an 'error' Problem for each parameter for which there
-- exists another parameter of the same name in the operation declaration.
rule ParameterNameIsUniqueInOperation {
	from
		s : ATL!Parameter (
			s.operation.parameters
				->exists(e | s.varName = e.varName and s <> e)
		)
	to
		t : Problem!Problem (
			severity <- #error,
			location <- s.location,
			description <-
				'a parameter named \'' + s.varName
				+ '\' is already declared in this operation'
		)
}

-- Rule 'IteratorNameIsUniqueInLoop'
-- This rule generates an 'error' Problem for each Iterator declaration for
-- which there exists either another Iterator or a result variable declaration
-- (for Iterate loop only) of the same name within the same loop definition.
rule VariableNameIsUniqueInLoop {
	from
		s : ATL!Iterator (
			s.loopExpr.iterators
				->exists(e | s.varName = e.varName and s <> e)
			or
			if s.loopExpr.oclIsTypeOf(ATL!IterateExp)
			then
				s.loopExpr.result.varName = s.varName
			else
				false
			endif
		)
	to
		t : Problem!Problem (
			severity <- #error,
			location <- s.location,
			description <-
				'a variable named \'' + s.varName
				+ '\' is already declared in this loop'
		)
}

-- Rule 'ResultNameIsUniqueInIterate'
-- This rule generates an 'error' Problem for each 'result' variable
-- declaration of an IterateExp for which there exists an Iterator variable of
-- the same name in the Iterate loop definition.
rule ResultNameIsUniqueInIterate {
	from
		s : ATL!VariableDeclaration (
			if s.baseExp.oclIsUndefined()
			then
				false
			else
				s.baseExp.iterators
					->exists(e | s.varName = e.varName and s <> e)
			endif
		)
	to
		t : Problem!Problem (
			severity <- #error,
			location <- s.location,
			description <-
				'a variable named \'' + s.varName
				+ '\' is already declared in this loop'
		)
}

-- Rule 'VariableNameIsUniqueInContainer'
-- This rule generates a 'warning' Problem for each declaration of a variable
-- for which there exists another variable declaration of the same name in the
-- same namespace (except multiple intances of an Iterator name in a same loop
-- which handle 'error' Problems).
rule VariableNameIsUniqueInContainer {
	from
		s : ATL!VariableDeclaration (
			s.getDeclarations()->exists(e | s.varName = e.varName and s <> e)
		)
	to
		t : Problem!Problem (
			severity <- #warning,
			location <- s.location,
			description <-
				'a variable named \'' + s.varName
				+ '\' is already declared in this container'
		)
}
",modul atl wfr creat out problem in atl helper this helper provid set contain name iteratorexp element accept singl iter context thismodul return set string helper def singleiteratorexp set string set isuniqu one collect select reject collectnest sortedbi this helper provid set contain name iteratorexp element sever iter may declar accord ocl spec context thismodul return set string helper def multiiteratorexp set string set exist foral this helper comput set exist collectiontyp element within input atl unit context thismodul return set atl collectiontyp helper def collectiontyp set atl collectiontyp atl collectiontyp allinst this helper comput sequenc contain oclmodel element use input atl unit context thismodul return sequenc atl oclmodel helper def allmodel sequenc atl oclmodel let atlmodul atl modul atl modul allinst assequ first sequenc atlmodul inmodel atlmodul outmodel flatten this helper comput queri element correspond input atl unit if input atl unit correspond modul eg transform comput valu oclundefin context thismodul return atl queri helper def queryelt atl queri atl queri allinst assequ first this helper comput sequenc contain bind element defin input atl unit context thismodul return sequenc atl bind helper def allbind sequenc atl bind atl bind allinst assequ this helper comput sequenc contain pattern element defin input atl unit context thismodul return sequenc atl inpattern helper def allinpattern sequenc atl inpattern atl inpattern allinst assequ this helper comput sequenc contain inpatternel element defin input atl unit context thismodul return sequenc atl inpatternel helper def allinpatternelt sequenc atl inpatternel atl inpatternel allinst assequ this helper comput sequenc contain outpatternel element defin input atl unit context thismodul return sequenc atl outpatternel helper def alloutpatternelt sequenc atl outpatternel atl outpatternel allinst assequ this helper comput sequenc contain rule element defin input atl unit if input unit queri comput sequenc empti context thismodul return sequenc atl rule helper def allrul sequenc atl rule atl rule allinst assequ this helper comput sequenc contain helper element defin input atl unit context thismodul return sequenc atl helper helper def allhelp sequenc atl helper atl helper allinst assequ this helper comput sequenc contain loopexp element defin input atl unit context thismodul return sequenc atl loopexp helper def allloopexp sequenc atl loopexp atl loopexp allinst assequ this helper comput sequenc contain iterateexp element defin input atl unit context thismodul return sequenc atl iterateexp helper def alliterateexp sequenc atl iterateexp atl iterateexp allinst assequ this helper comput sequenc contain variabledeclar element associ contextu rule these declar differ kind variabl declar rule outpatternel rule inpatternel rule last matchedrul context atl rule return sequenc atl variabledeclar helper context atl rule def namedel sequenc atl variabledeclar sequenc self oclistypeof atl matchedrul self inpattern element assequ els sequenc endif self variabl assequ self outpattern element assequ flatten this helper comput rule element contextu patterel declar this achiev return rule refer rule refer pattern conatin contexu patternel this last one access outpattern refer contextu patternel outpatternel throught inpattern inpatternel context atl patternel return atl rule helper context atl patternel def rule atl rule self ocliskindof atl outpatternel self outpattern rule els self inpattern rule endif this helper return immedi composit contain contextu variabledeclar if letexp refer contextu variabledeclar undefin helper return point letexp otherwis letexp refer contextu vd undefin helper return point iterateexp otherwis contextu vd inpatternel helper return inpattern contain otherwis contextu vd outpatternel helper return outpattern contain otherwis exist loopexp element contain contextu vd iter helper return loopexp otherwis exist iterateexp element contain contextu vd result helper return iterateexp otherwis exist rule element contain contextu vd rule variabl iter helper return rule element otherwis helper return oclundefin default valu context atl variabledeclar return atl element helper context atl variabledeclar def immediatecomposit atl element self letexp oclisundefin self letexp els self baseexp oclisundefin self baseexp els thismodul allinpatternelt exist e e self thismodul allinpatternelt select e e self first inpattern els thismodul alloutpatternelt exist e e self thismodul alloutpatternelt select e e self first outpattern els thismodul allloopexp exist l l iter exist e self e thismodul allloopexp select l l iter exist e self e first els thismodul alliterateexp exist e self e result thismodul alliterateexp select e self e result first els thismodul allrul exist r r variabl exist e self e thismodul allrul select r r variabl exist e self e first els oclundefin endif endif endif endif endif endif endif this helper return immedi composit contain contextu oclexpress if one ifexp ifexp ifexp refer contextu oclexpress undefin helper return point ifexp otherwis attribut undefin helper return point attribut otherwis oper undefin helper return point oper otherwis initializedvari undefin helper return point variabledeclar otherwis parentoper undefin helper return point operationcallexp otherwis loopexp undefin helper return point loopexp otherwis letexp undefin helper return point letexp otherwis collect undefin helper return point collectionexp otherwis appliedproperti undefin helper return point propertycallexp otherwis oper undefin helper return point oper otherwis exist inpattern contextu oclexp filter helper return inpattern otherwis exist bind contextu oclexp valu helper return bind otherwis exist queri contextu oclexp bodi helper return queri otherwis helper retun oclundefin default valu context atl oclexpress return atl element helper context atl oclexpress def immediatecomposit atl element self ifexp oclisundefin self ifexp els self ifexp oclisundefin self ifexp els self ifexp oclisundefin self ifexp els self attribut oclisundefin self attribut els self oper oclisundefin self oper els self initializedvari oclisundefin self initializedvari els self parentoper oclisundefin self parentoper els self loopexp oclisundefin self loopexp els self letexp oclisundefin self letexp els self collect oclisundefin self collect els self appliedproperti oclisundefin self appliedproperti els thismodul allinpattern exist e e filter self thismodul allinpattern select e e filter self first els thismodul allbind exist e e valu self thismodul allbind select e e valu self first els thismodul queryelt oclisundefin thismodul queryelt bodi self thismodul queryelt els oclundefin endif els oclundefin endif endif endif endif endif endif endif endif endif endif endif endif endif endif this helper comput sequenc contain variabledeclar preced contextu variabledeclar namespac if contextu variabledeclar patternel helper return vd otherwis comput contain contextu vd if contain letexp return sequenc compos vd result call getupd helper calcul contain if contain iteratorexp helper return sequenc compos vd result call getupd comput contain if contain iterateexp helper sequenc contain element one comput iteratorexp otherwis helper return contextu vd default valu context atl variabledeclar return sequenc atl variabledeclar helper context atl variabledeclar def getdeclar sequenc atl variabledeclar self ocliskindof atl patternel sequenc self els let contain atl element self immediatecomposit contain oclistypeof atl letexp sequenc self contain getupd flatten els contain oclistypeof atl iteratorexp sequenc self contain getupd flatten els contain oclistypeof atl iterateexp sequenc self contain getupd flatten els sequenc self flatten endif endif endif endif this helper comput sequenc contain variabledeclar defin higher contextu oclexpress namespac tree the helper first comput contain contextu oclexp if contain undefin retun empti sequenc otherwis contain oclexpress if contain rulevariabledeclar helper return sequenc contain name element rule contain inpattern if contain bind helper return sequenc contain name element rule contain bind otherwis comput contain oclexpress if contain letexp helper return sequenc compos letexp variabl result recurs call letexp if contain ifexp helper return sequenc compos result recurs call ifexp if contain iteratorexp contextu oclexp sourc iteratorexp helper return result recurs call iteratorexp els return result iter element iteratorexp if contain iterateexp helper return sequenc iteratorexp addit result element case contextu oclexp sourc iterateexp otherwis helper return empti sequenc default valu context atl oclexpress return sequenc atl variabledeclar helper context atl oclexpress def getupd sequenc atl variabledeclar let contain atl element self immediatecomposit contain oclisundefin sequenc els contain ocliskindof atl oclexpress contain oclistypeof atl rulevariabledeclar sequenc contain rule namedel flatten els contain oclistypeof atl bind sequenc contain outpatternel rule namedel flatten els sequenc endif endif els contain oclistypeof atl letexp sequenc contain variabl contain getupd flatten els contain oclistypeof atl ifexp sequenc contain getupd flatten els contain oclistypeof atl iteratorexp contain sourc self sequenc contain getupd flatten els sequenc contain iter contain getupd flatten endif els contain oclistypeof atl iterateexp contain sourc self sequenc contain getupd flatten els sequenc contain iter contain result contain getupd flatten endif els sequenc endif endif endif endif endif endif this helper comput sequenc contain variabledeclar defin lower contextu oclexpress namespac tree if contextu oclexpress letexp helper return sequenc compos letexp variabl result recurs call refer letexp otherwis contextu oclexpress ifexp helper return sequenc compos result recurs call condit thenexpress elseexpress refer ifexp otherwis contextu oclexpress iteratorexp helper return sequenc compos iteratorexp iter along result recurs call sourc bodi refer iteratorexp otherwis contextu oclexpress iterateexp helper return sequenc return iteratorexp addit result element otherwis helper return empti sequenc default valu context atl oclexpress return sequenc atl variabledeclar helper context atl oclexpress def getdownd sequenc atl variabledeclar self oclistypeof atl letexp sequenc self variabl self getdownd flatten els self oclistypeof atl ifexp sequenc self condit getdownd self thenexpress getdownd self elseexpress getdownd flatten els self oclistypeof atl iteratorexp sequenc self iter self sourc getdownd self bodi getdownd flatten els self oclistypeof atl iterateexp sequenc self iter self result self sourc getdownd self bodi getdownd flatten els sequenc endif endif endif endif this helper return root composit contain contextu oclexpress for purpos helper first comput immedi composit contextu oclexpress if contain undefin helper return oclundefin otherwis kind oclexpress helper return valu provid recurs call comput contain final contain oclexpress root composit reach bind inpattern oper queri attribut return context atl oclexpress return atl element helper context atl oclexpress def getrootcomposit atl element let contain atl element self immediatecomposit contain oclisundefin oclundefin els contain ocliskindof atl oclexpress contain getrootcomposit els contain endif endif rule rule freevariableisselforthismodul this rule generat error problem variabledeclar composit whose name differ self thismodul the variableexp previous declar atl file associ new variabledeclar without composit correspod atl model rule freevariableisselforthismodul atl variabledeclar immediatecomposit oclisundefin varnam self varnam thismodul problem problem sever error locat variableexp isempti locat els variableexp first locat endif descript variabl varnam undefin rule modelnameisuniqu this rule generat error problem exist model name check model rule modelnameisuniqu atl oclmodel thismodul allmodel exist e e name name e problem problem sever error locat locat descript model name alreadi defin rule rulenameisuniqu this rule generat error problem exist rule name check rule rule rulenameisuniqu atl rule thismodul allrul exist e e name name e problem problem sever error locat locat descript rule name alreadi defin rule helpersignatureisuniqu this rule generat error problem exist helper signatur check helper note current implement helper signatur correspond name context helper rule helpersignatureisuniqu atl helper thismodul allhelp exist e e definit featur name e definit featur name definit context oclisundefin e definit context oclisundefin definit context context name oclisundefin e definit context context name oclisundefin definit context context name e definit context context name els fals endif els e definit context context name oclisundefin endif els fals endif els e definit context oclisundefin endif problem problem sever error locat locat descript helper definit featur name alreadi defin rule bindingnameisuniqueinpattern this rule generat error problem exist pattern bind name check bind rule bindingnameisuniqueinpattern atl bind outpatternel bind exist e e propertynam propertynam e problem problem sever error locat locat descript bind propertynam alreadi defin pattern rule patternnameisuniqueinrul this rule generat error problem exist rule name element inpatternel outpatternel rulevariabledeclar name check pattern rule patternnameisuniqueinrul atl patternel rule namedel exist e e varnam varnam e problem problem sever error locat locat descript pattern variabl name varnam alreadi defin rule rule variablenameisuniqueinrul this rule generat error problem exist rule name element inpatternel outpatternel rulevariabledeclar name check rule variabl declar rule variablenameisuniqueinrul atl rulevariabledeclar rule namedel exist e e varnam varnam e problem problem sever error locat locat descript pattern variabl name varnam alreadi defin rule rule nohelperwithcollectionascontext this rule generat error problem helper defin collect type context note problem due limit current implement rule nohelperwithcollectionascontext atl helper definit context oclisundefin fals els thismodul collectiontyp exist e definit context context e endif problem problem sever error locat locat descript helper definit featur name current implement support helper collect context rule noselforthismodulevariabledeclar this rule generat error problem declar variabl name self thismodul atl program consid variabl declar must non undefin immedi composit sinc input atl model may alreadi includ self thismodul vd without immedi composit correspond global declar self thismodul variabl rule noselforthismodulevariabledeclar atl variabledeclar immediatecomposit oclisundefin varnam self varnam thismodul problem problem sever error locat locat descript helper varnam valid variabl name rule noselfvariableinrul this rule generat error problem self variabl express contain rule element rule noselfvariableinrul atl variableexp referredvari varnam self let rcomp atl element getrootcomposit rcomp oclistypeof atl bind rcomp oclistypeof atl inpattern referredvari oclisundefin fals els referredvari varnam self let rcomp atl element getrootcomposit rcomp oclistypeof atl bind rcomp oclistypeof atl inpattern endif problem problem sever error locat locat descript rule referredvari varnam use self variabl prohibit rule rule noresolvetempinsourcepattern this rule generat error problem call thismodul resolvetemp oper within sourc pattern rule rule noresolvetempinsourcepattern atl operationcallexp operationnam resolvetemp sourc oclistypeof atl variableexp sourc referredvari oclisundefin fals els sourc referredvari varnam thismodul endif els fals endif getrootcomposit oclistypeof atl inpattern problem problem sever error locat locat descript rule getrootcomposit rule name use thismodul resolvetemp function prohibit sourc pattern rule noresolvetempinmoduleattribut this rule generat error problem call thismodul resolvetemp oper within model attribut rule noresolvetempinmoduleattribut atl operationcallexp operationnam resolvetemp sourc oclistypeof atl variableexp sourc referredvari oclisundefin fals els sourc referredvari varnam thismodul endif els fals endif getrootcomposit oclistypeof atl attribut problem problem sever error locat locat descript attribut getrootcomposit name use thismodul resolvetemp function prohibit attribut rule prohibitedmultiiteratorcollectionoper this rule generat error problem iteratorexp singleiteratorexp set associ sever iter rule prohibitedmultiiteratorcollectionoper atl iteratorexp thismodul singleiteratorexp exist e name e iter size problem problem sever error locat locat descript iter name may one iter variabl rule unsupportedmultiiteratorcollectionoper this rule generat error problem iteratorexp multiiteratorexp set associ sever iter note problem due limit current implement rule unsupportedmultiiteratorcollectionoper atl iteratorexp thismodul multiiteratorexp exist e name e iter size problem problem sever error locat locat descript current implement iter name may one iter variabl rule parameternameisuniqueinoper this rule generat error problem paramet exist anoth paramet name oper declar rule parameternameisuniqueinoper atl paramet oper paramet exist e varnam e varnam e problem problem sever error locat locat descript paramet name varnam alreadi declar oper rule iteratornameisuniqueinloop this rule generat error problem iter declar exist either anoth iter result variabl declar iter loop name within loop definit rule variablenameisuniqueinloop atl iter loopexpr iter exist e varnam e varnam e loopexpr oclistypeof atl iterateexp loopexpr result varnam varnam els fals endif problem problem sever error locat locat descript variabl name varnam alreadi declar loop rule resultnameisuniqueiniter this rule generat error problem result variabl declar iterateexp exist iter variabl name iter loop definit rule resultnameisuniqueiniter atl variabledeclar baseexp oclisundefin fals els baseexp iter exist e varnam e varnam e endif problem problem sever error locat locat descript variabl name varnam alreadi declar loop rule variablenameisuniqueincontain this rule generat warn problem declar variabl exist anoth variabl declar name namespac except multipl intanc iter name loop handl error problem rule variablenameisuniqueincontain atl variabledeclar getdeclar exist e varnam e varnam e problem problem sever warn locat locat descript variabl name varnam alreadi declar contain,0
76,76,P40-KM32Metrics.atl,"module KM32Metrics;
create OUT : Metrics from IN : KM3;

-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- This helper computes the set of all the Class elements of the input model.
-- CONTEXT:	thisModule
-- RETURN:	Set(KM3!Class)
helper def: allClasses : Set(KM3!Class) = KM3!Class.allInstances();

-- This helper computes the set of all the Reference elements of the input
-- model.
-- CONTEXT:	thisModule
-- RETURN:	Set(KM3!Reference)
helper def: allReferences : Set(KM3!Reference) = KM3!Reference.allInstances();

-- This helper computes the set of all the Class elements of the input model
-- that correspond to the root of the different inheritance trees.
-- CONTEXT:	thisModule
-- RETURN:	Set(KM3!Class)
helper def: inheritanceRoots : Set(KM3!Class) =
	thisModule.allClasses
		->select(e | e.supertypes->isEmpty());

-- This helper returns the number of own attributes of the contextual Class.
-- CONTEXT:	KM3!Class
-- RETURN:	Integer
helper context KM3!Class def: attributeNb : Integer =
	self.structuralFeatures
		->select(e | e.oclIsTypeOf(KM3!Attribute))
		->size();

-- This helper returns the total number of attributes (including inherited
-- ones) of the contextual Class.
-- CONTEXT:	KM3!Class
-- RETURN:	Integer
helper context KM3!Class def: attributeNb2 : Integer =
	self.attributeNb + 
	self.supertypes
		->iterate(e; sum : Integer = 0 |
			sum + e.attributeNb
		);

-- This helper returns the number of own references of the contextual Class.
-- CONTEXT:	KM3!Class
-- RETURN:	Integer
helper context KM3!Class def: referenceNb : Integer =
	self.structuralFeatures
		->select(e | e.oclIsTypeOf(KM3!Reference))
		->size();

-- This helper returns the total number of references (including inherited
-- ones) of the contextual Class.
-- CONTEXT:	KM3!Class
-- RETURN:	Integer
helper context KM3!Class def: referenceNb2 : Integer =
	self.referenceNb + 
	self.supertypes
		->iterate(e; sum : Integer = 0 |
			sum + e.referenceNb
		);

-- This helper returns the size of the maximum lenght of the inheritance trees
-- that lead to the contextual Class.
-- If the class has no supertype, the helper returns 0. Otherwise, it iterates
-- through the set of supertypes of the contextual Class in order to find out
-- the maximum lenght of inheritance trees (from roots to the contextual
-- Class).
-- CONTEXT:	KM3!Class
-- RETURN:	Integer
helper context KM3!Class def: getInheritanceLenght() : Integer =
	if self.supertypes->size() = 0
	then
		0
	else
		self.supertypes->iterate(e; max : Integer = 0 |
			if e.getInheritanceLenght() + 1 > max
			then
				e.getInheritanceLenght() + 1
			else
				max
			endif
		)
	endif;

-- This helper returns the maximal depth of an inheritance tree in the input
-- metamodel. For this purpose, it calls the getInheritanceLenght() helper on
-- each Class of the input model and returns the maximum value.
-- CONTEXT:	thisModule
-- RETURN:	Integer
helper def: getInheritanceMaxDepth() : Integer =
	thisModule.allClasses
		->iterate(e; max : Integer = 0 |
			if e.getInheritanceLenght() > max
			then
				e.getInheritanceLenght()
			else
				max
			endif
		);

-- This helper returns the number of inheritance trees in the input model.
-- For this purpose, it computes the number of ""root"" classes, that is the
-- classes that donot have any supertype.
-- CONTEXT:	thisModule
-- RETURN:	Integer
helper def: getInheritanceTreeNb() : Integer =
	thisModule.inheritanceRoots->size();

-- This helper returns the set of subtypes of its contextual Class.
-- For this purpose, it selects among all existing Class elements, those that
-- have the contextual Class as a supertype.
-- CONTEXT:	KM3!Class
-- RETURN:	Set(KM3!Class)
helper context KM3!Class def: subTypes : Set(KM3!Class) =
	thisModule.allClasses
		->select(e | e.supertypes->includes(self))
		->asSet();

-- This helper computes the inheritance subtree of the contextual Class.
-- For this purpose, the helper recursively calls itself for each subtype of
-- the contextual Class, adding this contextual Class to the computed result.
-- CONTEXT:	KM3!Class
-- RETURN:	Set(KM3!Class)
helper context KM3!Class def: getTree() : Set(KM3!Class) =
	self.subTypes->iterate(e; tree : Set(KM3!Class) = Set{self} |
		tree->union( e.getTree() )
	);

-- This helper computes a boolean value stating whether its exists an (or more)
-- inheritance relation between classes of trees t1 and t2.
-- The helper checks whether such a relation (supertype/subtype) exists between
-- each class of the tree t1 and the classes of the tree t2.
-- Comment sur les asSet()...
-- CONTEXT:	thisModule
-- IN:		Set(KM3!Class), Set(KM3!Class)
-- RETURN:	Boolean
helper def: existsHLink(t1 : Set(KM3!Class), t2 : Set(KM3!Class)) : Boolean =
	t1->iterate(e; res : Boolean = false |
		if (e.supertypes->asSet()->intersection(t2)->isEmpty() and
			e.subTypes->asSet()->intersection(t2)->isEmpty())
		then
			res
		else
			true
		endif
	);

-- This recursive helper computes the number of independant inheritance graphs
-- corresponding to the sequence of inheritance trees passed as a parameter.
-- If the input sequence contains a single tree, the helper returns 1.
-- Otherwise, the helper checks whether there exists inheritance relationships
-- (super/subtype) between classes of the first tree of the input sequence (the
-- reference tree), and the following ones. If so, it merges the linked trees
-- into the reference tree.
-- If the new tree sequence built this way contains a single tree, the helper
-- returns 1. Otherwise, the helper returns 1 + the value provideed by a
-- recursive call of itself on the newly calculated tree sequence without its
-- first reference tree.
-- CONTEXT:	thisModule
-- IN:		Sequence(Set(KM3!Class))
-- RETURN:	Integer
helper def: computeGraphNb(tree_seq : Sequence(Set(KM3!Class))) : Integer =
	if tree_seq->size() = 1
	then
		1
	else
		let first_t : Set(KM3!Class) = tree_seq->first() in
		let new_seq : Sequence(Set(KM3!Class)) =
		tree_seq
			->subSequence(2, tree_seq->size())
			->iterate(e;t_seq : Sequence(Set(KM3!Class)) = Sequence{first_t} |
				if thisModule.existsHLink(first_t, e)
				then
					t_seq
						->subSequence(2, t_seq->size())
						->prepend(t_seq->first()->including(e))
				else
					t_seq.append(e)
				endif
			)
		in
		if new_seq->size() = 1
		then
			1
		else
			thisModule.computeGraphNb(
				new_seq->subSequence(2, new_seq->size())
			) + 1
		endif
	endif;

-- This helper returns the number of inheritage graphs in the input model.
-- For this purpose, it first computes a sequence containing the set of classes
-- representing the different inheritance trees of the input model. The helper
-- then calls the recursive computeGraphNb with the calculated sequence as a 
-- parameter.
-- CONTEXT:	thisModule
-- RETURN:	Integer
helper def: getInheritanceGraphNb() : Integer =
	let tree_seq : Sequence(Set(KM3!Class)) =
		thisModule.inheritanceRoots
			->collect(e | e.getTree())
			->asSequence()
	in thisModule.computeGraphNb(tree_seq);


-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'Model'
-- This rule generates metrics elements that are relative to the input model:
-- * the number of classes of the model;
-- * the number of associations of the model (this number corresponds to the
--   number of references without an opposite, plus the half of the number of
--   references that has an opposite);
-- * the maximal depth of an inheritance tree (computed by the
--   getInheritanceMaxDepth helper);
-- * the number of inheritance trees (computed by the getInheritanceTreeNb
--   helper);
-- * the number of inheritance graphs (computed by the getInheritanceGraphNb
--   helper).
rule Model {
	from
		i : KM3!Metamodel
	to
		o1 : Metrics!IntegerMetric (
			""context"" <- 'Model',
			label <- 'Number of classes',
			data <- thisModule.allClasses->size()
		),
		
		o2 : Metrics!IntegerMetric (
			""context"" <- 'Model',
			label <- 'Number of associations',
			data <-
				(thisModule.allReferences
					->select(e | e.opposite = OclUndefined)
					->size())
				+
				((thisModule.allReferences
					->select(e | e.opposite <> OclUndefined)
					->size()) div 2)
		),
		
		o3 : Metrics!IntegerMetric (
			""context"" <- 'Model',
			label <- 'Maximal depth of heritance',
			data <- thisModule.getInheritanceMaxDepth()
		),
		
		o4 : Metrics!IntegerMetric (
			""context"" <- 'Model',
			label <- 'Number of inheritance trees',
			data <- thisModule.getInheritanceTreeNb()
		),
		
		o5 : Metrics!IntegerMetric (
			""context"" <- 'Model',
			label <- 'Number of inheritance graphs',
			data <- thisModule.getInheritanceGraphNb()
		)
}

-- Rule 'Class'
-- This rule generates metrics elements taht are relative to a Class of the
-- input model. The context of the generated metrics elements therefore
-- includes the name of the class theyr refer to.
-- Generated metrics are:
-- * the number of own attributes of the class;
-- * the number of own references of the class;
-- * the total number of attributes of the class (including inherited ones);
-- * the total number of references of the class (including inherited ones);
rule Class {
	from
		i : KM3!Class
	to
		o1 : Metrics!IntegerMetric (
			""context"" <- 'Class ' + i.name,
			label <- 'Number of own attributes',
			data <- i.attributeNb
		),

		o2 : Metrics!IntegerMetric (
			""context"" <- 'Class ' + i.name,
			label <- 'Number of own references',
			data <- i.referenceNb
		),
		
		o3 : Metrics!IntegerMetric (
			""context"" <- 'Class ' + i.name,
			label <- 'Total number of attributes',
			data <- i.attributeNb2
		),

		o4 : Metrics!IntegerMetric (
			""context"" <- 'Class ' + i.name,
			label <- 'Total number of references',
			data <- i.referenceNb2
		)
}
",modul km metric creat out metric in km helper this helper comput set class element input model context thismodul return set km class helper def allclass set km class km class allinst this helper comput set refer element input model context thismodul return set km refer helper def allrefer set km refer km refer allinst this helper comput set class element input model correspond root differ inherit tree context thismodul return set km class helper def inheritanceroot set km class thismodul allclass select e e supertyp isempti this helper return number attribut contextu class context km class return integ helper context km class def attributenb integ self structuralfeatur select e e oclistypeof km attribut size this helper return total number attribut includ inherit one contextu class context km class return integ helper context km class def attributenb integ self attributenb self supertyp iter e sum integ sum e attributenb this helper return number refer contextu class context km class return integ helper context km class def referencenb integ self structuralfeatur select e e oclistypeof km refer size this helper return total number refer includ inherit one contextu class context km class return integ helper context km class def referencenb integ self referencenb self supertyp iter e sum integ sum e referencenb this helper return size maximum lenght inherit tree lead contextu class if class supertyp helper return otherwis iter set supertyp contextu class order find maximum lenght inherit tree root contextu class context km class return integ helper context km class def getinheritancelenght integ self supertyp size els self supertyp iter e max integ e getinheritancelenght max e getinheritancelenght els max endif endif this helper return maxim depth inherit tree input metamodel for purpos call getinheritancelenght helper class input model return maximum valu context thismodul return integ helper def getinheritancemaxdepth integ thismodul allclass iter e max integ e getinheritancelenght max e getinheritancelenght els max endif this helper return number inherit tree input model for purpos comput number root class class donot supertyp context thismodul return integ helper def getinheritancetreenb integ thismodul inheritanceroot size this helper return set subtyp contextu class for purpos select among exist class element contextu class supertyp context km class return set km class helper context km class def subtyp set km class thismodul allclass select e e supertyp includ self asset this helper comput inherit subtre contextu class for purpos helper recurs call subtyp contextu class ad contextu class comput result context km class return set km class helper context km class def gettre set km class self subtyp iter e tree set km class set self tree union e gettre this helper comput boolean valu state whether exist inherit relat class tree the helper check whether relat supertyp subtyp exist class tree class tree comment sur les asset context thismodul in set km class set km class return boolean helper def existshlink set km class set km class boolean iter e res boolean fals e supertyp asset intersect isempti e subtyp asset intersect isempti res els true endif this recurs helper comput number independ inherit graph correspond sequenc inherit tree pass paramet if input sequenc contain singl tree helper return otherwis helper check whether exist inherit relationship super subtyp class first tree input sequenc refer tree follow one if merg link tree refer tree if new tree sequenc built way contain singl tree helper return otherwis helper return valu provide recurs call newli calcul tree sequenc without first refer tree context thismodul in sequenc set km class return integ helper def computegraphnb tree seq sequenc set km class integ tree seq size els let first set km class tree seq first let new seq sequenc set km class tree seq subsequ tree seq size iter e seq sequenc set km class sequenc first thismodul existshlink first e seq subsequ seq size prepend seq first includ e els seq append e endif new seq size els thismodul computegraphnb new seq subsequ new seq size endif endif this helper return number inheritag graph input model for purpos first comput sequenc contain set class repres differ inherit tree input model the helper call recurs computegraphnb calcul sequenc paramet context thismodul return integ helper def getinheritancegraphnb integ let tree seq sequenc set km class thismodul inheritanceroot collect e e gettre assequ thismodul computegraphnb tree seq rule rule model this rule generat metric element relat input model number class model number associ model number correspond number refer without opposit plus half number refer opposit maxim depth inherit tree comput getinheritancemaxdepth helper number inherit tree comput getinheritancetreenb helper number inherit graph comput getinheritancegraphnb helper rule model km metamodel metric integermetr context model label number class data thismodul allclass size metric integermetr context model label number associ data thismodul allrefer select e e opposit oclundefin size thismodul allrefer select e e opposit oclundefin size div metric integermetr context model label maxim depth herit data thismodul getinheritancemaxdepth metric integermetr context model label number inherit tree data thismodul getinheritancetreenb metric integermetr context model label number inherit graph data thismodul getinheritancegraphnb rule class this rule generat metric element taht relat class input model the context generat metric element therefor includ name class theyr refer generat metric number attribut class number refer class total number attribut class includ inherit one total number refer class includ inherit one rule class km class metric integermetr context class name label number attribut data attributenb metric integermetr context class name label number refer data referencenb metric integermetr context class name label total number attribut data attributenb metric integermetr context class name label total number refer data referencenb,0
77,77,P41-KM32OWL.atl,"-- @atlcompiler atl2006

module KM32OWL; -- Module Template
create OUT : OWL from IN : KM3;

-- =============================================================================
-- KM32OWL
-- Version 1.0
-- Release date : 26/02/2007
-- Author : Guillaume Hillairet (g.hillairet@gmail.com)
-- =============================================================================
	
helper def: addNamespace( s : String ) : String = 'http://example.org/' + s;

helper def: primitiveTypeMap : Map(String, String) =
	Map {
		('String', 'http://www.w3.org/2001/XMLSchema#string'),
		('Integer', 'http://www.w3.org/2001/XMLSchema#nonNegativeInteger'),
		('Boolean', 'http://www.w3.org/2001/XMLSchema#boolean'),
		('UnlimitedNatural', 'http://www.w3.org/2001/XMLSchema#integer' )
	};
	
helper context KM3!Reference def: isSymmetric() : Boolean =
	if self.opposite.oclIsUndefined()
		then false
		else self.type = self.opposite.type
	endif;
			 
helper context KM3!Reference def: isInverseFunctional() : Boolean =
	if self.opposite.oclIsUndefined()
		then false
		else self.opposite.upper = 1 and self.opposite.lower = 1
	endif;

-- =============================================================================
-- RULES
-- =============================================================================

rule Metamodel2Graph {
	from
		m : KM3!Metamodel
	to
		g : OWL!OWLGraph (
			uriRef <- uri,
			ontology <- m.contents
		),
		uri : OWL!URIReference ( uri <- u_r_i ),
		u_r_i : OWL!UniformResourceIdentifier ( name <- '' )
}

rule Package2Ontology {
	from
		p : KM3!Package(
			not (p.name = 'PrimitiveTypes')
		)
	to
		o : OWL!OWLOntology (
			owlGraph <- p.metamodel,
			owlUniverse <- p.contents,
			uriRef <- uri
		),
		u : OWL!OWLUniverse (
			ontology <- p
		),
		uri : OWL!URIReference ( 
			fragmentIdentifier <- l, 
			uri <- u_r_i ),
		l : OWL!LocalName ( name <- p.name ),
		u_r_i : OWL!UniformResourceIdentifier ( name <- thisModule.addNamespace(p.name) )
}

rule PrimitiveType2RDFSDataType {
	from
		dt : KM3!DataType
	to
		d : OWL!RDFSDataType (
			uriRef <- u
		),
		u : OWL!URIReference (
			uri <- uri
		),
		uri : OWL!UniformResourceIdentifier ( name <- thisModule.primitiveTypeMap.get(dt.name) )
}

rule Class2Class {
	from
		c : KM3!Class
	to
		oc : OWL!OWLClass (
			uriRef <- uri,
			label <- label,
			subClassOf <- c.supertypes
		),
		label : OWL!PlainLiteral ( lexicalForm <- c.name ),
		uri : OWL!URIReference ( uri <- u_r_i ),
		u_r_i : OWL!UniformResourceIdentifier ( name <- c.name )
}

abstract rule StructuralFeature2Property {
	from 
		f : KM3!StructuralFeature
	to
		p : OWL!Property (
			domain <- f.owner,
			range <- f.type,
			uriRef <- o_u
		),
		o_u : OWL!URIReference ( fragmentIdentifier <- o_l, uri <- o_uri ),
		o_l : OWL!LocalName ( name <- f.owner.name + '.' + f.name ),
		o_uri : OWL!UniformResourceIdentifier ( name <- f.owner.name + '.' + f.name )
}

rule Attribute2DataTypeProperty extends StructuralFeature2Property {
	from
		f : KM3!Attribute (
			f.type.oclIsTypeOf( KM3!DataType )
		)
	to
		p : OWL!OWLDatatypeProperty ( )
		
	do {
		
		if ( ( f.upper = 1) and ( f.lower = 1) )
			thisModule.FunctionalProperty( f );
		
		if ( f.upper = f.lower )  -- [n-n]
			thisModule.addCardinalityRestriction( f );
		else
			if (( f.upper = 0-1 ) and ( f.lower >= 0 )) -- [*]
				thisModule.addMinCardinalityRestriction( f );
			else  { -- [m-n]
				thisModule.addMinCardinalityRestriction( f );
				thisModule.addMaxCardinalityRestriction( f );
			}
	}
}

rule Reference2ObjectProperty extends StructuralFeature2Property {
	from
		f : KM3!Reference 

	to
		p : OWL!OWLObjectProperty (
			OWLInverseOf <- f.opposite,
			subPropertyOf <- f.subsetOf
		)
	
	do {
		
		if ( f.isSymmetric() )
			thisModule.SymmetricProperty( f );
		
		if ( f.isInverseFunctional() )
			thisModule.InverseFunctionalProperty( f );
		
		if ( ( f.upper = 1) and ( f.lower = 1) )
				thisModule.FunctionalProperty( f );
		
		if ( f.upper = f.lower )  -- [n-n]
				thisModule.addCardinalityRestriction( f );
			else
				if (( f.upper = 0-1 ) and ( f.lower >= 0 )) -- [*]
					thisModule.addMinCardinalityRestriction( f );
				else  {-- [m-n]
					thisModule.addMinCardinalityRestriction( f );
					thisModule.addMaxCardinalityRestriction( f );
				}
	}
}

rule EnumerationProperty2ObjectProperty {
	from
		a : KM3!Attribute
		(
			a.type.oclIsTypeOf(KM3!Enumeration)
		)
	to
		d : OWL!OWLObjectProperty (
			uriRef <- u,
			domain <- a.owner,
			range <- a.type
		),
		u : OWL!URIReference ( fragmentIdentifier <- l, uri <- uri ),
		l : OWL!LocalName ( name <- a.owner.name + '.' + a.name ),
		uri : OWL!UniformResourceIdentifier ( name <- a.owner.name + '.' + a.name )
		
	do {
		
		if ( ( a.upper = 1) and ( a.lower = 1) )
				thisModule.FunctionalProperty( a );
		
		if ( a.upper = a.lower )  -- [n-n]
				thisModule.addCardinalityRestriction( a );
			else
				if (( a.upper = 0-1 ) and ( a.lower >= 0 )) -- [*]
					thisModule.addMinCardinalityRestriction( a );
				else  {-- [m-n]
					thisModule.addMinCardinalityRestriction( a );
					thisModule.addMaxCardinalityRestriction( a );
				}	
	}
}

lazy rule FunctionalProperty {
	from	
		r : KM3!Reference
	to
		o : OWL!FunctionalProperty (
				isDefinedBy <- r
		)
}

lazy rule InverseFunctionalProperty {
	from	
		r : KM3!Reference
	to
		o : OWL!InverseFunctionalProperty (
				isDefinedBy <- r
		)
}

lazy rule SymmetricProperty {
	from	
		r : KM3!Reference
	to
		o : OWL!SymmetricProperty (
				isDefinedBy <- r
		)
}

rule addCardinalityRestriction( s : KM3!StructuralFeature ) {
	to
		c : OWL!CardinalityRestriction (
			superClass <- s.owner,
			OWLCardinality <- literal,
			OWLOnProperty <- s
		),
		literal : OWL!TypedLiteral (
			lexicalForm <- s.upper.toString(),
			datatypeURI <- u
		),
		u : OWL!URIReference (
			uri <- uri
		),
		uri : OWL!UniformResourceIdentifier ( name <- thisModule.primitiveTypeMap.get('Integer') )
}

rule addMaxCardinalityRestriction( s : KM3!StructuralFeature ) {
	to
		c : OWL!MaxCardinalityRestriction (
			superClass <- s.owner,
			OWLMaxCardinality <- literal,
			OWLOnProperty <- s
		),
		literal : OWL!TypedLiteral (
			lexicalForm <- s.upper.toString(),
			datatypeURI <- u
		),
		u : OWL!URIReference (
			uri <- uri
		),
		uri : OWL!UniformResourceIdentifier ( name <- thisModule.primitiveTypeMap.get('Integer') )
}

rule addMinCardinalityRestriction( s : KM3!StructuralFeature ) {
	to
		c : OWL!MinCardinalityRestriction (
			superClass <- s.owner,
			OWLMinCardinality <- literal,
			OWLOnProperty <- s
		),
		literal : OWL!TypedLiteral (
			lexicalForm <- s.lower.toString(),
			datatypeURI <- u
		),
		u : OWL!URIReference (
			uri <- uri
		),
		uri : OWL!UniformResourceIdentifier ( name <- thisModule.primitiveTypeMap.get('Integer') )
}

rule Enumeration2EnumeratedClass {
	from
		e : KM3!Enumeration
	to
		oe : OWL!EnumeratedClass (
			OWLOneOf <- e.literals,
			uriRef <- u,
			label <- label
		),
		label : OWL!PlainLiteral ( lexicalForm <- e.name 	),
		u : OWL!URIReference (	fragmentIdentifier <- l, uri <- uri ),
		l : OWL!LocalName ( name <- e.name ),
		uri : OWL!UniformResourceIdentifier ( name <- e.name )
}

rule EnumLiteral2Individual {
	from
		e : KM3!EnumLiteral
	to
		oe : OWL!Individual (
			uriRef <- u
		),
		u : OWL!URIReference ( fragmentIdentifier <- l, uri <- uri ),
		l : OWL!LocalName ( name <- e.name ),
		uri : OWL!UniformResourceIdentifier ( name <- e.name )
}
",atlcompil atl modul km owl modul templat creat out owl in km km owl version releas date author guillaum hillairet g hillairet gmail com helper def addnamespac string string http exampl org helper def primitivetypemap map string string map string http www w org xmlschema string integ http www w org xmlschema nonnegativeinteg boolean http www w org xmlschema boolean unlimitednatur http www w org xmlschema integ helper context km refer def issymmetr boolean self opposit oclisundefin fals els self type self opposit type endif helper context km refer def isinversefunct boolean self opposit oclisundefin fals els self opposit upper self opposit lower endif rule rule metamodel graph km metamodel g owl owlgraph uriref uri ontolog content uri owl urirefer uri u r u r owl uniformresourceidentifi name rule packag ontolog p km packag p name primitivetyp owl owlontolog owlgraph p metamodel owlunivers p content uriref uri u owl owlunivers ontolog p uri owl urirefer fragmentidentifi l uri u r l owl localnam name p name u r owl uniformresourceidentifi name thismodul addnamespac p name rule primitivetyp rdfsdatatyp dt km datatyp owl rdfsdatatyp uriref u u owl urirefer uri uri uri owl uniformresourceidentifi name thismodul primitivetypemap get dt name rule class class c km class oc owl owlclass uriref uri label label subclassof c supertyp label owl plainliter lexicalform c name uri owl urirefer uri u r u r owl uniformresourceidentifi name c name abstract rule structuralfeatur properti f km structuralfeatur p owl properti domain f owner rang f type uriref u u owl urirefer fragmentidentifi l uri uri l owl localnam name f owner name f name uri owl uniformresourceidentifi name f owner name f name rule attribut datatypeproperti extend structuralfeatur properti f km attribut f type oclistypeof km datatyp p owl owldatatypeproperti f upper f lower thismodul functionalproperti f f upper f lower n n thismodul addcardinalityrestrict f els f upper f lower thismodul addmincardinalityrestrict f els n thismodul addmincardinalityrestrict f thismodul addmaxcardinalityrestrict f rule refer objectproperti extend structuralfeatur properti f km refer p owl owlobjectproperti owlinverseof f opposit subpropertyof f subsetof f issymmetr thismodul symmetricproperti f f isinversefunct thismodul inversefunctionalproperti f f upper f lower thismodul functionalproperti f f upper f lower n n thismodul addcardinalityrestrict f els f upper f lower thismodul addmincardinalityrestrict f els n thismodul addmincardinalityrestrict f thismodul addmaxcardinalityrestrict f rule enumerationproperti objectproperti km attribut type oclistypeof km enumer owl owlobjectproperti uriref u domain owner rang type u owl urirefer fragmentidentifi l uri uri l owl localnam name owner name name uri owl uniformresourceidentifi name owner name name upper lower thismodul functionalproperti upper lower n n thismodul addcardinalityrestrict els upper lower thismodul addmincardinalityrestrict els n thismodul addmincardinalityrestrict thismodul addmaxcardinalityrestrict lazi rule functionalproperti r km refer owl functionalproperti isdefinedbi r lazi rule inversefunctionalproperti r km refer owl inversefunctionalproperti isdefinedbi r lazi rule symmetricproperti r km refer owl symmetricproperti isdefinedbi r rule addcardinalityrestrict km structuralfeatur c owl cardinalityrestrict superclass owner owlcardin liter owlonproperti liter owl typedliter lexicalform upper tostr datatypeuri u u owl urirefer uri uri uri owl uniformresourceidentifi name thismodul primitivetypemap get integ rule addmaxcardinalityrestrict km structuralfeatur c owl maxcardinalityrestrict superclass owner owlmaxcardin liter owlonproperti liter owl typedliter lexicalform upper tostr datatypeuri u u owl urirefer uri uri uri owl uniformresourceidentifi name thismodul primitivetypemap get integ rule addmincardinalityrestrict km structuralfeatur c owl mincardinalityrestrict superclass owner owlmincardin liter owlonproperti liter owl typedliter lexicalform lower tostr datatypeuri u u owl urirefer uri uri uri owl uniformresourceidentifi name thismodul primitivetypemap get integ rule enumer enumeratedclass e km enumer oe owl enumeratedclass owloneof e liter uriref u label label label owl plainliter lexicalform e name u owl urirefer fragmentidentifi l uri uri l owl localnam name e name uri owl uniformresourceidentifi name e name rule enumliter individu e km enumliter oe owl individu uriref u u owl urirefer fragmentidentifi l uri uri l owl localnam name e name uri owl uniformresourceidentifi name e name,7
78,78,P41-OWL2XML.atl,"-- @atlcompiler atl2006

module OWL2XML; -- Module Template
create OUT : XML from IN : OWL;

-- =============================================================================
-- OWL2XML
-- Version 1.1
-- Release date : 26/02/2007
-- Author : Guillaume Hillairet (g.hillairet@gmail.com)
-- =============================================================================
	
helper context OWL!RDFSResource def: getURI() : String =
	let r : OWL!UniformResourceIdentifier = 
		self.uriRef->any( e | e.oclIsKindOf(OWL!URIReference)).uri
	in if not r.oclIsUndefined() then r.name else '' endif;

helper context OWL!RDFSResource def: getLabel() : String =
	let r : OWL!PlainLiteral =
		self.label->select( e | e.oclIsTypeOf( OWL!PlainLiteral ))->first()
	in if r.oclIsUndefined() then '' else r.lexicalForm endif	;

helper context OWL!CardinalityRestriction def: getDatatypeURI() : String = 
	let d : OWL!URIReference = self.OWLCardinality.datatypeURI
	in if not d.oclIsUndefined()
		then d.uri.name
		else ''
	endif;

helper context OWL!MaxCardinalityRestriction def: getDatatypeURI() : String = 
	let d : OWL!URIReference = self.OWLMaxCardinality.datatypeURI
	in if not d.oclIsUndefined()
		then d.uri.name
		else ''
	endif;

helper context OWL!MinCardinalityRestriction def: getDatatypeURI() : String = 
	let d : OWL!URIReference = self.OWLMinCardinality.datatypeURI
	in if not d.oclIsUndefined()
		then d.uri.name
		else ''
	endif;

-- =============================================================================
-- RULES
-- =============================================================================
	
rule Graph2Root {
	from
		g : OWL!OWLGraph
		
	to
		r : XML!Root (
			name <- 'rdf:RDF',
			children <- Sequence {
				att1, att2, att3, att4, att5, att6,
				g.ontology
			}
		),
		att1 : XML!Attribute (name <- 'xmlns:rdf',	value <- 'http://www.w3.org/1999/02/22-rdf-syntax-ns#'),
		att2 : XML!Attribute (name <- 'xmlns:rdfs', value <- 'http://www.w3.org/2000/01/rdf-schema#'),
		att3 : XML!Attribute (name <- 'xmlns:xsd',	value <- 'http://www.w3.org/2001/XMLSchema#'),
		att4 : XML!Attribute (name <- 'xmlns:owl',	value <- 'http://www.w3.org/2002/07/owl#'),
		att5 : XML!Attribute (name <- 'xmlns', value <- g.ontology->first().getURI() + '#'),
		att6 : XML!Attribute (name <- 'xml:base', value <- g.ontology->first().getURI())		
}

rule Ontology2Element {
	from
		o : OWL!OWLOntology
	to
		e : XML!Element ( name <- 'owl:Ontology', children <- about ),
		about : XML!Attribute ( name <- 'rdf:about', 
			value <- o.uriRef->collect( e | e.fragmentIdentifier.name )->flatten()->first() 
		)	
	do {
		for ( i in o.OWLImports ) {
			thisModule.addImports( o, i );
		}
	}
}

rule addImports( o : OWL!OWLOntology, i : OWL!OWLOntology ) {
	to
		imports : XML!Element ( parent <- o, name <- 'owl:imports', children <- imports_att ),
		imports_att : XML!Attribute ( name <- 'rdf:resource', value <- '#' + i.getURI() )
}

rule Class2Element{
	from
		c : OWL!OWLClass (
			c.oclIsTypeOf(OWL!OWLClass)
		)
	to
		e : XML!Element (
			name <- 'owl:Class',
			children <- Sequence{ID,label},
			parent <- OWL!OWLGraph.allInstances()->any( e | e.oclIsTypeOf(OWL!OWLGraph))
		),
		ID : XML!Attribute ( name <- 'rdf:ID', value <- c.getURI() ),
		label : XML!Element ( name <- 'rdfs:label', children <- label_text ),
		label_text : XML!Text ( name <- '#text', value <- c.getLabel() )
		
		do {
			 for (s in c.subClassOf ) {
		 		if (s.oclIsTypeOf(OWL!OWLClass))
					thisModule.makeSubClass(c,s);
		 		
		 		if (s.oclIsTypeOf(OWL!UnionClass))
					thisModule.makeSubClass(c,s);
		 		
				if (s.oclIsTypeOf(OWL!CardinalityRestriction))
					thisModule.makeCardinalityRestrictionSubClass(c,s);
				
				if (s.oclIsTypeOf(OWL!MaxCardinalityRestriction))
					thisModule.makeMaxCardinalityRestrictionSubClass(c,s);
				
				if (s.oclIsTypeOf(OWL!MinCardinalityRestriction))
					thisModule.makeMinCardinalityRestrictionSubClass(c,s);
			 }
		}
}

rule UnionClass2Element{
	from
		c : OWL!UnionClass (
			c.oclIsTypeOf(OWL!UnionClass)
		)
	to
		e : XML!Element (
			name <- 'owl:Class',
			children <- Sequence{ID,label,unionOf},
			parent <- OWL!OWLGraph.allInstances()->any( e | e.oclIsTypeOf(OWL!OWLGraph))
		),
		ID : XML!Attribute ( name <- 'rdf:ID', value <- c.getURI() ),
		label : XML!Element ( name <- 'rdfs:label', children <- label_text ),
		label_text : XML!Text ( name <- '#text', value <- c.getLabel() ),
		unionOf : XML!Element (
			name <- 'owl:unionOf',
			children <- Sequence{unionOf_att, c.OWLUnionOf->collect( e | 
				thisModule.makeUnionOf(e) ) 
			}
		),
		unionOf_att : XML!Attribute (
			name <- 'rdf:parseType',
			value <- 'Collection'
		)
		
		do {
			 for (s in c.subClassOf ) {
		 		if (s.oclIsKindOf(OWL!OWLClass))
					thisModule.makeSubClass(c,s);
				
				if (s.oclIsTypeOf(OWL!CardinalityRestriction))
					thisModule.makeCardinalityRestrictionSubClass(c,s);
				
				if (s.oclIsTypeOf(OWL!MaxCardinalityRestriction))
					thisModule.makeMaxCardinalityRestrictionSubClass(c,s);
				
				if (s.oclIsTypeOf(OWL!MinCardinalityRestriction))
					thisModule.makeMinCardinalityRestrictionSubClass(c,s);
			 }
		}
}

lazy rule makeUnionOf {
	from
		u : OWL!OWLClass
	to
		e : XML!Element ( name <- 'owl:Class', children <- Sequence{ e_att } ),
		e_att : XML!Attribute ( name <- 'rdf:about', value <- '#' + u.getURI() )
}

rule makeSubClass( c : OWL!OWLClass,  s : OWL!OWLClass ) {
	to
		e : XML!Element (
			name <- 'rdfs:subClassOf',
			children <-  subClassAttr,
			parent <- c
		),
		subClassAttr : XML!Attribute ( name <- 'rdf:resource', value <- '#' + s.getURI() )
}

rule makeCardinalityRestrictionSubClass( c : OWL!OWLClass,  s : OWL!CardinalityRestriction ) {
	to
		x : XML!Element (
			name <- 'rdfs:subClassOf',
			children <-  e,
			parent <- c
		),
		e : XML!Element ( name <- 'owl:Restriction', children <- Sequence{on, card} ),
		on : XML!Element (	name <- 'owl:onProperty', children <- on_attr ),
		on_attr : XML!Attribute ( name <- 'rdf:resource', value <- '#' + s.OWLOnProperty.getURI() ),
		card : XML!Element ( name <- 'owl:cardinality ', children <- Sequence{card_attr, card_text}	),
		card_attr : XML!Attribute (	name <- 'rdf:datatype', value <- s.getDatatypeURI()	),
		card_text : XML!Text ( name <- '#text',	value <- s.OWLCardinality.lexicalForm )
}

rule makeMaxCardinalityRestrictionSubClass( c : OWL!OWLClass,  s : OWL!MaxCardinalityRestriction ) {
	to
		x : XML!Element (
			name <- 'rdfs:subClassOf',
			children <-  e,
			parent <- c
		),
		e : XML!Element ( name <- 'owl:Restriction', children <- Sequence{on, card} ),
		on : XML!Element (	name <- 'owl:onProperty', children <- on_attr ),
		on_attr : XML!Attribute ( name <- 'rdf:resource', value <- '#' + s.OWLOnProperty.getURI() ),
		card : XML!Element ( name <- 'owl:maxCardinality ',	children <- Sequence{card_attr, card_text} ),
		card_attr : XML!Attribute (	name <- 'rdf:datatype', value <- s.getDatatypeURI()	),
		card_text : XML!Text ( name <- '#text',	value <- s.OWLMaxCardinality.lexicalForm )
}

rule makeMinCardinalityRestrictionSubClass( c : OWL!OWLClass,  s : OWL!MinCardinalityRestriction ) {
	to
		x : XML!Element (
			name <- 'rdfs:subClassOf',
			children <-  e,
			parent <- c
		),
		e : XML!Element (
			name <- 'owl:Restriction',
			children <- Sequence{on, card}
		),
		on : XML!Element (	name <- 'owl:onProperty', children <- on_attr ),
		on_attr : XML!Attribute ( name <- 'rdf:resource', value <- '#' + s.OWLOnProperty.getURI() ),
		card : XML!Element ( name <- 'owl:minCardinality ',	children <- Sequence{card_attr, card_text} ),
		card_attr : XML!Attribute (	name <- 'rdf:datatype', value <- s.getDatatypeURI()	),
		card_text : XML!Text ( name <- '#text',	value <- s.OWLMinCardinality.lexicalForm )
}

rule DatatypeProperty2Element {
	from
		d : OWL!OWLDatatypeProperty
	to
		e : XML!Element (
			name <- 'owl:DatatypeProperty',
			children <- Sequence{ID,domain,range},
			parent <- OWL!OWLGraph.allInstances()->any( e | e.oclIsTypeOf(OWL!OWLGraph))
		),
		ID : XML!Attribute (
			name <- 'rdf:ID',
			value <- d.getURI()
		),
		domain : XML!Element (
			name <- 'rdfs:domain',
			children <- domain_attr
		),
		domain_attr : XML!Attribute (
			name <- 'rdf:resource',
			value <- '#' + d.domain->any( c | c.oclIsKindOf(OWL!OWLClass)).getURI()
		),
		range : XML!Element (
			name <- 'rdfs:range',
			children <- range_attr
		),
		range_attr : XML!Attribute (
			name <- 'rdf:resource',
			value <-  d.range->any(c | c.oclIsKindOf(OWL!RDFSDataType)).getURI()
		)
}

rule ObjectProperty2Element {
	from
		o : OWL!OWLObjectProperty ( 
			o.oclIsTypeOf(OWL!OWLObjectProperty) 
		)
	to
		e : XML!Element (
			name <- 'owl:ObjectProperty',
			children <- Sequence{ID, domain, range},
			parent <- OWL!OWLGraph.allInstances()->any( e | e.oclIsTypeOf(OWL!OWLGraph))
		),
		ID : XML!Attribute (
			name <- 'rdf:ID',
			value <- o.getURI()
		),
		domain : XML!Element (
			name <- 'rdfs:domain',
			children <- domain_attr
		),
		domain_attr : XML!Attribute (
			name <-  'rdf:resource',
			value <- '#' + o.domain->any( c | c.oclIsKindOf(OWL!OWLClass)).getURI()
		),
		range : XML!Element (
			name <- 'rdfs:range',
			children <- range_attr
		),
		range_attr : XML!Attribute (
			name <- 'rdf:resource',
			value <- '#' + o.range->any( c | c.oclIsKindOf(OWL!OWLClass)).getURI()
		)
		
		do {
			if (not o.OWLInverseOf.oclIsUndefined())
				thisModule.addInverse(o);
			
			for (s in o.subPropertyOf ) {
		 		if (s.oclIsKindOf(OWL!OWLObjectProperty))
					thisModule.makeSubProperty(o,s);
			}
		}
}

rule makeSubProperty( c : OWL!OWLObjectProperty,  s : OWL!OWLObjectProperty ) {
	to
		e : XML!Element (
			name <- 'rdfs:subPropertyOf',
			children <-  subPropertyAttr,
			parent <- c
		),
		subPropertyAttr : XML!Attribute ( name <- 'rdf:resource', value <- '#' + s.getURI() )
}

rule addInverse( o : OWL!OWLObjectProperty ) {
	to
		e : XML!Element (
			name <- 'owl:inverseOf',
			children <- e_attr,
			parent <- o
		),
		e_attr : XML!Attribute (
			name <- 'rdf:resource',
			value <- '#' + o.OWLInverseOf.getURI()
		)
}

rule SymmetricProperty2Element {
	from
		o : OWL!SymmetricProperty ( 
			o.isDefinedBy.oclIsUndefined() and
			o.oclIsTypeOf(OWL!SymmetricProperty) 
		)
	to
		e : XML!Element (
			name <- 'owl:SymmetricProperty',
			children <- Sequence{ID, domain, range},
			parent <- OWL!OWLGraph.allInstances()->any( e | e.oclIsTypeOf(OWL!OWLGraph))
		),
		ID : XML!Attribute (
			name <- 'rdf:ID',
			value <- o.getURI()
		),
		domain : XML!Element (
			name <- 'rdfs:domain',
			children <- domain_attr
		),
		domain_attr : XML!Attribute (
			name <-  'rdf:resource',
			value <- '#' + o.domain->any( c | c.oclIsKindOf(OWL!OWLClass)).getURI()
		),
		range : XML!Element (
			name <- 'rdfs:range',
			children <- range_attr
		),
		range_attr : XML!Attribute (
			name <- 'rdf:resource',
			value <- '#' + o.range->any( c | c.oclIsKindOf(OWL!OWLClass)).getURI()
		)
		
		do {
			if (not o.OWLInverseOf.oclIsUndefined())
				thisModule.addInverse(o);
			
			for (s in o.subPropertyOf ) {
		 		if (s.oclIsKindOf(OWL!OWLObjectProperty))
					thisModule.makeSubProperty(o,s);
			}
		}
}

rule InverseFunctionalProperty2Element {
	from
		o : OWL!InverseFunctionalProperty ( 
			o.isDefinedBy.oclIsUndefined() and
			o.oclIsTypeOf(OWL!InverseFunctionalProperty) 
		)
	to
		e : XML!Element (
			name <- 'owl:InverseFunctionalProperty',
			children <- Sequence{ID, domain, range},
			parent <- OWL!OWLGraph.allInstances()->any( e | e.oclIsTypeOf(OWL!OWLGraph))
		),
		ID : XML!Attribute (
			name <- 'rdf:ID',
			value <- o.getURI()
		),
		domain : XML!Element (
			name <- 'rdfs:domain',
			children <- domain_attr
		),
		domain_attr : XML!Attribute (
			name <-  'rdf:resource',
			value <- '#' + o.domain->any( c | c.oclIsKindOf(OWL!OWLClass)).getURI()
		),
		range : XML!Element (
			name <- 'rdfs:range',
			children <- range_attr
		),
		range_attr : XML!Attribute (
			name <- 'rdf:resource',
			value <- '#' + o.range->any( c | c.oclIsKindOf(OWL!OWLClass)).getURI()
		)
		
		do {
			if (not o.OWLInverseOf.oclIsUndefined())
				thisModule.addInverse(o);
			
			for (s in o.subPropertyOf ) {
		 		if (s.oclIsKindOf(OWL!OWLObjectProperty))
					thisModule.makeSubProperty(o,s);
			}
		}
}

rule FunctionalProperty {
	from
		o : OWL!FunctionalProperty (
			o.oclIsTypeOf( OWL!FunctionalProperty )
		)
	to
		e : XML!Element (
			name <- 'owl:FunctionalProperty',
			children <- a,
			parent <- OWL!OWLGraph.allInstances()->any( e | e.oclIsTypeOf(OWL!OWLGraph))
		),
		a : XML!Attribute (
			name <- 'rdf:about',
			value <- '#' + o.isDefinedBy->asSequence()->any( e | e.oclIsKindOf(OWL!Property ) ).getURI()
		)
}

rule InverseFunctionalProperty {
	from
		o : OWL!InverseFunctionalProperty (
			not o.isDefinedBy.oclIsUndefined() and
			o.oclIsTypeOf( OWL!FunctionalProperty )
		)
	to
		e : XML!Element (
			name <- 'owl:InverseFunctionalProperty',
			children <- a,
			parent <- OWL!OWLGraph.allInstances()->any( e | e.oclIsTypeOf(OWL!OWLGraph))
		),
		a : XML!Attribute (
			name <- 'rdf:about',
			value <- '#' + o.isDefinedBy->asSequence()->any( e | e.oclIsKindOf(OWL!Property ) ).getURI()
		)
}

rule SymmetricProperty {
	from
		o : OWL!SymmetricProperty (
			not o.isDefinedBy.oclIsUndefined() and
			o.oclIsTypeOf( OWL!SymmetricProperty )
		)
	to
		e : XML!Element (
			name <- 'owl:SymmetricProperty',
			children <- a,
			parent <- OWL!OWLGraph.allInstances()->any( e | e.oclIsTypeOf(OWL!OWLGraph))
		),
		a : XML!Attribute (
			name <- 'rdf:about',
			value <- '#' + o.isDefinedBy->asSequence()->any( e | e.oclIsKindOf(OWL!Property ) ).getURI()
		)
}

rule EnumeratedClass2Element {
	from
		ec : OWL!EnumeratedClass (
			ec.oclIsTypeOf( OWL!EnumeratedClass )
		)
	to
		e : XML!Element (
			name <- 'owl:Class',
			children <- Sequence{ID,label,oneOf},
			parent <- OWL!OWLGraph.allInstances()->any( e | e.oclIsTypeOf(OWL!OWLGraph))
		),
		ID : XML!Attribute (
			name <- 'rdf:ID',
			value <- ec.getURI()
		),
		label : XML!Element (
			name <- 'rdfs:label',
			children <- label_text
		),
		label_text : XML!Text (
			name <- '#text',
			value <- ec.getLabel()
		),
		oneOf : XML!Element (
			name <- 'owl:oneOf',
			children <- Sequence{ oneOf_Att, ec.OWLOneOf->collect( e | 
				thisModule.IndividualLiteral2Element( e ) )
			}
		),
		oneOf_Att : XML!Attribute (
			name <- 'rdf:parseType',
			value <- 'Collection'
		)
	
}

lazy rule IndividualLiteral2Element {
	from
		i : OWL!Individual
	to
		e : XML!Element (
			name <- 'owl:Thing',
			children <- e_att
		),
		e_att : XML!Attribute (
			name <- 'rdf:about',
			value <- i.getURI()
		)
}

rule Individual2Element {
	from
		i : OWL!Individual (
			i.type->any( c | c.oclIsKindOf(OWL!OWLClass)).oclIsTypeOf(OWL!OWLClass)
		)
	to
		e : XML!Element (
			name  <- i.type->any( c | c.oclIsKindOf(OWL!OWLClass)).getURI(),
			children <- Sequence{ e_att },
			parent <- OWL!OWLGraph.allInstances()->any( e | e.oclIsTypeOf(OWL!OWLGraph))
		),
		e_att : XML!Attribute (
			name <- 'rdf:ID',
			value <- i.getURI()
		)
}

rule StatementPredicateOfDatatype2Element {
	from
		s : OWL!OWLStatement (
			s.RDFpredicate.oclIsTypeOf(OWL!OWLDatatypeProperty)
		)
	to
		p : XML!Element (
			parent <- s.RDFsubject,
			name <- s.RDFpredicate.getURI(),
			children <- Sequence{ p_att, p_text }
		),
		p_att : XML!Attribute (
			name <- 'rdf:datatype',
			value <- s.RDFpredicate.range->any(c | c.oclIsKindOf(OWL!RDFSDataType)).getURI()
		),
		p_text : XML!Text (
			name <- '#text',
			value <- s.RDFobject.getURI()
		)	
}

rule StatementPredicateOfObjectProperty2Element {
	from
		s : OWL!OWLStatement (
			s.RDFpredicate.oclIsKindOf(OWL!OWLObjectProperty)
		)
	to
		p : XML!Element (
			parent <- s.RDFsubject,
			name <- s.RDFpredicate.getURI(),
			children <- Sequence{ p_att }
		),
		p_att : XML!Attribute (
			name <- 'rdf:resource',
			value <- '#' + s.RDFobject.getURI()
		)
}
",atlcompil atl modul owl xml modul templat creat out xml in owl owl xml version releas date author guillaum hillairet g hillairet gmail com helper context owl rdfsresourc def geturi string let r owl uniformresourceidentifi self uriref e e ocliskindof owl urirefer uri r oclisundefin r name els endif helper context owl rdfsresourc def getlabel string let r owl plainliter self label select e e oclistypeof owl plainliter first r oclisundefin els r lexicalform endif helper context owl cardinalityrestrict def getdatatypeuri string let owl urirefer self owlcardin datatypeuri oclisundefin uri name els endif helper context owl maxcardinalityrestrict def getdatatypeuri string let owl urirefer self owlmaxcardin datatypeuri oclisundefin uri name els endif helper context owl mincardinalityrestrict def getdatatypeuri string let owl urirefer self owlmincardin datatypeuri oclisundefin uri name els endif rule rule graph root g owl owlgraph r xml root name rdf rdf children sequenc att att att att att att g ontolog att xml attribut name xmlns rdf valu http www w org rdf syntax ns att xml attribut name xmlns rdfs valu http www w org rdf schema att xml attribut name xmlns xsd valu http www w org xmlschema att xml attribut name xmlns owl valu http www w org owl att xml attribut name xmlns valu g ontolog first geturi att xml attribut name xml base valu g ontolog first geturi rule ontolog element owl owlontolog e xml element name owl ontolog children xml attribut name rdf valu uriref collect e e fragmentidentifi name flatten first owlimport thismodul addimport rule addimport owl owlontolog owl owlontolog import xml element parent name owl import children import att import att xml attribut name rdf resourc valu geturi rule class element c owl owlclass c oclistypeof owl owlclass e xml element name owl class children sequenc id label parent owl owlgraph allinst e e oclistypeof owl owlgraph id xml attribut name rdf id valu c geturi label xml element name rdfs label children label text label text xml text name text valu c getlabel c subclassof oclistypeof owl owlclass thismodul makesubclass c oclistypeof owl unionclass thismodul makesubclass c oclistypeof owl cardinalityrestrict thismodul makecardinalityrestrictionsubclass c oclistypeof owl maxcardinalityrestrict thismodul makemaxcardinalityrestrictionsubclass c oclistypeof owl mincardinalityrestrict thismodul makemincardinalityrestrictionsubclass c rule unionclass element c owl unionclass c oclistypeof owl unionclass e xml element name owl class children sequenc id label unionof parent owl owlgraph allinst e e oclistypeof owl owlgraph id xml attribut name rdf id valu c geturi label xml element name rdfs label children label text label text xml text name text valu c getlabel unionof xml element name owl unionof children sequenc unionof att c owlunionof collect e thismodul makeunionof e unionof att xml attribut name rdf parsetyp valu collect c subclassof ocliskindof owl owlclass thismodul makesubclass c oclistypeof owl cardinalityrestrict thismodul makecardinalityrestrictionsubclass c oclistypeof owl maxcardinalityrestrict thismodul makemaxcardinalityrestrictionsubclass c oclistypeof owl mincardinalityrestrict thismodul makemincardinalityrestrictionsubclass c lazi rule makeunionof u owl owlclass e xml element name owl class children sequenc e att e att xml attribut name rdf valu u geturi rule makesubclass c owl owlclass owl owlclass e xml element name rdfs subclassof children subclassattr parent c subclassattr xml attribut name rdf resourc valu geturi rule makecardinalityrestrictionsubclass c owl owlclass owl cardinalityrestrict x xml element name rdfs subclassof children e parent c e xml element name owl restrict children sequenc card xml element name owl onproperti children attr attr xml attribut name rdf resourc valu owlonproperti geturi card xml element name owl cardin children sequenc card attr card text card attr xml attribut name rdf datatyp valu getdatatypeuri card text xml text name text valu owlcardin lexicalform rule makemaxcardinalityrestrictionsubclass c owl owlclass owl maxcardinalityrestrict x xml element name rdfs subclassof children e parent c e xml element name owl restrict children sequenc card xml element name owl onproperti children attr attr xml attribut name rdf resourc valu owlonproperti geturi card xml element name owl maxcardin children sequenc card attr card text card attr xml attribut name rdf datatyp valu getdatatypeuri card text xml text name text valu owlmaxcardin lexicalform rule makemincardinalityrestrictionsubclass c owl owlclass owl mincardinalityrestrict x xml element name rdfs subclassof children e parent c e xml element name owl restrict children sequenc card xml element name owl onproperti children attr attr xml attribut name rdf resourc valu owlonproperti geturi card xml element name owl mincardin children sequenc card attr card text card attr xml attribut name rdf datatyp valu getdatatypeuri card text xml text name text valu owlmincardin lexicalform rule datatypeproperti element owl owldatatypeproperti e xml element name owl datatypeproperti children sequenc id domain rang parent owl owlgraph allinst e e oclistypeof owl owlgraph id xml attribut name rdf id valu geturi domain xml element name rdfs domain children domain attr domain attr xml attribut name rdf resourc valu domain c c ocliskindof owl owlclass geturi rang xml element name rdfs rang children rang attr rang attr xml attribut name rdf resourc valu rang c c ocliskindof owl rdfsdatatyp geturi rule objectproperti element owl owlobjectproperti oclistypeof owl owlobjectproperti e xml element name owl objectproperti children sequenc id domain rang parent owl owlgraph allinst e e oclistypeof owl owlgraph id xml attribut name rdf id valu geturi domain xml element name rdfs domain children domain attr domain attr xml attribut name rdf resourc valu domain c c ocliskindof owl owlclass geturi rang xml element name rdfs rang children rang attr rang attr xml attribut name rdf resourc valu rang c c ocliskindof owl owlclass geturi owlinverseof oclisundefin thismodul addinvers subpropertyof ocliskindof owl owlobjectproperti thismodul makesubproperti rule makesubproperti c owl owlobjectproperti owl owlobjectproperti e xml element name rdfs subpropertyof children subpropertyattr parent c subpropertyattr xml attribut name rdf resourc valu geturi rule addinvers owl owlobjectproperti e xml element name owl inverseof children e attr parent e attr xml attribut name rdf resourc valu owlinverseof geturi rule symmetricproperti element owl symmetricproperti isdefinedbi oclisundefin oclistypeof owl symmetricproperti e xml element name owl symmetricproperti children sequenc id domain rang parent owl owlgraph allinst e e oclistypeof owl owlgraph id xml attribut name rdf id valu geturi domain xml element name rdfs domain children domain attr domain attr xml attribut name rdf resourc valu domain c c ocliskindof owl owlclass geturi rang xml element name rdfs rang children rang attr rang attr xml attribut name rdf resourc valu rang c c ocliskindof owl owlclass geturi owlinverseof oclisundefin thismodul addinvers subpropertyof ocliskindof owl owlobjectproperti thismodul makesubproperti rule inversefunctionalproperti element owl inversefunctionalproperti isdefinedbi oclisundefin oclistypeof owl inversefunctionalproperti e xml element name owl inversefunctionalproperti children sequenc id domain rang parent owl owlgraph allinst e e oclistypeof owl owlgraph id xml attribut name rdf id valu geturi domain xml element name rdfs domain children domain attr domain attr xml attribut name rdf resourc valu domain c c ocliskindof owl owlclass geturi rang xml element name rdfs rang children rang attr rang attr xml attribut name rdf resourc valu rang c c ocliskindof owl owlclass geturi owlinverseof oclisundefin thismodul addinvers subpropertyof ocliskindof owl owlobjectproperti thismodul makesubproperti rule functionalproperti owl functionalproperti oclistypeof owl functionalproperti e xml element name owl functionalproperti children parent owl owlgraph allinst e e oclistypeof owl owlgraph xml attribut name rdf valu isdefinedbi assequ e e ocliskindof owl properti geturi rule inversefunctionalproperti owl inversefunctionalproperti isdefinedbi oclisundefin oclistypeof owl functionalproperti e xml element name owl inversefunctionalproperti children parent owl owlgraph allinst e e oclistypeof owl owlgraph xml attribut name rdf valu isdefinedbi assequ e e ocliskindof owl properti geturi rule symmetricproperti owl symmetricproperti isdefinedbi oclisundefin oclistypeof owl symmetricproperti e xml element name owl symmetricproperti children parent owl owlgraph allinst e e oclistypeof owl owlgraph xml attribut name rdf valu isdefinedbi assequ e e ocliskindof owl properti geturi rule enumeratedclass element ec owl enumeratedclass ec oclistypeof owl enumeratedclass e xml element name owl class children sequenc id label oneof parent owl owlgraph allinst e e oclistypeof owl owlgraph id xml attribut name rdf id valu ec geturi label xml element name rdfs label children label text label text xml text name text valu ec getlabel oneof xml element name owl oneof children sequenc oneof att ec owloneof collect e thismodul individualliter element e oneof att xml attribut name rdf parsetyp valu collect lazi rule individualliter element owl individu e xml element name owl thing children e att e att xml attribut name rdf valu geturi rule individu element owl individu type c c ocliskindof owl owlclass oclistypeof owl owlclass e xml element name type c c ocliskindof owl owlclass geturi children sequenc e att parent owl owlgraph allinst e e oclistypeof owl owlgraph e att xml attribut name rdf id valu geturi rule statementpredicateofdatatyp element owl owlstat rdfpredic oclistypeof owl owldatatypeproperti p xml element parent rdfsubject name rdfpredic geturi children sequenc p att p text p att xml attribut name rdf datatyp valu rdfpredic rang c c ocliskindof owl rdfsdatatyp geturi p text xml text name text valu rdfobject geturi rule statementpredicateofobjectproperti element owl owlstat rdfpredic ocliskindof owl owlobjectproperti p xml element parent rdfsubject name rdfpredic geturi children sequenc p att p att xml attribut name rdf resourc valu rdfobject geturi,7
79,79,P42-KM32Problem.atl,"module KM32Problem;
create OUT : Problem from IN : KM3;

-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- This helper ...
-- CONTEXT:	thisModule
-- RETURN:	Sequence(KM3!StructuralFeature)
--helper def: allSourceMEs : Sequence(oclAny) =
--	MOF!Class.allInstancesFrom('KM3')->collect(e |
--		e.allInstancesFrom('IN')
--	)->asSequence()->flatten();

-- This helper computes a Sequence containing all the Packages of the input
-- model.
-- CONTEXT:	thisModule
-- RETURN:	Sequence(KM3!Package)
helper def: allPackages : Sequence(KM3!Package) =
	KM3!Package.allInstances()->asSequence();

-- This helper computes a Sequence containing all the Classes of the input
-- model.
-- CONTEXT:	thisModule
-- RETURN:	Sequence(KM3!Class)
helper def: allClasses : Sequence(KM3!Class) =
	KM3!Class.allInstances()->asSequence();


-- This helper computes a Sequence that contains all the direct and inherited
-- StructuralFeatures of the contextual Class. The Sequence s which is also
-- passed as a parameter contains the KM3!Class elements that have already been
-- visited by the recursive process and that are not considered anymore.
-- The helper collects the direct StructuralFeatures of the contextual
-- Class and, by means of recursice calls, the ones of those of its supertypes
-- that do not already belong to the Sequence s.
-- CONTEXT:	KM3!Class
-- IN:		Sequence(KM3!Class)
-- RETURN:	Sequence(KM3!StructuralFeature)
helper context KM3!Class
	def: allStructuralFeaturesRec(s : Sequence(KM3!Class)) :
											Sequence(KM3!StructuralFeature) =
	self.structuralFeatures->union(
		self.supertypes->iterate(e; res : Sequence(KM3!Class) = Sequence{} |
			if s->includes(e)
			then
				res
			else
				res->union( e.allStructuralFeaturesRec(s->append(e)) )
			endif
		)
	);

-- This helper computes a Sequence that contains all the direct and inherited
-- StructuralFeatures of the contextual Class.
-- To this end, the helper calls the allStructuralFeaturesRec helper with
-- an Sequence (containing the contextual Class) as parameter.
-- CONTEXT:	KM3!Class
-- RETURN:	Sequence(KM3!StructuralFeature)
helper context KM3!Class
	def: allStructuralFeatures() : Sequence(KM3!StructuralFeature) =
	self.allStructuralFeaturesRec(Sequence{self});

-- This helper computes a Boolean value stating whether a direct or indirect
-- inheritance is defined from the contextual Class to the Class c passed as a
-- parameter. The Sequence s which is also passed as a parameter contains the
-- KM3!Class elements that have already been visited by the recursive process
-- (except the c element) and that are not consdidered anymore.
-- To this end, the helper successively tests its own supertypes, and the
-- supertypes of its supertypes (by means of a recursive call):
--  * if the contextual Class has no supertype, the helper returns false.
--  * if the Class passed as a parameter is a supertype of the contextual
--    Class, the helper returns true.
--  * otherwise, the helper returns the disjunction of the recursive calls of
--    the helper on each of its supertypes that has not been already visited
--    by the recursive process.
-- CONTEXT:	KM3!Class
-- IN:		KM3!Class
-- IN:		Sequence(KM3!Class)
-- RETURN:	Boolean
helper context KM3!Class
	def: recursiveInheritanceRec(c : KM3!Class,
								 s : Sequence(KM3!Class)) : Boolean =
	if self.supertypes->isEmpty()
	then
		false
	else
		if self.supertypes->exists(e | e = c)
		then
			true
		else
			self.supertypes->iterate(e; res : Boolean = false |
				if s->includes(e)
				then
					res
				else
					res or e.recursiveInheritanceRec(c, s->append(e))
				endif
			)
		endif
	endif;

-- This helper computes a Boolean value stating whether a direct or indirect
-- recursive inheritance is defined for the contextual Class.
-- To this end, the helper calls the recursiveInheritanceRec helper with
-- itself, and an empty Sequence as parameters.
-- CONTEXT:	KM3!Class
-- RETURN:	Boolean
helper context KM3!Class def: recursiveInheritance() : Boolean =
	self.recursiveInheritanceRec(self, Sequence{});


-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'PackageNameUnique'
-- This rule generates an 'error' Problem element for each Package whose name
-- is not unique.
rule PackageNameUnique {
	from
		i : KM3!Package (
			thisModule.allPackages->exists(e | (i <> e) and (i.name = e.name))
		)
	to
		o : Problem!Problem (
			severity <- #error,
			description <-
					'a Package of the same name already exists: '
					+ i.name,
			location <- i.location
		)
}

-- Rule 'ClassifierInPackage'
-- This rule generates an 'error' Problem element for each Classifier which is
-- not defined within a Package.
rule ClassifierInPackage {
	from
		i : KM3!Classifier (
			i.package.oclIsUndefined()
		)
	to
		o : Problem!Problem (
			severity <- #error,
			description <-
					'the Classifier ' + i.name
					+ ' must be contained by a Package',
			location <- i.location
		)
}

-- Rule 'EnumLiteralInPackage'
-- This rule generates an 'error' Problem element for each EnumLiteral which is
-- not defined within a Package.
rule EnumLiteralInPackage {
	from
		i : KM3!EnumLiteral (
			i.package.oclIsUndefined()
		)
	to
		o : Problem!Problem (
			severity <- #error,
			description <-
					'the EnumLiteral ' + i.name
					+ ' must be contained by a Package',
			location <- i.location
		)
}

-- Rule 'StructuralFeatureInClass'
-- This rule generates an 'error' Problem element for each Classifier which is
-- not defined within a Class.
rule StructuralFeatureInClass {
	from
		i : KM3!StructuralFeature (
			not i.package.oclIsUndefined()
		)
	to
		o : Problem!Problem (
			severity <- #error,
			description <-
					'the Feature ' + i.name
					+ ' cannot be contained by a Package',
			location <- i.location
		)
}

-- Rule 'OppositeOfOppositeExists'
-- This rule generates an 'error' Problem element for each Reference whose
-- opposite of the opposite is not defined.
rule OppositeOfOppositeExists {
	from
		i : KM3!Reference (
			if i.opposite.oclIsUndefined()
			then
				false
			else
				i.opposite.opposite.oclIsUndefined()
			endif
		)
	to
		o : Problem!Problem (
			severity <- #error,
			description <-
					'the opposite of the opposite of Reference ' +
					i.owner.name + '::' + i.name +
					' should be defined',
			location <- i.location
		)
}

-- Rule 'OppositeOfOppositeIsSelf'
-- This rule generates an 'error' Problem element for each Reference whose
-- opposite of the opposite is different from itself.
rule OppositeOfOppositeIsSelf {
	from
		i : KM3!Reference (
			if i.opposite.oclIsUndefined()
			then
				false
			else
				if i.opposite.opposite.oclIsUndefined()
				then
					false
				else
					i.opposite.opposite <> i
				endif
			endif
		)
	to
		o : Problem!Problem (
			severity <- #error,
			description <-
					'the opposite of the opposite of Reference ' +
					i.owner.name + '::' + i.name +
					' should be this very same Reference',
			location <- i.location
		)
}

-- Rule 'TypeOfOppositeIsOwner'
-- This rule generates an 'error' Problem element for each Reference whose
-- type of the opposite is different from its owner.
rule TypeOfOppositeIsOwner {
	from
		i : KM3!Reference (
			not
				if i.opposite.oclIsUndefined() then
					true
				else
					i.opposite.type = i.owner
				endif
		)
	to
		o : Problem!Problem (
			severity <- #error,
			description <-
					'the type of the opposite of Reference ' +
					i.owner.name + '::' + i.name +
					' should be the owner of this Reference (' +
					i.owner.name + ')',
			location <- i.location
		)
}

-- Rule 'ClassifierNameUniqueInPackage'
-- This rule generates an 'error' Problem element for each Classifier whose
-- name is not unique within its Package.
rule ClassifierNameUniqueInPackage {
	from
		i : KM3!Classifier (
			i.package.contents->exists(e | (i <> e) and (i.name = e.name))
		)
	to
		o : Problem!Problem (
			severity <- #error,
			description <-
					'a Classifier named ' + i.name
					+ ' already exists in Package '
					+ i.package.name,
			location <- i.location
		)
}

-- Rule 'ClassIsNotItsOwnSupertype'
-- This rule generates an 'error' Problem element for each Class which is its
-- direct or indirect supertype.
rule ClassIsNotItsOwnSupertype {
	from
		i : KM3!Class (
			i.recursiveInheritance()
		)
	to
		o : Problem!Problem (
			severity <- #error,
			description <- 'the Class ' + i.name
							+ ' is its direct/indirect own supertype',
			location <- i.location
		)
}

-- Rule 'StructuralFeatureNameUniqueInClass'
-- This rule generates an 'error' Problem element for each StructuralFeature
-- whose name is not unique within its Class (including inherited SFs).
rule StructuralFeatureNameUniqueInClass {
	from
		i : KM3!StructuralFeature (
			i.owner.allStructuralFeatures()
				->exists(e | (i <> e) and (i.name = e.name))
		)
	to
		o : Problem!Problem (
			severity <- #error,
			description <-
					'the Class ' + i.owner.name
					+ ' contains another feature (including inherited ones) '
					+ 'with the same name: '
					+ i.name,
			location <- i.location
		)
}

-- Rule 'StructuralFeatureLower'
-- This rule generates an 'error' Problem element for each StructuralFeature
-- whose lower attribute is lower than 0.
rule StructuralFeatureLower {
	from
		i : KM3!StructuralFeature (
			i.lower < 0
		)
	to
		o : Problem!Problem (
			severity <- #error,
			description <-
					'Lower bound value of Feature ' + i.owner.name + '::'
					+ i.name + 'is unvalid (lower than 0)',
			location <- i.location
		)
}

-- Rule 'StructuralFeatureUpper'
-- This rule generates an 'error' Problem element for each StructuralFeature
-- whose upper attribute is lower than 1.
rule StructuralFeatureUpper {
	from
		i : KM3!StructuralFeature (
			(i.upper < 1) and (i.upper <> 0-1)
		)
	to
		o : Problem!Problem (
			severity <- #error,
			description <-
					'Upper bound of Feature ' + i.owner.name + '::'
					+ i.name + 'is unvalid (lower than 1)',
			location <- i.location
		)
}

-- Rule 'StructuralFeatureLowerUpper'
-- This rule generates an 'error' Problem element for each StructuralFeature
-- whose upper attribute is lower than its upper attribute.
rule StructuralFeatureLowerUpper {
	from
		i : KM3!StructuralFeature (
			(i.upper < i.lower) and (i.upper <> 0-1)
		)
	to
		o : Problem!Problem (
			severity <- #error,
			description <-
					'Upper bound of Feature ' + i.owner.name + '::'
					+ i.name + ' is lower than its lower bound',
			location <- i.location
		)
}

-- Rule 'StructuralFeatureUniqueOrdered'
-- This rule generates an 'error' Problem element for each StructuralFeature
-- whose upper attribute is 1 and isOrdered attribute is true.
rule StructuralFeatureUniqueOrdered {
	from
		i : KM3!StructuralFeature (
			(i.upper = 1) and (i.isOrdered = true)
		)
	to
		o : Problem!Problem (
			severity <- #error,
			description <-
					'Feature ' + i.owner.name + '::' + i.name
					+ ' cannot be ordered with an upper bound equals to 1',
			location <- i.location
		)
}

-- Rule 'DataTypeReferenceProhibited'
-- This rule generates an 'error' Problem element for each Reference which
-- targets a Datatype element.
rule DataTypeReferenceProhibited {
	from
		i : KM3!Reference (
			not i.type.oclIsTypeOf(KM3!Class)
		)
	to
		o : Problem!Problem (
			severity <- #error,
			description <-
					'Reference ' + i.owner.name + '::' + i.name
					+ ' cannot target a DataType element',
			location <- i.location
		)
}

-- Rule 'ClassAttributeUnsupportedByEcore'
-- This rule generates an 'warning' Problem element for each Attribute whose
-- type is Class.
rule ClassAttributeUnsupportedByEcore {
	from
		i : KM3!Attribute (
			i.type.oclIsTypeOf(KM3!Class)
		)
	to
		o : Problem!Problem (
			severity <- #warning,
			description <-
					'Class ' + i.owner.name + ' defines a class Attribute ('
					+ i.name
					+ ') that is not supported by the Ecore metamodel',
			location <- i.location
		)
}

-- Rule 'AbstractClassShouldHaveChildren'
-- This rule generates an 'error' Problem element for each abstract Class which
-- has no child.
rule AbstractClassShouldHaveChildren {
	from
		i : KM3!Class (
			i.isAbstract and
			(thisModule.allClasses
			 	->select(e | e.supertypes->includes(i))
				->isEmpty()
			 )
		)
	to
		o : Problem!Problem (
			severity <- #warning,
			description <- 'the abstract Class ' + i.name + ' has no children',
			location <- i.location
		)
}

-- Rule 'ClassifierNameShouldStartWithUpperCase'
-- This rule generates an 'critic' Problem element for each Classifier whose
-- name does not start by an upper case character.
rule ClassifierNameShouldStartWithUpperCase {
	from
		i : KM3!Classifier (
			let firstChar : String = i.name.substring(1, 1) in
				firstChar <> firstChar.toUpper()
		)
	to
		o : Problem!Problem (
			severity <- #critic,
			description <-
					'the name of Classifier ' + i.name
					+ ' should begin with an upper case',
			location <- i.location
		)
}
",modul km problem creat out problem in km helper this helper context thismodul return sequenc km structuralfeatur helper def allsourcem sequenc oclani mof class allinstancesfrom km collect e e allinstancesfrom in assequ flatten this helper comput sequenc contain packag input model context thismodul return sequenc km packag helper def allpackag sequenc km packag km packag allinst assequ this helper comput sequenc contain class input model context thismodul return sequenc km class helper def allclass sequenc km class km class allinst assequ this helper comput sequenc contain direct inherit structuralfeatur contextu class the sequenc also pass paramet contain km class element alreadi visit recurs process consid anymor the helper collect direct structuralfeatur contextu class mean recursic call one supertyp alreadi belong sequenc context km class in sequenc km class return sequenc km structuralfeatur helper context km class def allstructuralfeaturesrec sequenc km class sequenc km structuralfeatur self structuralfeatur union self supertyp iter e res sequenc km class sequenc includ e res els res union e allstructuralfeaturesrec append e endif this helper comput sequenc contain direct inherit structuralfeatur contextu class to end helper call allstructuralfeaturesrec helper sequenc contain contextu class paramet context km class return sequenc km structuralfeatur helper context km class def allstructuralfeatur sequenc km structuralfeatur self allstructuralfeaturesrec sequenc self this helper comput boolean valu state whether direct indirect inherit defin contextu class class c pass paramet the sequenc also pass paramet contain km class element alreadi visit recurs process except c element consdid anymor to end helper success test supertyp supertyp supertyp mean recurs call contextu class supertyp helper return fals class pass paramet supertyp contextu class helper return true otherwis helper return disjunct recurs call helper supertyp alreadi visit recurs process context km class in km class in sequenc km class return boolean helper context km class def recursiveinheritancerec c km class sequenc km class boolean self supertyp isempti fals els self supertyp exist e e c true els self supertyp iter e res boolean fals includ e res els res e recursiveinheritancerec c append e endif endif endif this helper comput boolean valu state whether direct indirect recurs inherit defin contextu class to end helper call recursiveinheritancerec helper empti sequenc paramet context km class return boolean helper context km class def recursiveinherit boolean self recursiveinheritancerec self sequenc rule rule packagenameuniqu this rule generat error problem element packag whose name uniqu rule packagenameuniqu km packag thismodul allpackag exist e e name e name problem problem sever error descript packag name alreadi exist name locat locat rule classifierinpackag this rule generat error problem element classifi defin within packag rule classifierinpackag km classifi packag oclisundefin problem problem sever error descript classifi name must contain packag locat locat rule enumliteralinpackag this rule generat error problem element enumliter defin within packag rule enumliteralinpackag km enumliter packag oclisundefin problem problem sever error descript enumliter name must contain packag locat locat rule structuralfeatureinclass this rule generat error problem element classifi defin within class rule structuralfeatureinclass km structuralfeatur packag oclisundefin problem problem sever error descript featur name cannot contain packag locat locat rule oppositeofoppositeexist this rule generat error problem element refer whose opposit opposit defin rule oppositeofoppositeexist km refer opposit oclisundefin fals els opposit opposit oclisundefin endif problem problem sever error descript opposit opposit refer owner name name defin locat locat rule oppositeofoppositeisself this rule generat error problem element refer whose opposit opposit differ rule oppositeofoppositeisself km refer opposit oclisundefin fals els opposit opposit oclisundefin fals els opposit opposit endif endif problem problem sever error descript opposit opposit refer owner name name refer locat locat rule typeofoppositeisown this rule generat error problem element refer whose type opposit differ owner rule typeofoppositeisown km refer opposit oclisundefin true els opposit type owner endif problem problem sever error descript type opposit refer owner name name owner refer owner name locat locat rule classifiernameuniqueinpackag this rule generat error problem element classifi whose name uniqu within packag rule classifiernameuniqueinpackag km classifi packag content exist e e name e name problem problem sever error descript classifi name name alreadi exist packag packag name locat locat rule classisnotitsownsupertyp this rule generat error problem element class direct indirect supertyp rule classisnotitsownsupertyp km class recursiveinherit problem problem sever error descript class name direct indirect supertyp locat locat rule structuralfeaturenameuniqueinclass this rule generat error problem element structuralfeatur whose name uniqu within class includ inherit sfs rule structuralfeaturenameuniqueinclass km structuralfeatur owner allstructuralfeatur exist e e name e name problem problem sever error descript class owner name contain anoth featur includ inherit one name name locat locat rule structuralfeaturelow this rule generat error problem element structuralfeatur whose lower attribut lower rule structuralfeaturelow km structuralfeatur lower problem problem sever error descript lower bound valu featur owner name name unvalid lower locat locat rule structuralfeatureupp this rule generat error problem element structuralfeatur whose upper attribut lower rule structuralfeatureupp km structuralfeatur upper upper problem problem sever error descript upper bound featur owner name name unvalid lower locat locat rule structuralfeaturelowerupp this rule generat error problem element structuralfeatur whose upper attribut lower upper attribut rule structuralfeaturelowerupp km structuralfeatur upper lower upper problem problem sever error descript upper bound featur owner name name lower lower bound locat locat rule structuralfeatureuniqueord this rule generat error problem element structuralfeatur whose upper attribut isord attribut true rule structuralfeatureuniqueord km structuralfeatur upper isord true problem problem sever error descript featur owner name name cannot order upper bound equal locat locat rule datatypereferenceprohibit this rule generat error problem element refer target datatyp element rule datatypereferenceprohibit km refer type oclistypeof km class problem problem sever error descript refer owner name name cannot target datatyp element locat locat rule classattributeunsupportedbyecor this rule generat warn problem element attribut whose type class rule classattributeunsupportedbyecor km attribut type oclistypeof km class problem problem sever warn descript class owner name defin class attribut name support ecor metamodel locat locat rule abstractclassshouldhavechildren this rule generat error problem element abstract class child rule abstractclassshouldhavechildren km class isabstract thismodul allclass select e e supertyp includ isempti problem problem sever warn descript abstract class name children locat locat rule classifiernameshouldstartwithuppercas this rule generat critic problem element classifi whose name start upper case charact rule classifiernameshouldstartwithuppercas km classifi let firstchar string name substr firstchar firstchar toupper problem problem sever critic descript name classifi name begin upper case locat locat,18
80,80,P43-KM32XML.atl,"-- @atlcompiler atl2006
module km32xml;
create OUT: XML from IN: KM3;

uses FQL;

abstract rule ModelElement {
	from
		i: KM3!ModelElement
	to
		attribute_name: XML!Attribute (
			name <- 'name',
			value <- i.name
		)
}

rule Metamodel {
	from 
		i: KM3!Metamodel
	to
		o: XML!Root (
			name <- 'Metamodel',
			children <- i.contents
		)
}

rule Package extends ModelElement {
	from
		i: KM3!Package
	to
		o: XML!Element (
			name <- 'Package',
			children <- Sequence{attribute_name}->union(i.contents)
		)
}

rule Class extends ModelElement {
	from
		i: KM3!Class
	to
		o: XML!Element (
			name <- 'Class',
			children <- Sequence{attribute_name, attribute_isAbstract, reference_supertypes}->union(i.structuralFeatures)
		),
		attribute_isAbstract: XML!Attribute (
			name <- 'isAbstract',
			value <- i.isAbstract->toString()
		),
		reference_supertypes: XML!Attribute (
			name <- 'supertypes',
			value <- i.supertypes->iterate(e ; acc : String = '' | if acc = '' then acc else acc + ', '  endif + e.getFQL())
		)
}

rule DataType extends ModelElement {
	from
		i: KM3!DataType
	to
		o: XML!Element (
			name <- 'DataType',
			children <- Sequence{attribute_name}
		)
}

rule Enumeration extends ModelElement {
	from
		i: KM3!Enumeration
	to
		o: XML!Element (
			name <- 'Enumeration',
			children <- Sequence{attribute_name}->union(i.literals)
		)
}

rule EnumLiteral extends ModelElement {
	from
		i: KM3!EnumLiteral
	to
		o: XML!Element (
			name <- 'EnumLiteral',
			children <- Sequence{attribute_name}
		)
}

abstract rule StructuralFeature extends ModelElement {
	from
		i: KM3!StructuralFeature
	to
		attribute_lower: XML!Attribute (
			name <- 'lower',
			value <- i.lower->toString()
		),
		attribute_upper: XML!Attribute (
			name <- 'upper',
			value <- i.upper->toString()
		),
		attribute_isOrdered: XML!Attribute (
			name <- 'isOrdered',
			value <- i.isOrdered->toString()
		),
		reference_type: XML!Attribute (
			name <- 'type',
			value <- i.type.getFQL()
		)
		--type
}

rule Attribute extends StructuralFeature {
	from
		i: KM3!Attribute
	to
		o: XML!Element (
			name <- 'Attribute',
			children <- Sequence{attribute_name, attribute_lower, attribute_upper, attribute_isOrdered, attribute_isUnique, reference_type}
		),
		attribute_isUnique: XML!Attribute (
			name <- 'isUnique',
			value <- i.isUnique->toString()
		)
}

rule Reference extends StructuralFeature {
	from
		i: KM3!Reference
	to
		o: XML!Element (
			name <- 'Reference',
			children <- Sequence{attribute_name, attribute_lower, attribute_upper, attribute_isOrdered, attribute_isContainer, reference_type, reference_opposite}
		),
		attribute_isContainer: XML!Attribute (
			name <- 'isContainer',
			value <- i.isContainer->toString()
		),
		reference_opposite: XML!Attribute(
			name <- 'opposite',
			value <- if i.opposite->oclIsUndefined() then '' else  i.opposite.getFQL() endif
		)
}",atlcompil atl modul km xml creat out xml in km use fql abstract rule modelel km modelel attribut name xml attribut name name valu name rule metamodel km metamodel xml root name metamodel children content rule packag extend modelel km packag xml element name packag children sequenc attribut name union content rule class extend modelel km class xml element name class children sequenc attribut name attribut isabstract refer supertyp union structuralfeatur attribut isabstract xml attribut name isabstract valu isabstract tostr refer supertyp xml attribut name supertyp valu supertyp iter e acc string acc acc els acc endif e getfql rule datatyp extend modelel km datatyp xml element name datatyp children sequenc attribut name rule enumer extend modelel km enumer xml element name enumer children sequenc attribut name union liter rule enumliter extend modelel km enumliter xml element name enumliter children sequenc attribut name abstract rule structuralfeatur extend modelel km structuralfeatur attribut lower xml attribut name lower valu lower tostr attribut upper xml attribut name upper valu upper tostr attribut isord xml attribut name isord valu isord tostr refer type xml attribut name type valu type getfql type rule attribut extend structuralfeatur km attribut xml element name attribut children sequenc attribut name attribut lower attribut upper attribut isord attribut isuniqu refer type attribut isuniqu xml attribut name isuniqu valu isuniqu tostr rule refer extend structuralfeatur km refer xml element name refer children sequenc attribut name attribut lower attribut upper attribut isord attribut iscontain refer type refer opposit attribut iscontain xml attribut name iscontain valu iscontain tostr refer opposit xml attribut name opposit valu opposit oclisundefin els opposit getfql endif,18
81,81,P43-LibFQL.atl,"-- @atlcompiler atl2006
library FQL;

helper context KM3!ModelElement def: getFQL() : String =
	self.getFQLWithSeparator('::');

helper context KM3!ModelElement def: getFQLWithSeparator(separator: String) : String =
	if (self.oclIsKindOf(KM3!EnumLiteral)) then
		if (self.enumeration <> OclUndefined) then
			self.enumeration.getFQLWithSeparator(separator) + separator + self.name
		else 
			self.name
		endif
	else
		if (self.oclIsKindOf(KM3!StructuralFeature)) then
				if (self.owner <> OclUndefined) then
					self.owner.getFQLWithSeparator(separator) + separator + self.name
				else
					self.name
				endif
		else
			if (self.oclIsKindOf(KM3!Classifier)) then
				if (self.package <> OclUndefined) then
					self.package.getFQLWithSeparator(separator) + separator + self.name
				else 
					self.name
				endif
			else
				self.name
			endif
		endif
	endif;",atlcompil atl librari fql helper context km modelel def getfql string self getfqlwithsepar helper context km modelel def getfqlwithsepar separ string string self ocliskindof km enumliter self enumer oclundefin self enumer getfqlwithsepar separ separ self name els self name endif els self ocliskindof km structuralfeatur self owner oclundefin self owner getfqlwithsepar separ separ self name els self name endif els self ocliskindof km classifi self packag oclundefin self packag getfqlwithsepar separ separ self name els self name endif els self name endif endif endif,18
82,82,P44-XML2KML.atl,"-- @name XML2KML
-- @version 1.0
-- @domains KML, Google Earth, Geospatial data
-- @authors Eric Vepa (eric.vepa <at> gmail.com)
-- @date 2006/06/30
-- @description XML to KML transformation for 
-- @see KML specifications 	: http://earth.google.com/kml/kml_tags.html

module XML2KML; -- Module Template
create OUT : KML from IN : XML;

--@begin helper getAttrVal : returns the value of the first attribute named name
helper context XML!Element def : getAttrVal(name : String) : String =
	if self.children->select (c|c.oclIsTypeOf(XML!Attribute))->select(c|c.name = name)->notEmpty()
		then self.children->select (c|c.oclIsTypeOf(XML!Attribute))->select(c|c.name = name)->first().value
		else ''
	endif;
--@end helper getAttrVal

--@begin helper getChildren : returns all the children which belong to the sequence of possible children
helper context XML!Element def : getChildren(seq : Sequence(String)) : Sequence(XML!Element) =
	self.children->select(e|e.oclIsKindOf(XML!Element))->select(e|seq->includes(e.name));
--@end helper getChildren

--@begin helper getText : returns all valid text nodes
helper context XML!Element def : getText() : Sequence(XML!Text) =
	self.children->select(t|t.oclIsKindOf(XML!Text))->select(t|t.name = '#text')->select(t|t.value.trim() <> '');
--@end helper getText

--@begin helper getAllText : returns a String containing all text nodes
helper context XML!Element def : getAllText() : String =
	self.getText()->iterate(s ; str : String = '' | str.concat(s.value.trim()).concat(' '));
--@end helper getAllText

--@begin helper getValue : returns the value of the first text node
helper context XML!Element def : getValue() : String =
	self.getText()->first().value.trim();
--@end helper getValue


--@begin rule Address
rule Address {
	from e:XML!Element (
		e.name = 'address'
	)
	to adr:KML!Address (
		name <- e.name,
		value <- e.getValue()
	)
}
--@end rule Address

--@begin rule AltitudeMode
rule AltitudeMode {
	from e:XML!Element (
		e.name = 'altitudeMode'
	)
	to altMode:KML!AltitudeMode (
		name <- e.name,
		value <- if e.getValue() = 'relativeToGround'
					then #relativeToGround
					else if e.getValue() = 'absolute'
							then #absolute
							else #clampedToGround
						endif
				 endif
	)
}
--@end rule AltitudeMode

--@begin rule BalloonStyle
rule BalloonStyle {
	from e:XML!Element (
		e.name = 'BalloonStyle'
	)
	to ball:KML!BalloonStyle (
		name <- e.name,
		nodes <- e.getChildren(Sequence{'text', 'textColor', 'color'})
	)
}
--@end rule BalloonStyle

--@begin rule Color
rule Color {
	from e:XML!Element (
		e.name = 'color'
	)
	to color:KML!Color (
		name <- e.name,
		value <- e.getValue()
	)
}
--@end rule Color

--@begin rule ColorMode
rule ColorMode {
	from e:XML!Element (
		e.name = 'colorMode'
	)
	to colMode:KML!ColorMode (
		name <- e.name,
		value <- if e.getValue() = 'random'
					then #random
					else #normal
				 endif
	)
}
--@end rule ColorMode

--@begin rule Cookie
rule Cookie {
	from e:XML!Element (
		e.name = 'cookie'
	)
	to cook:KML!Cookie (
		name <- e.name,
		value <- e.getValue()
	)
}
--@end rule Cookie

--@begin rule Coordinates
rule Coordinates {
	from e:XML!Element (
		e.name = 'coordinates'
	)
	to coords:KML!Coordinates (
		name <- e.name,
		nodes <- coord
	),
	coord: distinct KML!Coordinate foreach (c in e.getText()) (
		name <- c.value.trim()
	)
}
--@end rule Coordinates

--@begin rule Description
rule Description {
	from e:XML!Element (
		e.name = 'description'
	)
	to desc:KML!Description (
		name <- e.name,
		value <- e.getAllText()
	)
}
--@end rule Description

--@begin rule Document
rule Document {
	from e:XML!Element (
		e.name = 'Document'
	)
	to doc:KML!Document (
		name <- e.name,
		nodes <- e.getChildren(Sequence{'description', 'Document', 'Folder', 'GroundOverlay', 'name', 'LookAt', 'NetworkLink', 'NetworkLinkControl', 'Placemark', 'ScreenOverlay', 'Style', 'StyleMap', 'visibility'})
	)
}
--@end rule Document

--@begin rule DrawOrder
rule DrawOrder {
	from e:XML!Element (
		e.name = 'drawOrder'
	)
	to dOrder:KML!DrawOrder (
		name <- e.name,
		value <- e.getValue().toInteger()
	)
}
--@end rule DrawOrder

--@begin rule East
rule East {
	from e:XML!Element (
		e.name = 'east'
	)
	to east:KML!East (
		name <- e.name,
		value <- e.getValue().toReal()
	)
}
--@end rule East

--@begin rule Extrude
rule Extrude {
	from e:XML!Element (
		e.name = 'extrude'
	)
	to extr:KML!Extrude (
		name <- e.name,
		value <- if e.getValue() = '1'
					then true
					else false
				 endif
	)
}
--@end rule Extrude

--@begin rule Fill
rule Fill {
	from e:XML!Element (
		e.name = 'fill'
	)
	to fill:KML!Fill (
		name <- e.name,
		value <- if e.getValue() = '0'
					then false
					else true
				 endif
	)
}
--@end rule Fill

--@begin rule Folder
rule Folder {
	from e:XML!Element (
		e.name = 'Folder'
	)
	to fd:KML!Folder (
		name <- e.name,
		nodes <- e.getChildren(Sequence{'description', 'Document', 'Folder', 'GroundOverlay', 'LookAt', 'name', 'NetworkLink', 'open', 'Placemark', 'ScreenOverlay', 'Style', 'visibility'})
	)
}
--@end rule Folder

--@begin rule GroundOverlay
rule GroundOverlay {
	from e:XML!Element (
		e.name = 'GroundOverlay'
	)
	to go:KML!GroundOverlay (
		name <- e.name,
		nodes <- e.getChildren(Sequence{'description', 'color', 'drawOrder', 'Icon', 'LatLonBox', 'LookAt', 'name', 'visibility'})
	)
}
--@end rule GroundOverlay

--@begin rule H
rule H {
	from e:XML!Element (
		e.name = 'h'
	)
	to h:KML!H (
		name <- e.name,
		value <- e.getValue().toInteger()
	)
}
--@end rule H

--@begin rule Heading
rule Heading {
	from e:XML!Element (
		e.name = 'heading'
	)
	to hding:KML!Heading (
		name <- e.name,
		value <- e.getValue().toReal()
	)
}
--@end rule Heading

--@begin rule Href
rule Href {
	from e:XML!Element (
		e.name = 'href'
	)
	to href:KML!Href (
		name <- e.name,
		value <- e.getValue()
	)
}
--@end rule Href

--@begin rule Icon
rule Icon {
	from e:XML!Element (
		e.name = 'Icon'
	)
	to icon:KML!Icon (
		name <- e.name,
		nodes <- e.getChildren(Sequence{'h', 'href', 'refreshMode', 'viewRefreshMode', 'w', 'x', 'y'})
	)
}
--@end rule Icon

--@begin rule IconStyle
rule IconStyle {
	from e:XML!Element (
		e.name = 'IconStyle'
	)
	to iconS:KML!IconStyle (
		name <- e.name,
		nodes <- e.getChildren(Sequence{'color', 'colorMode', 'heading', 'Icon', 'scale'})
	)
}
--@end rule IconStyle

--@begin rule InnerBoundaryIs
rule InnerBoundaryIs {
	from e:XML!Element (
		e.name = 'innerBoundaryIs'
	)
	to inner:KML!InnerBoundaryIs (
		name <- e.name,
		nodes <- e.getChildren(Sequence{'LinearRing'})
	)
}
--@end rule InnerBoundaryIs

--@begin rule Key
rule Key {
	from e:XML!Element (
		e.name = 'key'
	)
	to key:KML!Key (
		name <- e.name,
		value <- e.getValue()
	)
}
--@end rule Key

--@begin rule LabelStyle
rule LabelStyle {
	from e:XML!Element (
		e.name = 'LabelStyle'
	)
	to labelS:KML!LabelStyle (
		name <- e.name,
		nodes <- e.getChildren(Sequence{'color', 'colorMode', 'scale'})
	)
}
--@end rule LabelStyle

--@begin rule Latitude
rule Latitude {
	from e:XML!Element (
		e.name = 'latitude'
	)
	to lat:KML!Latitude (
		name <- e.name,
		value <- e.getValue().toReal()
	)
}
--@end rule Latitude

--@begin rule LatLonBox
rule LatLonBox {
	from e:XML!Element (
		e.name = 'LatLonBox'
	)
	to llb:KML!LatLonBox (
		name <- e.name,
		nodes <- e.getChildren(Sequence{'east', 'west', 'north', 'south', 'rotation'})
	)
}
--@end rule LatLonBox

--@begin rule LinearRing
rule LinearRing {
	from e:XML!Element (
		e.name = 'LinearRing'
	)
	to lr:KML!LinearRing (
		name <- e.name,
		nodes <- e.getChildren(Sequence{'coordinates'})
	)
}
--@end rule LinearRing

--@begin rule LineString
rule LineString {
	from e:XML!Element (
		e.name = 'LineString'
	)
	to ls:KML!LineString (
		name <- e.name,
		nodes <- e.getChildren(Sequence{'coordinates', 'tessellate', 'extrude', 'altitudeMode'})
	)
}
--@end rule LineString

--@begin rule LineStyle
rule LineStyle {
	from e:XML!Element (
		e.name = 'LineStyle'
	)
	to lineS:KML!LineStyle (
		name <- e.name,
		id <- e.getAttrVal('id'),
		nodes <- e.getChildren(Sequence{'color', 'colorMode', 'width'})
	)
}
--@end rule LineStyle

--@begin rule LinkDescription
rule LinkDescription {
	from e:XML!Element (
		e.name = 'linkDescription'
	)
	to lDesc:KML!LinkDescription (
		name <- e.name,
		value <- e.getAllText()	
	)
}
--@end rule LinkDescription

--@begin rule LinkName
rule LinkName {
	from e:XML!Element (
		e.name = 'LinkName'
	)
	to lName:KML!LinkName (
		name <- e.name,
		value <- e.getValue()
	)
}
--@end rule LinkName

--@begin rule Longitude
rule Longitude {
	from e:XML!Element (
		e.name = 'longitude'
	)
	to long:KML!Longitude (
		name <- e.name,
		value <- e.getValue().toReal()
	)
}
--@end rule Longitude

--@begin rule LookAt
rule LookAt {
	from e:XML!Element (
		e.name = 'LookAt'
	)
	to la:KML!LookAt (
		name <- e.name,
		nodes <- e.getChildren(Sequence{'heading', 'latitude', 'longitude', 'range', 'tilt'})
	)
}
--@end rule LookAt

--@begin rule Message
rule Message {
	from e:XML!Element (
		e.name = 'message'
	)
	to msg:KML!Message (
		name <- e.name,
		nodes <- text
	),
	text: distinct KML!TextNode foreach (txt in e.getText()) (
		name <- txt.value		
	)
}
--@end rule Message

--@begin rule MinRefreshPeriod
rule MinRefreshPeriod {
	from e:XML!Element (
		e.name = 'minRefreshPeriod'
	)
	to minRP:KML!MinRefreshPeriod (
		name <- e.name,
		value <- e.getValue()
	)
}
--@end rule MinRefreshPeriod

--@begin rule MultiGeometry
rule MultiGeometry {
	from e:XML!Element (
		e.name = 'MultiGeometry'
	)
	to mgeo:KML!MultiGeometry (
		name <- e.name,
		nodes <- e.getChildren(Sequence{'LineString', 'MultiGeometry', 'Point', 'Polygon'})
	)
}
--@end rule MultiGeometry

--@begin rule Name
rule Name {
	from e:XML!Element (
		e.name = 'name'
	)
	to name:KML!Name (
		name <- e.name,
		value <- e.getValue()
	)
}
--@end rule Name

--@begin rule NetworkLink
rule NetworkLink {
	from e:XML!Element (
		e.name = 'NetworkLink'
	)
	to netLink:KML!NetworkLink (
		name <- e.name,
		nodes <- e.getChildren(Sequence{'description', 'name', 'refreshVisibility', 'Url', 'visibility'}),
		nodes <- ftv
	),
	-- FlyToView
	ftv:KML!FlyToView (
		name <- 'flyToView',
		value <- if e.getChildren(Sequence{'flyToView'})->notEmpty()
					then if e.getChildren(Sequence{'flyToView'})->first().getValue() = '1'
							then true
							else false
						 endif
					else false
				 endif
	)
	-- FlyToView
}
--@end rule NetworkLink

--@begin rule NetworkLinkControl
rule NetworkLinkControl {
	from e:XML!Element (
		e.name = 'NetworkLinkControl'
	)
	to netLinCtrlk:KML!NetworkLinkControl (
		name <- e.name,
		nodes <- e.getChildren(Sequence{'cookie', 'linkDescription', 'linkName', 'message', 'minRefreshPeriod'})
	)
}
--@end rule NetworkLinkControl

--@begin rule North
rule North {
	from e:XML!Element (
		e.name = 'north'
	)
	to north:KML!North (
		name <- e.name,
		value <- e.getValue().toReal()
	)
}
--@end rule North

--@begin rule ObjArrayField
rule ObjArrayField {
	from e:XML!Element (
		e.name = 'ObjArrayField'
	)
	to objAF:KML!ObjArrayField (
		name <- e.name,
		nodes <- e.getChildren(Sequence{'name', 'type'})
	)
}
--@end rule ObjArrayField

--@begin rule ObjField
rule ObjField {
	from e:XML!Element (
		e.name = 'ObjField'
	)
	to objF:KML!ObjField (
		name <- e.name,
		nodes <- e.getChildren(Sequence{'name', 'type'})
	)
}
--@end rule ObjField

--@begin rule Open
rule Open {
	from e:XML!Element (
		e.name = 'open'
	)
	to open:KML!Open (
		name <- e.name,
		value <- e.getValue()
	)
}
--@end rule Open

--@begin rule OuterBoundaryIs
rule OuterBoundaryIs {
	from e:XML!Element (
		e.name = 'outerBoundaryIs'
	)
	to outerBI:KML!OuterBoundaryIs (
		name <- e.name,
		nodes <- e.getChildren(Sequence{'LinearRing'})
	)
}
--@end rule OuterBoundaryIs

--@begin rule Outline
rule Outline {
	from e:XML!Element (
		e.name = 'outline'
	)
	to out:KML!Outline (
		name <- e.name,
		value <- e.getValue()
	)
}
--@end rule Outline

--@begin rule OverlayXY
rule OverlayXY {
	from e:XML!Element (
		e.name = 'overlayXY'
	)
	to over:KML!OverlayXY (
		name <- e.name,
		x <- e.getAttrVal('x'),
		y <- e.getAttrVal('y'),
		xunits <- e.getAttrVal('xunits'),
		yunits <- e.getAttrVal('yunits')
	)
}
--@end rule OverlayXY

--@begin rule Pair
rule Pair {
	from e:XML!Element (
		e.name = 'Pair'
	)
	to pair:KML!Pair (
		name <- e.name,
		nodes <- e.getChildren(Sequence{'key', 'styleUrl'})
	)
}
--@end rule Pair

--@begin rule Parent
rule Parent {
	from e:XML!Element (
		e.name = 'parent'
	)
	to parent:KML!Parent (
		name <- e.name,
		value <- e.getValue()
	)
}
--@end rule Parent

--@begin rule Placemark
rule Placemark {
	from e:XML!Element (
		e.name = 'Placemark'
	)
	to pmk:KML!Placemark (
		name <- e.name,
		nodes <- e.getChildren(Sequence{'address', 'description', 'LookAt', 'LineString', 'MultiGeometry', 'name', 'Point', 'Polygon', 'Snippet', 'Style', 'styleUrl', 'visibility'})
	)
}
--@end rule Placemark

--@begin rule Point
rule Point {
	from e:XML!Element (
		e.name = 'Point'
	)
	to pt:KML!Point (
		name <- e.name,
		nodes <- e.getChildren(Sequence{'coordinates', 'tessallate', 'extrude', 'altitudeMode'})
	)
}
--@end rule Point

--@begin rule Polygon
rule Polygon {
	from e:XML!Element (
		e.name = 'Polygon'
	)
	to poly:KML!Polygon (
		name <- e.name,
		nodes <- e.getChildren(Sequence{'outerBoundaryIs', 'innerBoundaryIs', 'tessellate', 'extrude', 'altitudeMode'})
	)
}
--@end rule Polygon

--@begin rule PolyStyle
rule PolyStyle {
	from e:XML!Element (
		e.name = 'PolyStyle'
	)
	to polyS:KML!PolyStyle (
		name <- e.name,
		nodes <- e.getChildren(Sequence{'color', 'colorMode', 'fill', 'outline'})
	)
}
--@end rule PolyStyle

--@begin rule Range
rule Range {
	from e:XML!Element (
		e.name = 'range'
	)
	to rng:KML!Range (
		name <- e.name,
		value <- e.getValue()
	)
}
--@end rule Range

--@begin rule RefreshInterval
rule RefreshInterval {
	from e:XML!Element (
		e.name = 'refreshInterval'
	)
	to refrI:KML!RefreshInterval (
		name <- e.name,
		value <- e.getValue()
	)
}
--@end rule RefreshInterval

--@begin rule RefreshMode
rule RefreshMode {
	from e:XML!Element (
		e.name = 'refreshMode'
	)
	to refrM:KML!RefreshMode (
		name <- e.name,
		value <- e.getValue()
	)
}
--@end rule RefreshMode

--@begin rule RefreshVisibility
rule RefreshVisibility {
	from e:XML!Element (
		e.name = 'refreshVisibility'
	)
	to refrV:KML!RefreshVisibility (
		name <- e.name,
		value <- e.getValue()
	)
}
--@end rule RefreshVisibility

--@begin rule Rotation
rule Rotation {
	from e:XML!Element (
		e.name = 'rotation'
	)
	to rot:KML!Rotation (
		name <- e.name,
		value <- e.getValue()
	)
}
--@end rule Rotation

--@begin rule Schema
rule Schema {
	from e:XML!Element (
		e.name = 'Schema'
	)
	to schema:KML!Schema (
		name <- e.name,
		nodes <- e.getChildren(Sequence{'name', 'parent', 'ObjField', 'ObjArrayField', 'SimpleField', 'SimpleArrayField'})
	)
}
--@end rule Schema

--@begin rule Scale
rule Scale {
	from e:XML!Element (
		e.name = 'scale'
	)
	to scale:KML!Scale (
		name <- e.name,
		value <- e.getValue()
	)
}
--@end rule Scale

--@begin rule ScreenOverlay
rule ScreenOverlay {
	from e:XML!Element (
		e.name = 'ScreenOverlay'
	)
	to scrO:KML!ScreenOverlay (
		name <- e.name,
		id <- e.getAttrVal('id'),
		nodes <- e.getChildren(Sequence{'description', 'drawOrder', 'Icon', 'overlayXY', 'rotation', 'screenXY', 'size', 'name', 'visibility'})
	)
}
--@end rule ScreenOverlay

--@begin rule ScreenXY
rule ScreenXY {
	from e:XML!Element (
		e.name = 'screenXY'
	)
	to scrXY:KML!ScreenXY (
		name <- e.name,
		x <- e.getAttrVal('x'),
		y <- e.getAttrVal('y'),
		xunits <- e.getAttrVal('xunits'),
		yunits <- e.getAttrVal('yunits')
	)
}
--@end rule ScreenXY

--@begin rule SimpleArrayField
rule SimpleArrayField {
	from e:XML!Element (
		e.name = 'SimpleArrayField'
	)
	to sAF:KML!SimpleArrayField (
		name <- e.name,
		nodes <- e.getChildren(Sequence{'name', 'type'})
	)
}
--@end rule SimpleArrayField

--@begin rule SimpleField
rule SimpleField {
	from e:XML!Element (
		e.name = 'SimpleField'
	)
	to sF:KML!SimpleField (
		name <- e.name,
		nodes <- e.getChildren(Sequence{'name', 'type'})
	)
}
--@end rule SimpleField

--@begin rule Size
rule Size {
	from e:XML!Element (
		e.name = 'size'
	)
	to size:KML!Size (
		name <- e.name,
		x <- e.getAttrVal('x'),
		y <- e.getAttrVal('y'),
		xunits <- e.getAttrVal('xunits'),
		yunits <- e.getAttrVal('yunits')
	)
}
--@end rule Size

--@begin rule South
rule South {
	from e:XML!Element (
		e.name = 'south'
	)
	to south:KML!South (
		name <- e.name,
		value <- e.getValue().toReal()
	)
}
--@end rule South

--@begin rule Snippet
rule Snippet {
	from e:XML!Element (
		e.name = 'Snippet'
	)
	to snip:KML!Snippet (
		name <- e.name,
		nodes <- text
	),
	text: distinct KML!TextNode foreach (txt in e.getText()) (
		name <- txt.value		
	)
}
--@end rule Snippet

--@begin rule Style
rule Style {
	from e:XML!Element (
		e.name = 'Style'
	)
	to style:KML!Style (
		name <- e.name,
		id <- e.getAttrVal('id'),
		nodes <- e.getChildren(Sequence{'BalloonStyle', 'IconStyle', 'LabelStyle', 'LineStyle', 'PolyStyle'})
	)
}
--@end rule Style

--@begin rule StyleMap
rule StyleMap {
	from e:XML!Element (
		e.name = 'StyleMap'
	)
	to sMap:KML!StyleMap (
		name <- e.name,
		nodes <- e.getChildren(Sequence{'Pair'})
	)
}
--@end rule StyleMap

--@begin rule StyleUrl
rule StyleUrl {
	from e:XML!Element (
		e.name = 'styleUrl'
	)
	to sURL:KML!StyleUrl (
		name <- e.name,
		value <- e.getValue()
	)
}
--@end rule StyleUrl

--@begin rule Tessellate
rule Tessellate {
	from e:XML!Element (
		e.name = 'tessellate'
	)
	to tess:KML!Tessellate (
		name <- e.name,
		value <- e.getValue()
	)
}
--@end rule Tessellate

--@begin rule Text
rule Text {
	from e:XML!Element (
		e.name = 'text'
	)
	to txt:KML!Text (
		name <- e.name,
		nodes <- text,
		nodes <- e.getChildren(Sequence{'textColor'})
	),
	text: distinct KML!TextNode foreach (txt in e.getText()) (
		name <- txt.value		
	)
}
--@end rule Text

--@begin rule TextColor
rule TextColor {
	from e:XML!Element (
		e.name = 'textColor'
	)
	to txtColor:KML!TextColor (
		name <- e.name,
		value <- e.getValue()
	)
}
--@end rule TextColor

--@begin rule Tilt
rule Tilt {
	from e:XML!Element (
		e.name = 'tilt'
	)
	to tilt:KML!Tilt (
		name <- e.name,
		value <- e.getValue()
	)
}
--@end rule Tilt

--@begin rule Type
rule Type {
	from e:XML!Element (
		e.name = 'type'
	)
	to type:KML!Type (
		name <- e.name,
		value <- e.getValue()
	)
}
--@end rule Type

--@begin rule Url
rule Url {
	from e:XML!Element (
		e.name = 'Url'
	)
	to url:KML!Url (
		name <- e.name,
		nodes <- e.getChildren(Sequence{'href', 'refreshInterval', 'refreshMode', 'ViewFormat', 'viewRefreshMode', 'viewRefreshTime'})
	)
}
--@end rule Url

--@begin rule ViewBoundScale
rule ViewBoundScale {
	from e:XML!Element (
		e.name = 'viewBoundScale'
	)
	to viewBS:KML!ViewBoundScale (
		name <- e.name,
		value <- e.getValue()
	)
}
--@end rule ViewBoundScale

--@begin rule ViewRefreshMode
rule ViewRefreshMode {
	from e:XML!Element (
		e.name = 'viewRefreshMode'
	)
	to viewRM:KML!ViewRefreshMode (
		name <- e.name,
		value <- e.getValue()
	)
}
--@end rule ViewRefreshMode

--@begin rule ViewRefreshTime
rule ViewRefreshTime {
	from e:XML!Element (
		e.name = 'viewRefreshTime'
	)
	to viewRT:KML!ViewRefreshTime (
		name <- e.name,
		value <- e.getValue().toInteger()
	)
}
--@end rule ViewRefreshTime

--@begin rule ViewFormat
rule ViewFormat {
	from e:XML!Element (
		e.name = 'viewFormat'
	)
	to viewF:KML!ViewFormat (
		name <- e.name,
		value <- e.getValue()
	)
}
--@end rule ViewFormat

--@begin rule Visibility
rule Visibility {
	from e:XML!Element (
		e.name = 'visibility'
	)
	to vis:KML!Visibility (
		name <- e.name,
		value <- e.getValue()
	)
}
--@end rule Visibility

--@begin rule W
rule W {
	from e:XML!Element (
		e.name = 'w'
	)
	to w:KML!W (
		name <- e.name,
		value <- e.getValue().toInteger()
	)
}
--@end rule W

--@begin rule West
rule West {
	from e:XML!Element (
		e.name = 'west'
	)
	to west:KML!West (
		name <- e.name,
		value <- e.getValue().toReal()
	)
}
--@end rule West

--@begin rule Width
rule Width {
	from e:XML!Element (
		e.name = 'width'
	)
	to width:KML!Width (
		name <- e.name,
		value <- e.getValue().toReal()
	)
}
--@end rule Width

--@begin rule X
rule X {
	from e:XML!Element (
		e.name = 'x'
	)
	to x:KML!X (
		name <- e.name,
		value <- e.getValue().toInteger()
	)
}
--@end rule X

--@begin rule Y
rule Y {
	from e:XML!Element (
		e.name = 'y'
	)
	to y:KML!Y (
		name <- e.name,
		value <- e.getValue().toInteger()
	)
}
--@end rule Y",name xml kml version domain kml googl earth geospati data author eric vepa eric vepa gmail com date descript xml kml transform see kml specif http earth googl com kml kml tag html modul xml kml modul templat creat out kml in xml begin helper getattrv return valu first attribut name name helper context xml element def getattrv name string string self children select c c oclistypeof xml attribut select c c name name notempti self children select c c oclistypeof xml attribut select c c name name first valu els endif end helper getattrv begin helper getchildren return children belong sequenc possibl children helper context xml element def getchildren seq sequenc string sequenc xml element self children select e e ocliskindof xml element select e seq includ e name end helper getchildren begin helper gettext return valid text node helper context xml element def gettext sequenc xml text self children select ocliskindof xml text select name text select valu trim end helper gettext begin helper getalltext return string contain text node helper context xml element def getalltext string self gettext iter str string str concat valu trim concat end helper getalltext begin helper getvalu return valu first text node helper context xml element def getvalu string self gettext first valu trim end helper getvalu begin rule address rule address e xml element e name address adr kml address name e name valu e getvalu end rule address begin rule altitudemod rule altitudemod e xml element e name altitudemod altmod kml altitudemod name e name valu e getvalu relativetoground relativetoground els e getvalu absolut absolut els clampedtoground endif endif end rule altitudemod begin rule balloonstyl rule balloonstyl e xml element e name balloonstyl ball kml balloonstyl name e name node e getchildren sequenc text textcolor color end rule balloonstyl begin rule color rule color e xml element e name color color kml color name e name valu e getvalu end rule color begin rule colormod rule colormod e xml element e name colormod colmod kml colormod name e name valu e getvalu random random els normal endif end rule colormod begin rule cooki rule cooki e xml element e name cooki cook kml cooki name e name valu e getvalu end rule cooki begin rule coordin rule coordin e xml element e name coordin coord kml coordin name e name node coord coord distinct kml coordin foreach c e gettext name c valu trim end rule coordin begin rule descript rule descript e xml element e name descript desc kml descript name e name valu e getalltext end rule descript begin rule document rule document e xml element e name document doc kml document name e name node e getchildren sequenc descript document folder groundoverlay name lookat networklink networklinkcontrol placemark screenoverlay style stylemap visibl end rule document begin rule draword rule draword e xml element e name draword dorder kml draword name e name valu e getvalu tointeg end rule draword begin rule east rule east e xml element e name east east kml east name e name valu e getvalu toreal end rule east begin rule extrud rule extrud e xml element e name extrud extr kml extrud name e name valu e getvalu true els fals endif end rule extrud begin rule fill rule fill e xml element e name fill fill kml fill name e name valu e getvalu fals els true endif end rule fill begin rule folder rule folder e xml element e name folder fd kml folder name e name node e getchildren sequenc descript document folder groundoverlay lookat name networklink open placemark screenoverlay style visibl end rule folder begin rule groundoverlay rule groundoverlay e xml element e name groundoverlay go kml groundoverlay name e name node e getchildren sequenc descript color draword icon latlonbox lookat name visibl end rule groundoverlay begin rule h rule h e xml element e name h h kml h name e name valu e getvalu tointeg end rule h begin rule head rule head e xml element e name head hding kml head name e name valu e getvalu toreal end rule head begin rule href rule href e xml element e name href href kml href name e name valu e getvalu end rule href begin rule icon rule icon e xml element e name icon icon kml icon name e name node e getchildren sequenc h href refreshmod viewrefreshmod w x end rule icon begin rule iconstyl rule iconstyl e xml element e name iconstyl icon kml iconstyl name e name node e getchildren sequenc color colormod head icon scale end rule iconstyl begin rule innerboundaryi rule innerboundaryi e xml element e name innerboundaryi inner kml innerboundaryi name e name node e getchildren sequenc linear end rule innerboundaryi begin rule key rule key e xml element e name key key kml key name e name valu e getvalu end rule key begin rule labelstyl rule labelstyl e xml element e name labelstyl label kml labelstyl name e name node e getchildren sequenc color colormod scale end rule labelstyl begin rule latitud rule latitud e xml element e name latitud lat kml latitud name e name valu e getvalu toreal end rule latitud begin rule latlonbox rule latlonbox e xml element e name latlonbox llb kml latlonbox name e name node e getchildren sequenc east west north south rotat end rule latlonbox begin rule linear rule linear e xml element e name linear lr kml linear name e name node e getchildren sequenc coordin end rule linear begin rule linestr rule linestr e xml element e name linestr ls kml linestr name e name node e getchildren sequenc coordin tessel extrud altitudemod end rule linestr begin rule linestyl rule linestyl e xml element e name linestyl line kml linestyl name e name id e getattrv id node e getchildren sequenc color colormod width end rule linestyl begin rule linkdescript rule linkdescript e xml element e name linkdescript ldesc kml linkdescript name e name valu e getalltext end rule linkdescript begin rule linknam rule linknam e xml element e name linknam lname kml linknam name e name valu e getvalu end rule linknam begin rule longitud rule longitud e xml element e name longitud long kml longitud name e name valu e getvalu toreal end rule longitud begin rule lookat rule lookat e xml element e name lookat la kml lookat name e name node e getchildren sequenc head latitud longitud rang tilt end rule lookat begin rule messag rule messag e xml element e name messag msg kml messag name e name node text text distinct kml textnod foreach txt e gettext name txt valu end rule messag begin rule minrefreshperiod rule minrefreshperiod e xml element e name minrefreshperiod minrp kml minrefreshperiod name e name valu e getvalu end rule minrefreshperiod begin rule multigeometri rule multigeometri e xml element e name multigeometri mgeo kml multigeometri name e name node e getchildren sequenc linestr multigeometri point polygon end rule multigeometri begin rule name rule name e xml element e name name name kml name name e name valu e getvalu end rule name begin rule networklink rule networklink e xml element e name networklink netlink kml networklink name e name node e getchildren sequenc descript name refreshvis url visibl node ftv flytoview ftv kml flytoview name flytoview valu e getchildren sequenc flytoview notempti e getchildren sequenc flytoview first getvalu true els fals endif els fals endif flytoview end rule networklink begin rule networklinkcontrol rule networklinkcontrol e xml element e name networklinkcontrol netlinctrlk kml networklinkcontrol name e name node e getchildren sequenc cooki linkdescript linknam messag minrefreshperiod end rule networklinkcontrol begin rule north rule north e xml element e name north north kml north name e name valu e getvalu toreal end rule north begin rule objarrayfield rule objarrayfield e xml element e name objarrayfield objaf kml objarrayfield name e name node e getchildren sequenc name type end rule objarrayfield begin rule objfield rule objfield e xml element e name objfield objf kml objfield name e name node e getchildren sequenc name type end rule objfield begin rule open rule open e xml element e name open open kml open name e name valu e getvalu end rule open begin rule outerboundaryi rule outerboundaryi e xml element e name outerboundaryi outerbi kml outerboundaryi name e name node e getchildren sequenc linear end rule outerboundaryi begin rule outlin rule outlin e xml element e name outlin kml outlin name e name valu e getvalu end rule outlin begin rule overlayxi rule overlayxi e xml element e name overlayxi kml overlayxi name e name x e getattrv x e getattrv xunit e getattrv xunit yunit e getattrv yunit end rule overlayxi begin rule pair rule pair e xml element e name pair pair kml pair name e name node e getchildren sequenc key styleurl end rule pair begin rule parent rule parent e xml element e name parent parent kml parent name e name valu e getvalu end rule parent begin rule placemark rule placemark e xml element e name placemark pmk kml placemark name e name node e getchildren sequenc address descript lookat linestr multigeometri name point polygon snippet style styleurl visibl end rule placemark begin rule point rule point e xml element e name point pt kml point name e name node e getchildren sequenc coordin tessal extrud altitudemod end rule point begin rule polygon rule polygon e xml element e name polygon poli kml polygon name e name node e getchildren sequenc outerboundaryi innerboundaryi tessel extrud altitudemod end rule polygon begin rule polystyl rule polystyl e xml element e name polystyl poli kml polystyl name e name node e getchildren sequenc color colormod fill outlin end rule polystyl begin rule rang rule rang e xml element e name rang rng kml rang name e name valu e getvalu end rule rang begin rule refreshinterv rule refreshinterv e xml element e name refreshinterv refri kml refreshinterv name e name valu e getvalu end rule refreshinterv begin rule refreshmod rule refreshmod e xml element e name refreshmod refrm kml refreshmod name e name valu e getvalu end rule refreshmod begin rule refreshvis rule refreshvis e xml element e name refreshvis refrv kml refreshvis name e name valu e getvalu end rule refreshvis begin rule rotat rule rotat e xml element e name rotat rot kml rotat name e name valu e getvalu end rule rotat begin rule schema rule schema e xml element e name schema schema kml schema name e name node e getchildren sequenc name parent objfield objarrayfield simplefield simplearrayfield end rule schema begin rule scale rule scale e xml element e name scale scale kml scale name e name valu e getvalu end rule scale begin rule screenoverlay rule screenoverlay e xml element e name screenoverlay scro kml screenoverlay name e name id e getattrv id node e getchildren sequenc descript draword icon overlayxi rotat screenxi size name visibl end rule screenoverlay begin rule screenxi rule screenxi e xml element e name screenxi scrxi kml screenxi name e name x e getattrv x e getattrv xunit e getattrv xunit yunit e getattrv yunit end rule screenxi begin rule simplearrayfield rule simplearrayfield e xml element e name simplearrayfield saf kml simplearrayfield name e name node e getchildren sequenc name type end rule simplearrayfield begin rule simplefield rule simplefield e xml element e name simplefield sf kml simplefield name e name node e getchildren sequenc name type end rule simplefield begin rule size rule size e xml element e name size size kml size name e name x e getattrv x e getattrv xunit e getattrv xunit yunit e getattrv yunit end rule size begin rule south rule south e xml element e name south south kml south name e name valu e getvalu toreal end rule south begin rule snippet rule snippet e xml element e name snippet snip kml snippet name e name node text text distinct kml textnod foreach txt e gettext name txt valu end rule snippet begin rule style rule style e xml element e name style style kml style name e name id e getattrv id node e getchildren sequenc balloonstyl iconstyl labelstyl linestyl polystyl end rule style begin rule stylemap rule stylemap e xml element e name stylemap smap kml stylemap name e name node e getchildren sequenc pair end rule stylemap begin rule styleurl rule styleurl e xml element e name styleurl surl kml styleurl name e name valu e getvalu end rule styleurl begin rule tessel rule tessel e xml element e name tessel tess kml tessel name e name valu e getvalu end rule tessel begin rule text rule text e xml element e name text txt kml text name e name node text node e getchildren sequenc textcolor text distinct kml textnod foreach txt e gettext name txt valu end rule text begin rule textcolor rule textcolor e xml element e name textcolor txtcolor kml textcolor name e name valu e getvalu end rule textcolor begin rule tilt rule tilt e xml element e name tilt tilt kml tilt name e name valu e getvalu end rule tilt begin rule type rule type e xml element e name type type kml type name e name valu e getvalu end rule type begin rule url rule url e xml element e name url url kml url name e name node e getchildren sequenc href refreshinterv refreshmod viewformat viewrefreshmod viewrefreshtim end rule url begin rule viewboundscal rule viewboundscal e xml element e name viewboundscal viewb kml viewboundscal name e name valu e getvalu end rule viewboundscal begin rule viewrefreshmod rule viewrefreshmod e xml element e name viewrefreshmod viewrm kml viewrefreshmod name e name valu e getvalu end rule viewrefreshmod begin rule viewrefreshtim rule viewrefreshtim e xml element e name viewrefreshtim viewrt kml viewrefreshtim name e name valu e getvalu tointeg end rule viewrefreshtim begin rule viewformat rule viewformat e xml element e name viewformat viewf kml viewformat name e name valu e getvalu end rule viewformat begin rule visibl rule visibl e xml element e name visibl vis kml visibl name e name valu e getvalu end rule visibl begin rule w rule w e xml element e name w w kml w name e name valu e getvalu tointeg end rule w begin rule west rule west e xml element e name west west kml west name e name valu e getvalu toreal end rule west begin rule width rule width e xml element e name width width kml width name e name valu e getvalu toreal end rule width begin rule x rule x e xml element e name x x kml x name e name valu e getvalu tointeg end rule x begin rule y rule y e xml element e name kml y name e name valu e getvalu tointeg end rule y,9
83,83,P45-A2B.atl,"-- @path A=/ListMetamodelRefactoring/Metamodel/TypeA.ecore
-- @path B=/ListMetamodelRefactoring/Metamodel/TypeB.ecore

module A2B;
create OUT : B from IN : A;

-- This rule transforms a RootA into RootB.
-- An ElementB is created from the name of RootA and it is placed at the first position of the list.
rule Root {
	from
		s : A!RootA
	to
		t : B!RootB(
			elms <- OrderedSet {first_element, s.elms}
		),
		first_element : B!ElementB(
			name <- 'B_' + s.name
		)
}

-- This rule transforms an ElementA into an ElementB.
-- 'B_' is prefixed to the name of each ElementB
rule Element {
	from
		s : A!ElementA
	to
		t : B!ElementB(
			name <- 'B_' + s.name
		)
}",path a listmetamodelrefactor metamodel typea ecor path b listmetamodelrefactor metamodel typeb ecor modul a b creat out b in a this rule transform roota rootb an elementb creat name roota place first posit list rule root a roota b rootb elm orderedset first element elm first element b elementb name b name this rule transform elementa elementb b prefix name elementb rule element a elementa b elementb name b name,4
84,84,P46-Ant2XML.atl,"module Ant2XML;
create OUT : XML from IN : Ant;

-- concatene a list of String
-- the elements are separated by a comma
helper def: concat(list : Sequence(String)) : String =
	list -> asSet() -> iterate(element ;acc : String = '' |
								acc +
									if acc = ''
									then element
									else ',' + element
								endif);

-- rule for a project having a description
rule Project2Root{
	from i : Ant!Project(
		if i.description.oclIsUndefined() 
			then false
			else not(i.description='')
			endif
	)
	to o : XML!Root(
		name <- 'project',
		children <- Sequence {itsName,itsDescription,itsBasedir,itsDefaultTarget,i.properties,i.path,i.taskdef,i.targets}
	),
	 itsName : XML!Attribute(
		name <- 'name',
		value <- i.name
	),
	itsDescription : XML!Element(
		name <- 'description',
		children <- textText
	),
	textText : XML!Text(
		value <- i.description
	),
	 itsBasedir : XML!Attribute(
		name <- 'basedir',
		value <- i.basedir
	),
	itsDefaultTarget : XML!Attribute(
		name <- 'default',
		value <- i.default.name
	)
}

-- rule for a project without description
rule Project2RootWithoutDescription{
	from i : Ant!Project(
		if i.description.oclIsUndefined() 
			then true
			else i.description=''
			endif
	)
	to o : XML!Root(
		name <- 'project',
		children <- Sequence {itsName,itsBasedir,itsDefaultTarget,i.properties,i.path,i.taskdef,i.targets}
	),
	 itsName : XML!Attribute(
		name <- 'name',
		value <- i.name
	),
	 itsBasedir : XML!Attribute(
		name <- 'basedir',
		value <- i.basedir
	),
	itsDefaultTarget : XML!Attribute(
		name <- 'default',
		value <- i.default.name
	)
}

------------------------------------------------------------------------------------
-- properties

rule PropertyValue{
	from i : Ant!PropertyValue
	to o : XML!Element(
		name <- 'property',
		children <- Sequence{propertyName2,propertyValue}
	),
	propertyName2 : XML!Attribute(
		name <- 'name',
		value <- i.name
	),
	propertyValue : XML!Attribute(
		name <- 'value',
		value <- i.value
	)
}

rule PropertyLocation{
	from i : Ant!PropertyLocation
	to o : XML!Element(
		name <- 'property',
		children <- Sequence{propertyName2,propertyLocation}
	),
	propertyName2 : XML!Attribute(
		name <- 'name',
		value <- i.name
	),
	propertyLocation : XML!Attribute(
		name <- 'location',
		value <- i.location
	)
}



rule PropertyFile{
	from i : Ant!PropertyFile
	to o : XML!Element(
		name <- 'property',
		children <- nameFile
	),
	nameFile : XML!Attribute(
		name <- 'file',
		value <- i.file
	)
}

rule PropertyEnv{
	from i : Ant!PropertyEnv
	to o : XML!Element(
		name <- 'property',
		children <- environmentName
	),
	environmentName : XML!Attribute(
		name <- 'environment',
		value <- i.environment
	)
}



------------------------------------------------------------------------
-- target
rule TargetWithDescription{
	from i : Ant!Target(
		if i.description.oclIsUndefined() 
			then false
			else not (i.description='')
			endif
	)
	to o : XML!Element(
		name <- 'target',
		children <- Sequence{nameAttribute,descriptionElement,dependsAttribute,i.tasks}
   ),
	nameAttribute : XML!Attribute(
		name <- 'name',
		value <- i.name
	),
	descriptionElement : XML!Element(
		name <- 'description',
		children <- descriptionText
	),
	descriptionText : XML!Text(
		value <- i.description
	),
	dependsAttribute : XML!Attribute(
		name <- 'depends',
		value <- thisModule.concat(i.depends -> collect(e|e.name))
	)
 }

rule TargetWithoutDescription{
	from i : Ant!Target(
		if i.description.oclIsUndefined() 
			then true
			else i.description=''
			endif
	)
	to o : XML!Element(
		name <- 'target',
		children <- Sequence{nameAttribute,dependsAttribute,i.tasks}
   ),
	nameAttribute : XML!Attribute(
		name <- 'name',
		value <- i.name
	),
	dependsAttribute : XML!Attribute(
		name <- 'depends',
		value <- thisModule.concat(i.depends -> collect(e|e.name))
	)
 }
--------------------------------------------------------------------------------------
-- tasks


------------------------------
-- task defined by the user

-- taskdef (definition of the task)
rule TaskDef{
	from i : Ant!TaskDef
	to o : XML!Element(
		name <- 'taskdef',
		children <- Sequence{nameName,nameClassName}
	),
	nameName : XML!Attribute(
		name <- 'name',
		value <- i.name
	),
	nameClassName : XML!Attribute(
		name <- 'classname',
		value <- i.classname
	)
}


rule NewTask{
	from i : Ant!NewTask
	to o : XML!Element(
		name <- i.taskName.name,
		children <- i.attributes
	)
}

rule Attribut{
	from i : Ant!Attribut
	to o : XML!Attribute(
		name <- i.name,
		value <- i.value
	)
}

----------------------------------
-- pre-defined tasks
rule Tstamp{
	from i : Ant!Tstamp
	to o : XML!Element(
		name <- 'tstamp'
	)
}

rule Mkdir{
	from i : Ant!Mkdir
	to o : XML!Element(
		name <- 'mkdir',
		children <- dirAttribute
	),
	dirAttribute : XML!Attribute(
		name <- 'dir',
		value <- i.dir
	)
}

rule Javac{
	from i : Ant!Javac
	to o : XML!Element(
		name <- 'javac',
		children <- Sequence{sourceDirAttribute,destDirAttribute,i.inExcludes,i.classPath}
	),
	sourceDirAttribute : XML!Attribute(
		name <- 'srcdir',
		value <- i.srcdir
	),
	destDirAttribute : XML!Attribute(
		name <- 'destdir',
		value <- i.destdir
	)
}

rule Copy{
	from i : Ant!Copy
	to o : XML!Element(
		name <- 'copy',
		children <- Sequence{toDirAttribute,i.fileset}
	),
	toDirAttribute : XML!Attribute(
		name <- 'todir',
		value <- i.todir
	)
}


rule Exec{
	from i : Ant!Exec
	to o : XML!Element(
		name <- 'exec',
		children <- execAttribute
	),
	execAttribute : XML!Attribute(
		name <- 'executable',
		value <- i.executable
	)
}

rule Echo{
	from i : Ant!Echo
	to o : XML!Element(
		name <- 'echo',
		children <- echoAttribute
	),
	echoAttribute : XML!Attribute(
		name <- 'message',
		value <- i.message
	)
}
---------------------------------------------------------------------------------
-- path

-- this takes only the attribute 'id' (not 'refid')
rule Path{
	from i : Ant!Path
	to o : XML!Element(
		name <- 'path',
		children <- Sequence{idAttribute,i.fileset,i.path,i.pathElement}
	),
	idAttribute : XML!Attribute(
		name <- 'id',
		value <- i.id
	)
}

rule ClassPath{
	from i : Ant!ClassPath
	to o : XML!Element(
		name <- 'classpath',
		children <- refidAttribute),
	refidAttribute : XML!Attribute(
		name <- 'refid',
		value <- i.refid
	)
}

rule Fileset{
	from i : Ant!FileSet
	to o : XML!Element(
		name <- 'fileset',
		children <- Sequence{dirAttribute,i.patternset,i.include,i.exclude}
	),
	dirAttribute : XML!Attribute(
		name <- 'dir',
		value <- i.dir
	)
}

rule PathElement{
	from i : Ant!PathElement
	to o : XML!Element(
		name <- 'pathelement'
	)
}

rule PatternSet{
	from i : Ant!PatternSet
	to o : XML!Element(
		name <- 'patternset',
		children <- i.inexcludes
	)
}

rule Include{
	from i : Ant!Includes
	to o : XML!Element(
		name <- 'include',
		children <- nameAttribute
	),
	nameAttribute : XML!Attribute(
		name <- 'name',
		value <- i.name
	)
}

rule Exclude{
	from i : Ant!Excludes
	to o : XML!Element(
		name <- 'exclude',
		children <- nameAttribute
	),
	nameAttribute : XML!Attribute(
		name <- 'name',
		value <- i.name
	)
}",modul ant xml creat out xml in ant concaten list string element separ comma helper def concat list sequenc string string list asset iter element acc string acc acc element els element endif rule project descript rule project root ant project descript oclisundefin fals els descript endif xml root name project children sequenc itsnam itsdescript itsbasedir itsdefaulttarget properti path taskdef target itsnam xml attribut name name valu name itsdescript xml element name descript children texttext texttext xml text valu descript itsbasedir xml attribut name basedir valu basedir itsdefaulttarget xml attribut name default valu default name rule project without descript rule project rootwithoutdescript ant project descript oclisundefin true els descript endif xml root name project children sequenc itsnam itsbasedir itsdefaulttarget properti path taskdef target itsnam xml attribut name name valu name itsbasedir xml attribut name basedir valu basedir itsdefaulttarget xml attribut name default valu default name properti rule propertyvalu ant propertyvalu xml element name properti children sequenc propertynam propertyvalu propertynam xml attribut name name valu name propertyvalu xml attribut name valu valu valu rule propertyloc ant propertyloc xml element name properti children sequenc propertynam propertyloc propertynam xml attribut name name valu name propertyloc xml attribut name locat valu locat rule propertyfil ant propertyfil xml element name properti children namefil namefil xml attribut name file valu file rule propertyenv ant propertyenv xml element name properti children environmentnam environmentnam xml attribut name environ valu environ target rule targetwithdescript ant target descript oclisundefin fals els descript endif xml element name target children sequenc nameattribut descriptionel dependsattribut task nameattribut xml attribut name name valu name descriptionel xml element name descript children descriptiontext descriptiontext xml text valu descript dependsattribut xml attribut name depend valu thismodul concat depend collect e e name rule targetwithoutdescript ant target descript oclisundefin true els descript endif xml element name target children sequenc nameattribut dependsattribut task nameattribut xml attribut name name valu name dependsattribut xml attribut name depend valu thismodul concat depend collect e e name task task defin user taskdef definit task rule taskdef ant taskdef xml element name taskdef children sequenc namenam nameclassnam namenam xml attribut name name valu name nameclassnam xml attribut name classnam valu classnam rule newtask ant newtask xml element name tasknam name children attribut rule attribut ant attribut xml attribut name name valu valu pre defin task rule tstamp ant tstamp xml element name tstamp rule mkdir ant mkdir xml element name mkdir children dirattribut dirattribut xml attribut name dir valu dir rule javac ant javac xml element name javac children sequenc sourcedirattribut destdirattribut inexclud classpath sourcedirattribut xml attribut name srcdir valu srcdir destdirattribut xml attribut name destdir valu destdir rule copi ant copi xml element name copi children sequenc todirattribut fileset todirattribut xml attribut name todir valu todir rule exec ant exec xml element name exec children execattribut execattribut xml attribut name execut valu execut rule echo ant echo xml element name echo children echoattribut echoattribut xml attribut name messag valu messag path take attribut id refid rule path ant path xml element name path children sequenc idattribut fileset path pathel idattribut xml attribut name id valu id rule classpath ant classpath xml element name classpath children refidattribut refidattribut xml attribut name refid valu refid rule fileset ant fileset xml element name fileset children sequenc dirattribut patternset includ exclud dirattribut xml attribut name dir valu dir rule pathel ant pathel xml element name pathel rule patternset ant patternset xml element name patternset children inexclud rule includ ant includ xml element name includ children nameattribut nameattribut xml attribut name name valu name rule exclud ant exclud xml element name exclud children nameattribut nameattribut xml attribut name name valu name,0
85,85,P46-Make2Ant.atl,"module Make2Ant;
create OUT : Ant from IN : Make;

-- rule Makefile2Project:  its the 'main' rule.
-- This rule generates the Project element.
-- Its attributes are the name and the description of the makefile.
-- It contains properties, targets of the makefile.
-- It defines also the target called by default.
rule Makefile2Project{
	from
		m : Make!Makefile
	to
		a : Ant!Project(
			name       <- m.name,
			description <- m.comment.text,
			properties <- m.elements ->
				select(c | c.oclIsKindOf(Make!Macro)),
			targets    <- m.elements ->
				select(c | c.oclIsKindOf(Make!Rule)),
			default    <- m.elements ->
				select(c | c.oclIsKindOf(Make!Rule)) -> first()
		)
}

-- rule Macro2Property:
-- This rule generates a Property.
-- Its attributes are the name and the value of the Macro.
rule Macro2Property{
	from
		m : Make!Macro
	to
		a : Ant!PropertyValue(
			name  <- m.name,
			value <- m.value
		)
}

-- rule Rule2Target:
-- This rule generates a Target.
-- Its attribute is the name of the rule.
-- It contains tasks.
-- It can be dependent of others targets.
rule Rule2Target{
	from
		m : Make!Rule
	to
		a:Ant!Target(
			name    <- m.name,
			tasks <- m.shellLines,
			depends <- m.dependencies ->
							select(e | e.oclIsKindOf(Make!RuleDep)) ->
								collect(e | e.ruledep)
		)
}

-- rule ShellLine2Task_Display
-- This rule is started when the attribute display is true.
-- This rule generate a Task Echo and a Task Exec.
rule ShellLine2Task_Display{
	from
		m : Make!ShellLine(
				m.display
			)
	to
		e:Ant!Echo(
			message <- m.command,
			target <- m.ruleShellLine
		),
		x:Ant!Exec(
			executable <- m.command,
			target <- m.ruleShellLine
		)
}

-- rule ShellLine2Task_Display
-- This rule is started when the attribute display is false.
-- This rule generate only a Task Exec.
rule ShellLine2Task_NoDisplay{
	from
		m : Make!ShellLine(
				not m.display
			)
	to
		x:Ant!Exec(
			executable <- m.command,
			target <- m.ruleShellLine
		)
}
",modul make ant creat out ant in make rule makefil project main rule this rule generat project element it attribut name descript makefil it contain properti target makefil it defin also target call default rule makefil project make makefil ant project name name descript comment text properti element select c c ocliskindof make macro target element select c c ocliskindof make rule default element select c c ocliskindof make rule first rule macro properti this rule generat properti it attribut name valu macro rule macro properti make macro ant propertyvalu name name valu valu rule rule target this rule generat target it attribut name rule it contain task it depend other target rule rule target make rule ant target name name task shelllin depend depend select e e ocliskindof make ruledep collect e e ruledep rule shelllin task display this rule start attribut display true this rule generat task echo task exec rule shelllin task display make shelllin display e ant echo messag command target ruleshelllin x ant exec execut command target ruleshelllin rule shelllin task display this rule start attribut display fals this rule generat task exec rule shelllin task nodisplay make shelllin display x ant exec execut command target ruleshelllin,3
86,86,P46-XML2Make.atl,"module XML2Make;
create OUT : Make from IN : XML;

----------------------------------------------------------------------------------
-- helper : to extract a list of String from a String

-- extract a sequence of String from the String listString in the same order
-- (two elements are separated by a comma)
helper def:getList(listString : String):Sequence(String)=
	if(listString.size()=0)
		then Sequence{}
		else thisModule.getListAux(listString,1,1,Sequence{})
		endif;

-- index1 : begin of the word
-- index2 : compteur
helper def:getListAux(listString : String,index1 : Integer,index2 : Integer,provSequence : Sequence(String)):Sequence(String)=
	--let car : Sequence(String) = listString.substring(index2,index2) in
	if (listString.size()<index2)
		then provSequence -> append(listString.substring(index1,index2-1))
		else
			if listString.substring(index2,index2)=' ' --or(car='\t'))and not index1=index2
				then thisModule.getListAux(listString,index2+1,index2+1, provSequence -> append(listString.substring(index1,index2-1)))
				else thisModule.getListAux(listString,index1,index2+1, provSequence)
			endif
	endif;
------------------------------------------------------------------------------------------
-- helper : to get an attribute

-- returns the value of the attribute 'name' (without test of existence)
helper context XML!Element def: getAttrVal(name : String) : String =
    self.children->
		select(c | c.oclIsKindOf(XML!Attribute) and c.name = name)
			->first().value;

-- returns true if the attribute 'name' is defined
helper context XML!Element def: testAttribute(name : String) : Boolean =
	not (self.children -> select(d | d.oclIsKindOf(XML!Attribute) and d.name = name)->
		first().oclIsUndefined());


-- returns the value of the attribute given in parameter
-- returns '' if this attribute does not exist
helper context XML!Element def:getAttribute(name : String):String = 
	if (self.testAttribute(name))
		then self.getAttrVal(name)
		else ''
		endif;

-----------------------------------------------------------------------------------
-- returns the value  of a text belonging to an element
helper context XML!Element def: getText() : String =
    	self.children ->
					select(c | c.oclIsKindOf(XML!Text)) -> 
						first().value;



-----------------------------------------------------------------------------------
-- rules

-- central rule
rule Root2MakeFile{
	from i : XML!Root
	to o : Make!Makefile(
		name <- 'makefile',
		comment <- i.children ->
					select(d | d.oclIsKindOf(XML!Element) and d.name = 'comment')
						-> first(),
		elements <- i.children ->
					select(d | d.oclIsKindOf(XML!Element) and not (d.name = 'comment'))
	)
}

rule Comment{
	from i : XML!Element(
		i.name = 'comment'
	)
	to o : Make!Comment(
		text <- i.getText()
	)
}

rule Rule{
	from i : XML!Element(
		i.name = 'rule'
	)
	using{
	allRules : Sequence(XML!Element) = XML!Element.allInstances() ->
			select(d |  d.name = 'rule' );
	itsDependencies : Sequence(String) = thisModule.getList(i.getAttribute('depends'));
	itsRuleDep : Sequence(XML!Element) = XML!Element.allInstances() ->
			select(d |  d.name = 'rule' 
				and itsDependencies ->
						includes( d.getAttribute('name')));
	itsFileDep : Sequence(String) = itsDependencies ->
				select(d | allRules -> select(e|e.getAttribute('name')=d)-> isEmpty()) ;
	}
	to o : Make!Rule(
		name <- i.getAttribute('name'),
		dependencies <-  Sequence{makeRuleDep,makeFileDep},
		shellLines <-  i.children ->
					select(d | d.oclIsKindOf(XML!Element) and d.name = 'shellLine')
	),
	makeRuleDep : distinct Make!RuleDep foreach(dep in itsRuleDep)(
		ruledep	<- dep
	),
	makeFileDep : distinct Make!FileDep foreach(depFile in itsFileDep)(
		name <- depFile
	)		
}


rule Macro{
	from i : XML!Element(
		i.name = 'macro'
	)
	to o : Make!Macro(
		name <- i.getAttribute('name'),
		value <- i.getAttribute('value')
	)
}

helper context XML!Element def : getShellLine():String=
	let thisText : String = self.getText() in
	if (thisText.substring(1,1)='@')
		then thisText.substring(2,thisText.size())
		else thisText
		endif;

rule ShellLine{
	from i : XML!Element(
		i.name = 'shellLine'
	)
	to o  : Make!ShellLine(
		command <- i.getShellLine(),
		display <- not (i.getText().substring(1,1)='@')
	)
}",modul xml make creat out make in xml helper extract list string string extract sequenc string string liststr order two element separ comma helper def getlist liststr string sequenc string liststr size sequenc els thismodul getlistaux liststr sequenc endif index begin word index compteur helper def getlistaux liststr string index integ index integ provsequ sequenc string sequenc string let car sequenc string liststr substr index index liststr size index provsequ append liststr substr index index els liststr substr index index car index index thismodul getlistaux liststr index index provsequ append liststr substr index index els thismodul getlistaux liststr index index provsequ endif endif helper get attribut return valu attribut name without test exist helper context xml element def getattrv name string string self children select c c ocliskindof xml attribut c name name first valu return true attribut name defin helper context xml element def testattribut name string boolean self children select ocliskindof xml attribut name name first oclisundefin return valu attribut given paramet return attribut exist helper context xml element def getattribut name string string self testattribut name self getattrv name els endif return valu text belong element helper context xml element def gettext string self children select c c ocliskindof xml text first valu rule central rule rule root makefil xml root make makefil name makefil comment children select ocliskindof xml element name comment first element children select ocliskindof xml element name comment rule comment xml element name comment make comment text gettext rule rule xml element name rule use allrul sequenc xml element xml element allinst select name rule itsdepend sequenc string thismodul getlist getattribut depend itsruledep sequenc xml element xml element allinst select name rule itsdepend includ getattribut name itsfiledep sequenc string itsdepend select allrul select e e getattribut name isempti make rule name getattribut name depend sequenc makeruledep makefiledep shelllin children select ocliskindof xml element name shelllin makeruledep distinct make ruledep foreach dep itsruledep ruledep dep makefiledep distinct make filedep foreach depfil itsfiledep name depfil rule macro xml element name macro make macro name getattribut name valu getattribut valu helper context xml element def getshelllin string let thistext string self gettext thistext substr thistext substr thistext size els thistext endif rule shelllin xml element name shelllin make shelllin command getshelllin display gettext substr,0
87,87,P46-XML2Text.atl,"query XML2Text = XML!Root.allInstances()
		->asSequence()
		->first().toString2('').writeTo('G:\\eclipseATL\\workspace\\MakeAntAndMaven\\example1\\project.xml');


helper context XML!Element def: toString2(indent : String) : String =
	let na : Sequence(XML!Node) =
		self.children->select(e | not e.oclIsKindOf(XML!Attribute)) in
	let a : Sequence(XML!Node) =
		self.children->select(e | e.oclIsKindOf(XML!Attribute)) in
	indent + '<' + self.name + 
	a->iterate(e; acc : String = '' |
		acc + ' ' + e.toString2()
	) +
	if na->size() > 0 then
		'>'
		+ na->iterate(e; acc : String = '' |
			acc + 
			if e.oclIsKindOf(XML!Text) then
				''
			else
				'\r\n'
			endif
			+ e.toString2(indent + '  ')
		) +
		if na->first().oclIsKindOf(XML!Text) then
			'</' + self.name + '>'
			else
				'\r\n' + indent + '</' + self.name + '>'
		endif
	else
		'/>'
	endif;

	
helper context XML!Attribute def: toString2() : String =
	if (self.value.oclIsUndefined())or(self.value='')
		then ''
		else self.name + '=\""' + self.value + '\""'
		endif;
--self.name + '=\""' + self.value + '\""';

helper context XML!Text def: toString2() : String =
	self.value;
",queri xml text xml root allinst assequ first tostr writeto g eclipseatl workspac makeantandmaven exampl project xml helper context xml element def tostr indent string string let na sequenc xml node self children select e e ocliskindof xml attribut let sequenc xml node self children select e e ocliskindof xml attribut indent self name iter e acc string acc e tostr na size na iter e acc string acc e ocliskindof xml text els r n endif e tostr indent na first ocliskindof xml text self name els r n indent self name endif els endif helper context xml attribut def tostr string self valu oclisundefin self valu els self name self valu endif self name self valu helper context xml text def tostr string self valu,5
88,88,P47-partial2totalRole-context.atl,"module Replace; -- Module Template
create OUT : KM3target from IN : KM3;

--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3target!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
--@end rule Metamodel

--@begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3target!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
--@end rule Package

--@begin Class 
rule ClassWithPartialOrder {
	from
		inputClass:KM3!Class (
			not(inputClass.structuralFeatures->select(r|(r.upper=1)and(r.lower=0))->isEmpty())	
		)
		
	to
		outputClass:KM3target!Class (
			name <- inputClass.name,
			isAbstract <- inputClass.isAbstract,
			structuralFeatures <- inputClass.structuralFeatures,
			supertypes <- inputClass.supertypes
		),
		totalOrderClass : KM3target!Class (
			name <- inputClass.name+'TotalOrder',
			isAbstract <- true,
			package <- inputClass.package,
			supertypes <- inputClass.structuralFeatures->iterate(a;acc:Sequence(KM3!Class)=Sequence{}|
																	if (a->oclIsKindOf(KM3!Reference)) 
																		then acc->including(a.opposite.owner)
																		else acc->union(Sequence{})
																		endif)
		)
}
--@end Class

--@begin Class 
rule ClassWithoutPartialOrder {
	from
		inputClass:KM3!Class (
			inputClass.structuralFeatures->select(r|(r.upper=1)and(r.lower=0))->isEmpty()
		)
		
	to
		outputClass:KM3target!Class (
			name <- inputClass.name,
			isAbstract <- inputClass.isAbstract,
			structuralFeatures <- inputClass.structuralFeatures,
			supertypes <- inputClass.supertypes
		)
}
--@end Class

--@begin reference partial order
rule referencePartialOrder {
	from 
		inputRef : KM3!Reference (
			inputRef.upper = 1 and inputRef.lower = 0
		)
	to
		outputRef : KM3target!Reference (
			name <- inputRef.opposite.owner.name+'TotalOrder',
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			location <- inputRef.location,
			lower <- 1,
			upper <- 1,
			type <- KM3target!Class.allInstances()->select(a|a.name=inputRef.owner.name+'TotalOrder')->asSequence()->first(),
			owner <- inputRef.owner,
			opposite <- inputRef.opposite
		),
		outputOppositeRef : KM3target!Reference (
			name <- inputRef.opposite.owner.name+'OppositeTotalOrder',
			isOrdered <- inputRef.opposite.isOrdered,
			isUnique <- inputRef.opposite.isUnique,
			location <- inputRef.opposite.location,
			lower <- 1,
			upper <- 1,
			type <- inputRef.opposite.type,
			owner <- KM3target!Class.allInstances()->select(a|a.name=inputRef.owner.name+'TotalOrder')->asSequence()->first(),
			opposite <- outputRef
		)
}

--@begin rule attribute 
rule attribute {
	from
		inputAtt:KM3!Attribute 
	to
		outputAtt:KM3target!Attribute(
			name <- inputAtt.name,
			isOrdered <- inputAtt.isOrdered,
			isUnique <- inputAtt.isUnique,
			location <- inputAtt.location,
			lower <- inputAtt.lower,
			upper <- inputAtt.upper,
			type <- inputAtt.type,
			owner <- inputAtt.owner
			
		)
}
--@end rule attribute

--@begin rule DataType
rule DataType {
from
		inputData:KM3!DataType
	to
		outputData:KM3target!DataType(
			name <- inputData.name,
			location <- inputData.location
		)
}
--@end rule DataType

--@begin reference
rule reference {
	from
		inputRef:KM3!Reference (
			not(inputRef.upper = 1 and 	inputRef.lower = 0) and
			not(inputRef.opposite.upper = 1 and inputRef.opposite.lower = 0)
		)
	to
		outputRef:KM3target!Reference (
			name <- inputRef.name,
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			location <- inputRef.location,
			lower <- inputRef.lower,
			upper <- inputRef.upper,
			type <- inputRef.type,
			owner <- inputRef.owner,
			opposite <- inputRef.opposite
		)
}
--@end reference

--@begin enumeration
rule enumeration {
	from
		inputEnum:KM3!Enumeration 
	to
		outputEnum:KM3target!Enumeration (
			location <- inputEnum.location,
			name  <- inputEnum.name,
			package  <- inputEnum.package
		)

}
--@end enumeration

--@begin literal
rule literal {
	from
		inputEnum:KM3!EnumLiteral
	to
		outputEnum:KM3target!EnumLiteral (
			location <- inputEnum.location,
			name  <- inputEnum.name,
			enum  <- inputEnum.enum
		)

}
--@end literal
",modul replac modul templat creat out km target in km begin rule metamodel rule metamodel inputmm km metamodel outputmm km target metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km target packag name inputpkg name content inputpkg content end rule packag begin class rule classwithpartialord inputclass km class inputclass structuralfeatur select r r upper r lower isempti outputclass km target class name inputclass name isabstract inputclass isabstract structuralfeatur inputclass structuralfeatur supertyp inputclass supertyp totalorderclass km target class name inputclass name totalord isabstract true packag inputclass packag supertyp inputclass structuralfeatur iter acc sequenc km class sequenc ocliskindof km refer acc includ opposit owner els acc union sequenc endif end class begin class rule classwithoutpartialord inputclass km class inputclass structuralfeatur select r r upper r lower isempti outputclass km target class name inputclass name isabstract inputclass isabstract structuralfeatur inputclass structuralfeatur supertyp inputclass supertyp end class begin refer partial order rule referencepartialord inputref km refer inputref upper inputref lower outputref km target refer name inputref opposit owner name totalord isord inputref isord isuniqu inputref isuniqu locat inputref locat lower upper type km target class allinst select name inputref owner name totalord assequ first owner inputref owner opposit inputref opposit outputoppositeref km target refer name inputref opposit owner name oppositetotalord isord inputref opposit isord isuniqu inputref opposit isuniqu locat inputref opposit locat lower upper type inputref opposit type owner km target class allinst select name inputref owner name totalord assequ first opposit outputref begin rule attribut rule attribut inputatt km attribut outputatt km target attribut name inputatt name isord inputatt isord isuniqu inputatt isuniqu locat inputatt locat lower inputatt lower upper inputatt upper type inputatt type owner inputatt owner end rule attribut begin rule datatyp rule datatyp inputdata km datatyp outputdata km target datatyp name inputdata name locat inputdata locat end rule datatyp begin refer rule refer inputref km refer inputref upper inputref lower inputref opposit upper inputref opposit lower outputref km target refer name inputref name isord inputref isord isuniqu inputref isuniqu locat inputref locat lower inputref lower upper inputref upper type inputref type owner inputref owner opposit inputref opposit end refer begin enumer rule enumer inputenum km enumer outputenum km target enumer locat inputenum locat name inputenum name packag inputenum packag end enumer begin liter rule liter inputenum km enumliter outputenum km target enumliter locat inputenum locat name inputenum name enum inputenum enum end liter,8
89,89,P47-partial2totalRole-without.atl,"-- @name	 Making partial role total (a)
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		Baudry Julien (jul.baudry<at>gmail.com)
-- @date		2006/08/02
-- @description	The purpose of this transformation is to making a patial role total
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 2.14, page 23
-- @see author of article : K. Lano

module Replace; -- Module Template
create OUT : KM3target from IN : KM3;

--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3target!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
--@end rule Metamodel

--@begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3target!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
--@end rule Package

--@begin ClassWithPartialOrder
rule ClassWithPartialOrder {
	from
		inputClass:KM3!Class (
			not(inputClass.structuralFeatures->select(r|(r.upper=1)and(r.lower=0))->isEmpty())	
		)
		
	to
		outputClass:KM3target!Class (
			name <- inputClass.name,
			isAbstract <- inputClass.isAbstract,
			structuralFeatures <- inputClass.structuralFeatures,
			supertypes <- inputClass.supertypes
		),
		totalOrderClass : KM3target!Class (
			name <- inputClass.name+'TotalOrder',
			isAbstract <- true,
			package <- inputClass.package,
			supertypes <- inputClass.structuralFeatures->iterate(a;acc:Sequence(KM3!Class)=Sequence{}|
																	acc->including(a.opposite.owner))	
		)
}
--@end ClassWithPartialOrder

--@begin ClassWithoutPartialOrder
rule ClassWithoutPartialOrder {
	from
		inputClass:KM3!Class (
			inputClass.structuralFeatures->select(r|(r.upper=1)and(r.lower=0))->isEmpty()
		)
		
	to
		outputClass:KM3target!Class (
			name <- inputClass.name,
			isAbstract <- inputClass.isAbstract,
			structuralFeatures <- inputClass.structuralFeatures,
			supertypes <- inputClass.supertypes
		)
}
--@end ClassWithoutPartialOrder

--@begin reference partial order
rule referencePartialOrder {
	from 
		inputRef : KM3!Reference (
			inputRef.upper = 1 and inputRef.lower = 0
		)
	to
		outputRef : KM3target!Reference (
			name <- inputRef.opposite.owner.name+'TotalOrder',
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			location <- inputRef.location,
			lower <- 1,
			upper <- 1,
			type <- KM3target!Class.allInstances()->select(a|a.name=inputRef.owner.name+'TotalOrder')->asSequence()->first(),
			owner <- inputRef.owner,
			opposite <- inputRef.opposite
		),
		outputOppositeRef : KM3target!Reference (
			name <- inputRef.opposite.owner.name+'OppositeTotalOrder',
			isOrdered <- inputRef.opposite.isOrdered,
			isUnique <- inputRef.opposite.isUnique,
			location <- inputRef.opposite.location,
			lower <- 1,
			upper <- 1,
			type <- inputRef.opposite.type,
			owner <- KM3target!Class.allInstances()->select(a|a.name=inputRef.owner.name+'TotalOrder')->asSequence()->first(),
			opposite <- outputRef
		)
}
--@end reference partial order",name make partial role total version domain catalogu model transform author baudri julien jul baudri gmail com date descript the purpos transform make patial role total see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul replac modul templat creat out km target in km begin rule metamodel rule metamodel inputmm km metamodel outputmm km target metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km target packag name inputpkg name content inputpkg content end rule packag begin classwithpartialord rule classwithpartialord inputclass km class inputclass structuralfeatur select r r upper r lower isempti outputclass km target class name inputclass name isabstract inputclass isabstract structuralfeatur inputclass structuralfeatur supertyp inputclass supertyp totalorderclass km target class name inputclass name totalord isabstract true packag inputclass packag supertyp inputclass structuralfeatur iter acc sequenc km class sequenc acc includ opposit owner end classwithpartialord begin classwithoutpartialord rule classwithoutpartialord inputclass km class inputclass structuralfeatur select r r upper r lower isempti outputclass km target class name inputclass name isabstract inputclass isabstract structuralfeatur inputclass structuralfeatur supertyp inputclass supertyp end classwithoutpartialord begin refer partial order rule referencepartialord inputref km refer inputref upper inputref lower outputref km target refer name inputref opposit owner name totalord isord inputref isord isuniqu inputref isuniqu locat inputref locat lower upper type km target class allinst select name inputref owner name totalord assequ first owner inputref owner opposit inputref opposit outputoppositeref km target refer name inputref opposit owner name oppositetotalord isord inputref opposit isord isuniqu inputref opposit isuniqu locat inputref opposit locat lower upper type inputref opposit type owner km target class allinst select name inputref owner name totalord assequ first opposit outputref end refer partial order,1
90,90,P48-PartialRolesTotalB-context.atl,"-- @name	 Making partial role total (a)
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		Baudry Julien (jul.baudry<at>gmail.com)
-- @date		2006/08/02
-- @description	The purpose of this transformation is to making a patial role total
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 2.14, page 23
-- @see author of article : K. Lano

module PartialRolesTotalB; -- Module Template
create OUT : KM3Target from IN : KM3;

helper context KM3!Class def: hasChild : Boolean =
	KM3!Class.allInstances()->select(c|c.supertypes->notEmpty())->exists(r|r.supertypes.first() = self)
	;


--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3Target!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
--@end rule Metamodel

--@begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3Target!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
--@end rule Package

--@begin rule DataType
rule DataType {
	from
		inputData:KM3!DataType
	to
		outputData:KM3Target!DataType(
			name <- inputData.name,
			location <- inputData.location
		)
}
--@end rule DataType

--@begin rule EnumLiteral
rule EnumLiteral {
	from
		inputL:KM3!EnumLiteral
	to
		outputL:KM3Target!EnumLiteral (
			name <- inputL.name,
			location <- inputL.location,
			enum  <- inputL.enum,
			package <- inputL.package
		)
}
--@end rule EnumLiteral

--@begin rule Enumeration 
rule Enumeration {
	from
		inputEnum:KM3!Enumeration
	to
		outputEnum:KM3Target!Enumeration (
			name <- inputEnum.name,
			location <- inputEnum.location,
			package <- inputEnum.package,
			literals <- inputEnum.literals
		)
}
--@end rule Enumeration 

--@begin rule Class
rule Class {
	from
		inputC:KM3!Class
		( 		not( inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.upper=1)
					and inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.lower=0)
					and inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.opposite.upper=1)
					and inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.opposite.lower=1)
					and inputC.hasChild
				)
				and
				not( inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.upper=1)
					and inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.lower=1)
					and inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.opposite.upper=1)
					and inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.opposite.lower=0)
					and inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(c|c.type.hasChild)
				)
				and
				not( inputC.supertypes->exists(r|r.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.upper=1))
					and inputC.supertypes->exists(r|r.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.lower=0))
					and inputC.supertypes->exists(r|r.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.opposite.upper=1))
					and inputC.supertypes->exists(r|r.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.opposite.lower=1))
					and inputC.supertypes->notEmpty()
				)
			)
			to
		outputC:KM3Target!Class (
			isAbstract <- inputC.isAbstract,
			supertypes <- inputC.supertypes,
			name <- inputC.name,
			location <- inputC.location,
			package <- inputC.package,
			structuralFeatures <- inputC.structuralFeatures
		)
}
--@end rule Class

--@begin rule Attribute
rule Attribute {
	from
		inputAttr : KM3!Attribute
	to
		outputAttr : KM3Target!Attribute (
			package <- inputAttr.package,
			name <- inputAttr.name,
			lower <- inputAttr.lower,
			upper <- inputAttr.upper,
			isOrdered <- inputAttr.isOrdered,
			isUnique <- inputAttr.isUnique,
			owner <- inputAttr.owner,
			type <- inputAttr.type
		)
}
--@end rule Attribute

--@begin rule Reference
rule Reference {
	from
		inputRef : KM3!Reference
			( 	not( inputRef.upper=1
					and inputRef.lower=0
					and inputRef.opposite.upper=1
					and inputRef.opposite.lower=1
					and inputRef.owner.hasChild
				)
				and
				not( inputRef.upper=1
					and inputRef.lower=1
					and inputRef.opposite.upper=1
					and inputRef.opposite.lower=0
					and inputRef.type.hasChild
				)
			)
	to
		outputRef : KM3Target!Reference (
			package <- inputRef.package,
			name <- inputRef.name,
			lower <- inputRef.lower,
			upper <- inputRef.upper,
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			owner <- inputRef.owner,
			type <- inputRef.type,
			isContainer <- inputRef.isContainer,
			opposite <- inputRef.opposite
		)
}
--@end rule Attribute

--@begin rule Merging
rule PartialRoles {
	from
		inputSuperType : KM3!Class,
		inputChild : KM3!Class,
		inputClass : KM3!Class,
		inputRef : KM3!Reference,
		inputRef2 : KM3!Reference
	( (inputChild.supertypes->includes(inputSuperType)
		and inputRef.owner = inputSuperType
		and inputRef2.owner = inputClass
		and inputRef.upper = 1
		and inputRef.lower = 0
		and not inputRef.isContainer
		and inputRef2.upper = 1
		and inputRef2.lower = 1
		and not inputRef2.isContainer
		and inputRef.opposite=inputRef2
		)
	)
	to
		outputSuperType: KM3Target!Class(
			isAbstract <- inputSuperType.isAbstract,
			supertypes <- inputSuperType.supertypes,
			name <- inputSuperType.name,
			location <- inputSuperType.location,
			package <- inputSuperType.package,
			structuralFeatures <- inputSuperType.structuralFeatures->select(r| r<>inputRef)
			),
		outputClass: KM3Target!Class(
			isAbstract <- inputClass.isAbstract,
			supertypes <- inputClass.supertypes,
			name <- inputClass.name,
			location <- inputClass.location,
			package <- inputClass.package,
			structuralFeatures <- inputClass.structuralFeatures->select(r|r<>inputRef2),
			structuralFeatures <- outputRef2
			),
		outputRef: KM3Target!Reference(
			package <- inputRef.package,
			name <- inputRef.name,
			lower <- 1,
			upper <- 1,
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			owner <- outputChild,
			type <- outputClass,
			isContainer <- false,
			opposite <- outputRef2
			),
		outputChild: KM3Target!Class(
			isAbstract <- inputChild.isAbstract,
			supertypes <- inputChild.supertypes,
			name <- inputChild.name,
			location <- inputChild.location,
			package <- inputChild.package,
			structuralFeatures <- inputChild.structuralFeatures,
			structuralFeatures <- outputRef
			),
		outputRef2: KM3Target!Reference(
			package <- inputRef2.package,
			name <- inputRef2.name,
			lower <- 1,
			upper <- 1,
			isOrdered <- inputRef2.isOrdered,
			isUnique <- inputRef2.isUnique,
			owner <- inputRef2.owner,
			type <- outputChild,
			isContainer <- false,
			opposite <- outputRef
			)		
		
}




",name make partial role total version domain catalogu model transform author baudri julien jul baudri gmail com date descript the purpos transform make patial role total see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul partialrolestotalb modul templat creat out km target in km helper context km class def haschild boolean km class allinst select c c supertyp notempti exist r r supertyp first self begin rule metamodel rule metamodel inputmm km metamodel outputmm km target metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km target packag name inputpkg name content inputpkg content end rule packag begin rule datatyp rule datatyp inputdata km datatyp outputdata km target datatyp name inputdata name locat inputdata locat end rule datatyp begin rule enumliter rule enumliter inputl km enumliter outputl km target enumliter name inputl name locat inputl locat enum inputl enum packag inputl packag end rule enumliter begin rule enumer rule enumer inputenum km enumer outputenum km target enumer name inputenum name locat inputenum locat packag inputenum packag liter inputenum liter end rule enumer begin rule class rule class inputc km class inputc structuralfeatur select r r oclistypeof km refer exist r r upper inputc structuralfeatur select r r oclistypeof km refer exist r r lower inputc structuralfeatur select r r oclistypeof km refer exist r r opposit upper inputc structuralfeatur select r r oclistypeof km refer exist r r opposit lower inputc haschild inputc structuralfeatur select r r oclistypeof km refer exist r r upper inputc structuralfeatur select r r oclistypeof km refer exist r r lower inputc structuralfeatur select r r oclistypeof km refer exist r r opposit upper inputc structuralfeatur select r r oclistypeof km refer exist r r opposit lower inputc structuralfeatur select r r oclistypeof km refer exist c c type haschild inputc supertyp exist r r structuralfeatur select r r oclistypeof km refer exist r r upper inputc supertyp exist r r structuralfeatur select r r oclistypeof km refer exist r r lower inputc supertyp exist r r structuralfeatur select r r oclistypeof km refer exist r r opposit upper inputc supertyp exist r r structuralfeatur select r r oclistypeof km refer exist r r opposit lower inputc supertyp notempti outputc km target class isabstract inputc isabstract supertyp inputc supertyp name inputc name locat inputc locat packag inputc packag structuralfeatur inputc structuralfeatur end rule class begin rule attribut rule attribut inputattr km attribut outputattr km target attribut packag inputattr packag name inputattr name lower inputattr lower upper inputattr upper isord inputattr isord isuniqu inputattr isuniqu owner inputattr owner type inputattr type end rule attribut begin rule refer rule refer inputref km refer inputref upper inputref lower inputref opposit upper inputref opposit lower inputref owner haschild inputref upper inputref lower inputref opposit upper inputref opposit lower inputref type haschild outputref km target refer packag inputref packag name inputref name lower inputref lower upper inputref upper isord inputref isord isuniqu inputref isuniqu owner inputref owner type inputref type iscontain inputref iscontain opposit inputref opposit end rule attribut begin rule merg rule partialrol inputsupertyp km class inputchild km class inputclass km class inputref km refer inputref km refer inputchild supertyp includ inputsupertyp inputref owner inputsupertyp inputref owner inputclass inputref upper inputref lower inputref iscontain inputref upper inputref lower inputref iscontain inputref opposit inputref outputsupertyp km target class isabstract inputsupertyp isabstract supertyp inputsupertyp supertyp name inputsupertyp name locat inputsupertyp locat packag inputsupertyp packag structuralfeatur inputsupertyp structuralfeatur select r r inputref outputclass km target class isabstract inputclass isabstract supertyp inputclass supertyp name inputclass name locat inputclass locat packag inputclass packag structuralfeatur inputclass structuralfeatur select r r inputref structuralfeatur outputref outputref km target refer packag inputref packag name inputref name lower upper isord inputref isord isuniqu inputref isuniqu owner outputchild type outputclass iscontain fals opposit outputref outputchild km target class isabstract inputchild isabstract supertyp inputchild supertyp name inputchild name locat inputchild locat packag inputchild packag structuralfeatur inputchild structuralfeatur structuralfeatur outputref outputref km target refer packag inputref packag name inputref name lower upper isord inputref isord isuniqu inputref isuniqu owner inputref owner type outputchild iscontain fals opposit outputref,19
91,91,P48-PartialRolesTotalB-without.atl,"-- @name	 Making partial role total (a)
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		Baudry Julien (jul.baudry<at>gmail.com)
-- @date		2006/08/02
-- @description	The purpose of this transformation is to making a patial role total
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 2.14, page 23
-- @see author of article : K. Lano

module PartialRolesTotalB; -- Module Template
create OUT : KM3Target from IN : KM3;

helper context KM3!Class def: hasChild : Boolean =
	KM3!Class.allInstances()->select(c|c.supertypes->notEmpty())->exists(r|r.supertypes.first() = self)
	;


--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3Target!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
--@end rule Metamodel

--@begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3Target!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
--@end rule Package


--@begin rule Class
rule Class {
	from
		inputC:KM3!Class
		( 		not( inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.upper=1)
					and inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.lower=0)
					and inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.opposite.upper=1)
					and inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.opposite.lower=1)
					and inputC.hasChild
				)
				and
				not( inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.upper=1)
					and inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.lower=1)
					and inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.opposite.upper=1)
					and inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.opposite.lower=0)
					and inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(c|c.type.hasChild)
				)
				and
				not( inputC.supertypes->exists(r|r.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.upper=1))
					and inputC.supertypes->exists(r|r.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.lower=0))
					and inputC.supertypes->exists(r|r.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.opposite.upper=1))
					and inputC.supertypes->exists(r|r.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Reference))->exists(r|r.opposite.lower=1))
					and inputC.supertypes->notEmpty()
				)
			)
			to
		outputC:KM3Target!Class (
			isAbstract <- inputC.isAbstract,
			supertypes <- inputC.supertypes,
			name <- inputC.name,
			location <- inputC.location,
			package <- inputC.package,
			structuralFeatures <- inputC.structuralFeatures
		)
}
--@end rule Class


--@begin rule Reference
rule Reference {
	from
		inputRef : KM3!Reference
			( 	not( inputRef.upper=1
					and inputRef.lower=0
					and inputRef.opposite.upper=1
					and inputRef.opposite.lower=1
					and inputRef.owner.hasChild
				)
				and
				not( inputRef.upper=1
					and inputRef.lower=1
					and inputRef.opposite.upper=1
					and inputRef.opposite.lower=0
					and inputRef.type.hasChild
				)
			)
	to
		outputRef : KM3Target!Reference (
			package <- inputRef.package,
			name <- inputRef.name,
			lower <- inputRef.lower,
			upper <- inputRef.upper,
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			owner <- inputRef.owner,
			type <- inputRef.type,
			isContainer <- inputRef.isContainer,
			opposite <- inputRef.opposite
		)
}
--@end rule Attribute

--@begin rule Merging
rule PartialRoles {
	from
		inputSuperType : KM3!Class,
		inputChild : KM3!Class,
		inputClass : KM3!Class,
		inputRef : KM3!Reference,
		inputRef2 : KM3!Reference
	( (inputChild.supertypes->includes(inputSuperType)
		and inputRef.owner = inputSuperType
		and inputRef2.owner = inputClass
		and inputRef.upper = 1
		and inputRef.lower = 0
		and not inputRef.isContainer
		and inputRef2.upper = 1
		and inputRef2.lower = 1
		and not inputRef2.isContainer
		and inputRef.opposite=inputRef2
		)
	)
	to
		outputSuperType: KM3Target!Class(
			isAbstract <- inputSuperType.isAbstract,
			supertypes <- inputSuperType.supertypes,
			name <- inputSuperType.name,
			location <- inputSuperType.location,
			package <- inputSuperType.package,
			structuralFeatures <- inputSuperType.structuralFeatures->select(r| r<>inputRef)
			),
		outputClass: KM3Target!Class(
			isAbstract <- inputClass.isAbstract,
			supertypes <- inputClass.supertypes,
			name <- inputClass.name,
			location <- inputClass.location,
			package <- inputClass.package,
			structuralFeatures <- inputClass.structuralFeatures->select(r|r<>inputRef2),
			structuralFeatures <- outputRef2
			),
		outputRef: KM3Target!Reference(
			package <- inputRef.package,
			name <- inputRef.name,
			lower <- 1,
			upper <- 1,
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			owner <- outputChild,
			type <- outputClass,
			isContainer <- false,
			opposite <- outputRef2
			),
		outputChild: KM3Target!Class(
			isAbstract <- inputChild.isAbstract,
			supertypes <- inputChild.supertypes,
			name <- inputChild.name,
			location <- inputChild.location,
			package <- inputChild.package,
			structuralFeatures <- inputChild.structuralFeatures,
			structuralFeatures <- outputRef
			),
		outputRef2: KM3Target!Reference(
			package <- inputRef2.package,
			name <- inputRef2.name,
			lower <- 1,
			upper <- 1,
			isOrdered <- inputRef2.isOrdered,
			isUnique <- inputRef2.isUnique,
			owner <- inputRef2.owner,
			type <- outputChild,
			isContainer <- false,
			opposite <- outputRef
			)		
		
}




",name make partial role total version domain catalogu model transform author baudri julien jul baudri gmail com date descript the purpos transform make patial role total see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul partialrolestotalb modul templat creat out km target in km helper context km class def haschild boolean km class allinst select c c supertyp notempti exist r r supertyp first self begin rule metamodel rule metamodel inputmm km metamodel outputmm km target metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km target packag name inputpkg name content inputpkg content end rule packag begin rule class rule class inputc km class inputc structuralfeatur select r r oclistypeof km refer exist r r upper inputc structuralfeatur select r r oclistypeof km refer exist r r lower inputc structuralfeatur select r r oclistypeof km refer exist r r opposit upper inputc structuralfeatur select r r oclistypeof km refer exist r r opposit lower inputc haschild inputc structuralfeatur select r r oclistypeof km refer exist r r upper inputc structuralfeatur select r r oclistypeof km refer exist r r lower inputc structuralfeatur select r r oclistypeof km refer exist r r opposit upper inputc structuralfeatur select r r oclistypeof km refer exist r r opposit lower inputc structuralfeatur select r r oclistypeof km refer exist c c type haschild inputc supertyp exist r r structuralfeatur select r r oclistypeof km refer exist r r upper inputc supertyp exist r r structuralfeatur select r r oclistypeof km refer exist r r lower inputc supertyp exist r r structuralfeatur select r r oclistypeof km refer exist r r opposit upper inputc supertyp exist r r structuralfeatur select r r oclistypeof km refer exist r r opposit lower inputc supertyp notempti outputc km target class isabstract inputc isabstract supertyp inputc supertyp name inputc name locat inputc locat packag inputc packag structuralfeatur inputc structuralfeatur end rule class begin rule refer rule refer inputref km refer inputref upper inputref lower inputref opposit upper inputref opposit lower inputref owner haschild inputref upper inputref lower inputref opposit upper inputref opposit lower inputref type haschild outputref km target refer packag inputref packag name inputref name lower inputref lower upper inputref upper isord inputref isord isuniqu inputref isuniqu owner inputref owner type inputref type iscontain inputref iscontain opposit inputref opposit end rule attribut begin rule merg rule partialrol inputsupertyp km class inputchild km class inputclass km class inputref km refer inputref km refer inputchild supertyp includ inputsupertyp inputref owner inputsupertyp inputref owner inputclass inputref upper inputref lower inputref iscontain inputref upper inputref lower inputref iscontain inputref opposit inputref outputsupertyp km target class isabstract inputsupertyp isabstract supertyp inputsupertyp supertyp name inputsupertyp name locat inputsupertyp locat packag inputsupertyp packag structuralfeatur inputsupertyp structuralfeatur select r r inputref outputclass km target class isabstract inputclass isabstract supertyp inputclass supertyp name inputclass name locat inputclass locat packag inputclass packag structuralfeatur inputclass structuralfeatur select r r inputref structuralfeatur outputref outputref km target refer packag inputref packag name inputref name lower upper isord inputref isord isuniqu inputref isuniqu owner outputchild type outputclass iscontain fals opposit outputref outputchild km target class isabstract inputchild isabstract supertyp inputchild supertyp name inputchild name locat inputchild locat packag inputchild packag structuralfeatur inputchild structuralfeatur structuralfeatur outputref outputref km target refer packag inputref packag name inputref name lower upper isord inputref isord isuniqu inputref isuniqu owner inputref owner type outputchild iscontain fals opposit outputref,19
92,92,P49-Measure2Table.atl,"--@atlcompiler	atl2006
--@name			Measure2Table
--@version		2.0
--@domains		measurement data, metrics, generic table
--@authors		Eric Vepa (evepa <at> sodius.com) for SODIUS (www.sodius.com)
--@date			2007/08/28
--@description	This transformation is used to represent measurement data from terminal models as a generic table representation.

module Measure2Table; -- Module Template
create OUT : Table from IN : Measure;

uses MeasureHelpers;

--@begin helper modelKind
--@comments String values for model type of a measure set.
helper def : modelKind : Map(String,String) =
	Map {('KM3','KM3'),
		('UML2','UML2')};
--@end helper modelKind

--@begin helper elementKind
--@comments String values for element type of a measure set.
helper def : elementKind : Map(String,String) =
	Map {('metamodel','Metamodel'),
		('model','Model'),
		('package','Package'),
		('interface','Interface'),
		('class','Class')};
--@end helper elementKind

--@begin entrypoint rule Tables
--@comments Creates tables from the collected measurement data.
entrypoint rule Tables() {
	using {
		allMetamodelMeasuresSets : Sequence(Measure!MeasureSet) =
			thisModule.allMeasureSets(#metamodel);
		allModelMeasuresSets : Sequence(Measure!MeasureSet) =
			thisModule.allMeasureSets(#model);
		allPackageMeasuresSets : Sequence(Measure!MeasureSet) =
			thisModule.allMeasureSets(#package);
		allInterfaceMeasuresSets : Sequence(Measure!MeasureSet) =
			thisModule.allMeasureSets(#interface);
		allClassMeasuresSets : Sequence(Measure!MeasureSet) =
			thisModule.allMeasureSets(#class);
	}
	do {
		if (allMetamodelMeasuresSets->notEmpty()) {
			thisModule.AllMeasureSet2Table(allMetamodelMeasuresSets);
		}
		if (allModelMeasuresSets->notEmpty()) {
			thisModule.AllMeasureSet2Table(allModelMeasuresSets);
		}
		if (allPackageMeasuresSets->notEmpty()) {
			thisModule.AllMeasureSet2Table(allPackageMeasuresSets);
		}
		if (allInterfaceMeasuresSets->notEmpty()) {
			thisModule.AllMeasureSet2Table(allInterfaceMeasuresSets);
		}
		if (allClassMeasuresSets->notEmpty()) {
			thisModule.AllMeasureSet2Table(allClassMeasuresSets);
		}
	}
}
--@end entrypoint rule Tables

--@begin called rule AllMeasureSet2Table
--@comments Creates a table for all measure sets for one kind of element.
rule AllMeasureSet2Table(allMeasSet : Sequence(Measure!MeasureSet)) {
	to
		t : Table!Table (
			rows <- thisModule.MeasureSet2HdrRow(allMeasSet->first()),
			rows <- allMeasSet->
				collect(ms|thisModule.MeasureSet2ValueRow(ms))
		)
}
--@end called rule AllMeasureSet2Table

--@begin called rule MeasureSet2HdrRow
--@comments Creates a header row with the names of all metrics for this kind of element.
rule MeasureSet2HdrRow(ms : Measure!MeasureSet) {
	to
		hdrRow : Table!Row (
			cells <- thisModule.String2Cell(ms.getElementKind()),
			cells <- ms.allMeasures->
				collect(meas|thisModule.String2Cell(meas.metricName()))
		)
	do {
		hdrRow;
	}
}
--@end called rule MeasureSet2HdrRow

--@begin called rule MeasureSet2ValueRow
--@comments Creates a row with the values for simple measures of a measure set.
rule MeasureSet2ValueRow(ms : Measure!MeasureSet) {
	to
		valueRow : Table!Row (
			cells <- thisModule.String2Cell(ms.absoluteName()),
			cells <- ms.allMeasures->
				collect(meas|thisModule.String2Cell(meas.stringValue()))
		)
	do {
		valueRow;
	}
}
--@end called rule MeasureSet2ValueRow

--@begin called rule Sequence2Row
--@comments Creates a rows with the cells given.
rule Sequence2Row(cells : Sequence(OclAny)) {
	to
		row : Table!Row (
			cells <- cells
		)
	do {
		row;
	}
}
--@end called rule Sequence2Row

--@begin called rule String2Cell
--@comments Creates a cell with the content given.
rule String2Cell(content : String) {
	to
		cell : Table!Cell (
			content <- content
		)
	do {
		cell;
	}
}
--@end called rule String2Cell",atlcompil atl name measur tabl version domain measur data metric generic tabl author eric vepa evepa sodius com sodius www sodius com date descript this transform use repres measur data termin model generic tabl represent modul measur tabl modul templat creat out tabl in measur use measurehelp begin helper modelkind comment string valu model type measur set helper def modelkind map string string map km km uml uml end helper modelkind begin helper elementkind comment string valu element type measur set helper def elementkind map string string map metamodel metamodel model model packag packag interfac interfac class class end helper elementkind begin entrypoint rule tabl comment creat tabl collect measur data entrypoint rule tabl use allmetamodelmeasuresset sequenc measur measureset thismodul allmeasureset metamodel allmodelmeasuresset sequenc measur measureset thismodul allmeasureset model allpackagemeasuresset sequenc measur measureset thismodul allmeasureset packag allinterfacemeasuresset sequenc measur measureset thismodul allmeasureset interfac allclassmeasuresset sequenc measur measureset thismodul allmeasureset class allmetamodelmeasuresset notempti thismodul allmeasureset tabl allmetamodelmeasuresset allmodelmeasuresset notempti thismodul allmeasureset tabl allmodelmeasuresset allpackagemeasuresset notempti thismodul allmeasureset tabl allpackagemeasuresset allinterfacemeasuresset notempti thismodul allmeasureset tabl allinterfacemeasuresset allclassmeasuresset notempti thismodul allmeasureset tabl allclassmeasuresset end entrypoint rule tabl begin call rule allmeasureset tabl comment creat tabl measur set one kind element rule allmeasureset tabl allmeasset sequenc measur measureset tabl tabl row thismodul measureset hdrrow allmeasset first row allmeasset collect ms thismodul measureset valuerow ms end call rule allmeasureset tabl begin call rule measureset hdrrow comment creat header row name metric kind element rule measureset hdrrow ms measur measureset hdrrow tabl row cell thismodul string cell ms getelementkind cell ms allmeasur collect mea thismodul string cell mea metricnam hdrrow end call rule measureset hdrrow begin call rule measureset valuerow comment creat row valu simpl measur measur set rule measureset valuerow ms measur measureset valuerow tabl row cell thismodul string cell ms absolutenam cell ms allmeasur collect mea thismodul string cell mea stringvalu valuerow end call rule measureset valuerow begin call rule sequenc row comment creat row cell given rule sequenc row cell sequenc oclani row tabl row cell cell row end call rule sequenc row begin call rule string cell comment creat cell content given rule string cell content string cell tabl cell content content cell end call rule string cell,12
93,93,P5-ATL2Tracer.atl,"module ATL2Tracer;
create OUT : ATL refining IN : ATL;

rule Module {
	from
		s : ATL!Module
	to
		t : ATL!Module (
			name <- s.name,
			libraries <- s.libraries,
			isRefining <- s.isRefining,
			inModels <- s.inModels,
			outModels <- s.outModels->including(traceModel),
			elements <- s.elements,

			location <- s.location,
			commentsBefore <- s.commentsBefore,
			commentsAfter <- s.commentsAfter
		),
		traceModel : ATL!OclModel (
			name <- 'trace',
			metamodel <- traceMetamodel
		),
		traceMetamodel : ATL!OclModel (
			name <- 'Trace'
		)
}

rule OutPattern {
	from
		s : ATL!OutPattern
	to
		t : ATL!OutPattern (
			elements <- s.elements->including(traceLink)
		),

		-- We add a target pattern element creating a trace link to the rule.
		traceLink : ATL!SimpleOutPatternElement (
			varName <- 'traceLink',
			type <- traceType,
			bindings <- Sequence {ruleName, targetElements}
		),
		traceType : ATL!OclModelElement (
			name <- 'TraceLink',
			model <- thisModule.resolveTemp(s.""rule"".""module"", 'traceMetamodel')
		),

		-- The rule name is set using a binding.
		ruleName : ATL!Binding (
			propertyName <- 'ruleName',
			value <- nameString
		),
		nameString : ATL!StringExp (
			stringSymbol <- s.""rule"".name
		),

		-- Source elements cannot be set with a binding because they are not supposed to be referrable.
		-- An imperative block is used instead.
		sourceSeq : ATL!SequenceExp (
			elements <- sourceVars
		),
		sourceVars : distinct ATL!VariableExp foreach(e in s.""rule"".inPattern.elements) (
			referredVariable <- e
		),
		actionBlock : ATL!ActionBlock (	-- we suppose there is no action block in the original program
			""rule"" <- s.""rule"",
			statements <- Sequence {stat}
		),
		stat : ATL!ExpressionStat (
			expression <- refSetValue
		),
		refSetValue : ATL!OperationCallExp (
			operationName <- 'refSetValue',
			source <- traceLinkVar,
			arguments <- Sequence {seString, sourceSeq}
		),
		traceLinkVar : ATL!VariableExp (
			referredVariable <- traceLink
		),
		seString : ATL!StringExp (
			stringSymbol <- 'sourceElements'
		),

		-- Target elements are initialized using a binding
		targetElements : ATL!Binding (
			propertyName <- 'targetElements',
			value <- targetSeq
		),
		targetSeq : ATL!SequenceExp (
			elements <- targetVars
		),
		targetVars : distinct ATL!VariableExp foreach(e in s.elements) (
			referredVariable <- e
		)
}

",modul atl tracer creat out atl refin in atl rule modul atl modul atl modul name name librari librari isrefin isrefin inmodel inmodel outmodel outmodel includ tracemodel element element locat locat commentsbefor commentsbefor commentsaft commentsaft tracemodel atl oclmodel name trace metamodel tracemetamodel tracemetamodel atl oclmodel name trace rule outpattern atl outpattern atl outpattern element element includ tracelink we add target pattern element creat trace link rule tracelink atl simpleoutpatternel varnam tracelink type tracetyp bind sequenc rulenam targetel tracetyp atl oclmodelel name tracelink model thismodul resolvetemp rule modul tracemetamodel the rule name set use bind rulenam atl bind propertynam rulenam valu namestr namestr atl stringexp stringsymbol rule name sourc element cannot set bind suppos referr an imper block use instead sourceseq atl sequenceexp element sourcevar sourcevar distinct atl variableexp foreach e rule inpattern element referredvari e actionblock atl actionblock suppos action block origin program rule rule statement sequenc stat stat atl expressionstat express refsetvalu refsetvalu atl operationcallexp operationnam refsetvalu sourc tracelinkvar argument sequenc sestr sourceseq tracelinkvar atl variableexp referredvari tracelink sestr atl stringexp stringsymbol sourceel target element initi use bind targetel atl bind propertynam targetel valu targetseq targetseq atl sequenceexp element targetvar targetvar distinct atl variableexp foreach e element referredvari e,3
94,94,P5-sample-ATL-0.2.atl,"module ATL2BindingDebugger;
create OUT : ATL refining IN : ATL;

-- We copy the ATL!Module to make sure the whole program is actually copied even if it contains no binding.
rule Module {
  from
    s : ATL!Module
  to
    t : ATL!Module (
      name <- s.name,
      libraries <- s.libraries,
      isRefining <- s.isRefining,
      inModels <- s.inModels,
      outModels <- s.outModels,
      elements <- s.elements
    )
}

-- We change the value of each binding so that it calls the OclAny.debug(msg : String)
-- operation with information about the current rule, target element and property name
-- as a message.
rule Binding {
  from
    s : ATL!Binding
  to
    t : ATL!Binding (
      propertyName <- s.propertyName,
      value <- debugger
    ),
    debugger : ATL!OperationCallExp (
      source <- s.value,
      operationName <- 'debug',
      arguments <- Sequence {arg}
    ),
    arg : ATL!StringExp (
      stringSymbol <- s.outPatternElement.outPattern.""rule"".name + '.' + s.outPatternElement.varName + '.' + s.propertyName
    )
}
",modul atl bindingdebugg creat out atl refin in atl we copi atl modul make sure whole program actual copi even contain bind rule modul atl modul atl modul name name librari librari isrefin isrefin inmodel inmodel outmodel outmodel element element we chang valu bind call oclani debug msg string oper inform current rule target element properti name messag rule bind atl bind atl bind propertynam propertynam valu debugg debugg atl operationcallexp sourc valu operationnam debug argument sequenc arg arg atl stringexp stringsymbol outpatternel outpattern rule name outpatternel varnam propertynam,3
95,95,P50-Measure2XHTML.atl,"--@atlcompiler	atl2006
--@name			Measure2XHTML
--@version		2.0
--@domains		measurement data, metrics, XHTML
--@authors		Eric Vepa (evepa <at> sodius.com) for SODIUS (www.sodius.com)
--@date			2007/08/28
--@description	This transformation is used to represent measurement data from terminal models as an XHTML document

module Measure2XHTML; -- Module Template
create OUT : XHTML from IN : Measure;

uses MeasureHelpers;

--@begin helper useCCSFile
--@comments A flag for using a CSS file or an embedded CSS using the getStyleSheet() helper at the end of this file (XHTML link or style tags).
helper def : useCSSFile : Boolean = false;
--@end helper useCCSFile

--@begin helper useJSFile
--@comments A flag for using a JavaScript file or an embedded script using the getJavaScript() helper at the end of this file (XHTML script tag).
helper def : useJSFile : Boolean = false;
--@end helper useJSFile

--@begin helper metricDefLocation
--@comments The URL of the metrics definition page.
helper def : metricDefLocation : String =
	'http://www.mdworkbench.com/measurement/metrics/definition.htm';
--@end helper metricDefLocation

--@begin helper modelKind
--@comments String values for model type of a measure set.
helper def : modelKind : Map(String,String) =
	Map {('KM3','KM3'),
		('UML2','UML2')};
--@end helper modelKind

--@begin helper elementKind
--@comments String values for element type of a measure set.
helper def : elementKind : Map(String,String) =
	Map {('metamodel','Metamodel'),
		('model','Model'),
		('package','Package'),
		('interface','Interface'),
		('class','Class')};
--@end helper elementKind

--@begin attribute helper html
--@comments The root HTML tag.
helper def : html : XHTML!HTML = OclUndefined;
--@end attribute helper html

--@begin rule RootMeasureSet
--@comments Creates the unique XHTML, head, title, link or style and body tags.
rule RootMeasureSet {
	from
		root : Measure!RootMeasureSet
	using {
		allMetamodelMeasuresSets : Sequence(Measure!MeasureSet) =
			thisModule.allMeasureSets(#metamodel);
		allModelMeasuresSets : Sequence(Measure!MeasureSet) =
			thisModule.allMeasureSets(#model);
		allPackageMeasuresSets : Sequence(Measure!MeasureSet) =
			thisModule.allMeasureSets(#package);
		allInterfaceMeasuresSets : Sequence(Measure!MeasureSet) =
			thisModule.allMeasureSets(#interface);
		allClassMeasuresSets : Sequence(Measure!MeasureSet) =
			thisModule.allMeasureSets(#class);
	}
	do {		
		if (not (allMetamodelMeasuresSets->isEmpty() and
			allModelMeasuresSets->isEmpty() and
				allPackageMeasuresSets->isEmpty() and
					allInterfaceMeasuresSets->isEmpty() and
						allClassMeasuresSets->isEmpty())) {
			thisModule.html <- thisModule.HTML();
		
			for (cat in root.categories) {
				if (allMetamodelMeasuresSets->notEmpty()) {
					if (allMetamodelMeasuresSets->
							first().categories()->includes(cat)) {
						thisModule.html.body.blocks->last().flows <-
							thisModule.TABLE(allMetamodelMeasuresSets,cat);
					}
				}
				if (allModelMeasuresSets->notEmpty()) {
					if (allModelMeasuresSets->
							first().categories()->includes(cat)) {
						thisModule.html.body.blocks->last().flows <-
							thisModule.TABLE(allModelMeasuresSets,cat);
					}
				}
				if (allPackageMeasuresSets->notEmpty()) {
					if (allPackageMeasuresSets->
							first().categories()->includes(cat)) {
						thisModule.html.body.blocks->last().flows <-
							thisModule.TABLE(allPackageMeasuresSets,cat);
					}
				}
				if (allInterfaceMeasuresSets->notEmpty()) {
					if (allInterfaceMeasuresSets->
							first().categories()->includes(cat)) {
						thisModule.html.body.blocks->last().flows <-
							thisModule.TABLE(allInterfaceMeasuresSets,cat);
					}
				}
				if (allClassMeasuresSets->notEmpty()) {
					if (allClassMeasuresSets->
							first().categories()->includes(cat)) {
						thisModule.html.body.blocks->last().flows <-
							thisModule.TABLE(allClassMeasuresSets,cat);
					}
				}
			}
		}
	}
}
--@end rule RootMeasureSet

--@begin called rule HTML
--@comments Creates the XHTML document structure.
rule HTML() {
	to
		html : XHTML!HTML (
            xmllang <- xmllang,
			head <- head,
			body <- body
		),
		xmllang : XHTML!LanguageCode (
			value <- 'en-US'
		),
		head : XHTML!HEAD (
			title <- title,
			headMiscs <- meta,
			headMiscs <-
				if (thisModule.useCSSFile)
					then thisModule.LINK()
					else thisModule.STYLE()
				endif,
			headMiscs <-
				if (thisModule.useJSFile)
					then thisModule.SCRIPT()
					else thisModule.EmbeddedSCRIPT()
				endif,
			headMiscs <- thisModule.NOSCRIPT()
        ),
        title : XHTML!TITLE (
            pcdata <- thisModule.PCDATA('Interactive metric report on a ' +
            	thisModule.getModelKind() + ' model')
        ),
        meta : XHTML!META (
            httpequiv <- thisModule.CDATA('Content-Type'),
            content <- thisModule.CDATA('text/html; charset=utf-8')
        ),
		body : XHTML!BODY (
			blocks <- thisModule.HowToDIV()
		)
	do {			
		html;
	}
}
--@end called rule HTML

--@begin called rule LINK
--@comments Creates a link on the default .css file used by the generated document.
rule LINK() {	
	to
		link : XHTML!LINK (
			href <- href,
			type <- type,
			rel <- rel
		),
		href : XHTML!URI (
			value <- 'stylesheet.css'
		),
		type : XHTML!ContentType (
			value <- 'text/css'
		),
		rel : XHTML!LinkTypes (
			value <- 'stylesheet'
		)
	do {
		link;
	}
}
--@end called rule LINK

--@begin called rule STYLE
--@comments Creates a XHTML style using the stylesheet returned by the getStyleSheet() helper from MeasureHelpers library.
rule STYLE() {	
	to
		style : XHTML!STYLE (
			type <- type,
			pcdata <- thisModule.PCDATA(thisModule.getStyleSheet())
		),
		type : XHTML!ContentType (
			value <- 'text/css'
		)
	do {
		style;
	}
}
--@end called rule STYLE

--@begin called rule SCRIPT
--@comments Creates a XHTML script using the default script.js used by the generated document.
rule SCRIPT() {	
	to
		script : XHTML!SCRIPT (
			type <- type,
			src <- src
		),
		type : XHTML!ContentType (
			value <- 'text/javascript'
		),
		src : XHTML!URI (
			value <- 'script.js'
		)
	do {		
		script;
	}
}
--@end called rule SCRIPT

--@begin called rule EmbeddedSCRIPT
--@comments Creates a XHTML script using the script returned by the getJavaScript() helper from MeasureHelpers library.
rule EmbeddedSCRIPT() {	
	to
		embeddedScript : XHTML!SCRIPT (
			type <- type,
			pcdata <- thisModule.PCDATA(thisModule.getJavaScript())
		),
		type : XHTML!ContentType (
			value <- 'text/javascript'
		)
	do {		
		embeddedScript;
	}
}
--@end called rule EmbeddedSCRIPT

--@begin called rule NOSCRIPT
--@comments Creates a XHTML noscript, for preventing user activatoing JavaScript in his browser
rule NOSCRIPT() { 
    to
        noscript : XHTML!NOSCRIPT (
            blocks <- fieldset
        ),
        fieldset : XHTML!FIELDSET (
            fieldsetElements <- legend, 
            fieldsetElements <- p
        ),
        legend : XHTML!LEGEND (
            inlines <- thisModule.PCDATA('Warning')
        ),
        p : XHTML!P (
            inlines <- thisModule.PCDATA('In order to use the interactive features, you must enable JavaScript in your browser.')
        )
    do {        
        noscript;
    }
}
--@end called rule NOSCRIPT

--@begin called rule ACRONYM
--@comments Creates an XHTML acronym with a value and a title.
rule ACRONYM(value : String, title : String) {
	to
		acronym : XHTML!ACRONYM (
			title <- titleText,
			inlines <- thisModule.PCDATA(value)
		),
		titleText : XHTML!Text (
			value <- title
		)
	do {
		acronym;
	}
}
--@end called rule ACRONYM

--begin called rule LI
--@comments Creates an XHTML li with a text content.
rule LI(text : String) {
    to
        li : XHTML!LI (
            flows <- thisModule.PCDATA(text)
        )
    do {
        li;
    }
}
--end called rule LI

--begin called rule BR
--@comments Creates an XHTML br.
rule BR() {
    to
        br : XHTML!BR
    do {
        br;
    }
}
--end called rule BR

--@begin called rule HowToDIV
--@comments Creates a XHTML div with the validation for the XHTML and CSS content of the generated document.
rule HowToDIV() {
    to
        howtoDiv : XHTML!DIV (
            flows <- fieldset,
            flows <- thisModule.BR(),
            flows <- thisModule.BR()
        ),
        fieldset : XHTML!FIELDSET (
            fieldsetElements <- legend, 
            fieldsetElements <- p1,
            fieldsetElements <- p2,
            fieldsetElements <- operatorsUl,
            fieldsetElements <- p3,
            fieldsetElements <- p4,
            fieldsetElements <- samplesUl
        ),
        legend : XHTML!LEGEND (
            inlines <- thisModule.PCDATA('How To')
        ),
        p1 : XHTML!P (
            inlines <- thisModule.PCDATA('A predicate can be set for each metric column (an operator followed by a number).' +
                     ' The values for the metric that respect the given predicate are emphasized.')
        ),
        p2 : XHTML!P (
            inlines <- thisModule.PCDATA('Operators for the predicate are among:')
        ),
        operatorsUl : XHTML!UL (
            lis <- thisModule.LI('lower than (&lt;)'),
            lis <- thisModule.LI('lower or equal than (&lt;=)'),
            lis <- thisModule.LI('equal to (= or ==)'),
            lis <- thisModule.LI('not equal to (!= or !)'),
            lis <- thisModule.LI('greater or equal than (&gt;)'),
            lis <- thisModule.LI('greater than (&gt;=)')
        ),
        p3 : XHTML!P (
            inlines <- thisModule.PCDATA('Unit for percentage values are not necessary.' +
                     ' If no operator is given, the operator lower or equal than (&lt;=) is used.' +
                     ' If the predicate is incorrect, no value is emphasized.')
        ),
        p4 : XHTML!P (
            inlines <- thisModule.PCDATA('Predicate samples:')
        ),
        samplesUl : XHTML!UL (
            lis <- thisModule.LI('&gt;1'),
            lis <- thisModule.LI('=33.3')
        )
    do {
        howtoDiv;
    }
}
--@end called rule HowToDIV

--@begin called rule TABLE
--@comments Creates a table for the measures of a category and on a type of model element.
rule TABLE(allMeasSet : Sequence(Measure!MeasureSet), cat : Measure!Category) {
	to
		table : XHTML!TABLE (
			caption <- caption,
			thead <- thead,
			tfoot <- tfoot,
			tableElements <- tbody
		),
		caption : XHTML!CAPTION (
			inlines <- thisModule.PCDATA(cat.desc + ' on ' +
                allMeasSet->first().getElementKind() + ' elements')
		),
		thead : XHTML!THEAD (
			trs <-thisModule.FirstHeaderRow(cat,
				allMeasSet->first().allMeasures(cat)->size()),
			trs <-thisModule.HeaderRow(allMeasSet->first(),cat)
		),
		tfoot : XHTML!TFOOT (
			trs <-thisModule.HeaderRow(allMeasSet->first(),cat)
		),
		tbody : XHTML!TBODY (
			trs <-thisModule.InputTextRow(allMeasSet->
				first().allMeasures(cat)),
			trs <-allMeasSet->
				collect(ms|thisModule.DataRow(ms,cat))
		)
	do {
		table;
	}
}
--@end called rule TABLE

--@begin called rule FirstHeaderRow
--@comments Creates an XHTML table header row with the category and the number of column.
rule FirstHeaderRow(cat : Measure!Category, colspan : Integer) {
	to
		tr : XHTML!TR (
			trElements <- emptyTh,
			trElements <- th			
		),
		emptyTh : XHTML!TH (
			class <- thisModule.CDATA('empty')
		),
		th : XHTML!TH (
			class <- thisModule.CDATA('category'),
			colspan <- colspanNumber,
			flows <- a
		),
		colspanNumber : XHTML!Number (
			value <- colspan.toString()
		),
		a : XHTML!A (
			href <- href,
			onclick <- onclick,
			aContents <- thisModule.ACRONYM(cat.name,cat.desc)
		),
		href : XHTML!URI (
			value <- thisModule.metricDefLocation + '#' + cat.name  +
				'4' + thisModule.getModelKind()
		),
		onclick : XHTML!Script (
			value <- 'window.open(this.href,""_blank""); return false;'
		)
	do {
		tr;
	}
}
--@end called rule FirstHeaderRow

--@begin lazy rule HeaderRow
--@comments Creates a table row with table header cells for the names of all metrics for this kind of element and for a category.
lazy rule HeaderRow {
	from
		ms : Measure!MeasureSet,
		cat : Measure!Category
	to
		tr : XHTML!TR (
			trElements <- thisModule.FirstHeaderCell(ms.getElementKind()),
			trElements <- ms.allMeasures(cat)->
				collect(meas|thisModule.HeaderCell(meas.metric))
		)
}
--@end lazy rule HeaderRow

--@begin called rule FirstHeaderCell
--@comments Creates an XHTML table header cell with the kind of model element.
rule FirstHeaderCell(elementType : String) {
	to
		th : XHTML!TH (
			class <- thisModule.CDATA('element'),
			flows <- thisModule.PCDATA(elementType)
		)
	do {
		th;
	}
}
--@end called rule FirstHeaderCell

--@begin lazy rule HeaderCell
--@comments Creates an XHTML table header cell with an acronym for the metric given.
lazy rule HeaderCell {
	from
		metric : Measure!Metric
	to
		th : XHTML!TH (
			class <- thisModule.CDATA('metric'),
			flows <- a
		),
		a : XHTML!A (
			href <- href,
			onclick <- onclick,
			aContents <- thisModule.ACRONYM(metric.name,metric.desc)
		),
		href : XHTML!URI (
			value <- thisModule.metricDefLocation +
				'#' + metric.category.name + '4' + thisModule.getModelKind() +
				'::' + metric.name
		),
		onclick : XHTML!Script (
			value <- 'window.open(this.href,""_blank""); return false;'
		)
}
--@end called rule HeaderCell

--@begin lazy rule 	
--@comments Creates an XHTML table row with input text fields for all measures of a category.
rule InputTextRow(allMeas : Sequence(Measure!Measure)) {
	to
		tr : XHTML!TR (
			class <- thisModule.CDATA('bound'),
			trElements <- firstTh
		),
		firstTh : XHTML!TH
	do {
		for (meas in allMeas) {
			tr.trElements <- thisModule.InputTextCell(meas);
		}
		
		tr;
	}
}
--@end called rule InputTextRow

--@begin called rule InputTextCell
--@comments Creates an XHTML table data cell with an input text field for a given measure.
rule InputTextCell(meas : Measure!Measure) {
	to
		th : XHTML!TH (
			flows <- inputText
		),
		inputText : XHTML!INPUT (
			type <- #text,
			size <- thisModule.CDATA('3'),
			maxlength <- thisModule.CDATA('7'),
			value <- thisModule.CDATA(meas.metric.preferredValue),
			onchange <- onchange,
			onkeypress <- onkeypress
		),
		onchange : XHTML!Script (
			value <- 'changeStyle(this);'
		),
		onkeypress : XHTML!Script (
			value <- 'changeStyleOnEnter(event,this);'
		)
	do {
		th;
	}
}
--@end called rule InputTextCell

--@begin lazy rule DataRow
--@comments Creates XHTML rows with the values for the measures of a measure set and for a category.
lazy rule DataRow {
	from
		ms : Measure!MeasureSet,
		cat : Measure!Category
	to
		tr : XHTML!TR (
			trElements <- thisModule.FirstDataCell(ms.absoluteName()),
			trElements <- ms.allMeasures(cat)->
				collect(meas|thisModule.DataCell(meas))
		)
}
--@end lazy rule DataRow

--@begin called rule FirstDataCell
--@comments Creates an XHTML table data cell with a value.
rule FirstDataCell(elementName : String) {
	to
		td : XHTML!TD (
			class <- thisModule.CDATA('first'),
			flows <- thisModule.PCDATA(elementName)
		)
	do {
		td;
	}
}
--@end called rule FirstDataCell

--@begin lazy rule DataCell
--@comments Creates an XHTML table data cell for a measure.
lazy rule DataCell {
	from
		meas : Measure!Measure
	to
		td : XHTML!TD (
			flows <- thisModule.PCDATA(meas.stringValue())
		)
	do {
		if (not meas.matchPreferredValue()) {
			td.class <- thisModule.CDATA('ignoredValue');
		}
		
		td;
	}
}
--@end lazy rule DataCell

--begin called rule CDATA
--@comments Creates an XHTML CDATA for the value given.
rule CDATA(value : String) {
    to
		cdata : XHTML!CDATA (
            value <- value
        )
    do {
        cdata;
    }
}
--end called rule CDATA

--begin called rule PCDATA
--@comments Creates an XHTML PCDATA with a CDATA for the value given.
rule PCDATA(value : String) {
    to
        pcdata : XHTML!PCDATA (
            inlines <- thisModule.CDATA(value)
        )
    do {
        pcdata;
    }
}
--end called rule PCDATA

--@begin helper getStyleSheet
--@comments Returns a String containing the stylesheet used by the generated HTML document.
helper def : getStyleSheet() : String = '
<!--/*--><![CDATA[/*><!--*/
html
{
    font-family: arial,helvetica,sans-serif;
    font-size: small;
    font-style: normal;
    font-weight: normal;
    text-align: justify;
}

fieldset
{
    padding: 0px 10px 0px 10px;
}

legend
{
    font-weight: bold;
}

caption
{
    font-style: italic;
    font-weight: bold;
    margin-left: auto;
    margin-right: auto;
    padding-bottom: 5px;
}

table
{
    border: none;
    border-collapse: collapse;
    margin: 5px auto 40px auto;
}

tr.bound, th.metric, th.element
{
    background: #c8c8ff;
    text-align: center;
}

th
{
    border: 1px solid black;
    padding: 1px 4px 4px 4px;
    text-align: center;
    white-space: nowrap;
}

th.empty
{
    border: none;
}

th.category
{
    background: #9696ff;
}

acronym
{
    border-bottom: 1px dotted;
}

input
{
    border: 1px solid gray;
    padding-right: 2px;
    text-align: right;
}

td
{
    background: #e5e5ef;
    border: 1px solid black;
    color: #0000ff;
    font-family: courier,monospace;
    padding: 2px 5px 2px 5px;
    text-align: right;
    white-space: nowrap;
}

td.first
{
    color: #000000;
    font-family: arial,helvetica,sans-serif;
    text-align: left;
}

td.ignoredValue
{
    background: #ffffff;
    color: #adadad;
    text-align: right;
}

a
{
    color: blue;
    text-decoration: none;
}

a:hover
{
    text-decoration: underline;
}
/*]]>*/-->
';
--@end helper getStyleSheet

--@begin helper getJavaScript
--@comments Returns a String containing the script used by the generated HTML document.
helper def : getJavaScript() : String =	'
<!--//--><![CDATA[//><!--
function indexOf(node, item)
{
  var index = 0;
  var current = first_child(node);
  
  while (current != null)
  {
    if (current == item)
    {
      return index;
    }
    else
    {
      current = node_after(current);
      index++;
    }
  }
  
  return 0;
}

function at(node, index)
{
  var i = 0;
  var current = first_child(node);
  
  while (current != null)
  {
    if (i == index)
    {
      return current;
    }
    else
    {
      current = node_after(current);
      i++;
    }
  }
  
  return current;
}

function matchPreferredValue(rawValue, inputText)
{    
  var result = false;
  var value = parseFloat(rawValue);
  
  if (inputText.value.substring(0,2) == ""<="")
  {
    result = (value <= parseFloat(inputText.value.substring(2,inputText.value.length)));
  }
  else if (inputText.value.substring(0,2) == "">="")
  {
    result = (value >= parseFloat(inputText.value.substring(2,inputText.value.length)));
  }
  else if (inputText.value.substring(0,2) == ""=="")
  {
    result = (value == parseFloat(inputText.value.substring(2,inputText.value.length)));
  }
  else if (inputText.value.substring(0,2) == ""!="")
  {
    result = (value != parseFloat(inputText.value.substring(2,inputText.value.length)));
  }
  else if (inputText.value.substring(0,1) == ""<"")
  {
    result = (value < parseFloat(inputText.value.substring(1,inputText.value.length)));
  }
  else if (inputText.value.substring(0,1) == "">"")
  {
    result = (value > parseFloat(inputText.value.substring(1,inputText.value.length)));
  }
  else if (inputText.value.substring(0,1) == ""="")
  {
    result = (value == parseFloat(inputText.value.substring(1,inputText.value.length)));
  } 
  else if (inputText.value.substring(0,1) == ""!"")
  {
    result = (value != parseFloat(inputText.value.substring(1,inputText.value.length)));
    }
  else
  {
    result = (value <= parseFloat(inputText.value));
    if (inputText.value != """")
    {
      inputText.value = ""<="" + inputText.value
    }
  }
  
  return result;
}function changeStyleOnEnter(event, inputText)
{
  if (event.keyCode == 13)
  {
  	changeStyle(inputText);
  }
}

function changeStyle(inputText)
{
  var tdInputText = inputText.parentNode;
  var index = indexOf(tdInputText.parentNode,tdInputText);
     
  if (index != -1)
  {
    for (var trValue = node_after(tdInputText.parentNode); trValue != null; trValue = node_after(trValue))
    {
      var tdValue = at(trValue,index)
    
      if (matchPreferredValue(tdValue.innerHTML,inputText))
      {
        tdValue.className = """";
      }
      else
      {
        tdValue.className = ""ignoredValue"";
      }
    }
  }
}

function is_all_ws(nod)
{
  return !(/[^\\t\\n\\r ]/.test(nod.data));
}

function is_ignorable(nod)
{
  return (nod.nodeType == 8) ||
         ((nod.nodeType == 3) && is_all_ws(nod));
}
function node_after(sib)
{
  while ((sib = sib.nextSibling)) {
    if (!is_ignorable(sib)) return sib;
  }
  return null;
}
function first_child(par)
{
  var res=par.firstChild;
  while (res) {
    if (!is_ignorable(res)) return res;
    res = res.nextSibling;
  }
  return null;
}
//--><!]]>
';
--@end helper getJavaScript",atlcompil atl name measur xhtml version domain measur data metric xhtml author eric vepa evepa sodius com sodius www sodius com date descript this transform use repres measur data termin model xhtml document modul measur xhtml modul templat creat out xhtml in measur use measurehelp begin helper useccsfil comment a flag use css file embed css use getstylesheet helper end file xhtml link style tag helper def usecssfil boolean fals end helper useccsfil begin helper usejsfil comment a flag use javascript file embed script use getjavascript helper end file xhtml script tag helper def usejsfil boolean fals end helper usejsfil begin helper metricdefloc comment the url metric definit page helper def metricdefloc string http www mdworkbench com measur metric definit htm end helper metricdefloc begin helper modelkind comment string valu model type measur set helper def modelkind map string string map km km uml uml end helper modelkind begin helper elementkind comment string valu element type measur set helper def elementkind map string string map metamodel metamodel model model packag packag interfac interfac class class end helper elementkind begin attribut helper html comment the root html tag helper def html xhtml html oclundefin end attribut helper html begin rule rootmeasureset comment creat uniqu xhtml head titl link style bodi tag rule rootmeasureset root measur rootmeasureset use allmetamodelmeasuresset sequenc measur measureset thismodul allmeasureset metamodel allmodelmeasuresset sequenc measur measureset thismodul allmeasureset model allpackagemeasuresset sequenc measur measureset thismodul allmeasureset packag allinterfacemeasuresset sequenc measur measureset thismodul allmeasureset interfac allclassmeasuresset sequenc measur measureset thismodul allmeasureset class allmetamodelmeasuresset isempti allmodelmeasuresset isempti allpackagemeasuresset isempti allinterfacemeasuresset isempti allclassmeasuresset isempti thismodul html thismodul html cat root categori allmetamodelmeasuresset notempti allmetamodelmeasuresset first categori includ cat thismodul html bodi block last flow thismodul tabl allmetamodelmeasuresset cat allmodelmeasuresset notempti allmodelmeasuresset first categori includ cat thismodul html bodi block last flow thismodul tabl allmodelmeasuresset cat allpackagemeasuresset notempti allpackagemeasuresset first categori includ cat thismodul html bodi block last flow thismodul tabl allpackagemeasuresset cat allinterfacemeasuresset notempti allinterfacemeasuresset first categori includ cat thismodul html bodi block last flow thismodul tabl allinterfacemeasuresset cat allclassmeasuresset notempti allclassmeasuresset first categori includ cat thismodul html bodi block last flow thismodul tabl allclassmeasuresset cat end rule rootmeasureset begin call rule html comment creat xhtml document structur rule html html xhtml html xmllang xmllang head head bodi bodi xmllang xhtml languagecod valu en us head xhtml head titl titl headmisc meta headmisc thismodul usecssfil thismodul link els thismodul style endif headmisc thismodul usejsfil thismodul script els thismodul embeddedscript endif headmisc thismodul noscript titl xhtml titl pcdata thismodul pcdata interact metric report thismodul getmodelkind model meta xhtml meta httpequiv thismodul cdata content type content thismodul cdata text html charset utf bodi xhtml bodi block thismodul howtodiv html end call rule html begin call rule link comment creat link default css file use generat document rule link link xhtml link href href type type rel rel href xhtml uri valu stylesheet css type xhtml contenttyp valu text css rel xhtml linktyp valu stylesheet link end call rule link begin call rule style comment creat xhtml style use stylesheet return getstylesheet helper measurehelp librari rule style style xhtml style type type pcdata thismodul pcdata thismodul getstylesheet type xhtml contenttyp valu text css style end call rule style begin call rule script comment creat xhtml script use default script js use generat document rule script script xhtml script type type src src type xhtml contenttyp valu text javascript src xhtml uri valu script js script end call rule script begin call rule embeddedscript comment creat xhtml script use script return getjavascript helper measurehelp librari rule embeddedscript embeddedscript xhtml script type type pcdata thismodul pcdata thismodul getjavascript type xhtml contenttyp valu text javascript embeddedscript end call rule embeddedscript begin call rule noscript comment creat xhtml noscript prevent user activato javascript browser rule noscript noscript xhtml noscript block fieldset fieldset xhtml fieldset fieldsetel legend fieldsetel p legend xhtml legend inlin thismodul pcdata warn p xhtml p inlin thismodul pcdata in order use interact featur must enabl javascript browser noscript end call rule noscript begin call rule acronym comment creat xhtml acronym valu titl rule acronym valu string titl string acronym xhtml acronym titl titletext inlin thismodul pcdata valu titletext xhtml text valu titl acronym end call rule acronym begin call rule li comment creat xhtml li text content rule li text string li xhtml li flow thismodul pcdata text li end call rule li begin call rule br comment creat xhtml br rule br br xhtml br br end call rule br begin call rule howtodiv comment creat xhtml div valid xhtml css content generat document rule howtodiv howtodiv xhtml div flow fieldset flow thismodul br flow thismodul br fieldset xhtml fieldset fieldsetel legend fieldsetel p fieldsetel p fieldsetel operatorsul fieldsetel p fieldsetel p fieldsetel samplesul legend xhtml legend inlin thismodul pcdata how to p xhtml p inlin thismodul pcdata a predic set metric column oper follow number the valu metric respect given predic emphas p xhtml p inlin thismodul pcdata oper predic among operatorsul xhtml ul lis thismodul li lower lt lis thismodul li lower equal lt lis thismodul li equal lis thismodul li equal lis thismodul li greater equal gt lis thismodul li greater gt p xhtml p inlin thismodul pcdata unit percentag valu necessari if oper given oper lower equal lt use if predic incorrect valu emphas p xhtml p inlin thismodul pcdata predic sampl samplesul xhtml ul lis thismodul li gt lis thismodul li howtodiv end call rule howtodiv begin call rule tabl comment creat tabl measur categori type model element rule tabl allmeasset sequenc measur measureset cat measur categori tabl xhtml tabl caption caption thead thead tfoot tfoot tableel tbodi caption xhtml caption inlin thismodul pcdata cat desc allmeasset first getelementkind element thead xhtml thead trs thismodul firstheaderrow cat allmeasset first allmeasur cat size trs thismodul headerrow allmeasset first cat tfoot xhtml tfoot trs thismodul headerrow allmeasset first cat tbodi xhtml tbodi trs thismodul inputtextrow allmeasset first allmeasur cat trs allmeasset collect ms thismodul datarow ms cat tabl end call rule tabl begin call rule firstheaderrow comment creat xhtml tabl header row categori number column rule firstheaderrow cat measur categori colspan integ tr xhtml tr trelement emptyth trelement th emptyth xhtml th class thismodul cdata empti th xhtml th class thismodul cdata categori colspan colspannumb flow colspannumb xhtml number valu colspan tostr xhtml a href href onclick onclick acont thismodul acronym cat name cat desc href xhtml uri valu thismodul metricdefloc cat name thismodul getmodelkind onclick xhtml script valu window open href blank return fals tr end call rule firstheaderrow begin lazi rule headerrow comment creat tabl row tabl header cell name metric kind element categori lazi rule headerrow ms measur measureset cat measur categori tr xhtml tr trelement thismodul firstheadercel ms getelementkind trelement ms allmeasur cat collect mea thismodul headercel mea metric end lazi rule headerrow begin call rule firstheadercel comment creat xhtml tabl header cell kind model element rule firstheadercel elementtyp string th xhtml th class thismodul cdata element flow thismodul pcdata elementtyp th end call rule firstheadercel begin lazi rule headercel comment creat xhtml tabl header cell acronym metric given lazi rule headercel metric measur metric th xhtml th class thismodul cdata metric flow xhtml a href href onclick onclick acont thismodul acronym metric name metric desc href xhtml uri valu thismodul metricdefloc metric categori name thismodul getmodelkind metric name onclick xhtml script valu window open href blank return fals end call rule headercel begin lazi rule comment creat xhtml tabl row input text field measur categori rule inputtextrow allmea sequenc measur measur tr xhtml tr class thismodul cdata bound trelement firstth firstth xhtml th mea allmea tr trelement thismodul inputtextcel mea tr end call rule inputtextrow begin call rule inputtextcel comment creat xhtml tabl data cell input text field given measur rule inputtextcel mea measur measur th xhtml th flow inputtext inputtext xhtml input type text size thismodul cdata maxlength thismodul cdata valu thismodul cdata mea metric preferredvalu onchang onchang onkeypress onkeypress onchang xhtml script valu changestyl onkeypress xhtml script valu changestyleonent event th end call rule inputtextcel begin lazi rule datarow comment creat xhtml row valu measur measur set categori lazi rule datarow ms measur measureset cat measur categori tr xhtml tr trelement thismodul firstdatacel ms absolutenam trelement ms allmeasur cat collect mea thismodul datacel mea end lazi rule datarow begin call rule firstdatacel comment creat xhtml tabl data cell valu rule firstdatacel elementnam string td xhtml td class thismodul cdata first flow thismodul pcdata elementnam td end call rule firstdatacel begin lazi rule datacel comment creat xhtml tabl data cell measur lazi rule datacel mea measur measur td xhtml td flow thismodul pcdata mea stringvalu mea matchpreferredvalu td class thismodul cdata ignoredvalu td end lazi rule datacel begin call rule cdata comment creat xhtml cdata valu given rule cdata valu string cdata xhtml cdata valu valu cdata end call rule cdata begin call rule pcdata comment creat xhtml pcdata cdata valu given rule pcdata valu string pcdata xhtml pcdata inlin thismodul cdata valu pcdata end call rule pcdata begin helper getstylesheet comment return string contain stylesheet use generat html document helper def getstylesheet string cdata html font famili arial helvetica san serif font size small font style normal font weight normal text align justifi fieldset pad px px px px legend font weight bold caption font style ital font weight bold margin left auto margin right auto pad bottom px tabl border none border collaps collaps margin px auto px auto tr bound th metric th element background c c ff text align center th border px solid black pad px px px px text align center white space nowrap th empti border none th categori background ff acronym border bottom px dot input border px solid gray pad right px text align right td background e e ef border px solid black color ff font famili courier monospac pad px px px px text align right white space nowrap td first color font famili arial helvetica san serif text align left td ignoredvalu background ffffff color adadad text align right color blue text decor none hover text decor underlin end helper getstylesheet begin helper getjavascript comment return string contain script use generat html document helper def getjavascript string cdata function indexof node item var index var current first child node current null current item return index els current node current index return function node index var var current first child node current null index return current els current node current return current function matchpreferredvalu rawvalu inputtext var result fals var valu parsefloat rawvalu inputtext valu substr result valu parsefloat inputtext valu substr inputtext valu length els inputtext valu substr result valu parsefloat inputtext valu substr inputtext valu length els inputtext valu substr result valu parsefloat inputtext valu substr inputtext valu length els inputtext valu substr result valu parsefloat inputtext valu substr inputtext valu length els inputtext valu substr result valu parsefloat inputtext valu substr inputtext valu length els inputtext valu substr result valu parsefloat inputtext valu substr inputtext valu length els inputtext valu substr result valu parsefloat inputtext valu substr inputtext valu length els inputtext valu substr result valu parsefloat inputtext valu substr inputtext valu length els result valu parsefloat inputtext valu inputtext valu inputtext valu inputtext valu return result function changestyleonent event inputtext event keycod changestyl inputtext function changestyl inputtext var tdinputtext inputtext parentnod var index indexof tdinputtext parentnod tdinputtext index var trvalu node tdinputtext parentnod trvalu null trvalu node trvalu var tdvalu trvalu index matchpreferredvalu tdvalu innerhtml inputtext tdvalu classnam els tdvalu classnam ignoredvalu function ws nod return n r test nod data function ignor nod return nod nodetyp nod nodetyp ws nod function node sib sib sib nextsibl ignor sib return sib return null function first child par var res par firstchild res ignor res return res res res nextsibl return null end helper getjavascript,12
96,96,P50-XHTML2XML.atl,"--@atlcompiler	atl2006
--@name			XHTML2XML
--@version		2.0
--@domains		XHTML, Table
--@authors		Eric Vepa (evepa <at> sodius.com) for SODIUS (www.sodius.com)
--@date			2007/08/14
--@description	XHTML extractor for a subset of the XHTML metamodel (table representation).
--@see			<!DOCTYPE html PUBLIC ""-//W3C//DTD XHTML 1.1//EN"" ""http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"">

module XHTML2XML; -- Module Template
create OUT : XML from IN : XHTML;

rule inlines(inlines : Sequence(XHTML!Inline)) {
    using {
        seq : Sequence(XML!Node) = Sequence{};      
    }
    do {
        for (inline in inlines) {            
            if (inline.oclIsKindOf(XHTML!CDATA))
                seq <- seq->append(thisModule.Text(inline.value));
            else if (inline.oclIsKindOf(XHTML!PCDATA))
                seq <- seq->union(thisModule.inlines(inline.inlines));
            else
                seq <- seq->append(inline);
        }
        seq;
    }
}

-- -------------------------------------------------------------------------
-- Document Structure ------------------------------------------------------
-- -------------------------------------------------------------------------

rule HTML {
	from
		html : XHTML!HTML
	to
		xml : XML!Root (
			name <- 'html',
			children <- html.head,
			children <- html.body
		)
	do {
        -- Local attributes and references
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        xml.children <- thisModule.Attribute('xmlns', 'http://www.w3.org/1999/xhtml');
--        xml.children <- thisModule.Attribute('xmlns:xsi', 'http://www.w3.org/2001/XMLSchema-instance');
--        xml.children <- thisModule.Attribute('xsi:schemaLocation', 'http://www.w3.org/MarkUp/SCHEMA/xhtml11.xsd');
    	-- Inherited from Internationalization super-class
		if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
		if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
	}
}

-- -------------------------------------------------------------------------
-- Document Head -----------------------------------------------------------
-- -------------------------------------------------------------------------

rule HEAD {
    from
        html : XHTML!HEAD
    to
        xml : XML!Element (
            name <- 'head',
            children <- html.title,
            children <- html.bases,
            children <- html.headMiscs
        )
    do {
        -- Local attributes and references
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.profile.oclIsUndefined()) xml.children <- thisModule.Attribute('profile', html.profile.value);
        -- Inherited from Internationalization super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
    }
}

rule TITLE {
    from
        html : XHTML!TITLE
    to
        xml : XML!Element (
            name <- 'title',
            children <- thisModule.inlines(html.pcdata.inlines)
        )
    do {
        -- Local attributes and references
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        -- Inherited from Internationalization super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
    }
}

rule META {
    from
        html : XHTML!META
    to
        xml : XML!Element (
            name <- 'meta'
        )
    do {
        -- Local attributes and references
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.httpequiv.oclIsUndefined()) xml.children <- thisModule.Attribute('http-equiv', html.httpequiv.value);
        if (not html.name.oclIsUndefined()) xml.children <- thisModule.Attribute('name', html.name.value);
        if (not html.content.oclIsUndefined()) xml.children <- thisModule.Attribute('content', html.content.value);
        if (not html.scheme.oclIsUndefined()) xml.children <- thisModule.Attribute('scheme', html.scheme.value);
        -- Inherited from Internationalization super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
    }
}

rule LINK {
    from
        html : XHTML!LINK
    to
        xml : XML!Element (
            name <- 'link'
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Local attributes and references
        if (not html.charset.oclIsUndefined()) xml.children <- thisModule.Attribute('charset', html.charset.value);
        if (not html.href.oclIsUndefined()) xml.children <- thisModule.Attribute('href', html.href.value);
        if (not html.hreflang.oclIsUndefined()) xml.children <- thisModule.Attribute('hreflang', html.hreflang.value);
        if (not html.type.oclIsUndefined()) xml.children <- thisModule.Attribute('type', html.type.value);
        if (not html.rel.oclIsUndefined()) xml.children <- thisModule.Attribute('rel', html.rel.value);
        if (not html.rev.oclIsUndefined()) xml.children <- thisModule.Attribute('rev', html.rev.value);
        if (not html.media.oclIsUndefined()) xml.children <- thisModule.Attribute('media', html.media.value);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

rule STYLE {
    from
        html : XHTML!STYLE
    to
        xml : XML!Element (
            name <- 'style',
            children <- thisModule.inlines(html.pcdata.inlines)
        )
    do {
        -- Local attributes and references
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        xml.children <- thisModule.Attribute('type', html.type.value);
        if (not html.media.oclIsUndefined()) xml.children <- thisModule.Attribute('media', html.media.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
    }
}

rule SCRIPT {
    from
        html : XHTML!SCRIPT
    to
        xml : XML!Element (
            name <- 'script',
            children <- if (not html.pcdata.oclIsUndefined())
			                 then thisModule.inlines(html.pcdata.inlines)
							 else thisModule.Text('')
			             endif
        )
    do {
        -- Local attributes and references
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.charset.oclIsUndefined()) xml.children <- thisModule.Attribute('charset', html.charset.value);
        xml.children <- thisModule.Attribute('type', html.type.value);
        if (not html.src.oclIsUndefined()) xml.children <- thisModule.Attribute('src', html.src.value);
        if (not html.defer.oclIsUndefined()) xml.children <- thisModule.Attribute('defer', html.defer.value);
    }
}

rule NOSCRIPT {
    from
        html : XHTML!NOSCRIPT
    to
        xml : XML!Element (
            name <- 'noscript',
            children <- thisModule.inlines(html.blocks)
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

-- -------------------------------------------------------------------------
-- Document Body -----------------------------------------------------------
-- -------------------------------------------------------------------------

rule BODY {
    from
        html : XHTML!BODY
    to
        xml : XML!Element (
            name <- 'body',
            children <- thisModule.inlines(html.blocks)
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Local attributes and references
        if (not html.onload.oclIsUndefined()) xml.children <- thisModule.Attribute('onload', html.onload.value);
        if (not html.onunload.oclIsUndefined()) xml.children <- thisModule.Attribute('onunload', html.onunload.value);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

rule DIV {
    from
        html : XHTML!DIV
    to
        xml : XML!Element (
            name <- 'div',
            children <- thisModule.inlines(html.flows)
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

-- -------------------------------------------------------------------------
-- Paragraphs --------------------------------------------------------------
-- -------------------------------------------------------------------------

rule P {
    from
        html : XHTML!P
    to
        xml : XML!Element (
            name <- 'p',
            children <- thisModule.inlines(html.inlines)
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

-- -------------------------------------------------------------------------
-- Lists -------------------------------------------------------------------
-- -------------------------------------------------------------------------

-- UL or OL
rule AbstractList {
    from
        html : XHTML!AbstractList
    to
        xml : XML!Element (
            name <- if (html.oclIsKindOf(XHTML!UL))
                       then 'ul'
                       else 'ol'
                    endif,
			children <- html.lis
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

rule LI {
    from
        html : XHTML!LI
    to
        xml : XML!Element (
            name <- 'li',
            children <- thisModule.inlines(html.flows)
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

-- -------------------------------------------------------------------------
-- Horizontal Rule --------------------------------------------------
-- -------------------------------------------------------------------------

rule HR {
    from
        html : XHTML!HR
    to
        xml : XML!Element (
            name <- 'hr'
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

-- -------------------------------------------------------------------------
-- Preformatted Text -------------------------------------------------------
-- -------------------------------------------------------------------------

rule PRE {
    from
        html : XHTML!PRE
    to
        xml : XML!Element (
            name <- 'pre',
			children <- thisModule.inlines(html.preContents)
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

-- -------------------------------------------------------------------------
-- The Anchor Element ------------------------------------------------------
-- -------------------------------------------------------------------------

rule A {
    from
        html : XHTML!A
    to
        xml : XML!Element (
            name <- 'a',
            children <- thisModule.inlines(html.aContents)
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Local attributes and references
        if (not html.charset.oclIsUndefined()) xml.children <- thisModule.Attribute('charset', html.charset.value);
        if (not html.type.oclIsUndefined()) xml.children <- thisModule.Attribute('type', html.type.value);
        if (not html.href.oclIsUndefined()) xml.children <- thisModule.Attribute('href', html.href.value);
        if (not html.hreflang.oclIsUndefined()) xml.children <- thisModule.Attribute('hreflang', html.hreflang.value);
        if (not html.rel.oclIsUndefined()) xml.children <- thisModule.Attribute('rel', html.rel.value);
        if (not html.rev.oclIsUndefined()) xml.children <- thisModule.Attribute('rev', html.rev.value);
        if (not (html.shape = #rect)) xml.children <- thisModule.Attribute('shape', html.shape);
        if (not html.coords.oclIsUndefined()) xml.children <- thisModule.Attribute('coords', html.coords.value);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
        -- Inherited from Focus super-class
        if (not html.accesskey.oclIsUndefined()) xml.children <- thisModule.Attribute('accesskey', html.accesskey.value);
        if (not html.tabindex.oclIsUndefined()) xml.children <- thisModule.Attribute('tabindex', html.tabindex.value);
        if (not html.onfocus.oclIsUndefined()) xml.children <- thisModule.Attribute('onfocus', html.onfocus.value);
        if (not html.onblur.oclIsUndefined()) xml.children <- thisModule.Attribute('onblur', html.onblur.value);
    }
}

-- -------------------------------------------------------------------------
-- Inline Elements ---------------------------------------------------------
-- -------------------------------------------------------------------------

rule BR {
    from
        html : XHTML!BR
    to
        xml : XML!Element (
            name <- 'br'
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
    }
}

-- STRONG or ACRONYM
rule Phrase {
    from
        html : XHTML!Phrase
    to
        xml : XML!Element (
            name <- if (html.oclIsKindOf(XHTML!STRONG))
		            	then 'strong'
		            	else 'acronym'
					endif,
            children <- thisModule.inlines(html.inlines)
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

-- I
rule Fontstyle {
    from
        html : XHTML!Fontstyle
    to
        xml : XML!Element (
            name <- 'i',
            children <- thisModule.inlines(html.inlines)
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

-- -------------------------------------------------------------------------
-- Images ------------------------------------------------------------------
-- -------------------------------------------------------------------------

rule IMG {
    from
        html : XHTML!IMG
    to
        xml : XML!Element (
            name <- 'img'
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Local attributes and references
        xml.children <- thisModule.Attribute('src', html.src.value); 
        xml.children <- thisModule.Attribute('alt', html.alt.value); 
        if (not html.longdesc.oclIsUndefined()) xml.children <- thisModule.Attribute('longdesc', html.longdesc.value); 
        if (not html.height.oclIsUndefined()) xml.children <- thisModule.Attribute('height', html.height.value); 
        if (not html.width.oclIsUndefined()) xml.children <- thisModule.Attribute('width', html.width.value); 
        if (not html.usemap.oclIsUndefined()) xml.children <- thisModule.Attribute('usemap', html.usemap.value);
        if (html.ismap) xml.children <- thisModule.Attribute('ismap', 'ismap');
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

-- -------------------------------------------------------------------------
-- Forms -------------------------------------------------------------------
-- -------------------------------------------------------------------------

rule INPUT {
    from
        html : XHTML!INPUT
    to
        xml : XML!Element (
            name <- 'input'
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Local attributes and references
		if (not (html.type = #text)) xml.children <- thisModule.Attribute('type', html.type);
        if (not html.name.oclIsUndefined()) xml.children <- thisModule.Attribute('name', html.name.value);
        if (not html.value.oclIsUndefined()) xml.children <- thisModule.Attribute('value', html.value.value);
        if (html.checked) xml.children <- thisModule.Attribute('checked', 'checked');
        if (html.disabled) xml.children <- thisModule.Attribute('disabled', 'disabled');
        if (html.readonly) xml.children <- thisModule.Attribute('readonly', 'readonly');
        if (not html.size.oclIsUndefined()) xml.children <- thisModule.Attribute('size', html.size.value);
        if (not html.maxlength.oclIsUndefined()) xml.children <- thisModule.Attribute('maxlength', html.maxlength.value);
        if (not html.src.oclIsUndefined()) xml.children <- thisModule.Attribute('src', html.src.value);
        if (not html.alt.oclIsUndefined()) xml.children <- thisModule.Attribute('alt', html.alt.value);
        if (not html.usemap.oclIsUndefined()) xml.children <- thisModule.Attribute('usemap', html.usemap.value);
        if (not html.onselect.oclIsUndefined()) xml.children <- thisModule.Attribute('onselect', html.onselect.value);
        if (not html.onchange.oclIsUndefined()) xml.children <- thisModule.Attribute('onchange', html.onchange.value);
        if (not html.accept.oclIsUndefined()) xml.children <- thisModule.Attribute('accept', html.accept.value);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
        -- Inherited from Focus super-class
        if (not html.accesskey.oclIsUndefined()) xml.children <- thisModule.Attribute('accesskey', html.accesskey.value);
        if (not html.tabindex.oclIsUndefined()) xml.children <- thisModule.Attribute('tabindex', html.tabindex.value);
        if (not html.onfocus.oclIsUndefined()) xml.children <- thisModule.Attribute('onfocus', html.onfocus.value);
        if (not html.onblur.oclIsUndefined()) xml.children <- thisModule.Attribute('onblur', html.onblur.value);
    }
}

rule FIELDSET {
    from
        html : XHTML!FIELDSET
    to
        xml : XML!Element (
            name <- 'fieldset',
			children <- html.fieldsetElements
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

rule LEGEND {
    from
        html : XHTML!LEGEND
    to
        xml : XML!Element (
            name <- 'legend',
            children <- thisModule.inlines(html.inlines)
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Local attributes and references
        if (not html.accesskey.oclIsUndefined()) xml.children <- thisModule.Attribute('accesskey', html.accesskey.value);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

-- -------------------------------------------------------------------------
-- Tables ------------------------------------------------------------------
-- -------------------------------------------------------------------------

rule TABLE {
    from
        html : XHTML!TABLE
    to
        xml : XML!Element (
            name <- 'table',
            children <- html.caption,
            children <- html.colElements,
            children <- html.thead,
            children <- html.tfoot,
            children <- html.tableElements
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Local attributes and references
        if (not html.summary.oclIsUndefined()) xml.children <- thisModule.Attribute('summary', html.summary.value); 
        if (not html.width.oclIsUndefined()) xml.children <- thisModule.Attribute('width', html.width.value); 
        if (not html.border.oclIsUndefined()) xml.children <- thisModule.Attribute('border', html.border.value); 
        if (not (html.frame = #void)) xml.children <- thisModule.Attribute('frame', html.frame); 
        if (not (html.rules = #none)) xml.children <- thisModule.Attribute('rules', html.rules); 
        if (not html.cellspacing.oclIsUndefined()) xml.children <- thisModule.Attribute('cellspacing', html.cellspacing.value); 
        if (not html.cellpadding.oclIsUndefined()) xml.children <- thisModule.Attribute('cellpadding', html.cellpadding.value); 
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

rule CAPTION {
    from
        html : XHTML!CAPTION
    to
        xml : XML!Element (
            name <- 'caption',
            children <- thisModule.inlines(html.inlines)
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

-- THEAD, TFOOT or TBODY
rule TElement {
    from
        html : XHTML!TElement
    to
        xml : XML!Element (
            name <- if (html.oclIsKindOf(XHTML!TBODY))
            	       then 'tbody'
					   else if (html.oclIsKindOf(XHTML!TFOOT))
		                       then 'tfoot'
		                       else 'thead'
		                    endif
					endif,
            children <- html.trs
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Inherited from CellHAlign super-class
        if (not (html.align = #left)) xml.children <- thisModule.Attribute('align', html.align);
        if (not html.charoff.oclIsUndefined()) xml.children <- thisModule.Attribute('charoff', html.charoff.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
        -- Inherited from CellVAlign super-class
        if (not (html.valign = #top)) xml.children <- thisModule.Attribute('valign', html.valign);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

rule TR {
    from
        html : XHTML!TR
    to
        xml : XML!Element (
            name <- 'tr',
            children <- html.trElements
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Inherited from CellHAlign super-class
        if (not (html.align = #left)) xml.children <- thisModule.Attribute('align', html.align);
        if (not html.charoff.oclIsUndefined()) xml.children <- thisModule.Attribute('charoff', html.charoff.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
        -- Inherited from CellVAlign super-class
        if (not (html.valign = #top)) xml.children <- thisModule.Attribute('valign', html.valign);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

-- TD or TH
rule TRElement {
    from
        html : XHTML!TRElement
    to
        xml : XML!Element (
            name <- if (html.oclIsKindOf(XHTML!TD))
                       then 'td'
                       else 'th'
                    endif,
            children <- thisModule.inlines(html.flows)
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Local attributes and references
        if (not html.abbr.oclIsUndefined()) xml.children <- thisModule.Attribute('abbr', html.abbr.value);
        if (not html.headers.oclIsUndefined()) xml.children <- thisModule.Attribute('headers', html.headers.value);
        if (not (html.scope = #none)) xml.children <- thisModule.Attribute('scope', html.scope);
        if (not html.rowspan.oclIsUndefined()) xml.children <- thisModule.Attribute('rowspan', html.rowspan.value);
        if (not html.colspan.oclIsUndefined()) xml.children <- thisModule.Attribute('colspan', html.colspan.value);
        -- Inherited from CellHAlign super-class        if (not (html.align = #left)) xml.children <- thisModule.Attribute('align', html.align);
        if (not html.charoff.oclIsUndefined()) xml.children <- thisModule.Attribute('charoff', html.charoff.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
        -- Inherited from CellVAlign super-class
        if (not (html.valign = #top)) xml.children <- thisModule.Attribute('valign', html.valign);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

-- -------------------------------------------------------------------------
-- XML Attribute and Text --------------------------------------------------
-- -------------------------------------------------------------------------

--@begin called rule Attribute
rule Attribute(attrName : String, attrValue : String) {
	to
		attr : XML!Attribute (
			name <- attrName,
			value <- attrValue
		)
	do {
		attr;
	}
}	
--@end called rule Attribute

--@begin called rule Attribute
rule Attribute(attrName : String, attrValue : Integer) {
	to
		attr : XML!Attribute (
			name <- attrName,
			value <- attrValue.toString()
		)
	do {
		attr;
	}
}	
--@end called rule Attribute

--@begin called rule Text
rule Text(value : String) {
	to
		text : XML!Text (
			value <-
				if not value.oclIsUndefined()
					then value
					else ''
				endif
		)
	do {
		text;
	}
}	
--@end called rule Text",atlcompil atl name xhtml xml version domain xhtml tabl author eric vepa evepa sodius com sodius www sodius com date descript xhtml extractor subset xhtml metamodel tabl represent see doctyp html public w c dtd xhtml en http www w org tr xhtml dtd xhtml dtd modul xhtml xml modul templat creat out xml in xhtml rule inlin inlin sequenc xhtml inlin use seq sequenc xml node sequenc inlin inlin inlin ocliskindof xhtml cdata seq seq append thismodul text inlin valu els inlin ocliskindof xhtml pcdata seq seq union thismodul inlin inlin inlin els seq seq append inlin seq document structur rule html html xhtml html xml xml root name html children html head children html bodi local attribut refer html id oclisundefin xml children thismodul attribut id html id valu xml children thismodul attribut xmlns http www w org xhtml xml children thismodul attribut xmlns xsi http www w org xmlschema instanc xml children thismodul attribut xsi schemaloc http www w org markup schema xhtml xsd inherit internation super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir document head rule head html xhtml head xml xml element name head children html titl children html base children html headmisc local attribut refer html id oclisundefin xml children thismodul attribut id html id valu html profil oclisundefin xml children thismodul attribut profil html profil valu inherit internation super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir rule titl html xhtml titl xml xml element name titl children thismodul inlin html pcdata inlin local attribut refer html id oclisundefin xml children thismodul attribut id html id valu inherit internation super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir rule meta html xhtml meta xml xml element name meta local attribut refer html id oclisundefin xml children thismodul attribut id html id valu html httpequiv oclisundefin xml children thismodul attribut http equiv html httpequiv valu html name oclisundefin xml children thismodul attribut name html name valu html content oclisundefin xml children thismodul attribut content html content valu html scheme oclisundefin xml children thismodul attribut scheme html scheme valu inherit internation super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir rule link html xhtml link xml xml element name link inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir local attribut refer html charset oclisundefin xml children thismodul attribut charset html charset valu html href oclisundefin xml children thismodul attribut href html href valu html hreflang oclisundefin xml children thismodul attribut hreflang html hreflang valu html type oclisundefin xml children thismodul attribut type html type valu html rel oclisundefin xml children thismodul attribut rel html rel valu html rev oclisundefin xml children thismodul attribut rev html rev valu html media oclisundefin xml children thismodul attribut media html media valu inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu rule style html xhtml style xml xml element name style children thismodul inlin html pcdata inlin local attribut refer html id oclisundefin xml children thismodul attribut id html id valu xml children thismodul attribut type html type valu html media oclisundefin xml children thismodul attribut media html media valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir rule script html xhtml script xml xml element name script children html pcdata oclisundefin thismodul inlin html pcdata inlin els thismodul text endif local attribut refer html id oclisundefin xml children thismodul attribut id html id valu html charset oclisundefin xml children thismodul attribut charset html charset valu xml children thismodul attribut type html type valu html src oclisundefin xml children thismodul attribut src html src valu html defer oclisundefin xml children thismodul attribut defer html defer valu rule noscript html xhtml noscript xml xml element name noscript children thismodul inlin html block inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu document bodi rule bodi html xhtml bodi xml xml element name bodi children thismodul inlin html block inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir local attribut refer html onload oclisundefin xml children thismodul attribut onload html onload valu html onunload oclisundefin xml children thismodul attribut onunload html onunload valu inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu rule div html xhtml div xml xml element name div children thismodul inlin html flow inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu paragraph rule p html xhtml p xml xml element name p children thismodul inlin html inlin inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu list ul ol rule abstractlist html xhtml abstractlist xml xml element name html ocliskindof xhtml ul ul els ol endif children html lis inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu rule li html xhtml li xml xml element name li children thismodul inlin html flow inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu horizont rule rule hr html xhtml hr xml xml element name hr inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu preformat text rule pre html xhtml pre xml xml element name pre children thismodul inlin html precont inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu the anchor element rule a html xhtml a xml xml element name children thismodul inlin html acont inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir local attribut refer html charset oclisundefin xml children thismodul attribut charset html charset valu html type oclisundefin xml children thismodul attribut type html type valu html href oclisundefin xml children thismodul attribut href html href valu html hreflang oclisundefin xml children thismodul attribut hreflang html hreflang valu html rel oclisundefin xml children thismodul attribut rel html rel valu html rev oclisundefin xml children thismodul attribut rev html rev valu html shape rect xml children thismodul attribut shape html shape html coord oclisundefin xml children thismodul attribut coord html coord valu inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu inherit focus super class html accesskey oclisundefin xml children thismodul attribut accesskey html accesskey valu html tabindex oclisundefin xml children thismodul attribut tabindex html tabindex valu html onfocus oclisundefin xml children thismodul attribut onfocus html onfocus valu html onblur oclisundefin xml children thismodul attribut onblur html onblur valu inlin element rule br html xhtml br xml xml element name br inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu strong acronym rule phrase html xhtml phrase xml xml element name html ocliskindof xhtml strong strong els acronym endif children thismodul inlin html inlin inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu i rule fontstyl html xhtml fontstyl xml xml element name children thismodul inlin html inlin inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu imag rule img html xhtml img xml xml element name img inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir local attribut refer xml children thismodul attribut src html src valu xml children thismodul attribut alt html alt valu html longdesc oclisundefin xml children thismodul attribut longdesc html longdesc valu html height oclisundefin xml children thismodul attribut height html height valu html width oclisundefin xml children thismodul attribut width html width valu html usemap oclisundefin xml children thismodul attribut usemap html usemap valu html ismap xml children thismodul attribut ismap ismap inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu form rule input html xhtml input xml xml element name input inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir local attribut refer html type text xml children thismodul attribut type html type html name oclisundefin xml children thismodul attribut name html name valu html valu oclisundefin xml children thismodul attribut valu html valu valu html check xml children thismodul attribut check check html disabl xml children thismodul attribut disabl disabl html readon xml children thismodul attribut readon readon html size oclisundefin xml children thismodul attribut size html size valu html maxlength oclisundefin xml children thismodul attribut maxlength html maxlength valu html src oclisundefin xml children thismodul attribut src html src valu html alt oclisundefin xml children thismodul attribut alt html alt valu html usemap oclisundefin xml children thismodul attribut usemap html usemap valu html onselect oclisundefin xml children thismodul attribut onselect html onselect valu html onchang oclisundefin xml children thismodul attribut onchang html onchang valu html accept oclisundefin xml children thismodul attribut accept html accept valu inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu inherit focus super class html accesskey oclisundefin xml children thismodul attribut accesskey html accesskey valu html tabindex oclisundefin xml children thismodul attribut tabindex html tabindex valu html onfocus oclisundefin xml children thismodul attribut onfocus html onfocus valu html onblur oclisundefin xml children thismodul attribut onblur html onblur valu rule fieldset html xhtml fieldset xml xml element name fieldset children html fieldsetel inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu rule legend html xhtml legend xml xml element name legend children thismodul inlin html inlin inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir local attribut refer html accesskey oclisundefin xml children thismodul attribut accesskey html accesskey valu inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu tabl rule tabl html xhtml tabl xml xml element name tabl children html caption children html colel children html thead children html tfoot children html tableel inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir local attribut refer html summari oclisundefin xml children thismodul attribut summari html summari valu html width oclisundefin xml children thismodul attribut width html width valu html border oclisundefin xml children thismodul attribut border html border valu html frame void xml children thismodul attribut frame html frame html rule none xml children thismodul attribut rule html rule html cellspac oclisundefin xml children thismodul attribut cellspac html cellspac valu html cellpad oclisundefin xml children thismodul attribut cellpad html cellpad valu inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu rule caption html xhtml caption xml xml element name caption children thismodul inlin html inlin inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu thead tfoot tbodi rule telement html xhtml telement xml xml element name html ocliskindof xhtml tbodi tbodi els html ocliskindof xhtml tfoot tfoot els thead endif endif children html trs inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir inherit cellhalign super class html align left xml children thismodul attribut align html align html charoff oclisundefin xml children thismodul attribut charoff html charoff valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu inherit cellvalign super class html valign top xml children thismodul attribut valign html valign inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu rule tr html xhtml tr xml xml element name tr children html trelement inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir inherit cellhalign super class html align left xml children thismodul attribut align html align html charoff oclisundefin xml children thismodul attribut charoff html charoff valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu inherit cellvalign super class html valign top xml children thismodul attribut valign html valign inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu td th rule trelement html xhtml trelement xml xml element name html ocliskindof xhtml td td els th endif children thismodul inlin html flow inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir local attribut refer html abbr oclisundefin xml children thismodul attribut abbr html abbr valu html header oclisundefin xml children thismodul attribut header html header valu html scope none xml children thismodul attribut scope html scope html rowspan oclisundefin xml children thismodul attribut rowspan html rowspan valu html colspan oclisundefin xml children thismodul attribut colspan html colspan valu inherit cellhalign super class html align left xml children thismodul attribut align html align html charoff oclisundefin xml children thismodul attribut charoff html charoff valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu inherit cellvalign super class html valign top xml children thismodul attribut valign html valign inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu xml attribut text begin call rule attribut rule attribut attrnam string attrvalu string attr xml attribut name attrnam valu attrvalu attr end call rule attribut begin call rule attribut rule attribut attrnam string attrvalu integ attr xml attribut name attrnam valu attrvalu tostr attr end call rule attribut begin call rule text rule text valu string text xml text valu valu oclisundefin valu els endif text end call rule text,9
97,97,P51-HTML2XML.atl,"--@name HTML2XML
--@version 1.0
--@domains HTML, Table
--@authors Eric Vepa (eric.vepa <at> gmail.com)
--@date 2006/08/04
--@description XML extractor for HTML tabular representation.
--@see
--@comments

module HTML2XML; -- Module Template
create OUT : XML from IN : HTML;

--@begin rule HTML2Root
rule HTML2Root {
	from
		html:HTML!HTML
	to
		root:XML!Root (
			name <- 'HTML',
			children <- html.head,
			children <- html.body
		)
}	
--@end rule HTML2Root

--@begin rule HEAD2Element
rule HEAD2Element {
	from
		head:HTML!HEAD
	to
		elmt:XML!Element (
			name <- 'HEAD',
			children <- head.headElements
		)
}	
--@end rule HEAD2Element

--@begin rule TITLE2Element
rule TITLE2Element {
	from
		title:HTML!TITLE
	to
		elmt:XML!Element (
			name <- 'TITLE',
			children <- value
		),
		value:XML!Text (
			value <- if not title.value.oclIsUndefined() then title.value else '' endif
		)
}	
--@end rule TITLE2Element

--@begin rule BODY2Element
rule BODY2Element {
	from
		body:HTML!BODY
	to
		elmt:XML!Element (
			name <- 'BODY',
			children <- body.bodyElements
		)
}	
--@end rule BODY2Element

--@begin rule TABLE2Element
rule TABLE2Element {
	from
		table:HTML!TABLE
	to
		elmt:XML!Element (
			name <- 'TABLE',
			children <- thisModule.Attribute('border', if not table.border.oclIsUndefined() then table.border else '0' endif),
			children <- table.trs
		)
}	
--@end rule TABLE2Element

--@begin rule TR2Element
rule TR2Element {
	from
		tr:HTML!TR
	to
		elmt:XML!Element (
			name <- 'TR',
			children <- tr.tds
		)
}	
--@end rule TR2Element

--@begin rule TH2Element
rule TH2Element {
	from
		th:HTML!TH
	to
		elmt:XML!Element (
			name <- 'TH',
			children <- value
		),
		value:XML!Text (
			value <- if not th.value.oclIsUndefined() then th.value else '' endif
		)
}	
--@end rule TH2Element

--@begin rule TD2Element
rule TD2Element {
	from
		td:HTML!TD (
			not td.oclIsTypeOf(HTML!TH)
		)
	to
		elmt:XML!Element (
			name <- 'TD',
			children <- value
		),
		value:XML!Text (
			value <- if not td.value.oclIsUndefined() then td.value else '' endif
		)
}	
--@end rule TD2Element

--@begin lazy rule Attribute
lazy rule Attribute {
	from
		attrName:String,
		attrValue:String
	to
		attr:XML!Attribute (
			name <- attrName,
			value <- attrValue
		)
}	
--@end lazy rule Attribute",name html xml version domain html tabl author eric vepa eric vepa gmail com date descript xml extractor html tabular represent see comment modul html xml modul templat creat out xml in html begin rule html root rule html root html html html root xml root name html children html head children html bodi end rule html root begin rule head element rule head element head html head elmt xml element name head children head headel end rule head element begin rule titl element rule titl element titl html titl elmt xml element name titl children valu valu xml text valu titl valu oclisundefin titl valu els endif end rule titl element begin rule bodi element rule bodi element bodi html bodi elmt xml element name bodi children bodi bodyel end rule bodi element begin rule tabl element rule tabl element tabl html tabl elmt xml element name tabl children thismodul attribut border tabl border oclisundefin tabl border els endif children tabl trs end rule tabl element begin rule tr element rule tr element tr html tr elmt xml element name tr children tr tds end rule tr element begin rule th element rule th element th html th elmt xml element name th children valu valu xml text valu th valu oclisundefin th valu els endif end rule th element begin rule td element rule td element td html td td oclistypeof html th elmt xml element name td children valu valu xml text valu td valu oclisundefin td valu els endif end rule td element begin lazi rule attribut lazi rule attribut attrnam string attrvalu string attr xml attribut name attrnam valu attrvalu end lazi rule attribut,9
98,98,P51-KM32EMF.atl,"module KM32EMF;
create OUT : MOF from IN : KM3;

uses strings;

rule Package {
	from e : KM3!Package
	to
		c : MOF!EPackage (
			name <- e.name,
			eClassifiers <- e.contents->select(e | e.oclIsKindOf(KM3!Classifier)),
			eSubpackages <- e.contents->select(e | e.oclIsKindOf(KM3!Package))
		)
}

--rule OCLConstraint {
--	from e : XML!Element (e.name = 'ocl')
--	to
--		c : MOF!Constraint (
--			name <- e.getAttrVal('name'),
--			container <- e.parent.parent.parent,		-- WARNING Poseidon->UML2MOF stores constraints in packages, not classes
--			constrainedElements <- Sequence {e.parent},
--			language <- 'OCL',
--			expression <- e.getAttrVal('expr'),
--			annotation <- ''
--		)
--}

--rule Import {
--	from e : XML!Element (e.name = 'import')
--	to
--		c : MOF!Import (
--			name <- e.getAttrVal('name'),
--			visibility <- #public_vis,
--			isClustered <- true,
--			annotation <- '',
----			importedNamespace <- xmm2MOF.getElement(e.getAttrVal('name'), Set {'pack'})
--			importedNamespace <- self.getElement(e.getAttrVal('name'), Set {'pack'})
--		)
--}

rule PrimitiveType {
	from e : KM3!DataType
	to
		c : MOF!EDataType (
			name <- e.name
		)
}

rule Reference {
	from e : KM3!Reference
	to
		c : MOF!EReference (
			name <- e.name,
			eType <- e.type,
			lowerBound <- e.lower,
			upperBound <- e.upper,
			ordered <- e.isOrdered,
			eOpposite <- e.opposite,
			containment <- e.isContainer
		)
}

rule Class {
	from e : KM3!Class
	to
		c : MOF!EClass (
			name <- e.name,
			eStructuralFeatures <- e.structuralFeatures,
			eOperations <- e.operations,
			eSuperTypes <- e.supertypes,
			""abstract"" <- e.isAbstract
		)
}

rule Attribute {
	from e : KM3!Attribute
	to
		c : MOF!EAttribute (
			name <- e.name,
			eType <- e.type,
			lowerBound <- e.lower,
			upperBound <- e.upper,
			ordered <- e.isOrdered
		)
}

rule Enumeration {
	from e : KM3!Enumeration
	to
		c : MOF!EEnum (
			name <- e.name,
			eLiterals <- e.literals
		)
}

rule EnumLiteral {
	from e : KM3!EnumLiteral
	to
		c : MOF!EEnumLiteral (
			name <- e.name
		)
}

rule Operation {
	from
		io : KM3!Operation
	to
		oo : MOF!EOperation (
			name <- io.name,
			eParameters <- io.parameters,
			eType <- io.type
		)
}

rule Parameter {
	from
		ip : KM3!Parameter
	to
		op : MOF!EParameter (
			name <- ip.name,
			eType <- ip.type
		)
}

",modul km emf creat out mof in km use string rule packag e km packag c mof epackag name e name eclassifi e content select e e ocliskindof km classifi esubpackag e content select e e ocliskindof km packag rule oclconstraint e xml element e name ocl c mof constraint name e getattrv name contain e parent parent parent warn poseidon uml mof store constraint packag class constrainedel sequenc e parent languag ocl express e getattrv expr annot rule import e xml element e name import c mof import name e getattrv name visibl public vis isclust true annot importednamespac xmm mof getel e getattrv name set pack importednamespac self getel e getattrv name set pack rule primitivetyp e km datatyp c mof edatatyp name e name rule refer e km refer c mof erefer name e name etyp e type lowerbound e lower upperbound e upper order e isord eopposit e opposit contain e iscontain rule class e km class c mof eclass name e name estructuralfeatur e structuralfeatur eoper e oper esupertyp e supertyp abstract e isabstract rule attribut e km attribut c mof eattribut name e name etyp e type lowerbound e lower upperbound e upper order e isord rule enumer e km enumer c mof eenum name e name eliter e liter rule enumliter e km enumliter c mof eenumliter name e name rule oper io km oper oo mof eoper name io name eparamet io paramet etyp io type rule paramet ip km paramet op mof eparamet name ip name etyp ip type,18
99,99,P51-KM32Measure.atl,"--@name KM32Measure
--@version 1.0
--@domains measurement data, metrics, metamodel
--@authors Eric Vepa (eric.vepa <at> gmail.com)
--@date 2006/08/06
--@description This transformation is used to collect measurement data on a KM3 metamodel. Some metrics are defined and measures are performed on the different model element and stored with the help of the Measure metamodel.

module KM32Measure; -- Module Template
create OUT : Measure from IN : KM3;

--@begin helper divide
--@comments returns a number even for a division by zero
helper context Real def : divide(divisor: Real) : Real =
	if divisor = 0
		then 0
		else self/divisor
	endif;
--@end helper divide

--@begin attribute helper allClasses
--@comments returns the sequence of all Class element of a Package or Metamodel element
helper context KM3!Package def : allClasses : Sequence(KM3!Class) =
	self.contents->select(c|c.oclIsTypeOf(KM3!Class));

helper context KM3!Metamodel def : allClasses : Sequence(KM3!Class) =
	self.contents->iterate(pkg; acc : Sequence(KM3!Class)=Sequence{}|
		acc->union(pkg.allClasses))->flatten();
--@end attribute helper allClasses

--@begin attribute helper allAttributesInherited
--@comments returns the sequence of all Attribute elements inherited of a Class, a Package or a Metamodel element
helper context KM3!Class def : allAttributesInherited : Sequence(KM3!Attribute) =
	if self.supertypes->isEmpty()
		then Sequence{}
		else self.supertypes->iterate(supertype; acc : Sequence(KM3!Attribute)=Sequence{}|
			acc->union(supertype.allAttributes))
	endif;

helper context KM3!Package def : allAttributesInherited : Sequence(KM3!Attribute) =
	self.allClasses->iterate(c; acc : Sequence(KM3!Attribute)=Sequence{}|
		acc->including(c.allAttributesInherited))->flatten();

helper context KM3!Metamodel def : allAttributesInherited : Sequence(KM3!Attribute) =
	self.allClasses->iterate(c; acc : Sequence(KM3!Attribute)=Sequence{}|
		acc->including(c.allAttributesInherited))->flatten();
--@end attribute helper allAttributesInherited

--@begin attribute helper allAttributes
--@comments returns the sequence of all Attribute elements (locally defined and inherited) of a Class, a Package or a Metamodel element
helper context KM3!Class def : allAttributes : Sequence(KM3!Attribute) =
	self.structuralFeatures->select(sf|sf.oclIsTypeOf(KM3!Attribute))->
		union(self.allAttributesInherited);

helper context KM3!Package def : allAttributes : Sequence(KM3!Attribute) =
	self.allClasses->iterate(class; acc : Sequence(KM3!Attribute)=Sequence{}|
		acc->union(class.allAttributes))->flatten();

helper context KM3!Metamodel def : allAttributes : Sequence(KM3!Attribute) =
	self.contents->iterate(pkg; acc : Sequence(KM3!Attribute)=Sequence{}|
		acc->union(pkg.allAttributes))->flatten();
--@end attribute helper allAttributes

--@begin attribute helper allReferencesInherited
--@comments returns the sequence of all Reference elements inherited of a Class, a Package or a Metamodel element
helper context KM3!Class def : allReferencesInherited : Sequence(KM3!Reference) =
	if self.supertypes->isEmpty()
		then Sequence{}
		else self.supertypes->iterate(supertype; acc : Sequence(KM3!Reference)=Sequence{}|
			supertype.allReferences)
	endif;

helper context KM3!Package def : allReferencesInherited : Sequence(KM3!Reference) =
	self.allClasses->iterate(c; acc : Sequence(KM3!Reference)=Sequence{}|
		acc->including(c.allReferencesInherited))->flatten();

helper context KM3!Metamodel def : allReferencesInherited : Sequence(KM3!Reference) =
	self.allClasses->iterate(c; acc : Sequence(KM3!Reference)=Sequence{}|
		acc->including(c.allReferencesInherited))->flatten();
--@end attribute helper allReferencesInherited

--@begin attribute helper allReferences
--@comments returns the sequence of all Reference elements (locally defined and inherited) of a Class, a Package or a Metamodel element
helper context KM3!Class def : allReferences : Sequence(KM3!Reference) =
	self.structuralFeatures->select(sf|sf.oclIsTypeOf(KM3!Reference))->
		union(self.allReferencesInherited)->flatten();

helper context KM3!Package def : allReferences : Sequence(KM3!Reference) =
	self.allClasses->iterate(class; acc : Sequence(KM3!Reference)=Sequence{}|
		--@comments returns Reference element without opposite or which not have container opposite
		acc->union(class.allReferences->select(ref|
				if ref.opposite.oclIsUndefined()
					then true
					else not ref.opposite.isContainer
				endif)))->flatten();

helper context KM3!Metamodel def : allReferences : Sequence(KM3!Reference) =
	self.contents->iterate(pkg; acc : Sequence(KM3!Reference)=Sequence{}|
		acc->union(pkg.allReferences))->flatten();
--@end attribute helper allReferences

--@begin helper attributeInheritanceFactor
--@comments returns the value of the metric Attribute Inheritance Factor for a Class, Package or Metamodel element
helper context KM3!LocatedElement def : attributeInheritanceFactor() : Real =
	self.allAttributesInherited->size().divide(self.allAttributes->size());
--@end helper attributeInheritanceFactor

--@begin helper depthInheritanceTree
--@comments returns the value of the metric Depth Inheritance Tree for a Class, Package or Metamodel element
helper context KM3!Class def : depthInheritanceTree() : Real =
	if self.supertypes->isEmpty()
		then 0
		else 1+self.supertypes->iterate(supertype; maxDIT:Real=0|
			maxDIT.max(supertype.depthInheritanceTree()))
	endif;

helper context KM3!Package def : depthInheritanceTree() : Real =
	self.allClasses->iterate(c; maxDIT:Real=0|maxDIT.max(c.depthInheritanceTree()));

helper context KM3!Metamodel def : depthInheritanceTree() : Real =
	self.allClasses->iterate(c; maxDIT:Real=0|maxDIT.max(c.depthInheritanceTree()));
--@end helper depthInheritanceTree

--@begin helper numberOfChildren
--@comments returns the value of the metric Number of Children for a Class, Package or Metamodel element
helper context KM3!Class def : numberOfChildren() : Real =
	KM3!Class.allInstances()->select(c|c.supertypes->includes(self))->size();

helper context KM3!Package def : numberOfChildren() : Real =
	if self.allClasses->isEmpty()
		then 0
		else self.allClasses->collect(c|c.numberOfChildren())->sum()
	endif;

helper context KM3!Metamodel def : numberOfChildren() : Real =
	if self.allClasses->isEmpty()
		then 0
		else self.allClasses->collect(c|c.numberOfChildren())->sum()
	endif;
--@end helper numberOfChildren


--@begin helper metric
--@comments returns the Metric element which shortName is given
helper def : metric(shortName: String) : Measure!Metric =
	Measure!Metric.allInstances()->select(metric|metric.shortName=shortName)->first();
--@end helper metric

--@begin entrypoint rule Metrics
--@comments creates all Metric elements with a short and long name
entrypoint rule Metrics() {
	to
		--@comments corresponds to the metric : Total Number of Packages
		metricTNP:Measure!Metric (
			shortName <- 'TNP',
			name <- 'Total Number of Packages'
		),
		--@comments corresponds to the metric : Total Number of Classes
		metricTNC:Measure!Metric (
			shortName <- 'TNC',
			name <- 'Total Number of Classes'
		),
		--@comments corresponds to the metric : Total Number of Attributes
		metricTNA:Measure!Metric (
			shortName <- 'TNA',
			name <- 'Total Number of Attributes'
		),
		--@comments corresponds to the metric : Total Number of Attributes Inherited
		metricTNAI:Measure!Metric (
			shortName <- 'TNAI',
			name <- 'Total Number of Attributes Inherited'
		),
		--@comments corresponds to the metric : Attribute Inheritance Factor
		metricAIF:Measure!Metric (
			shortName <- 'AIF',
			name <- 'Attribute Inheritance Factor'
		),
		--@comments corresponds to the metric : Depth Inheritance Tree
		metricDIT:Measure!Metric (
			shortName <- 'DIT',
			name <- 'Depth Inheritance Tree'
		),
		--@comments corresponds to the metric : Number of Children
		metricNOC:Measure!Metric (
			shortName <- 'NOC',
			name <- 'Number of Children'
		),
		--@comments corresponds to the metric : Total Number of Relationships
		metricTNR:Measure!Metric (
			shortName <- 'TNR',
			name <- 'Total Number of Relationships'
		),
		--@comments corresponds to the metric : Total Number of Relationships Inherited
		metricTNRI:Measure!Metric (
			shortName <- 'TNRI',
			name <- 'Total Number of Relationships Inherited'
		)
}
--@end entrypoint rule Metrics
		

--@begin rule MetamodelMeasureSet
--@comments collect measurement data on a Metamodel element
rule MetamodelMeasureSet {
	from
		mm:KM3!Metamodel
	to
		mmMeasSet:Measure!MetamodelMeasureSet (
			elementName <- mm.contents->iterate(pkg; name:String=''|name +
				if pkg.name <> 'PrimitiveTypes'
					then pkg.name
					else ''
				endif),
			elementType <- #Metamodel,
			measures <- thisModule.SimpleMeasure('TNP','',
					mm.contents->size()),
			measures <- thisModule.SimpleMeasure('TNC','',
					mm.allClasses->size()),
			measures <- thisModule.SimpleMeasure('TNC','per Package',
					mm.allClasses->size().divide(mm.contents->size())),
			measures <- thisModule.SimpleMeasure('TNA','',
					mm.allAttributes->size()),
			measures <- thisModule.SimpleMeasure('TNA','per Package',
					mm.allAttributes->size().divide(mm.contents->size())),
			measures <- thisModule.SimpleMeasure('TNA','per Class',
					mm.allAttributes->size().divide(mm.allClasses->size())),
			measures <- thisModule.SimpleMeasure('TNAI','',
					mm.allAttributesInherited->size()),
			measures <- thisModule.SimpleMeasure('TNAI','per Package',
					mm.allAttributesInherited->size().divide(mm.contents->size())),
			measures <- thisModule.SimpleMeasure('TNAI','per Class',
					mm.allAttributesInherited->size().divide(mm.allClasses->size())),
			measures <- thisModule.SimpleMeasure('TNR','',
					mm.allReferences->size()),
			measures <- thisModule.SimpleMeasure('TNR','per Package',
					mm.allReferences->size().divide(mm.contents->size())),
			measures <- thisModule.SimpleMeasure('TNR','per Class',
					mm.allReferences->size().divide(mm.allClasses->size())),
			measures <- thisModule.SimpleMeasure('TNRI','',
					mm.allReferencesInherited->size()),
			measures <- thisModule.SimpleMeasure('TNRI','per Package',
					mm.allReferencesInherited->size().divide(mm.contents->size())),
			measures <- thisModule.SimpleMeasure('TNRI','per Class',
					mm.allReferencesInherited->size().divide(mm.allClasses->size())),
			measures <- thisModule.SimpleMeasure('AIF','per Class',
					mm.attributeInheritanceFactor()),
			measures <- thisModule.SimpleMeasure('DIT','',
					mm.depthInheritanceTree()),
			measures <- thisModule.SimpleMeasure('DIT','per Package',
				if mm.contents->isEmpty()
					then 0
					else mm.contents->collect(c|c.depthInheritanceTree())->
						sum()/mm.contents->size()
					endif),
			measures <- thisModule.SimpleMeasure('DIT','per Class',
				if mm.allClasses->isEmpty()
					then 0
					else mm.allClasses->collect(c|c.depthInheritanceTree())->
						sum()/mm.allClasses->size()
				endif),
			measures <- thisModule.SimpleMeasure('NOC','',
					mm.numberOfChildren()),
			measures <- thisModule.SimpleMeasure('NOC','per Package',
					mm.numberOfChildren().divide(mm.contents->size())),
			measures <- thisModule.SimpleMeasure('NOC','per Class',
					mm.numberOfChildren().divide(mm.allClasses->size())),
			pkgMeasureSets <- mm.contents
		)
}
--@end rule MetamodelMeasureSet

--@begin rule PackageMeasureSet
--@comments collect measurement data on a Package element
rule PackageMeasureSet {
	from
		pkg:KM3!Package
	to
		pkgMeasSet:Measure!PackageMeasureSet (
			elementName <- pkg.name,
			elementType <- #Package,
			measures <- thisModule.SimpleMeasure('TNC','',
					pkg.allClasses->size()),
			measures <- thisModule.SimpleMeasure('TNA','',
					pkg.allAttributes->size()),
			measures <- thisModule.SimpleMeasure('TNA','per Class',
					pkg.allAttributes->size().divide(pkg.allClasses->size())),
			measures <- thisModule.SimpleMeasure('TNAI','',
					pkg.allAttributesInherited->size()),
			measures <- thisModule.SimpleMeasure('TNAI','per Class',
					pkg.allAttributesInherited->size().divide(pkg.allClasses->size())),
			measures <- thisModule.SimpleMeasure('TNR','',
					pkg.allReferences->size()),
			measures <- thisModule.SimpleMeasure('TNR','per Class',
					pkg.allReferences->size().divide(pkg.allClasses->size())),
			measures <- thisModule.SimpleMeasure('TNRI','',
					pkg.allReferencesInherited->size()),
			measures <- thisModule.SimpleMeasure('TNRI','per Class',
					pkg.allReferencesInherited->size().divide(pkg.allClasses->size())),
			measures <- thisModule.SimpleMeasure('AIF','',
					pkg.attributeInheritanceFactor()),
			measures <- thisModule.SimpleMeasure('DIT','',
					pkg.depthInheritanceTree()),
			measures <- thisModule.SimpleMeasure('DIT','per Class',
				if pkg.allClasses->isEmpty()
					then 0
					else pkg.allClasses->collect(c|c.depthInheritanceTree())->
						sum()/pkg.allClasses->size()
				endif),
			measures <- thisModule.SimpleMeasure('NOC','',
					pkg.numberOfChildren()),
			measures <- thisModule.SimpleMeasure('NOC','per Class',
					pkg.numberOfChildren().divide(pkg.allClasses->size())),
			classMeasureSets <- pkg.allClasses
		)
}
--@end rule PackageMeasureSet

--@begin rule ClassMeasureSet
--@comments collect measurement data on a Class element
rule ClassMeasureSet {
	from
		class:KM3!Class
	to
		classMeasSet:Measure!ClassMeasureSet (
			elementName <- class.name,
			elementType <- #Class,
			measures <- thisModule.SimpleMeasure('TNA','',
					class.allAttributes->size()),
			measures <- thisModule.SimpleMeasure('TNAI','',
					class.allAttributesInherited->size()),	
			measures <- thisModule.SimpleMeasure('TNR','',
					class.allReferences->size()),
			measures <- thisModule.SimpleMeasure('TNRI','',
					class.allReferencesInherited->size()),
			measures <- thisModule.SimpleMeasure('AIF','',
					class.attributeInheritanceFactor()),
			measures <- thisModule.SimpleMeasure('DIT','',
					class.depthInheritanceTree()),
			measures <- thisModule.SimpleMeasure('NOC','',
					class.numberOfChildren()),
			attrMeasureSets <- class.allAttributes
		)
}
--@end rule ClassMeasureSet

--@begin rule AttributeMeasureSet
--@comments collect measurement data on a Attribute element
rule AttributeMeasureSet {
	from
		attr:KM3!Attribute
	to
		attrMeasSet:Measure!AttributeMeasureSet (
			elementName <- attr.name,
			elementType <- #Attribute
		)
}
--@end rule AttributeMeasureSet
		
--@begin lazy rule SimpleMeasure
--@comments stores a simple measure for the metric named 'shortName', the unit 'unit' and the value given
lazy rule SimpleMeasure {
	from
		shortName:String,
		unit:String,
		value:Real
	to
		simpleMeas:Measure!SimpleMeasure (
			metric <- thisModule.metric(shortName),
			unit <- unit,
			value <- value
		)
}
--@end lazy rule SimpleMeasure",name km measur version domain measur data metric metamodel author eric vepa eric vepa gmail com date descript this transform use collect measur data km metamodel some metric defin measur perform differ model element store help measur metamodel modul km measur modul templat creat out measur in km begin helper divid comment return number even divis zero helper context real def divid divisor real real divisor els self divisor endif end helper divid begin attribut helper allclass comment return sequenc class element packag metamodel element helper context km packag def allclass sequenc km class self content select c c oclistypeof km class helper context km metamodel def allclass sequenc km class self content iter pkg acc sequenc km class sequenc acc union pkg allclass flatten end attribut helper allclass begin attribut helper allattributesinherit comment return sequenc attribut element inherit class packag metamodel element helper context km class def allattributesinherit sequenc km attribut self supertyp isempti sequenc els self supertyp iter supertyp acc sequenc km attribut sequenc acc union supertyp allattribut endif helper context km packag def allattributesinherit sequenc km attribut self allclass iter c acc sequenc km attribut sequenc acc includ c allattributesinherit flatten helper context km metamodel def allattributesinherit sequenc km attribut self allclass iter c acc sequenc km attribut sequenc acc includ c allattributesinherit flatten end attribut helper allattributesinherit begin attribut helper allattribut comment return sequenc attribut element local defin inherit class packag metamodel element helper context km class def allattribut sequenc km attribut self structuralfeatur select sf sf oclistypeof km attribut union self allattributesinherit helper context km packag def allattribut sequenc km attribut self allclass iter class acc sequenc km attribut sequenc acc union class allattribut flatten helper context km metamodel def allattribut sequenc km attribut self content iter pkg acc sequenc km attribut sequenc acc union pkg allattribut flatten end attribut helper allattribut begin attribut helper allreferencesinherit comment return sequenc refer element inherit class packag metamodel element helper context km class def allreferencesinherit sequenc km refer self supertyp isempti sequenc els self supertyp iter supertyp acc sequenc km refer sequenc supertyp allrefer endif helper context km packag def allreferencesinherit sequenc km refer self allclass iter c acc sequenc km refer sequenc acc includ c allreferencesinherit flatten helper context km metamodel def allreferencesinherit sequenc km refer self allclass iter c acc sequenc km refer sequenc acc includ c allreferencesinherit flatten end attribut helper allreferencesinherit begin attribut helper allrefer comment return sequenc refer element local defin inherit class packag metamodel element helper context km class def allrefer sequenc km refer self structuralfeatur select sf sf oclistypeof km refer union self allreferencesinherit flatten helper context km packag def allrefer sequenc km refer self allclass iter class acc sequenc km refer sequenc comment return refer element without opposit contain opposit acc union class allrefer select ref ref opposit oclisundefin true els ref opposit iscontain endif flatten helper context km metamodel def allrefer sequenc km refer self content iter pkg acc sequenc km refer sequenc acc union pkg allrefer flatten end attribut helper allrefer begin helper attributeinheritancefactor comment return valu metric attribut inherit factor class packag metamodel element helper context km locatedel def attributeinheritancefactor real self allattributesinherit size divid self allattribut size end helper attributeinheritancefactor begin helper depthinheritancetre comment return valu metric depth inherit tree class packag metamodel element helper context km class def depthinheritancetre real self supertyp isempti els self supertyp iter supertyp maxdit real maxdit max supertyp depthinheritancetre endif helper context km packag def depthinheritancetre real self allclass iter c maxdit real maxdit max c depthinheritancetre helper context km metamodel def depthinheritancetre real self allclass iter c maxdit real maxdit max c depthinheritancetre end helper depthinheritancetre begin helper numberofchildren comment return valu metric number children class packag metamodel element helper context km class def numberofchildren real km class allinst select c c supertyp includ self size helper context km packag def numberofchildren real self allclass isempti els self allclass collect c c numberofchildren sum endif helper context km metamodel def numberofchildren real self allclass isempti els self allclass collect c c numberofchildren sum endif end helper numberofchildren begin helper metric comment return metric element shortnam given helper def metric shortnam string measur metric measur metric allinst select metric metric shortnam shortnam first end helper metric begin entrypoint rule metric comment creat metric element short long name entrypoint rule metric comment correspond metric total number packag metrictnp measur metric shortnam tnp name total number packag comment correspond metric total number class metrictnc measur metric shortnam tnc name total number class comment correspond metric total number attribut metrictna measur metric shortnam tna name total number attribut comment correspond metric total number attribut inherit metrictnai measur metric shortnam tnai name total number attribut inherit comment correspond metric attribut inherit factor metricaif measur metric shortnam aif name attribut inherit factor comment correspond metric depth inherit tree metricdit measur metric shortnam dit name depth inherit tree comment correspond metric number children metricnoc measur metric shortnam noc name number children comment correspond metric total number relationship metrictnr measur metric shortnam tnr name total number relationship comment correspond metric total number relationship inherit metrictnri measur metric shortnam tnri name total number relationship inherit end entrypoint rule metric begin rule metamodelmeasureset comment collect measur data metamodel element rule metamodelmeasureset mm km metamodel mmmeasset measur metamodelmeasureset elementnam mm content iter pkg name string name pkg name primitivetyp pkg name els endif elementtyp metamodel measur thismodul simplemeasur tnp mm content size measur thismodul simplemeasur tnc mm allclass size measur thismodul simplemeasur tnc per packag mm allclass size divid mm content size measur thismodul simplemeasur tna mm allattribut size measur thismodul simplemeasur tna per packag mm allattribut size divid mm content size measur thismodul simplemeasur tna per class mm allattribut size divid mm allclass size measur thismodul simplemeasur tnai mm allattributesinherit size measur thismodul simplemeasur tnai per packag mm allattributesinherit size divid mm content size measur thismodul simplemeasur tnai per class mm allattributesinherit size divid mm allclass size measur thismodul simplemeasur tnr mm allrefer size measur thismodul simplemeasur tnr per packag mm allrefer size divid mm content size measur thismodul simplemeasur tnr per class mm allrefer size divid mm allclass size measur thismodul simplemeasur tnri mm allreferencesinherit size measur thismodul simplemeasur tnri per packag mm allreferencesinherit size divid mm content size measur thismodul simplemeasur tnri per class mm allreferencesinherit size divid mm allclass size measur thismodul simplemeasur aif per class mm attributeinheritancefactor measur thismodul simplemeasur dit mm depthinheritancetre measur thismodul simplemeasur dit per packag mm content isempti els mm content collect c c depthinheritancetre sum mm content size endif measur thismodul simplemeasur dit per class mm allclass isempti els mm allclass collect c c depthinheritancetre sum mm allclass size endif measur thismodul simplemeasur noc mm numberofchildren measur thismodul simplemeasur noc per packag mm numberofchildren divid mm content size measur thismodul simplemeasur noc per class mm numberofchildren divid mm allclass size pkgmeasureset mm content end rule metamodelmeasureset begin rule packagemeasureset comment collect measur data packag element rule packagemeasureset pkg km packag pkgmeasset measur packagemeasureset elementnam pkg name elementtyp packag measur thismodul simplemeasur tnc pkg allclass size measur thismodul simplemeasur tna pkg allattribut size measur thismodul simplemeasur tna per class pkg allattribut size divid pkg allclass size measur thismodul simplemeasur tnai pkg allattributesinherit size measur thismodul simplemeasur tnai per class pkg allattributesinherit size divid pkg allclass size measur thismodul simplemeasur tnr pkg allrefer size measur thismodul simplemeasur tnr per class pkg allrefer size divid pkg allclass size measur thismodul simplemeasur tnri pkg allreferencesinherit size measur thismodul simplemeasur tnri per class pkg allreferencesinherit size divid pkg allclass size measur thismodul simplemeasur aif pkg attributeinheritancefactor measur thismodul simplemeasur dit pkg depthinheritancetre measur thismodul simplemeasur dit per class pkg allclass isempti els pkg allclass collect c c depthinheritancetre sum pkg allclass size endif measur thismodul simplemeasur noc pkg numberofchildren measur thismodul simplemeasur noc per class pkg numberofchildren divid pkg allclass size classmeasureset pkg allclass end rule packagemeasureset begin rule classmeasureset comment collect measur data class element rule classmeasureset class km class classmeasset measur classmeasureset elementnam class name elementtyp class measur thismodul simplemeasur tna class allattribut size measur thismodul simplemeasur tnai class allattributesinherit size measur thismodul simplemeasur tnr class allrefer size measur thismodul simplemeasur tnri class allreferencesinherit size measur thismodul simplemeasur aif class attributeinheritancefactor measur thismodul simplemeasur dit class depthinheritancetre measur thismodul simplemeasur noc class numberofchildren attrmeasureset class allattribut end rule classmeasureset begin rule attributemeasureset comment collect measur data attribut element rule attributemeasureset attr km attribut attrmeasset measur attributemeasureset elementnam attr name elementtyp attribut end rule attributemeasureset begin lazi rule simplemeasur comment store simpl measur metric name shortnam unit unit valu given lazi rule simplemeasur shortnam string unit string valu real simplemea measur simplemeasur metric thismodul metric shortnam unit unit valu valu end lazi rule simplemeasur,9
100,100,P51-Measure2Table.atl,"--@name Measure2Table
--@version 1.0
--@domains measurement data, metrics, metamodel, generic table representation
--@authors Eric Vepa (eric.vepa <at> gmail.com)
--@date 2006/08/06
--@description This transformation is used to represent measurement data on metamodels as a generic table representation. Different kind of table are created (different header row, number of columns, etc), depending on the final representation (tabular HTML, SVG bar and pie chart, etc). 

module Measure2Table; -- Module Template
create OUT : Table from IN : Measure;

--@begin helper metric
--@comments returns the Metric element which shortName is given
helper def : metric(shortName: String) : Measure!Metric =
	Measure!Metric.allInstances()->select(metric|metric.shortName=shortName)->first();
--@end helper metric

--@begin helper simpleMeasures
--@comments returns all the simple measures of a measure set for the metric shortName given
helper context Measure!MeasureSet def : simpleMeasures(metricName: String) : Sequence(Measure!SimpleMeasure) =
	self.measures->select(m|m.oclIsTypeOf(Measure!SimpleMeasure))->
		select(meas|meas.metric.shortName = metricName);
--@end helper simpleMeasures

--@begin helper classMeasureSets
--@comments returns the sequence of all the ClassMeasureSet elements of a MetamodelMeasureSet element
helper context Measure!MetamodelMeasureSet def : classMeasureSets() : Sequence(Measure!ClassMeasureSet) =
	self.pkgMeasureSets->collect(pkg|pkg.classMeasureSets)->flatten();
--@end helper classMeasureSets

--@begin helper valueNotNull
--@comments returns true, if the value for the metric named 'metricName' is not null
helper context Measure!MeasureSet def : valueNotNull(metricName: String) : Boolean =
	self.simpleMeasures(metricName)->first().value <> 0;
--@end helper valueNotNull

--@begin helper canCreatePieChart
--@comments returns true if the data measurement on the metric named 'metricName' are sufficient for creating a table for a SVG pie chart representation (at least one row with a non null value)
helper context Measure!PackageMeasureSet def : canCreatePieChart(metricName: String) : Boolean =
	if self.classMeasureSets->notEmpty()
		then self.classMeasureSets->exists(measSet|measSet.valueNotNull(metricName))
		else false
	endif;

helper context Measure!MetamodelMeasureSet def : canCreatePieChart(metricName: String) : Boolean =
	if self.classMeasureSets()->notEmpty()
		then self.classMeasureSets()->exists(measSet|measSet.valueNotNull(metricName))
		else false
	endif;
--@end helper canCreatePieChart

--@begin entrypoint rule Tables
--@comments creates tables for different representations
entrypoint rule Tables() {
	using {
		--@comments only non empty measure sets are retained, then sorted by element name
		allMetamodelMeasuresSets : Sequence(Measure!MetamodelMeasureSet) =
			Measure!MetamodelMeasureSet.allInstances()->
				select(measSet|measSet.measures->notEmpty())->
					asSet()->sortedBy(measSet|measSet.elementName);
		allPackageMeasuresSets : Sequence(Measure!PackageMeasureSet) =
			Measure!PackageMeasureSet.allInstances()->
				select(measSet|measSet.measures->notEmpty())->
					asSet()->sortedBy(measSet|measSet.elementName);
		allClassMeasuresSets : Sequence(Measure!ClassMeasureSet) =
			Measure!ClassMeasureSet.allInstances()->
				select(measSet|measSet.measures->notEmpty())->
					asSet()->sortedBy(measSet|measSet.elementName);
		allAttributeMeasuresSets : Sequence(Measure!AttributeMeasureSet) =
			Measure!AttributeMeasureSet.allInstances()->
				select(measSet|measSet.measures->notEmpty())->
					asSet()->sortedBy(measSet|measSet.elementName);
	}
	do {
		--@comments creates tables for each kind of non empty measure set [Metamodel][Zoo][TabularHTML]
		if allMetamodelMeasuresSets->notEmpty()
			then thisModule.AllMeasureSet2Table(allMetamodelMeasuresSets)
			else OclUndefined
		endif;
		if allPackageMeasuresSets->notEmpty()
			then thisModule.AllMeasureSet2Table(allPackageMeasuresSets)
			else OclUndefined
		endif;
		if allClassMeasuresSets->notEmpty()
			then thisModule.AllMeasureSet2Table(allClassMeasuresSets)
			else OclUndefined
		endif;
		if allAttributeMeasuresSets->notEmpty()
			then thisModule.AllMeasureSet2Table(allAttributeMeasuresSets)
			else OclUndefined
		endif;
		--@comments creates tables for metrics on one metamodel and for SVG bar chart representation [Metamodel][SVGBarChart]
		for (pkgMeasSet in allPackageMeasuresSets->select(pkgMeasSet|pkgMeasSet.classMeasureSets->notEmpty())) {
			thisModule.MeasureSets2SVGBarChart(pkgMeasSet.classMeasureSets,'TNAI');
			thisModule.MeasureSets2SVGBarChart(pkgMeasSet.classMeasureSets,'TNR');
			thisModule.MeasureSets2SVGBarChart(pkgMeasSet.classMeasureSets,'TNRI');
			thisModule.MeasureSets2SVGBarChart(pkgMeasSet.classMeasureSets,'AIF');
			thisModule.MeasureSets2SVGBarChart(pkgMeasSet.classMeasureSets,'DIT');
			thisModule.MeasureSets2SVGBarChart(pkgMeasSet.classMeasureSets,'NOC');
		}
		--@comments creates tables for metrics on one metamodel and for SVG pie chart representation [Metamodel][SVGPieChart]
		for (pkgMeasSet in allPackageMeasuresSets) {
			if pkgMeasSet.canCreatePieChart('TNA')
				then thisModule.MeasureSets2SVGPieChart(pkgMeasSet.classMeasureSets,'TNA')
				else OclUndefined
			endif;
			if pkgMeasSet.canCreatePieChart('TNAI')
				then thisModule.MeasureSets2SVGPieChart(pkgMeasSet.classMeasureSets,'TNAI')
				else OclUndefined
			endif;
			if pkgMeasSet.canCreatePieChart('TNR')
				then thisModule.MeasureSets2SVGPieChart(pkgMeasSet.classMeasureSets,'TNR')
				else OclUndefined
			endif;
			if pkgMeasSet.canCreatePieChart('TNRI')
				then thisModule.MeasureSets2SVGPieChart(pkgMeasSet.classMeasureSets,'TNRI')
				else OclUndefined
			endif;
			if pkgMeasSet.canCreatePieChart('AIF')
				then thisModule.MeasureSets2SVGPieChart(pkgMeasSet.classMeasureSets,'AIF')
				else OclUndefined
			endif;
			if pkgMeasSet.canCreatePieChart('DIT')
				then thisModule.MeasureSets2SVGPieChart(pkgMeasSet.classMeasureSets,'DIT')
				else OclUndefined
			endif;
			if pkgMeasSet.canCreatePieChart('NOC')
				then thisModule.MeasureSets2SVGPieChart(pkgMeasSet.classMeasureSets,'NOC')
				else OclUndefined
			endif;
		}
		--@comments creates tables for metrics on the entire zoo of metamodels and for SVG bar and pie chart representation [Zoo][SVGBarChart][SVGPieChart]
		if allPackageMeasuresSets->isEmpty()
			then thisModule.TablesForEntireZoo(allMetamodelMeasuresSets)
			else OclUndefined
		endif;
	}
}
--@end entrypoint rule Tables

--@begin called rule AllMeasureSet2Table
--@comments creates a table for all measure sets of one kind
rule AllMeasureSet2Table(allMeasSet:Sequence(Measure!MeasureSet)) {
	to
		globalTable:Table!Table (
			rows <- thisModule.MeasureSet2RowName(allMeasSet->first()),
			rows <- allMeasSet->iterate(measSet; acc:Sequence(Table!Row)=Sequence{}|
					acc->including(thisModule.MeasureSet2RowValue(measSet)))
		)
}
--@end called rule AllMeasureSet2Table

--@begin called rule TablesForEntireZoo
--@comments creates tables for metrics on the entire zoo of metamodels and for SVG bar and pie chart representation [Zoo][SVGBarChart][SVGPieChart]
rule TablesForEntireZoo(allMmMeasSet:Sequence(Measure!MetamodelMeasureSet)) {
	do {
		--@comments creates tables for metrics on the entire zoo of metamodels and for SVG bar chart representation [Zoo][SVGBarChart]
		thisModule.MeasureSets2SVGBarChart(allMmMeasSet,'TNP');
		thisModule.MeasureSets2SVGBarChart(allMmMeasSet,'TNC');
		thisModule.MeasureSets2SVGBarChart(allMmMeasSet,'TNA');
		thisModule.MeasureSets2SVGBarChart(allMmMeasSet,'TNAI');
		thisModule.MeasureSets2SVGBarChart(allMmMeasSet,'TNR');
		thisModule.MeasureSets2SVGBarChart(allMmMeasSet,'TNRI');
		thisModule.MeasureSets2SVGBarChart(allMmMeasSet,'AIF');
		thisModule.MeasureSets2SVGBarChart(allMmMeasSet,'DIT');
		thisModule.MeasureSets2SVGBarChart(allMmMeasSet,'NOC');
		--@comments creates tables for metrics on the entire zoo of metamodels and for SVG pie chart representation [Zoo][SVGPieChart]
		thisModule.MeasureSets2SVGPieChart(allMmMeasSet,'TNP');
		thisModule.MeasureSets2SVGPieChart(allMmMeasSet,'TNC');
		thisModule.MeasureSets2SVGPieChart(allMmMeasSet,'TNA');
		thisModule.MeasureSets2SVGPieChart(allMmMeasSet,'TNAI');
		thisModule.MeasureSets2SVGPieChart(allMmMeasSet,'TNR');
		thisModule.MeasureSets2SVGPieChart(allMmMeasSet,'TNRI');
		thisModule.MeasureSets2SVGPieChart(allMmMeasSet,'AIF');
		thisModule.MeasureSets2SVGPieChart(allMmMeasSet,'DIT');
		thisModule.MeasureSets2SVGPieChart(allMmMeasSet,'NOC');
	}
}
--@end called rule TablesForEntireZoo

--@begin unique lazy rule MeasureSet2RowName
--@comments creates a row with the type and all the names of the metrics of a MeasureSet element
unique lazy rule MeasureSet2RowName {
	from
		measSet:Measure!MeasureSet
	to
		rowName:Table!Row (
			cells <- thisModule.MeasureSet2CellElementType(measSet),
			cells <- measSet.measures->
				select(meas|meas.oclIsTypeOf(Measure!SimpleMeasure))->
					iterate(meas; acc:Sequence(Table!Cell)=Sequence{}|
						acc->including(thisModule.Measure2CellName(meas)))
		)
}
--@end unique lazy rule MeasureSet2RowName

--@begin lazy rule MeasureSet2RowValue
--@comments creates a row with the name and all the values of the simple measures of a MeasureSet element
lazy rule MeasureSet2RowValue {
	from
		measSet:Measure!MeasureSet
	to
		rowValue:Table!Row (
			cells <- thisModule.MeasureSet2CellElementName(measSet),
			cells <- measSet.measures->
				select(meas|meas.oclIsTypeOf(Measure!SimpleMeasure))->
					iterate(meas; acc:Sequence(Table!Cell)=Sequence{}|
						acc->including(thisModule.SimpleMeasure2CellValue(meas)))
		)
}
--@end lazy rule MeasureSet2RowValue

--@begin unique lazy rule MeasureSet2CellElementType
--@comments creates a cell with the type of a MeasureSet element
unique lazy rule MeasureSet2CellElementType {
	from
		measSet:Measure!MeasureSet
	to
		cellType:Table!Cell (
			content <-	if measSet.elementType = #Attribute
							then 'Attribute'
							else	if measSet.elementType = #Class
										then 'Class'
										else	if measSet.elementType = #Package
													then 'Package'
													else	if measSet.elementType = #Metamodel
																then 'Metamodel'
																else 'UnknowModelElement'
															endif
												endif
									endif
						endif
		)
}
--@end unique lazy rule MeasureSet2CellElementType

--@begin lazy rule MeasureSet2CellElementName
--@comments creates a cell with the name of a MeasureSet element
lazy rule MeasureSet2CellElementName {
	from
		measSet:Measure!MeasureSet
	to
		cellName:Table!Cell (
			content <- measSet.elementName
		)
}
--@end lazy rule MeasureSet2CellElementName

--@begin lazy rule Measure2CellName
--@comments creates a cell with the name of the metric and the unit of a Measure element
lazy rule Measure2CellName {
	from
		meas:Measure!Measure
	to
		cellName:Table!Cell (
			content <- meas.metric.shortName +
				if meas.unit->size() <> 0
					then ' ' + meas.unit
					else ''
				endif
		)
}
--@end lazy rule Measure2CellName

--@begin lazy rule SimpleMeasure2CellValue
--@comments creates a cell with a the value of a SimpleMeasure element
lazy rule SimpleMeasure2CellValue {
	from
		meas:Measure!SimpleMeasure
	to
		cellValue:Table!Cell (
			content <- meas.value.toString()
		)
}
--@end lazy rule SimpleMeasure2CellValue


--@begin lazy rule ChartHeaderRow
--@comments creates a header row for a SVG chart representation
lazy rule ChartHeaderRow {
	from
		firstCellContent:String,
		metricName:String,
		unit:String
	to		
		headerRow:Table!Row (
			cells <- headerCell,
			cells <- metricNameCell
		),
		headerCell:Table!Cell (
			content <- firstCellContent
		),
		metricNameCell:Table!Cell (
			content <- thisModule.metric(metricName).name +
				' ' + unit
		)
}
--@end lazy rule ChartHeaderRow

--@begin lazy rule MeasureSets2SVGBarChart
--@comments creates a table for a SVG bar chart representation and for one metric
lazy rule MeasureSets2SVGBarChart {
	from
		measSets:Sequence(Measure!MeasureSet),
		metricName:String
	to
		barDiagTable:Table!Table (
			rows <- thisModule.ChartHeaderRow('Bar Chart',metricName,
				if measSets->first().oclIsTypeOf(Measure!AttributeMeasureSet)
					then 'per Attribute'
					else if measSets->first().oclIsTypeOf(Measure!ClassMeasureSet)
							then 'per Class'
							else if measSets->first().oclIsTypeOf(Measure!PackageMeasureSet)
									then 'per Package'
									else 'per Metamodel'
								endif
						endif
				endif),
			rows <- measSets->iterate(measSet; acc:Sequence(Table!Row)=Sequence{}|
					acc->including(thisModule.MeasureName2RowBar(measSet,metricName)))
		)
}
--@end lazy rule MeasureSets2SVGBarChart

--@begin lazy rule MeasureName2RowBar
--@comments creates a row, for a bar of the SVG bar chart representation, with the name and the value of the model element for one metric
lazy rule MeasureName2RowBar {
	from
		measSet:Measure!MeasureSet,
		metricName:String
	to
		rowValue:Table!Row (
			cells <- thisModule.MeasureSet2CellElementName(measSet),
			cells <- thisModule.SimpleMeasure2CellValue(measSet.simpleMeasures(metricName)->first())
		)
}
--@end lazy rule MeasureName2RowBar


--@begin lazy rule MeasureSets2SVGPieChart
--@comments creates a table for a SVG pie chart representation and for one metric
lazy rule MeasureSets2SVGPieChart {
	from
		measSets:Sequence(Measure!MeasureSet),
		metricName:String
	using {
		sumSectors : Real = measSets->
			collect(measSet|measSet.simpleMeasures(metricName)->
				first().value)->sum();
	}
	to
		pieDiagTable:Table!Table (
			rows <- thisModule.ChartHeaderRow('Pie Chart',metricName,
				if measSets->first().oclIsTypeOf(Measure!AttributeMeasureSet)
					then 'per Attribute'
					else if measSets->first().oclIsTypeOf(Measure!ClassMeasureSet)
							then 'per Class'
							else if measSets->first().oclIsTypeOf(Measure!PackageMeasureSet)
									then 'per Package'
									else 'per Metamodel'
								endif
						endif
				endif),
			rows <- measSets->iterate(measSet; acc:Sequence(Table!Row)=Sequence{}|
				--@comments creates a sector for non null value
				if measSet.valueNotNull(metricName)
					then acc->including(thisModule.MeasureName2RowSector(measSet,metricName,sumSectors))
					else acc
				endif)
		)
}
--@end lazy rule MeasureSets2SVGPieChart
--
--@begin lazy rule MeasureName2RowSector
--@comments creates a row, for a sector of the SVG pie chart representation, with the name and the value of the model element for one metric
lazy rule MeasureName2RowSector {
	from
		measSet:Measure!MeasureSet,
		metricName:String,
		sumSectors:Real
	to
		rowValue:Table!Row (
			cells <- thisModule.MeasureSet2CellElementName(measSet),
			cells <- cellSector
		),
		cellSector:Table!Cell (
			content <- (measSet.simpleMeasures(metricName)->
					first().value/sumSectors*100).toString()
		)
}
--@end lazy rule MeasureName2RowSector",name measur tabl version domain measur data metric metamodel generic tabl represent author eric vepa eric vepa gmail com date descript this transform use repres measur data metamodel generic tabl represent differ kind tabl creat differ header row number column etc depend final represent tabular html svg bar pie chart etc modul measur tabl modul templat creat out tabl in measur begin helper metric comment return metric element shortnam given helper def metric shortnam string measur metric measur metric allinst select metric metric shortnam shortnam first end helper metric begin helper simplemeasur comment return simpl measur measur set metric shortnam given helper context measur measureset def simplemeasur metricnam string sequenc measur simplemeasur self measur select oclistypeof measur simplemeasur select mea mea metric shortnam metricnam end helper simplemeasur begin helper classmeasureset comment return sequenc classmeasureset element metamodelmeasureset element helper context measur metamodelmeasureset def classmeasureset sequenc measur classmeasureset self pkgmeasureset collect pkg pkg classmeasureset flatten end helper classmeasureset begin helper valuenotnul comment return true valu metric name metricnam null helper context measur measureset def valuenotnul metricnam string boolean self simplemeasur metricnam first valu end helper valuenotnul begin helper cancreatepiechart comment return true data measur metric name metricnam suffici creat tabl svg pie chart represent least one row non null valu helper context measur packagemeasureset def cancreatepiechart metricnam string boolean self classmeasureset notempti self classmeasureset exist measset measset valuenotnul metricnam els fals endif helper context measur metamodelmeasureset def cancreatepiechart metricnam string boolean self classmeasureset notempti self classmeasureset exist measset measset valuenotnul metricnam els fals endif end helper cancreatepiechart begin entrypoint rule tabl comment creat tabl differ represent entrypoint rule tabl use comment non empti measur set retain sort element name allmetamodelmeasuresset sequenc measur metamodelmeasureset measur metamodelmeasureset allinst select measset measset measur notempti asset sortedbi measset measset elementnam allpackagemeasuresset sequenc measur packagemeasureset measur packagemeasureset allinst select measset measset measur notempti asset sortedbi measset measset elementnam allclassmeasuresset sequenc measur classmeasureset measur classmeasureset allinst select measset measset measur notempti asset sortedbi measset measset elementnam allattributemeasuresset sequenc measur attributemeasureset measur attributemeasureset allinst select measset measset measur notempti asset sortedbi measset measset elementnam comment creat tabl kind non empti measur set metamodel zoo tabularhtml allmetamodelmeasuresset notempti thismodul allmeasureset tabl allmetamodelmeasuresset els oclundefin endif allpackagemeasuresset notempti thismodul allmeasureset tabl allpackagemeasuresset els oclundefin endif allclassmeasuresset notempti thismodul allmeasureset tabl allclassmeasuresset els oclundefin endif allattributemeasuresset notempti thismodul allmeasureset tabl allattributemeasuresset els oclundefin endif comment creat tabl metric one metamodel svg bar chart represent metamodel svgbarchart pkgmeasset allpackagemeasuresset select pkgmeasset pkgmeasset classmeasureset notempti thismodul measureset svgbarchart pkgmeasset classmeasureset tnai thismodul measureset svgbarchart pkgmeasset classmeasureset tnr thismodul measureset svgbarchart pkgmeasset classmeasureset tnri thismodul measureset svgbarchart pkgmeasset classmeasureset aif thismodul measureset svgbarchart pkgmeasset classmeasureset dit thismodul measureset svgbarchart pkgmeasset classmeasureset noc comment creat tabl metric one metamodel svg pie chart represent metamodel svgpiechart pkgmeasset allpackagemeasuresset pkgmeasset cancreatepiechart tna thismodul measureset svgpiechart pkgmeasset classmeasureset tna els oclundefin endif pkgmeasset cancreatepiechart tnai thismodul measureset svgpiechart pkgmeasset classmeasureset tnai els oclundefin endif pkgmeasset cancreatepiechart tnr thismodul measureset svgpiechart pkgmeasset classmeasureset tnr els oclundefin endif pkgmeasset cancreatepiechart tnri thismodul measureset svgpiechart pkgmeasset classmeasureset tnri els oclundefin endif pkgmeasset cancreatepiechart aif thismodul measureset svgpiechart pkgmeasset classmeasureset aif els oclundefin endif pkgmeasset cancreatepiechart dit thismodul measureset svgpiechart pkgmeasset classmeasureset dit els oclundefin endif pkgmeasset cancreatepiechart noc thismodul measureset svgpiechart pkgmeasset classmeasureset noc els oclundefin endif comment creat tabl metric entir zoo metamodel svg bar pie chart represent zoo svgbarchart svgpiechart allpackagemeasuresset isempti thismodul tablesforentirezoo allmetamodelmeasuresset els oclundefin endif end entrypoint rule tabl begin call rule allmeasureset tabl comment creat tabl measur set one kind rule allmeasureset tabl allmeasset sequenc measur measureset globalt tabl tabl row thismodul measureset rownam allmeasset first row allmeasset iter measset acc sequenc tabl row sequenc acc includ thismodul measureset rowvalu measset end call rule allmeasureset tabl begin call rule tablesforentirezoo comment creat tabl metric entir zoo metamodel svg bar pie chart represent zoo svgbarchart svgpiechart rule tablesforentirezoo allmmmeasset sequenc measur metamodelmeasureset comment creat tabl metric entir zoo metamodel svg bar chart represent zoo svgbarchart thismodul measureset svgbarchart allmmmeasset tnp thismodul measureset svgbarchart allmmmeasset tnc thismodul measureset svgbarchart allmmmeasset tna thismodul measureset svgbarchart allmmmeasset tnai thismodul measureset svgbarchart allmmmeasset tnr thismodul measureset svgbarchart allmmmeasset tnri thismodul measureset svgbarchart allmmmeasset aif thismodul measureset svgbarchart allmmmeasset dit thismodul measureset svgbarchart allmmmeasset noc comment creat tabl metric entir zoo metamodel svg pie chart represent zoo svgpiechart thismodul measureset svgpiechart allmmmeasset tnp thismodul measureset svgpiechart allmmmeasset tnc thismodul measureset svgpiechart allmmmeasset tna thismodul measureset svgpiechart allmmmeasset tnai thismodul measureset svgpiechart allmmmeasset tnr thismodul measureset svgpiechart allmmmeasset tnri thismodul measureset svgpiechart allmmmeasset aif thismodul measureset svgpiechart allmmmeasset dit thismodul measureset svgpiechart allmmmeasset noc end call rule tablesforentirezoo begin uniqu lazi rule measureset rownam comment creat row type name metric measureset element uniqu lazi rule measureset rownam measset measur measureset rownam tabl row cell thismodul measureset cellelementtyp measset cell measset measur select mea mea oclistypeof measur simplemeasur iter mea acc sequenc tabl cell sequenc acc includ thismodul measur cellnam mea end uniqu lazi rule measureset rownam begin lazi rule measureset rowvalu comment creat row name valu simpl measur measureset element lazi rule measureset rowvalu measset measur measureset rowvalu tabl row cell thismodul measureset cellelementnam measset cell measset measur select mea mea oclistypeof measur simplemeasur iter mea acc sequenc tabl cell sequenc acc includ thismodul simplemeasur cellvalu mea end lazi rule measureset rowvalu begin uniqu lazi rule measureset cellelementtyp comment creat cell type measureset element uniqu lazi rule measureset cellelementtyp measset measur measureset celltyp tabl cell content measset elementtyp attribut attribut els measset elementtyp class class els measset elementtyp packag packag els measset elementtyp metamodel metamodel els unknowmodelel endif endif endif endif end uniqu lazi rule measureset cellelementtyp begin lazi rule measureset cellelementnam comment creat cell name measureset element lazi rule measureset cellelementnam measset measur measureset cellnam tabl cell content measset elementnam end lazi rule measureset cellelementnam begin lazi rule measur cellnam comment creat cell name metric unit measur element lazi rule measur cellnam mea measur measur cellnam tabl cell content mea metric shortnam mea unit size mea unit els endif end lazi rule measur cellnam begin lazi rule simplemeasur cellvalu comment creat cell valu simplemeasur element lazi rule simplemeasur cellvalu mea measur simplemeasur cellvalu tabl cell content mea valu tostr end lazi rule simplemeasur cellvalu begin lazi rule chartheaderrow comment creat header row svg chart represent lazi rule chartheaderrow firstcellcont string metricnam string unit string headerrow tabl row cell headercel cell metricnamecel headercel tabl cell content firstcellcont metricnamecel tabl cell content thismodul metric metricnam name unit end lazi rule chartheaderrow begin lazi rule measureset svgbarchart comment creat tabl svg bar chart represent one metric lazi rule measureset svgbarchart measset sequenc measur measureset metricnam string bardiagt tabl tabl row thismodul chartheaderrow bar chart metricnam measset first oclistypeof measur attributemeasureset per attribut els measset first oclistypeof measur classmeasureset per class els measset first oclistypeof measur packagemeasureset per packag els per metamodel endif endif endif row measset iter measset acc sequenc tabl row sequenc acc includ thismodul measurenam rowbar measset metricnam end lazi rule measureset svgbarchart begin lazi rule measurenam rowbar comment creat row bar svg bar chart represent name valu model element one metric lazi rule measurenam rowbar measset measur measureset metricnam string rowvalu tabl row cell thismodul measureset cellelementnam measset cell thismodul simplemeasur cellvalu measset simplemeasur metricnam first end lazi rule measurenam rowbar begin lazi rule measureset svgpiechart comment creat tabl svg pie chart represent one metric lazi rule measureset svgpiechart measset sequenc measur measureset metricnam string use sumsector real measset collect measset measset simplemeasur metricnam first valu sum piediagt tabl tabl row thismodul chartheaderrow pie chart metricnam measset first oclistypeof measur attributemeasureset per attribut els measset first oclistypeof measur classmeasureset per class els measset first oclistypeof measur packagemeasureset per packag els per metamodel endif endif endif row measset iter measset acc sequenc tabl row sequenc comment creat sector non null valu measset valuenotnul metricnam acc includ thismodul measurenam rowsector measset metricnam sumsector els acc endif end lazi rule measureset svgpiechart begin lazi rule measurenam rowsector comment creat row sector svg pie chart represent name valu model element one metric lazi rule measurenam rowsector measset measur measureset metricnam string sumsector real rowvalu tabl row cell thismodul measureset cellelementnam measset cell cellsector cellsector tabl cell content measset simplemeasur metricnam first valu sumsector tostr end lazi rule measurenam rowsector,2
101,101,P51-RefineAndMergeMeasure.atl,"--@name RefineAndMergeMeasure
--@version 1.0
--@domains measurement data, metrics, metamodel, merged data
--@authors Eric Vepa (eric.vepa <at> gmail.com)
--@date 2006/08/06
--@description This transformation is used to refine and merge measurement data on metamodels. We refine the first input model of measures by keeping only MetamodelMeasureSet. Next, we merge these sets of measure with the existing ones in the second input model. The result measurement data are for severals metamodels.

module RefineAndMergeMeasure; -- Module Template
create OUT : Measure from IN1 : Measure, IN2 : Measure;

--@begin rule RefineMetamodelMeasureSet
rule RefineMetamodelMeasureSet {
	from
		mmMeasSet:Measure!MetamodelMeasureSet
	to
		refinedMmMeasSet:Measure!MetamodelMeasureSet (
			elementType <- mmMeasSet.elementType,
			elementName <- mmMeasSet.elementName,
			measures <- mmMeasSet.measures->
				select(meas|meas.oclIsTypeOf(Measure!SimpleMeasure))->
					iterate(meas; acc:Sequence(Measure!SimpleMeasure)=Sequence{}|
						acc->append(thisModule.CopySimpleMeasure(meas)))
		)
}
--@end rule RefineMetamodelMeasureSet

--@begin lazy rule CopySimpleMeasure
lazy rule CopySimpleMeasure {
	from
		meas:Measure!SimpleMeasure
	to
		copyMeas:Measure!SimpleMeasure (
			metric <- thisModule.CopyMetric(meas.metric),
			unit <- meas.unit,
			value <- meas.value
		)
}
--@end lazy rule CopySimpleMeasure

--@begin lazy rule CopyMetric
lazy rule CopyMetric {
	from
		metric:Measure!Metric
	to
		copyMetric:Measure!Metric (
			shortName <- metric.shortName,
			name <- metric.name
		)
}
--@end lazy rule CopyMetric",name refineandmergemeasur version domain measur data metric metamodel merg data author eric vepa eric vepa gmail com date descript this transform use refin merg measur data metamodel we refin first input model measur keep metamodelmeasureset next merg set measur exist one second input model the result measur data sever metamodel modul refineandmergemeasur modul templat creat out measur in measur in measur begin rule refinemetamodelmeasureset rule refinemetamodelmeasureset mmmeasset measur metamodelmeasureset refinedmmmeasset measur metamodelmeasureset elementtyp mmmeasset elementtyp elementnam mmmeasset elementnam measur mmmeasset measur select mea mea oclistypeof measur simplemeasur iter mea acc sequenc measur simplemeasur sequenc acc append thismodul copysimplemeasur mea end rule refinemetamodelmeasureset begin lazi rule copysimplemeasur lazi rule copysimplemeasur mea measur simplemeasur copymea measur simplemeasur metric thismodul copymetr mea metric unit mea unit valu mea valu end lazi rule copysimplemeasur begin lazi rule copymetr lazi rule copymetr metric measur metric copymetr measur metric shortnam metric shortnam name metric name end lazi rule copymetr,9
102,102,P51-SVG2XML.atl,"--@name SVG2XML
--@version 1.0
--@domains SVG, Pie chart
--@authors Eric Vepa (eric.vepa <at> gmail.com)
--@date 2006/08/04
--@description XML extractor for SVG pie charts.
--@see
--@comments

module SVG2XML; -- Module Template
create OUT : XML from IN : SVG;

--@begin helper scale
--@comments returns the string value for a scale transformation attribute
helper context SVG!Scale def : scale() : String =
	'scale(' + self.sx.toString() +
	if self.sy = self.sx
		then ''
		else ',' + self.sy.toString()
	endif + ')';
--@end helper scale

--@begin helper translate
--@comments returns the string value for a translate transformation attribute
helper context SVG!Translate def : translate() : String =
	'translate(' + self.tx.toString() + ',' + self.ty.toString() + ')';
--@end helper translate

--@begin helper rotate
--@comments returns the string value for a rotate transformation attribute
helper context SVG!Rotate def : rotate() : String =
	'rotate(' + self.angle.toString() + ')';
--@end helper rotate

--@begin rule Svg2Root
rule Svg2Root {
	from
		svg:SVG!Svg
	to
		root:XML!Root (
			name <- 'svg',
			children <- xmlns,
			children <- version,
			children <- thisModule.Attribute('width', if not svg.size.oclIsUndefined() then svg.size.width.toString() else '100%' endif),
			children <- thisModule.Attribute('height', if not svg.size.oclIsUndefined() then svg.size.height.toString() else '100%' endif),
			children <- svg.children
		),
		xmlns:XML!Attribute (
			name <- 'xmlns',
			value <- svg.namespace
		),
		version:XML!Attribute (
			name <- 'version',
			value <- svg.version
		)
}	
--@end rule Svg2Root

--@begin rule G2Element
rule G2Element {
	from
		g:SVG!G
	using {
		transforms : Sequence(SVG!Transform) = g.attribute->select(a|a.oclIsKindOf(SVG!Transform));
		transformValue : String = transforms->iterate(transf; str:String=''|str +
			if transf.oclIsTypeOf(SVG!Scale)
				then transf.scale()
				else if transf.oclIsTypeOf(SVG!Translate)
					then transf.translate()
					else if transf.oclIsTypeOf(SVG!Rotate)
						then transf.rotate()
						else ''
					endif
				endif
			endif +
			if transf <> transforms->last()
				then ' '
				else ''
			endif);	
	}
	to
		elmt:XML!Element (
			name <- 'g',
			children <- thisModule.Attribute('transform', if transforms->notEmpty() then transformValue else '' endif),
			children <- thisModule.Attribute('fill', if not g.fill.oclIsUndefined() then g.fill else 'black' endif),
			children <- g.groupContent
		)
}	
--@end rule G2Element

--@begin rule Rect2Element
rule Rect2Element {
	from
		rect:SVG!Rect
	to
		elmt:XML!Element (
			name <- 'rect',
			children <- thisModule.Attribute('x', if not rect.position.oclIsUndefined() then rect.position.x.toString() else '0' endif),
			children <- thisModule.Attribute('y', if not rect.position.oclIsUndefined() then rect.position.y.toString() else '0' endif),
			children <- thisModule.Attribute('width', if not rect.size.oclIsUndefined() then rect.size.width.toString() else '100%' endif),
			children <- thisModule.Attribute('height', if not rect.size.oclIsUndefined() then rect.size.height.toString() else '100%' endif),
			children <- thisModule.Attribute('fill', if not rect.fill.oclIsUndefined() then rect.fill else 'black' endif),
			children <- thisModule.Attribute('stroke', if not rect.stroke.oclIsUndefined() then rect.stroke else 'none' endif)
		)
}	
--@end rule Rect2Element

--@begin rule Circle2Element
rule Circle2Element {
	from
		circ:SVG!Circle
	to
		elmt:XML!Element (
			name <- 'circle',
			children <- thisModule.Attribute('x', if not circ.position.oclIsUndefined() then circ.position.x.toString() else '0' endif),
			children <- thisModule.Attribute('y', if not circ.position.oclIsUndefined() then circ.position.y.toString() else '0' endif),
			children <- thisModule.Attribute('r', if not circ.size.oclIsUndefined() then circ.size.width.toString() else '100%' endif),
			children <- thisModule.Attribute('fill', if not circ.fill.oclIsUndefined() then circ.fill else 'black' endif),
			children <- thisModule.Attribute('stroke', if not circ.stroke.oclIsUndefined() then circ.stroke else 'none' endif)
		)
}	
--@end rule Circle2Element

--@begin rule Path2Element
rule Path2Element {
	from
		path:SVG!Path
	to
		elmt:XML!Element (
			name <- 'path',
			children <- thisModule.Attribute('d', path.d),
			children <- thisModule.Attribute('fill', if not path.fill.oclIsUndefined() then path.fill else 'black' endif),
			children <- thisModule.Attribute('stroke', if not path.stroke.oclIsUndefined() then path.stroke else 'none' endif)
		)
}	
--@end rule Path2Element

--@begin rule Text2Element
rule Text2Element {
	from
		text:SVG!Text
	to
		elmt:XML!Element (
			name <- 'text',
			children <- thisModule.Attribute('x', if not text.position.oclIsUndefined() then text.position.x.toString() else '0' endif),
			children <- thisModule.Attribute('y', if not text.position.oclIsUndefined() then text.position.y.toString() else '0' endif),
			children <- thisModule.Attribute('stroke', if not text.stroke.oclIsUndefined() then text.stroke else 'none' endif),
			children <-	thisModule.Attribute('font-size', if not text.fontSize.oclIsUndefined() then text.fontSize else 'medium' endif),
			--@comments text-anchor value stored in lengthAdjust attribute
			children <- thisModule.Attribute('text-anchor', if not text.lengthAdjust.oclIsUndefined() then text.lengthAdjust else 'start' endif),
			children <- txt
		),
		txt:XML!Text (
			value <- text.content
		)
}	
--@end rule Text2Element

--@begin lazy rule Attribute
lazy rule Attribute {
	from
		attrName:String,
		attrValue:String
	to
		attr:XML!Attribute (
			name <- attrName,
			value <- attrValue
		)
}	
--@end lazy rule Attribute",name svg xml version domain svg pie chart author eric vepa eric vepa gmail com date descript xml extractor svg pie chart see comment modul svg xml modul templat creat out xml in svg begin helper scale comment return string valu scale transform attribut helper context svg scale def scale string scale self sx tostr self sy self sx els self sy tostr endif end helper scale begin helper translat comment return string valu translat transform attribut helper context svg translat def translat string translat self tx tostr self ty tostr end helper translat begin helper rotat comment return string valu rotat transform attribut helper context svg rotat def rotat string rotat self angl tostr end helper rotat begin rule svg root rule svg root svg svg svg root xml root name svg children xmlns children version children thismodul attribut width svg size oclisundefin svg size width tostr els endif children thismodul attribut height svg size oclisundefin svg size height tostr els endif children svg children xmlns xml attribut name xmlns valu svg namespac version xml attribut name version valu svg version end rule svg root begin rule g element rule g element g svg g use transform sequenc svg transform g attribut select ocliskindof svg transform transformvalu string transform iter transf str string str transf oclistypeof svg scale transf scale els transf oclistypeof svg translat transf translat els transf oclistypeof svg rotat transf rotat els endif endif endif transf transform last els endif elmt xml element name g children thismodul attribut transform transform notempti transformvalu els endif children thismodul attribut fill g fill oclisundefin g fill els black endif children g groupcont end rule g element begin rule rect element rule rect element rect svg rect elmt xml element name rect children thismodul attribut x rect posit oclisundefin rect posit x tostr els endif children thismodul attribut rect posit oclisundefin rect posit tostr els endif children thismodul attribut width rect size oclisundefin rect size width tostr els endif children thismodul attribut height rect size oclisundefin rect size height tostr els endif children thismodul attribut fill rect fill oclisundefin rect fill els black endif children thismodul attribut stroke rect stroke oclisundefin rect stroke els none endif end rule rect element begin rule circl element rule circl element circ svg circl elmt xml element name circl children thismodul attribut x circ posit oclisundefin circ posit x tostr els endif children thismodul attribut circ posit oclisundefin circ posit tostr els endif children thismodul attribut r circ size oclisundefin circ size width tostr els endif children thismodul attribut fill circ fill oclisundefin circ fill els black endif children thismodul attribut stroke circ stroke oclisundefin circ stroke els none endif end rule circl element begin rule path element rule path element path svg path elmt xml element name path children thismodul attribut path children thismodul attribut fill path fill oclisundefin path fill els black endif children thismodul attribut stroke path stroke oclisundefin path stroke els none endif end rule path element begin rule text element rule text element text svg text elmt xml element name text children thismodul attribut x text posit oclisundefin text posit x tostr els endif children thismodul attribut text posit oclisundefin text posit tostr els endif children thismodul attribut stroke text stroke oclisundefin text stroke els none endif children thismodul attribut font size text fontsiz oclisundefin text fontsiz els medium endif comment text anchor valu store lengthadjust attribut children thismodul attribut text anchor text lengthadjust oclisundefin text lengthadjust els start endif children txt txt xml text valu text content end rule text element begin lazi rule attribut lazi rule attribut attrnam string attrvalu string attr xml attribut name attrnam valu attrvalu end lazi rule attribut,9
103,103,P51-Table2SVGBarChart.atl,"--@name Table2SVG
--@version 1.0
--@domains Table, SVG, Bar chart
--@authors Eric Vepa (eric.vepa <at> gmail.com)
--@date 2006/08/04
--@description This transformation is used to transform generic tables into SVG bar charts. Each entry table is a two columns table (two cells per row). The first row contains two cells with a String (the first cell contains the String 'Bar Chart' and the second cell, the name of the chart). The other rows contains one cell with a name as String and an other cell with the value as Double.

module Table2SVG; -- Module Template
create OUT : SVG from IN : Table;

--@begin attribute helper allValidTables
--@comments returns all valid tables, ie tables which can be represented as bar chart
helper def : allValidTables : Sequence(Table!Table) =
	Table!Table.allInstances()->select(t|t.rows->first().cells->first().content = 'Bar Chart')->
		asSet()->sortedBy(t|t.rows->first().cells->at(2).content);
--@end attribute helper allValidTables

--@begin helper maxSizeName
--@comments returns the max size of all name of a table
helper context Table!Table def : maxSizeName() : Integer =
	self.rows->subSequence(2,self.rows->size())->iterate(row; max:Integer=0|
		let value : Integer =
			let point : Integer = row.cells->at(2).content->indexOf('.') in
				(row.cells->first().content + row.cells->at(2).content->substring(1,point+2))->size() + 2 in
				if value > max
					then value
					else max
				endif)*7;
--@end helper maxSizeName

--@begin attribute helper prevRectWidth
--@comments returns the previous value of SVG rect width
helper def : prevRectWidth : Integer = 0;
--@end attribute helper prevRectWidth

--@begin entrypoint rule SvgFile
--@comments creates the SVG file with one svg tag
helper def: svgFile : SVG!SvgFile = OclUndefined;

entrypoint rule SvgFile() {
	to
		svgFile:SVG!SvgFile (
			tag <- svg
		),
		svg:SVG!Svg (
			size <- svgSize,
			namespace <- 'http://www.w3.org/2000/svg',
			version <- '1.1'
		),
		svgSize:SVG!Dimension (
			width <- thisModule.allValidTables->iterate(table; sum:Integer=0|
				sum + table.maxSizeName() + 170),
			height <- thisModule.allValidTables->iterate(table; max:Integer=0|
				if (table.rows.size()-1) > max
					then (table.rows.size()-1)
					else max
				endif)*10 + 50)
	do {
		thisModule.svgFile <- svgFile;
		for (table in thisModule.allValidTables) {
			thisModule.Table2BarChart(table);
		}
	}
}
--@end entrypoint rule SvgFile
--
--@begin lazy rule Table2BarChart
--@comments creates a bar chart (SVG group) for one valid table
lazy rule Table2BarChart {
	from
		table:Table!Table (
			table.rows->first().cells->first().content = 'Bar Chart'
		)
	using {
		rows : Sequence(Table!Row) = table.rows->subSequence(2,table.rows->size());
		scaleFactor : Real = 135/rows->iterate(row; max:Real=0|
			if row.cells->at(2).content.toReal() > max
				then row.cells->at(2).content.toReal()
				else max
			endif);
	}
	to
		g:SVG!G (
			attribute <- transl,
			attribute <- scale,
			groupContent <- text,
			groupContent <- rect,
			groupContent <- axis,
			groupContent <- rows->iterate(row; acc:Sequence(SVG!G)=Sequence{}|
				acc->including(thisModule.Row2Bar(rows.indexOf(row),scaleFactor,row)))
		),
		rect:SVG!Rect (
			size <- rectSize,
			position <- rectCoord,
			fill <- 'none',
			stroke <- 'blue'
		),
		rectSize:SVG!Dimension (
			width <- 5+table.maxSizeName()+5+145+5,
			height <- (table.rows.size()+1)*10
		),
		rectCoord:SVG!AbsoluteCoord (
			x <- 0-table.maxSizeName()-5,
			y <- 0-5
		),
		transl:SVG!Translate (
			tx <- table.maxSizeName()+10 + thisModule.prevRectWidth,
			ty <- 10
		),
		scale:SVG!Scale (
			sx <- 1,
			sy <- scale.sx
		),
		axis:SVG!Path (
			d <- 'M145,0 H0 V' + (table.rows.size()*10).toString() + ',0 z',
			fill <- 'none',
			stroke <- 'black'
		),
		text:SVG!Text (
			position <- textCoord,
			stroke <- 'blue',
			fontSize <- '12',
			--@comments text-anchor value strored in lengthAdjust attribute
			lengthAdjust <- 'middle',
			content <- table.rows->first().cells->at(2).content
		),
		textCoord:SVG!AbsoluteCoord (
			x <- rectSize.width/2-table.maxSizeName(),
			y <- rectSize.height+10
		)
		
	do {
		thisModule.prevRectWidth <- thisModule.prevRectWidth + rectSize.width + 5;
		thisModule.svgFile.tag.children <- g;
	}
}
--@end lazy rule Table2BarChart

--@begin lazy rule Row2Bar
--@comments creates a bar (SVG line) for the row at position given
lazy rule Row2Bar {
	from
		position:Integer,
		scaleFactor:Real,
		row:Table!Row
	using {
		value : String =
			let point : Integer = row.cells->at(2).content->indexOf('.') in
				row.cells->at(2).content->substring(1,point+2);
	}
	to
		g:SVG!G (
			groupContent <- text,
			groupContent <- bar
		),
		bar:SVG!Rect (
			size <- barSize,
			position <- barCoord,
			fill <- 'blue',
			stroke <- 'black'
		),
		barSize:SVG!Dimension (
			width <- row.cells->at(2).content.toReal()*scaleFactor,
			height <- 10
		),
		barCoord:SVG!AbsoluteCoord (
			x <- 0,
			y <-barSize.height*(position-1)
		),
		text:SVG!Text (
			position <- txtCoord,
			stroke <- 'blue',
			fontSize <- '8',
			--@comments text-anchor value strored in lengthAdjust attribute
			lengthAdjust <- 'end',
			content <- row.cells->first().content + ' (' + value + ')'
		),
		txtCoord:SVG!AbsoluteCoord (
			x <- 0-5,
			y <- barCoord.y+barSize.height-1
		)
}
--@end lazy rule Row2Bar",name tabl svg version domain tabl svg bar chart author eric vepa eric vepa gmail com date descript this transform use transform generic tabl svg bar chart each entri tabl two column tabl two cell per row the first row contain two cell string first cell contain string bar chart second cell name chart the row contain one cell name string cell valu doubl modul tabl svg modul templat creat out svg in tabl begin attribut helper allvalidt comment return valid tabl ie tabl repres bar chart helper def allvalidt sequenc tabl tabl tabl tabl allinst select row first cell first content bar chart asset sortedbi row first cell content end attribut helper allvalidt begin helper maxsizenam comment return max size name tabl helper context tabl tabl def maxsizenam integ self row subsequ self row size iter row max integ let valu integ let point integ row cell content indexof row cell first content row cell content substr point size valu max valu els max endif end helper maxsizenam begin attribut helper prevrectwidth comment return previous valu svg rect width helper def prevrectwidth integ end attribut helper prevrectwidth begin entrypoint rule svgfile comment creat svg file one svg tag helper def svgfile svg svgfile oclundefin entrypoint rule svgfile svgfile svg svgfile tag svg svg svg svg size svgsize namespac http www w org svg version svgsize svg dimens width thismodul allvalidt iter tabl sum integ sum tabl maxsizenam height thismodul allvalidt iter tabl max integ tabl row size max tabl row size els max endif thismodul svgfile svgfile tabl thismodul allvalidt thismodul tabl barchart tabl end entrypoint rule svgfile begin lazi rule tabl barchart comment creat bar chart svg group one valid tabl lazi rule tabl barchart tabl tabl tabl tabl row first cell first content bar chart use row sequenc tabl row tabl row subsequ tabl row size scalefactor real row iter row max real row cell content toreal max row cell content toreal els max endif g svg g attribut transl attribut scale groupcont text groupcont rect groupcont axi groupcont row iter row acc sequenc svg g sequenc acc includ thismodul row bar row indexof row scalefactor row rect svg rect size rectsiz posit rectcoord fill none stroke blue rectsiz svg dimens width tabl maxsizenam height tabl row size rectcoord svg absolutecoord x tabl maxsizenam transl svg translat tx tabl maxsizenam thismodul prevrectwidth ty scale svg scale sx sy scale sx axi svg path m h v tabl row size tostr z fill none stroke black text svg text posit textcoord stroke blue fontsiz comment text anchor valu strore lengthadjust attribut lengthadjust middl content tabl row first cell content textcoord svg absolutecoord x rectsiz width tabl maxsizenam rectsiz height thismodul prevrectwidth thismodul prevrectwidth rectsiz width thismodul svgfile tag children g end lazi rule tabl barchart begin lazi rule row bar comment creat bar svg line row posit given lazi rule row bar posit integ scalefactor real row tabl row use valu string let point integ row cell content indexof row cell content substr point g svg g groupcont text groupcont bar bar svg rect size barsiz posit barcoord fill blue stroke black barsiz svg dimens width row cell content toreal scalefactor height barcoord svg absolutecoord x barsiz height posit text svg text posit txtcoord stroke blue fontsiz comment text anchor valu strore lengthadjust attribut lengthadjust end content row cell first content valu txtcoord svg absolutecoord x barcoord barsiz height end lazi rule row bar,2
104,104,P51-Table2SVGPieChart.atl,"--@name Table2SVG
--@version 1.0
--@domains Table, SVG, Pie chart
--@authors Eric Vepa (eric.vepa <at> gmail.com)
--@date 2006/08/04
--@description This transformation is used to transform generic tables into SVG pie charts. Each entry table is a two columns table (two cells per row). The first row contains two cells with a String (the first cell contains the String 'Pie Chart' and the second cell, the name of the chart). The other rows contains one cell with a name as String and an other cell with the value as Double.

module Table2SVG; -- Module Template
create OUT : SVG from IN : Table;

--@begin attribute helper radius
--@comments radius of the pie chart
helper def : radius : Real = 100;
--@end attribute helper radius

--@begin attribute helper scale
--@comments scale of the pie chart
helper def : scale : Real = 0.9;
--@end attribute helper scale

--@begin attribute helper allValidTables
--@comments returns all valid tables, ie tables which can be represented as pie chart
helper def : allValidTables : Sequence(Table!Table) =
	Table!Table.allInstances()->select(t|t.rows->first().cells->first().content = 'Pie Chart')->
		asSet()->sortedBy(t|t.rows->first().cells->at(2).content);
--@end attribute helper allValidTables

--@begin attribute helper maxSizeName
--@comments returns the max size of all name of a table
helper def : maxSizeName : Integer =
	thisModule.allValidTables->iterate(table; max:Integer=0|
		let maxTable : Integer =
				table.rows->subSequence(2,table.rows->size())->iterate(row; max:Integer=0|
					let value : Integer = row.cells->first().content->size() in
						if value > max
							then value
							else max
						endif)*10*thisModule.scale  in
			if maxTable > max
				then maxTable
				else max
			endif);		
--@end attribute helper maxSizeName

--@begin attribute helper angle
--@comments current angle rotation for a sector
helper def : angle : Real = 0;
--@end attribute helper angle

--@begin helper toDegree
--@comments converts from radians to degrees
helper context Real def : toDegree() : Real =
	self*(3.1415926535897932/180);
--@end helper toDegree

--@begin helper radianAngle
--@comments converts the angle value, stored in the cell, from radians to degrees
helper context Table!Cell def : radianAngle() : Real =
	(self.content.toReal()*3.6).toDegree();
--@end helper radianAngle

--@begin entrypoint rule SvgFile
--@comments creates the SVG file with one svg tag
helper def: svgFile : SVG!SvgFile = OclUndefined;

entrypoint rule SvgFile() {
	to
		svgFile:SVG!SvgFile (
			tag <- svg
		),
		svg:SVG!Svg (
			size <- svgSize,
			namespace <- 'http://www.w3.org/2000/svg',
			version <- '1.1'
		),
		svgSize:SVG!Dimension (
			width <- 2*(thisModule.radius+thisModule.maxSizeName)*thisModule.allValidTables->size()*thisModule.scale,
			height <- 2*(thisModule.radius+thisModule.maxSizeName)*thisModule.scale
		)
	do {
		thisModule.svgFile <- svgFile;
		for (table in thisModule.allValidTables) {
			thisModule.Table2PieChart(table);
		}
	}
}
--@end entrypoint rule SvgFile

--@begin lazy rule Table2PieChart
--@comments creates a pie chart (SVG group) for one valid table
lazy rule Table2PieChart {
	from
		table:Table!Table (
			table.rows->first().cells->first().content = 'Pie Chart'
		)
	to
		g:SVG!G (
			attribute <- transl,
			attribute <- scale,
			groupContent <- rect,
			groupContent <- text,
			--@comments creates a complete pie chart for table with one valued row or a sector for each row
			groupContent <-	if table.rows->size() = 2
											then thisModule.Row2Circle(table.rows->at(2))
											else table.rows->subSequence(2,table.rows->size())->iterate(row; acc:Sequence(SVG!G)=Sequence{}|
												acc->including(thisModule.Row2Sector(row)))
										endif
		),
		scale:SVG!Scale (
			sx <- thisModule.scale,
			sy <- scale.sx
		),
		transl:SVG!Translate (
			ty <- (thisModule.svgFile.tag.size.height/2)*scale.sx,
			tx <- transl.ty+(thisModule.allValidTables->indexOf(table)-1)*thisModule.svgFile.tag.size.height*scale.sx
		),
		rect:SVG!Rect (
			size <- rectSize,
			position <- rectCoord,
			fill <- 'none'
		),
		rectSize:SVG!Dimension (
			width <- thisModule.svgFile.tag.size.height-5,
			height <- rectSize.width
		),
		rectCoord:SVG!AbsoluteCoord (
			x <- 0-rectSize.width/2,
			y <- rectCoord.x
		),
		text:SVG!Text (
			position <- txtCoord,
			stroke <- 'blue',
			--@comments text-anchor value strored in lengthAdjust attribute
			lengthAdjust <- 'middle',
			content <- table.rows->first().cells->at(2).content
		),
		txtCoord:SVG!AbsoluteCoord (
			x <- 0,
			y <- rectSize.height/2-25
		)
	do {
		thisModule.svgFile.tag.children <- g;
		--@comments initialise rotation angle
		thisModule.angle <- 0;
	}
}
--@end lazy rule Table2PieChart

--@begin lazy rule Row2Sector
--@comments creates a sector (SVG path) for one row
lazy rule Row2Sector {
	from
		row:Table!Row
	using {
		x : Real = thisModule.radius*row.cells->at(2).radianAngle().cos();
		y : Real = thisModule.radius*row.cells->at(2).radianAngle().sin();
	}
	to
		g:SVG!G (
			attribute <- rotate,
			groupContent <- sector,
			groupContent <- text
		),
		rotate:SVG!Rotate (
			angle <- thisModule.angle
		),
		sector:SVG!Path (
			d <- 'M0,0 L' + thisModule.radius.toString() + ',0 ' +
				'A' + thisModule.radius.toString() + ',' +
				thisModule.radius.toString() + ' 0 ' +
				if 3.6*row.cells->at(2).content.toReal() < 180
					then '0,1 '
					else '1,1 '
				endif +	x.toString() + ',' + y.toString() + ' z',
			--@comments rgb color defined with absolute values of angle, cosinus and sinus of the sector
			fill <- 'rgb(' + rotate.angle.floor().toString() + ',' +
					x.abs().floor().toString() + ',' +
					y.abs().floor().toString() + ')',
			stroke <- 'black'
		),
		text:SVG!Text (
			position <- coord,
			stroke <- 'blue',
			fontSize <- '10',
			content <- '-- ' + row.cells->first().content
		),
		coord:SVG!AbsoluteCoord (
			x <- x,
			y <- y
		)
	do {
		--@comments add the angle value of the new sector
		thisModule.angle <- rotate.angle + 3.6*row.cells->at(2).content.toReal();
	}
}
--@end lazy rule Row2Sector

--@begin lazy rule Row2Circle
--@comments creates a complete pie (SVG Circle) for a table containing one row with a value
lazy rule Row2Circle {
	from
		row:Table!Row
	to
		g:SVG!G (
			groupContent <- circle,
			groupContent <- text
		),
		circle:SVG!Circle (
			size <- cirlceSize,
			position <- circleCoord,
			fill <- 'blue',
			stroke <- 'black'
		),
		cirlceSize:SVG!Dimension (
			width <- thisModule.radius,
			height <- cirlceSize.width
		),
		circleCoord:SVG!AbsoluteCoord (
			x <- 0,
			y <- 0
		),
		text:SVG!Text (
			position <- coord,
			stroke <- 'blue',
			fontSize <- '10',
			content <- '-- ' + row.cells->first().content
		),
		coord:SVG!AbsoluteCoord (
			x <- cirlceSize.width,
			y <- 0
		)
}
--@end lazy rule Row2Circle",name tabl svg version domain tabl svg pie chart author eric vepa eric vepa gmail com date descript this transform use transform generic tabl svg pie chart each entri tabl two column tabl two cell per row the first row contain two cell string first cell contain string pie chart second cell name chart the row contain one cell name string cell valu doubl modul tabl svg modul templat creat out svg in tabl begin attribut helper radius comment radius pie chart helper def radius real end attribut helper radius begin attribut helper scale comment scale pie chart helper def scale real end attribut helper scale begin attribut helper allvalidt comment return valid tabl ie tabl repres pie chart helper def allvalidt sequenc tabl tabl tabl tabl allinst select row first cell first content pie chart asset sortedbi row first cell content end attribut helper allvalidt begin attribut helper maxsizenam comment return max size name tabl helper def maxsizenam integ thismodul allvalidt iter tabl max integ let maxtabl integ tabl row subsequ tabl row size iter row max integ let valu integ row cell first content size valu max valu els max endif thismodul scale maxtabl max maxtabl els max endif end attribut helper maxsizenam begin attribut helper angl comment current angl rotat sector helper def angl real end attribut helper angl begin helper todegre comment convert radian degre helper context real def todegre real self end helper todegre begin helper radianangl comment convert angl valu store cell radian degre helper context tabl cell def radianangl real self content toreal todegre end helper radianangl begin entrypoint rule svgfile comment creat svg file one svg tag helper def svgfile svg svgfile oclundefin entrypoint rule svgfile svgfile svg svgfile tag svg svg svg svg size svgsize namespac http www w org svg version svgsize svg dimens width thismodul radius thismodul maxsizenam thismodul allvalidt size thismodul scale height thismodul radius thismodul maxsizenam thismodul scale thismodul svgfile svgfile tabl thismodul allvalidt thismodul tabl piechart tabl end entrypoint rule svgfile begin lazi rule tabl piechart comment creat pie chart svg group one valid tabl lazi rule tabl piechart tabl tabl tabl tabl row first cell first content pie chart g svg g attribut transl attribut scale groupcont rect groupcont text comment creat complet pie chart tabl one valu row sector row groupcont tabl row size thismodul row circl tabl row els tabl row subsequ tabl row size iter row acc sequenc svg g sequenc acc includ thismodul row sector row endif scale svg scale sx thismodul scale sy scale sx transl svg translat ty thismodul svgfile tag size height scale sx tx transl ty thismodul allvalidt indexof tabl thismodul svgfile tag size height scale sx rect svg rect size rectsiz posit rectcoord fill none rectsiz svg dimens width thismodul svgfile tag size height height rectsiz width rectcoord svg absolutecoord x rectsiz width rectcoord x text svg text posit txtcoord stroke blue comment text anchor valu strore lengthadjust attribut lengthadjust middl content tabl row first cell content txtcoord svg absolutecoord x rectsiz height thismodul svgfile tag children g comment initialis rotat angl thismodul angl end lazi rule tabl piechart begin lazi rule row sector comment creat sector svg path one row lazi rule row sector row tabl row use x real thismodul radius row cell radianangl cos real thismodul radius row cell radianangl sin g svg g attribut rotat groupcont sector groupcont text rotat svg rotat angl thismodul angl sector svg path m l thismodul radius tostr a thismodul radius tostr thismodul radius tostr row cell content toreal els endif x tostr tostr z comment rgb color defin absolut valu angl cosinus sinus sector fill rgb rotat angl floor tostr x ab floor tostr ab floor tostr stroke black text svg text posit coord stroke blue fontsiz content row cell first content coord svg absolutecoord x x comment add angl valu new sector thismodul angl rotat angl row cell content toreal end lazi rule row sector begin lazi rule row circl comment creat complet pie svg circl tabl contain one row valu lazi rule row circl row tabl row g svg g groupcont circl groupcont text circl svg circl size cirlces posit circlecoord fill blue stroke black cirlces svg dimens width thismodul radius height cirlces width circlecoord svg absolutecoord x text svg text posit coord stroke blue fontsiz content row cell first content coord svg absolutecoord x cirlces width end lazi rule row circl,2
105,105,P51-Table2TabularHTML.atl,"--@name Table2HTML
--@version 1.0
--@domains Table, HTML
--@authors Eric Vepa (eric.vepa <at> gmail.com)
--@date 2006/08/04
--@description This transformation is used to transform generic tables into HTML model with tables.

module Table2HTML; -- Module Template
create OUT : HTML from IN : Table;

--@begin attribute helper allValidTables
--@comments returns all valid sorted tables, ie tables which are not for bar or pie chart representations
helper def : allValidTables : Sequence(Table!Table) =
	Table!Table.allInstances()->
		select(table|table.rows->first().cells->first().content <> 'Bar Chart')->
			select(table|table.rows->first().cells->first().content <> 'Pie Chart')->
				asSet()->sortedBy(table|table.rows->first().cells->first().content);
--@end attribute helper allValidTables

--@begin helper roundValue
--@comments for String with a Real content (a dot exists), returns the String with only one decimal after the dot
helper context Table!Cell def : roundValue() : String =
	let point : Integer = self.content->indexOf('.') in
		if point > 0
			then self.content->substring(1,point+2)
			else self.content
		endif;
--@end helper roundValue

--@begin entrypoint rule HTML
--@comments only one HTML tag is created with one BODY tag
entrypoint rule HTML() {
	using {
		metamodelTables : Sequence(Table!Table) = thisModule.allValidTables->select(table|table.rows->first().cells->first().content = 'Metamodel');
	}
	to
		h:HTML!HTML (
			head <- head,
			body <- body
		),
		head:HTML!HEAD (
			headElements <- title
		),
		title:HTML!TITLE (
			value <-	if metamodelTables->notEmpty()
								then	if metamodelTables->first().rows->size() = 2
												then metamodelTables->first().rows->at(2).cells->first().content
												else 'Zoo'
											endif
								else ''
							endif
		),
		body:HTML!BODY (
			bodyElements <- thisModule.allValidTables->iterate(table; acc:Sequence(HTML!TABLE)=Sequence{}|
				acc->including(thisModule.Table2TABLE(table)))
		)
}
--@end entrypoint rule HTML

--@begin lazy rule Table2TABLE
--@comments HTML TABLE are added in the BODY of the only HTML tag
lazy rule Table2TABLE {
	from
		tab:Table!Table
	to
		table:HTML!TABLE (
			border <- '1',
			trs <- firstRow,
			trs <- tab.rows->subSequence(2,tab.rows->size())->iterate(row; acc:Sequence(HTML!TR)=Sequence{}|
				acc->including(thisModule.Row2TR(row)))
		),
		firstRow:HTML!TR (
			tds <- tab.rows->first().cells->iterate(cell; acc:Sequence(HTML!TH)=Sequence{}|
				acc->including(thisModule.Cell2TH(cell)))
		)
}
--@end lazy rule Table2TABLE

--@begin lazy rule Cell2TH
lazy rule Cell2TH {
	from
		cell:Table!Cell
	to
		th:HTML!TH (
			value <- cell.roundValue()
		)
}
--@end lazy rule Cell2TH

--@begin lazy rule Row2TR
lazy rule Row2TR {
	from
		row:Table!Row
	to
		tr:HTML!TR (
			tds <- row.cells->iterate(cell; acc:Sequence(HTML!TD)=Sequence{}|
				acc->including(thisModule.Cell2TD(cell)))
		)
}
--@end lazy rule Row2TR

--@begin lazy rule Cell2TD
lazy rule Cell2TD {
	from
		cell:Table!Cell
	to
		td:HTML!TD (
			value <- cell.roundValue()
		)
}
--@end lazy rule Cell2TD",name tabl html version domain tabl html author eric vepa eric vepa gmail com date descript this transform use transform generic tabl html model tabl modul tabl html modul templat creat out html in tabl begin attribut helper allvalidt comment return valid sort tabl ie tabl bar pie chart represent helper def allvalidt sequenc tabl tabl tabl tabl allinst select tabl tabl row first cell first content bar chart select tabl tabl row first cell first content pie chart asset sortedbi tabl tabl row first cell first content end attribut helper allvalidt begin helper roundvalu comment string real content dot exist return string one decim dot helper context tabl cell def roundvalu string let point integ self content indexof point self content substr point els self content endif end helper roundvalu begin entrypoint rule html comment one html tag creat one bodi tag entrypoint rule html use metamodelt sequenc tabl tabl thismodul allvalidt select tabl tabl row first cell first content metamodel h html html head head bodi bodi head html head headel titl titl html titl valu metamodelt notempti metamodelt first row size metamodelt first row cell first content els zoo endif els endif bodi html bodi bodyel thismodul allvalidt iter tabl acc sequenc html tabl sequenc acc includ thismodul tabl tabl tabl end entrypoint rule html begin lazi rule tabl tabl comment html tabl ad bodi html tag lazi rule tabl tabl tab tabl tabl tabl html tabl border trs firstrow trs tab row subsequ tab row size iter row acc sequenc html tr sequenc acc includ thismodul row tr row firstrow html tr tds tab row first cell iter cell acc sequenc html th sequenc acc includ thismodul cell th cell end lazi rule tabl tabl begin lazi rule cell th lazi rule cell th cell tabl cell th html th valu cell roundvalu end lazi rule cell th begin lazi rule row tr lazi rule row tr row tabl row tr html tr tds row cell iter cell acc sequenc html td sequenc acc includ thismodul cell td cell end lazi rule row tr begin lazi rule cell td lazi rule cell td cell tabl cell td html td valu cell roundvalu end lazi rule cell td,2
106,106,P52-MergingPartialClasses-context.atl,"-- @name		Merge partial classes(with all context)
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		Eric Simon(simon.eric3<at>gmail.com), Régis Chevrel (chevrel.regis <at> gmail.com)
-- @date		2006/08/09
-- @description	Classes may define only part of a coherent concept, other parts may be expressed in different classes and their commonalities have not been recognised. This transformation merges such classes into a single class.
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 2.6, page 22
-- @see author of article : K. Lano

module MergingPartialClasses; -- Module Template
create OUT : KM3 from IN : KM3;

helper context KM3!Reference def: isMerginable : Boolean =
	self.lower = 1 and self.upper = 1 and not self.isContainer
	;

helper def: assoMap : Map(KM3!Reference, Sequence(KM3!Reference)) = Map{};
rule isAlreadyConsidered(ref1 : KM3!Reference, ref2 : KM3!Reference) {

	do {
		if (not thisModule.assoMap.get(ref2).oclIsUndefined()) {
			if (thisModule.assoMap.get(ref2)->includes(ref1)) {
				true;
			}
			else {
			    if (not thisModule.assoMap.get(ref1).oclIsUndefined()) {
					thisModule.assoMap <- thisModule.assoMap.including(ref1,thisModule.assoMap.get(ref1)->including(ref2));
					false;
			    }
				else {
					thisModule.assoMap <- thisModule.assoMap.including(ref1, Sequence{ref2});
					false;
				}
			}
		}
		else  {
				if (not thisModule.assoMap.get(ref1).oclIsUndefined()) {
					thisModule.assoMap <- thisModule.assoMap.including(ref1,thisModule.assoMap.get(ref1)->including(ref2));
					false;
			    }
				else {	
					thisModule.assoMap <- thisModule.assoMap.including(ref1, Sequence{ref2});
					false;
				}
		}
		
	}
}



--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
--@end rule Metamodel

--@begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
--@end rule Package

--@begin rule DataType
rule DataType {
	from
		inputData:KM3!DataType
	to
		outputData:KM3!DataType(
			name <- inputData.name,
			location <- inputData.location
		)
}
--@end rule DataType

--@begin rule EnumLiteral
rule EnumLiteral {
	from
		inputL:KM3!EnumLiteral
	to
		outputL:KM3!EnumLiteral (
			name <- inputL.name,
			location <- inputL.location,
			enum  <- inputL.enum,
			package <- inputL.package
		)
}
--@end rule EnumLiteral

--@begin rule Enumeration 
rule Enumeration {
	from
		inputEnum:KM3!Enumeration
	to
		outputEnum:KM3!Enumeration (
			name <- inputEnum.name,
			location <- inputEnum.location,
			package <- inputEnum.package,
			literals <- inputEnum.literals
		)
}
--@end rule Enumeration 

--@begin rule Class
rule Class {
	from
		inputC:KM3!Class
		(not inputC.structuralFeatures->select(a|a.oclIsTypeOf(KM3!Reference))->exists(r| r.isMerginable and r.opposite.isMerginable))
	to
		outputC:KM3!Class (
			isAbstract <- inputC.isAbstract,
			supertypes <- inputC.supertypes,
			name <- inputC.name,
			location <- inputC.location,
			package <- inputC.package,
			structuralFeatures <- inputC.structuralFeatures
		)
}
--@end rule Class

--@begin rule Attribute
rule Attribute {
	from
		inputAttr : KM3!Attribute
	to
		outputAttr : KM3!Attribute (
			package <- inputAttr.package,
			name <- inputAttr.name,
			lower <- inputAttr.lower,
			upper <- inputAttr.upper,
			isOrdered <- inputAttr.isOrdered,
			isUnique <- inputAttr.isUnique,
			owner <- inputAttr.owner,
			type <- inputAttr.type
		)
}
--@end rule Attribute

--@begin rule Reference
rule Reference {
	from
		inputRef : KM3!Reference
			( not (inputRef.isMerginable and inputRef.opposite.isMerginable))
	to
		outputRef : KM3!Reference (
			package <- inputRef.package,
			name <- inputRef.name,
			lower <- inputRef.lower,
			upper <- inputRef.upper,
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			owner <- inputRef.owner,
			type <- inputRef.type,
			isContainer <- inputRef.isContainer,
			opposite <- inputRef.opposite
		)
}
--@end rule Attribute

--@begin rule Merging
rule Merging {
	from
		inputA : KM3!Reference,
		inputB : KM3!Reference
		(
			inputA.opposite = inputB
			and inputA.isMerginable
			and inputB.isMerginable
			and inputA <> inputB
			and not thisModule.isAlreadyConsidered(inputA, inputB)
		)


	to
		outputA : KM3!Class (
			package <- inputA.owner.package,
			name <- inputA.owner.name->concat(inputB.owner.name),
			isAbstract <- inputA.owner.isAbstract,
			structuralFeatures <- inputA.owner.structuralFeatures->select(b|b.oclIsTypeOf(KM3!Reference))->select(a| not a.isMerginable),
			structuralFeatures <- inputA.owner.structuralFeatures->select(b|b.oclIsTypeOf(KM3!Attribute)),
			structuralFeatures <- inputB.owner.structuralFeatures->select(b|b.oclIsTypeOf(KM3!Reference))->select(a| not a.isMerginable),
			structuralFeatures <- inputB.owner.structuralFeatures->select(b|b.oclIsTypeOf(KM3!Attribute))
		)
}
--@end rule Merging



",name merg partial class context version domain catalogu model transform author eric simon simon eric gmail com r gis chevrel chevrel regi gmail com date descript class may defin part coher concept part may express differ class common recognis this transform merg class singl class see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul mergingpartialclass modul templat creat out km in km helper context km refer def ismergin boolean self lower self upper self iscontain helper def assomap map km refer sequenc km refer map rule isalreadyconsid ref km refer ref km refer thismodul assomap get ref oclisundefin thismodul assomap get ref includ ref true els thismodul assomap get ref oclisundefin thismodul assomap thismodul assomap includ ref thismodul assomap get ref includ ref fals els thismodul assomap thismodul assomap includ ref sequenc ref fals els thismodul assomap get ref oclisundefin thismodul assomap thismodul assomap includ ref thismodul assomap get ref includ ref fals els thismodul assomap thismodul assomap includ ref sequenc ref fals begin rule metamodel rule metamodel inputmm km metamodel outputmm km metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km packag name inputpkg name content inputpkg content end rule packag begin rule datatyp rule datatyp inputdata km datatyp outputdata km datatyp name inputdata name locat inputdata locat end rule datatyp begin rule enumliter rule enumliter inputl km enumliter outputl km enumliter name inputl name locat inputl locat enum inputl enum packag inputl packag end rule enumliter begin rule enumer rule enumer inputenum km enumer outputenum km enumer name inputenum name locat inputenum locat packag inputenum packag liter inputenum liter end rule enumer begin rule class rule class inputc km class inputc structuralfeatur select oclistypeof km refer exist r r ismergin r opposit ismergin outputc km class isabstract inputc isabstract supertyp inputc supertyp name inputc name locat inputc locat packag inputc packag structuralfeatur inputc structuralfeatur end rule class begin rule attribut rule attribut inputattr km attribut outputattr km attribut packag inputattr packag name inputattr name lower inputattr lower upper inputattr upper isord inputattr isord isuniqu inputattr isuniqu owner inputattr owner type inputattr type end rule attribut begin rule refer rule refer inputref km refer inputref ismergin inputref opposit ismergin outputref km refer packag inputref packag name inputref name lower inputref lower upper inputref upper isord inputref isord isuniqu inputref isuniqu owner inputref owner type inputref type iscontain inputref iscontain opposit inputref opposit end rule attribut begin rule merg rule merg inputa km refer inputb km refer inputa opposit inputb inputa ismergin inputb ismergin inputa inputb thismodul isalreadyconsid inputa inputb outputa km class packag inputa owner packag name inputa owner name concat inputb owner name isabstract inputa owner isabstract structuralfeatur inputa owner structuralfeatur select b b oclistypeof km refer select ismergin structuralfeatur inputa owner structuralfeatur select b b oclistypeof km attribut structuralfeatur inputb owner structuralfeatur select b b oclistypeof km refer select ismergin structuralfeatur inputb owner structuralfeatur select b b oclistypeof km attribut end rule merg,19
107,107,P52-MergingPartialClasses-without.atl,"-- @name		Merge partial classes(with only the  elements necessary for the example context)
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		Eric Simon(simon.eric3<at>gmail.com), Régis Chevrel (chevrel.regis <at> gmail.com)
-- @date		2006/08/09
-- @description	Classes may define only part of a coherent concept, other parts may be expressed in different classes and their commonalities have not been recognised. This transformation merges such classes into a single class.
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 2.6, page 22
-- @see author of article : K. Lano

module MergingPartialClasses; -- Module Template
create OUT : KM3 from IN : KM3;

--helper def: rootPackage : KM3!Package =
--	KM3!Package.allInstances()->select(e | e.name <> 'PrimitiveTypes')->first();

helper context KM3!Reference def: isMerginable : Boolean =
	self.lower = 1 and self.upper = 1 and not self.isContainer
	;

helper def: assoMap : Map(KM3!Reference, Sequence(KM3!Reference)) = Map{};
rule isAlreadyConsidered(ref1 : KM3!Reference, ref2 : KM3!Reference) {

	do {
		if (not thisModule.assoMap.get(ref2).oclIsUndefined()) {
			if (thisModule.assoMap.get(ref2)->includes(ref1)) {
				true;
			}
			else {
			    if (not thisModule.assoMap.get(ref1).oclIsUndefined()) {
					thisModule.assoMap <- thisModule.assoMap.including(ref1,thisModule.assoMap.get(ref1)->including(ref2));
					false;
			    }
				else {
					thisModule.assoMap <- thisModule.assoMap.including(ref1, Sequence{ref2});
					false;
				}
			}
		}
		else  {
				if (not thisModule.assoMap.get(ref1).oclIsUndefined()) {
					thisModule.assoMap <- thisModule.assoMap.including(ref1,thisModule.assoMap.get(ref1)->including(ref2));
					false;
			    }
				else {	
					thisModule.assoMap <- thisModule.assoMap.including(ref1, Sequence{ref2});
					false;
				}
		}
		
	}
}



--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
--@end rule Metamodel

--@begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
--@end rule Package

--@begin rule DataType
rule DataType {
	from
		inputData:KM3!DataType
	to
		outputData:KM3!DataType(
			name <- inputData.name,
			location <- inputData.location
		)
}
--@end rule DataType

--@begin rule EnumLiteral
rule EnumLiteral {
	from
		inputL:KM3!EnumLiteral
	to
		outputL:KM3!EnumLiteral (
			name <- inputL.name,
			location <- inputL.location,
			enum  <- inputL.enum,
			package <- inputL.package
		)
}
--@end rule EnumLiteral


--@begin rule Class
rule Class {
	from
		inputC:KM3!Class
		(not inputC.structuralFeatures->select(a|a.oclIsTypeOf(KM3!Reference))->exists(r| r.isMerginable and r.opposite.isMerginable))
	to
		outputC:KM3!Class (
			isAbstract <- inputC.isAbstract,
			supertypes <- inputC.supertypes,
			name <- inputC.name,
			location <- inputC.location,
			package <- inputC.package,
			structuralFeatures <- inputC.structuralFeatures
		)
}
--@end rule Class

--@begin rule Attribute
rule Attribute {
	from
		inputAttr : KM3!Attribute
	to
		outputAttr : KM3!Attribute (
			package <- inputAttr.package,
			name <- inputAttr.name,
			lower <- inputAttr.lower,
			upper <- inputAttr.upper,
			isOrdered <- inputAttr.isOrdered,
			isUnique <- inputAttr.isUnique,
			owner <- inputAttr.owner,
			type <- inputAttr.type
		)
}
--@end rule Attribute

--@begin rule Reference
rule Reference {
	from
		inputRef : KM3!Reference
			( not (inputRef.isMerginable and inputRef.opposite.isMerginable))
	to
		outputRef : KM3!Reference (
			package <- inputRef.package,
			name <- inputRef.name,
			lower <- inputRef.lower,
			upper <- inputRef.upper,
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			owner <- inputRef.owner,
			type <- inputRef.type,
			isContainer <- inputRef.isContainer,
			opposite <- inputRef.opposite
		)
}
--@end rule Attribute

--@begin rule Merging
rule Merging {
	from
		inputA : KM3!Reference,
		inputB : KM3!Reference
		(
			inputA.opposite = inputB
			and inputA.isMerginable
			and inputB.isMerginable
			and inputA <> inputB
			and not thisModule.isAlreadyConsidered(inputA, inputB)
		)


	to
		outputA : KM3!Class (
			package <- inputA.owner.package,
			name <- inputA.owner.name->concat(inputB.owner.name),
			isAbstract <- inputA.owner.isAbstract,
			structuralFeatures <- inputA.owner.structuralFeatures->select(b|b.oclIsTypeOf(KM3!Reference))->select(a| not a.isMerginable),
			structuralFeatures <- inputA.owner.structuralFeatures->select(b|b.oclIsTypeOf(KM3!Attribute)),
			structuralFeatures <- inputB.owner.structuralFeatures->select(b|b.oclIsTypeOf(KM3!Reference))->select(a| not a.isMerginable),
			structuralFeatures <- inputB.owner.structuralFeatures->select(b|b.oclIsTypeOf(KM3!Attribute))
		)
}
--@end rule Merging



",name merg partial class element necessari exampl context version domain catalogu model transform author eric simon simon eric gmail com r gis chevrel chevrel regi gmail com date descript class may defin part coher concept part may express differ class common recognis this transform merg class singl class see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul mergingpartialclass modul templat creat out km in km helper def rootpackag km packag km packag allinst select e e name primitivetyp first helper context km refer def ismergin boolean self lower self upper self iscontain helper def assomap map km refer sequenc km refer map rule isalreadyconsid ref km refer ref km refer thismodul assomap get ref oclisundefin thismodul assomap get ref includ ref true els thismodul assomap get ref oclisundefin thismodul assomap thismodul assomap includ ref thismodul assomap get ref includ ref fals els thismodul assomap thismodul assomap includ ref sequenc ref fals els thismodul assomap get ref oclisundefin thismodul assomap thismodul assomap includ ref thismodul assomap get ref includ ref fals els thismodul assomap thismodul assomap includ ref sequenc ref fals begin rule metamodel rule metamodel inputmm km metamodel outputmm km metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km packag name inputpkg name content inputpkg content end rule packag begin rule datatyp rule datatyp inputdata km datatyp outputdata km datatyp name inputdata name locat inputdata locat end rule datatyp begin rule enumliter rule enumliter inputl km enumliter outputl km enumliter name inputl name locat inputl locat enum inputl enum packag inputl packag end rule enumliter begin rule class rule class inputc km class inputc structuralfeatur select oclistypeof km refer exist r r ismergin r opposit ismergin outputc km class isabstract inputc isabstract supertyp inputc supertyp name inputc name locat inputc locat packag inputc packag structuralfeatur inputc structuralfeatur end rule class begin rule attribut rule attribut inputattr km attribut outputattr km attribut packag inputattr packag name inputattr name lower inputattr lower upper inputattr upper isord inputattr isord isuniqu inputattr isuniqu owner inputattr owner type inputattr type end rule attribut begin rule refer rule refer inputref km refer inputref ismergin inputref opposit ismergin outputref km refer packag inputref packag name inputref name lower inputref lower upper inputref upper isord inputref isord isuniqu inputref isuniqu owner inputref owner type inputref type iscontain inputref iscontain opposit inputref opposit end rule attribut begin rule merg rule merg inputa km refer inputb km refer inputa opposit inputb inputa ismergin inputb ismergin inputa inputb thismodul isalreadyconsid inputa inputb outputa km class packag inputa owner packag name inputa owner name concat inputb owner name isabstract inputa owner isabstract structuralfeatur inputa owner structuralfeatur select b b oclistypeof km refer select ismergin structuralfeatur inputa owner structuralfeatur select b b oclistypeof km attribut structuralfeatur inputb owner structuralfeatur select b b oclistypeof km refer select ismergin structuralfeatur inputb owner structuralfeatur select b b oclistypeof km attribut end rule merg,19
108,108,P53-METAH2ACME.atl,"module METAH2ACME;
create OUT : ACME from IN : METAH;


--@begin METAHFile2ACMEFile
--@comments METAHFile and ACMEFile are root element of ACME and METAH metamodel
rule METAHFile2ACMEFile {
	from
		m : METAH!METAHFile 
	to
		a : ACME!ACMEFile (
			entries <- m.entries
		)
	}
--@end METAHFile2ACMEFile

--@begin ProcessDeclaration2ComponentType
rule ProcessDeclaration2ComponentType {
	from
		p : METAH!ProcessDeclaration
	to
		c: ACME!ComponentType (
			name <- p.procDecName,
			ports <- p.ports,
			extend <- 'MH_Process'
		)
}
--@end ProcessDeclaration2ComponentType


--@begin Port2Port
--@comments Transform a METAH port into an ACME port with two properties
rule Port2Port {
	from
		p1 : METAH!Port 
	to
	 	p2 : ACME!Port (
	 		name <- p1.portName,
			property <- Sequence {port_type,port_subclass}
	 	),
		port_type : ACME!Property(
			name <- 'MH_port_type',
			val <- p1.portType
		),
		port_subclass : ACME!Property(
			name <- 'MH_port_subclass',
			val <- 'MH_'+p1.portCom
		)
}
--@end Port2Port


--@begin ProcessImplementation2ComponentType
rule ProcessImplementation2ComponentType {
	from
		p1 : METAH!ProcessImplementation
	to
		p2 : ACME!ComponentType (
			name <- p1.declaration+'_'+p1.procImpName,	
			property <- p1.processAttributes,
			extend <- p1.declaration
	)
}
--@end ProcessImplementation2ComponentType

--@begin ProcessAttribute2Property
rule ProcessAttribute2Property {
	from
		a : METAH!ProcessAttribute
	to
		p : ACME!Property (
			name <- 'MH_'+a.attName,
			val <- a.attValue.toString().concat(' ').concat(a.attValueType)
		)
}
--@end ProcessAttribute2Property

--@begin MacroDeclaration2ComponentType
rule MacroDeclaration2ComponentType {
	from
		m : METAH!MacroDeclaration
	to
		c : ACME!ComponentType (
			name <- m.name,
			ports <- m.ports,
			extend <- 'MH_macro'
		)
}
--@end MacroDeclaration2ComponentType

--@begin MacroImplementation2ComponentType
rule MacroImplementation2ComponentType {
	from
		m : METAH!MacroImplementation
	to
		c : ACME!ComponentType(
			name <- m.macroImpName,
			extend <- m.declaration,
			representations <- Sequence {r}
		), 
		r : ACME!Representation (
			systems <- Sequence {s}
		),
		s : ACME!System(
			 name <- 'MH_little_System',
			 componentDeclaration <- m.process,
			 attachments <- m.connections
		)
}
--@end MacroImplementation2ComponentType

--@begin Process2Component
rule Process2Component {
	from 
		p : METAH!Process
	to
		c : ACME!ComponentInstance (
			name <- p.procName,
			instanceOf <- p.declaration+'_'+p.implementation,
			property <- period
		),
		period : ACME!Property (
			name <- 'MH_Process_subclass',
			val <-  'MH_'+p.periodic
		)
}
--@end Process2Component

--@begin Connection2Connector
rule Connection2Connector {
	from
		c1 : METAH!Connection (
			not((c1.compSrc.oclIsUndefined())or
			(c1.compDest.oclIsUndefined()))
		)
	to
		attach1 : ACME!Attachment (		
			comp <- c1.compSrc,
			port <- c1.portSrc,
			con <- c1.compSrc+'_to_'+c1.compDest,
			role <- 'MH_sink',
			systemAttachment <- thisModule.resolveTemp(METAH!MacroImplementation.allInstances()->asSequence()->first(),'s')
		),
		attach2 : ACME!Attachment (		
			comp <- c1.compDest,
			port <- c1.portDest,
			con <- c1.compSrc+'_to_'+c1.compDest,
			role <- 'MH_source',
			systemAttachment <- thisModule.resolveTemp(METAH!MacroImplementation.allInstances()->asSequence()->first(),'s')
		),
		c2 : ACME!Connector (
			 name <- c1.compSrc+'_to_'+c1.compDest,
			 roles <- Sequence {r1,r2},
			 system <- thisModule.resolveTemp(METAH!MacroImplementation.allInstances()->asSequence()->first(),'s')
		),
		r1 : ACME!Role (
			name <- 'MH_sink'	
		),
		r2 : ACME!Role (
			name <- 'MH_source'	
		)
}
--@end Connection2Connector

--@begin Connection2Binding
rule Connection2Binding {
	from
		b1 : METAH!Connection (
			((b1.compSrc.oclIsUndefined())or(b1.compDest.oclIsUndefined()))
		)
	to
		b2 : ACME!Binding (
			compSrc <- b1.compSrc,
			compDest <- b1.compDest,
			portDest <- b1.portDest,
			portSrc <- b1.portSrc,
			systemBinding <- thisModule.resolveTemp(METAH!MacroImplementation.allInstances()->asSequence()->first(),'s')
		)
}
--@end Connection2Binding

",modul metah acm creat out acm in metah begin metahfil acmefil comment metahfil acmefil root element acm metah metamodel rule metahfil acmefil metah metahfil acm acmefil entri entri end metahfil acmefil begin processdeclar componenttyp rule processdeclar componenttyp p metah processdeclar c acm componenttyp name p procdecnam port p port extend mh process end processdeclar componenttyp begin port port comment transform metah port acm port two properti rule port port p metah port p acm port name p portnam properti sequenc port type port subclass port type acm properti name mh port type val p porttyp port subclass acm properti name mh port subclass val mh p portcom end port port begin processimplement componenttyp rule processimplement componenttyp p metah processimplement p acm componenttyp name p declar p procimpnam properti p processattribut extend p declar end processimplement componenttyp begin processattribut properti rule processattribut properti metah processattribut p acm properti name mh attnam val attvalu tostr concat concat attvaluetyp end processattribut properti begin macrodeclar componenttyp rule macrodeclar componenttyp metah macrodeclar c acm componenttyp name name port port extend mh macro end macrodeclar componenttyp begin macroimplement componenttyp rule macroimplement componenttyp metah macroimplement c acm componenttyp name macroimpnam extend declar represent sequenc r r acm represent system sequenc acm system name mh littl system componentdeclar process attach connect end macroimplement componenttyp begin process compon rule process compon p metah process c acm componentinst name p procnam instanceof p declar p implement properti period period acm properti name mh process subclass val mh p period end process compon begin connect connector rule connect connector c metah connect c compsrc oclisundefin c compdest oclisundefin attach acm attach comp c compsrc port c portsrc con c compsrc c compdest role mh sink systemattach thismodul resolvetemp metah macroimplement allinst assequ first attach acm attach comp c compdest port c portdest con c compsrc c compdest role mh sourc systemattach thismodul resolvetemp metah macroimplement allinst assequ first c acm connector name c compsrc c compdest role sequenc r r system thismodul resolvetemp metah macroimplement allinst assequ first r acm role name mh sink r acm role name mh sourc end connect connector begin connect bind rule connect bind b metah connect b compsrc oclisundefin b compdest oclisundefin b acm bind compsrc b compsrc compdest b compdest portdest b portdest portsrc b portsrc systembind thismodul resolvetemp metah macroimplement allinst assequ first end connect bind,0
109,109,P54-SpreadsheetMLSimplified2SoftwareQualityControl.atl,"module SpreadsheetMLSimplified2SoftwareQualityControl; -- Module Template
create OUT : SoftwareQualityControl from IN : SpreadsheetMLSimplified;


-- This helper permits to recover a string value in the worksheet thanks to the row and cell numbers.
-- CONTEXT: SpreadsheetMLSimplified!Worksheet
-- RETURN: String
helper context SpreadsheetMLSimplified!Worksheet def: getStringValueByRowAndCell(rowNb : Integer, cellNb : Integer) : String =
	self.ws_table.t_rows->at(rowNb).r_cells->at(cellNb).c_data.value.value;
	

-- This helper permits to recover an optional string value in the worksheet thanks to the row and cell numbers.
-- CONTEXT: SpreadsheetMLSimplified!Worksheet
-- RETURN: String
helper context SpreadsheetMLSimplified!Worksheet def: getOptStringValueByRowAndCell(rowNb : Integer, cellNb : Integer) : String =
	let d : SpreadsheetMLSimplified!Data = self.ws_table.t_rows->at(rowNb).r_cells->at(cellNb).c_data
	in
		if d.oclIsUndefined()
		then
			String
		else
			d.value.value
		endif;


-- This helper permits to recover a string value in a row thanks to its column number,
-- if it exists.
-- CONTEXT: SpreadsheetMLSimplified!Row
-- RETURN: String
helper context SpreadsheetMLSimplified!Row def: getStringValueByColumn(colNb : Integer) : String =
	let d : SpreadsheetMLSimplified!Data = self.r_cells->at(colNb).c_data
	in
		if d.oclIsUndefined()
		then
			String
		else
			d.value.value
		endif;


-- This helper permits to recover the bug status value from a string
-- CONTEXT: n/a
-- RETURN: SoftwareQualityControl!BugStatusType
helper def: getBugStatus(st : String) : SoftwareQualityControl!BugStatusType =
	if ( not st.oclIsUndefined() )
	then
		if st = 'open'
		then
			#bst_open
		else
			if st = 'closed'
			then
				#bst_closed
			else
				if st = 'skipped'
				then
					#bst_skipped
				else
					#bst_open
				endif
			endif
		endif
	else
		#bst_open
	endif;
	


-- Rule 'Workbook2ControlsSequence'
-- This rule generates the sequence of controls which is the
-- root element of the ""SoftwareQualityControl"" metamodel
rule Workbook2ControlsSequence {
	from
		wb : SpreadsheetMLSimplified!Workbook
	
	to
		cs : SoftwareQualityControl!ControlsSequence (
			controls <- wb.wb_worksheets->collect(e | thisModule.resolveTemp(e, 'c'))
		)	
}


-- Rule 'Worksheet2Control'
-- This rule generates the controls that are contained in the controls sequence.
-- Each worksheet of the Excel workbook describes a specific control.
rule Worksheet2Control {
	from
		ws : SpreadsheetMLSimplified!Worksheet
	
	using {
		controlDate : SpreadsheetMLSimplified!DateTimeType = ws.ws_table.t_rows->at(7).r_cells->at(2).c_data.value.value;
	}

	to
		c : SoftwareQualityControl!Control (
			responsible <- ws.getStringValueByRowAndCell(1,2),
			component <- ws.getStringValueByRowAndCell(3,2),
			developmentPhase <- ws.getStringValueByRowAndCell(5,2),
			scope <- ws.getStringValueByRowAndCell(6,2),
			date <- d,
			controlledElt <- ws.getOptStringValueByRowAndCell(2,3),
			eltRef <- ws.getOptStringValueByRowAndCell(4,1),
			eltAuthor <- ws.getOptStringValueByRowAndCell(6,3),
			formRef <- ws.getOptStringValueByRowAndCell(2,4)
		),	
		d : SoftwareQualityControl!Date (
			day <- controlDate.day,
			month <- controlDate.month,
			year <- controlDate.year
		)
}


-- Rule 'BugTracking'
-- This rule generates the Bug Tracking's type of control
-- from the ""Type of control field"" of the worksheet.
rule BugTracking {
	from
		btt : SpreadsheetMLSimplified!Table (
			btt.t_rows->at(2).r_cells->at(2).c_data.value.value='Bug Tracking'	
		)

	to
		bt : SoftwareQualityControl!BugTracking (
			ct_control <- Sequence{btt.t_worksheet}->collect(e | thisModule.resolveTemp(e, 'c'))->first()
		)
}

-- Rule 'Bug'
-- This rule generates a bug from a line of the worksheet's bugs table.
rule Bug {
	from
		row : SpreadsheetMLSimplified!Row (
			let d : SpreadsheetMLSimplified!Data = row.r_cells->at(1).c_data
			in
				if d.oclIsUndefined()
				then
					false
				else
					d.value.oclIsTypeOf(SpreadsheetMLSimplified!NumberValue)
				endif
		)

	to
		bug : SoftwareQualityControl!Bug(
			b_bugTracking <- Sequence{row.r_table}->collect(e | thisModule.resolveTemp(e, 'bt'))->first(),
			number <- row.r_cells->at(1).c_data.value.value.round(),
			componentVersion <- row.getStringValueByColumn(2),
			description <- row.getStringValueByColumn(3),
			status <- thisModule.getBugStatus(row.getStringValueByColumn(4)),
			originator <- row.getStringValueByColumn(5),
			responsible <- row.getStringValueByColumn(6),
			commentsAnswers <- row.getStringValueByColumn(7),
			openDate <- row.getStringValueByColumn(8),
			closeDate <- row.getStringValueByColumn(9)
		)
}",modul spreadsheetmlsimplifi softwarequalitycontrol modul templat creat out softwarequalitycontrol in spreadsheetmlsimplifi this helper permit recov string valu worksheet thank row cell number context spreadsheetmlsimplifi worksheet return string helper context spreadsheetmlsimplifi worksheet def getstringvaluebyrowandcel rownb integ cellnb integ string self ws tabl row rownb r cell cellnb c data valu valu this helper permit recov option string valu worksheet thank row cell number context spreadsheetmlsimplifi worksheet return string helper context spreadsheetmlsimplifi worksheet def getoptstringvaluebyrowandcel rownb integ cellnb integ string let spreadsheetmlsimplifi data self ws tabl row rownb r cell cellnb c data oclisundefin string els valu valu endif this helper permit recov string valu row thank column number exist context spreadsheetmlsimplifi row return string helper context spreadsheetmlsimplifi row def getstringvaluebycolumn colnb integ string let spreadsheetmlsimplifi data self r cell colnb c data oclisundefin string els valu valu endif this helper permit recov bug status valu string context n return softwarequalitycontrol bugstatustyp helper def getbugstatus st string softwarequalitycontrol bugstatustyp st oclisundefin st open bst open els st close bst close els st skip bst skip els bst open endif endif endif els bst open endif rule workbook controlssequ this rule generat sequenc control root element softwarequalitycontrol metamodel rule workbook controlssequ wb spreadsheetmlsimplifi workbook cs softwarequalitycontrol controlssequ control wb wb worksheet collect e thismodul resolvetemp e c rule worksheet control this rule generat control contain control sequenc each worksheet excel workbook describ specif control rule worksheet control ws spreadsheetmlsimplifi worksheet use controld spreadsheetmlsimplifi datetimetyp ws ws tabl row r cell c data valu valu c softwarequalitycontrol control respons ws getstringvaluebyrowandcel compon ws getstringvaluebyrowandcel developmentphas ws getstringvaluebyrowandcel scope ws getstringvaluebyrowandcel date controlledelt ws getoptstringvaluebyrowandcel eltref ws getoptstringvaluebyrowandcel eltauthor ws getoptstringvaluebyrowandcel formref ws getoptstringvaluebyrowandcel softwarequalitycontrol date day controld day month controld month year controld year rule bugtrack this rule generat bug track type control type control field worksheet rule bugtrack btt spreadsheetmlsimplifi tabl btt row r cell c data valu valu bug track bt softwarequalitycontrol bugtrack ct control sequenc btt worksheet collect e thismodul resolvetemp e c first rule bug this rule generat bug line worksheet bug tabl rule bug row spreadsheetmlsimplifi row let spreadsheetmlsimplifi data row r cell c data oclisundefin fals els valu oclistypeof spreadsheetmlsimplifi numbervalu endif bug softwarequalitycontrol bug b bugtrack sequenc row r tabl collect e thismodul resolvetemp e bt first number row r cell c data valu valu round componentvers row getstringvaluebycolumn descript row getstringvaluebycolumn status thismodul getbugstatus row getstringvaluebycolumn origin row getstringvaluebycolumn respons row getstringvaluebycolumn commentsansw row getstringvaluebycolumn opend row getstringvaluebycolumn closed row getstringvaluebycolumn,11
110,110,P55-SpreadsheetMLSimplified2XML.atl,"module SpreadsheetMLSimplified2XML; -- Module Template
create  OUT : XML from  IN : SpreadsheetMLSimplified;



-- This helper permits to obtain the string associated
-- to a DateTimeType value.
-- CONTEXT: n/a
-- RETURN: String
helper def: getDateTimeStringValue(dtv : SpreadsheetMLSimplified!DateTimeType) : String =
	dtv.year.toString() + '-' + dtv.month.toString() + '-' + dtv.day.toString() + 'T' 
	+ dtv.hour.toString() + ':' + dtv.minute.toString() + ':' + dtv.second.toString() + '.000';
	


-- Rule 'DocumentRoot'.
-- This rule generates the root element of an Excel xml file
-- which is the ""Workbook"" element
rule DocumentRoot {
	 from 
	 	wb : SpreadsheetMLSimplified!Workbook
	 to 
	 	r : XML!Root(
		 	name<-'Workbook',
			value <- '',
			children <- Sequence{	att1,att2,
		 							wb.wb_worksheets->collect(e | thisModule.resolveTemp(e, 'wsElt')) }
		),
		att1 : XML!Attribute (
			name <- 'xmlns',
			value <- 'urn:schemas-microsoft-com:office:spreadsheet'
		),
		att2 : XML!Attribute (
			name <- 'xmlns:ss',
			value <-'urn:schemas-microsoft-com:office:spreadsheet'
		)
}


-- Rule 'Worksheets'.
-- This rule generates the different ""Worksheet"" elements 
-- contained in a ""Workbook"" element
rule Worksheets {
	from 
		ws : SpreadsheetMLSimplified!Worksheet
		
	to
		wsElt : XML!Element (
			name <- 'Worksheet',
			children <- Sequence{nameAtt,Sequence{ws.ws_table}->collect(e | thisModule.resolveTemp(e, 'tElt'))->first()}
		),
		nameAtt : XML!Attribute (
			name <- 'ss:Name',
			value <- ws.name,
			parent <- wsElt
		)
}


-- Rule 'WorksheetTable'.
-- This rule generates the ""Table"" element  
-- contained in a ""Worksheet"" element
rule WorksheetTable {
	from 
		t : SpreadsheetMLSimplified!Table

	to
		tElt : XML!Element (
			name <- 'Table',
			children <- Sequence{
									t.t_cols->collect(e | thisModule.resolveTemp(e, 'colElt')),
									t.t_rows->collect(e | thisModule.resolveTemp(e, 'rowElt'))
								}
		)
}


-- Rule 'TableColumn'.
-- This rule generates the ""Column"" elements  
-- contained in a ""Table"" element
rule TableColumn {
	from 
		col : SpreadsheetMLSimplified!Column
	
	using {
		widthOrNot : Sequence(String) =
			let wdh : Real = col.width
			in
				if wdh.oclIsUndefined()
				then
					Sequence{}
				else
					Sequence{wdh.toString()}
				endif;		
	}

	to
		colElt : XML!Element (
			name <- 'Column',
			children <- Sequence{colWidth}
		),
		colWidth : distinct XML!Attribute foreach(widthValue in widthOrNot)(
			name <- 'ss:Width',
			value <- widthValue
		)
}


-- Rule 'TableRow'.
-- This rule generates the ""Row"" elements  
-- contained in a ""Table"" element
rule TableRow {
	from 
		row : SpreadsheetMLSimplified!Row

	to
		rowElt : XML!Element (
			name <- 'Row',
			children <- Sequence{row.r_cells->collect(e | thisModule.resolveTemp(e, 'cellElt'))}
		)
}


-- Rule 'RowCell'.
-- This rule generates the ""Cell"" elements  
-- contained in a ""Row"" element
rule RowCell {
	from 
		cell : SpreadsheetMLSimplified!Cell

	to
		cellElt : XML!Element (
			name <- 'Cell',
			children <- Sequence{
							Sequence{cell.c_data}->collect(e | thisModule.resolveTemp(e, 'dataElt'))->first()
						}
		)
}


-- Rule 'CellData'.
-- This rule generates the ""Data"" element  
-- contained in a ""Cell"" element
rule CellData {
	from 
		data : SpreadsheetMLSimplified!Data

	to
		dataElt : XML!Element (
			name <- 'Data'
		)
}


-- Rule 'DataStringValue'.
-- This rule generates the string value  
-- associated to a ""Data"" element
rule DataStringValue {
	from 
		strVal: SpreadsheetMLSimplified!StringValue

	to
		strValAtt : XML!Attribute (
			parent <- Sequence{strVal.vt_data}->collect(e | thisModule.resolveTemp(e, 'dataElt'))->first(),
			name <- 'ss:Type',
			value <- 'String'
		),
		strValTxt : XML!Text (
			parent <- Sequence{strVal.vt_data}->collect(e | thisModule.resolveTemp(e, 'dataElt'))->first(),
			value <- strVal.value
		)
}


-- Rule 'DataNumberValue'.
-- This rule generates the number value  
-- associated to a ""Data"" element
rule DataNumberValue {
	from 
		numVal: SpreadsheetMLSimplified!NumberValue

	to
		numValAtt : XML!Attribute (
			parent <- Sequence{numVal.vt_data}->collect(e | thisModule.resolveTemp(e, 'dataElt'))->first(),
			name <- 'ss:Type',
			value <- 'Number'
		),
		numValTxt : XML!Text (
			parent <- Sequence{numVal.vt_data}->collect(e | thisModule.resolveTemp(e, 'dataElt'))->first(),
			value <- numVal.value.toString()
		)
}


-- Rule 'DataBooleanValue'.
-- This rule generates the boolean value  
-- associated to a ""Data"" element
rule DataBooleanValue {
	from 
		boolVal: SpreadsheetMLSimplified!BooleanValue

	to
		boolValAtt : XML!Attribute (
			parent <- Sequence{boolVal.vt_data}->collect(e | thisModule.resolveTemp(e, 'dataElt'))->first(),
			name <- 'ss:Type',
			value <- 'Boolean'
		),
		boolValTxt : XML!Text (
			parent <- Sequence{boolVal.vt_data}->collect(e | thisModule.resolveTemp(e, 'dataElt'))->first(),
			value <- boolVal.value.toString()
		)
}


-- Rule 'DataErrorValue'.
-- This rule generates the error value  
-- associated to a ""Data"" element
rule DataErrorValue {
	from 
		errVal: SpreadsheetMLSimplified!ErrorValue

	to
		errValAtt : XML!Attribute (
			parent <- Sequence{errVal.vt_data}->collect(e | thisModule.resolveTemp(e, 'dataElt'))->first(),
			name <- 'ss:Type',
			value <- 'Error'
		)
}


-- Rule 'DataDateTimeValue'.
-- This rule generates the date/time value  
-- associated to a ""Data"" element
rule DataDateTimeValue {
	from 
		dtVal: SpreadsheetMLSimplified!DateTimeTypeValue

	to
		dtValAtt : XML!Attribute (
			parent <- Sequence{dtVal.vt_data}->collect(e | thisModule.resolveTemp(e, 'dataElt'))->first(),
			name <- 'ss:Type',
			value <- 'DateTime'
		),
		dtValTxt : XML!Text (
			parent <- Sequence{dtVal.vt_data}->collect(e | thisModule.resolveTemp(e, 'dataElt'))->first(),
			value <- thisModule.getDateTimeStringValue(dtVal.value)
		)
}",modul spreadsheetmlsimplifi xml modul templat creat out xml in spreadsheetmlsimplifi this helper permit obtain string associ datetimetyp valu context n return string helper def getdatetimestringvalu dtv spreadsheetmlsimplifi datetimetyp string dtv year tostr dtv month tostr dtv day tostr t dtv hour tostr dtv minut tostr dtv second tostr rule documentroot this rule generat root element excel xml file workbook element rule documentroot wb spreadsheetmlsimplifi workbook r xml root name workbook valu children sequenc att att wb wb worksheet collect e thismodul resolvetemp e wselt att xml attribut name xmlns valu urn schema microsoft com offic spreadsheet att xml attribut name xmlns ss valu urn schema microsoft com offic spreadsheet rule worksheet this rule generat differ worksheet element contain workbook element rule worksheet ws spreadsheetmlsimplifi worksheet wselt xml element name worksheet children sequenc nameatt sequenc ws ws tabl collect e thismodul resolvetemp e telt first nameatt xml attribut name ss name valu ws name parent wselt rule worksheett this rule generat tabl element contain worksheet element rule worksheett spreadsheetmlsimplifi tabl telt xml element name tabl children sequenc col collect e thismodul resolvetemp e colelt row collect e thismodul resolvetemp e rowelt rule tablecolumn this rule generat column element contain tabl element rule tablecolumn col spreadsheetmlsimplifi column use widthornot sequenc string let wdh real col width wdh oclisundefin sequenc els sequenc wdh tostr endif colelt xml element name column children sequenc colwidth colwidth distinct xml attribut foreach widthvalu widthornot name ss width valu widthvalu rule tablerow this rule generat row element contain tabl element rule tablerow row spreadsheetmlsimplifi row rowelt xml element name row children sequenc row r cell collect e thismodul resolvetemp e cellelt rule rowcel this rule generat cell element contain row element rule rowcel cell spreadsheetmlsimplifi cell cellelt xml element name cell children sequenc sequenc cell c data collect e thismodul resolvetemp e dataelt first rule celldata this rule generat data element contain cell element rule celldata data spreadsheetmlsimplifi data dataelt xml element name data rule datastringvalu this rule generat string valu associ data element rule datastringvalu strval spreadsheetmlsimplifi stringvalu strvalatt xml attribut parent sequenc strval vt data collect e thismodul resolvetemp e dataelt first name ss type valu string strvaltxt xml text parent sequenc strval vt data collect e thismodul resolvetemp e dataelt first valu strval valu rule datanumbervalu this rule generat number valu associ data element rule datanumbervalu numval spreadsheetmlsimplifi numbervalu numvalatt xml attribut parent sequenc numval vt data collect e thismodul resolvetemp e dataelt first name ss type valu number numvaltxt xml text parent sequenc numval vt data collect e thismodul resolvetemp e dataelt first valu numval valu tostr rule databooleanvalu this rule generat boolean valu associ data element rule databooleanvalu boolval spreadsheetmlsimplifi booleanvalu boolvalatt xml attribut parent sequenc boolval vt data collect e thismodul resolvetemp e dataelt first name ss type valu boolean boolvaltxt xml text parent sequenc boolval vt data collect e thismodul resolvetemp e dataelt first valu boolval valu tostr rule dataerrorvalu this rule generat error valu associ data element rule dataerrorvalu errval spreadsheetmlsimplifi errorvalu errvalatt xml attribut parent sequenc errval vt data collect e thismodul resolvetemp e dataelt first name ss type valu error rule datadatetimevalu this rule generat date time valu associ data element rule datadatetimevalu dtval spreadsheetmlsimplifi datetimetypevalu dtvalatt xml attribut parent sequenc dtval vt data collect e thismodul resolvetemp e dataelt first name ss type valu datetim dtvaltxt xml text parent sequenc dtval vt data collect e thismodul resolvetemp e dataelt first valu thismodul getdatetimestringvalu dtval valu,11
111,111,P55-XML2ExcelText.atl,"query XML2Text = XML!Root.allInstances()
		->asSequence()
		->first().ExcelFile().writeTo('C:\\ ... the path has to be completed ... \\Excel2XML_Extractor\\exampleExcelJavaSource.xml');

helper context XML!Root def: ExcelFile() : String =
	'<?xml version=""1.0""?>'+'\n'+'<?mso-application progid=""Excel.Sheet""?>'+'\n'
	+ self.toString2('');
	

helper context XML!Element def: toString2(indent : String) : String =
	let na : Sequence(XML!Node) =
		self.children->select(e | not e.oclIsKindOf(XML!Attribute)) in
	let a : Sequence(XML!Node) =
		self.children->select(e | e.oclIsKindOf(XML!Attribute)) in
	indent + '<' + self.name + 
	a->iterate(e; acc : String = '' |
		acc + ' ' + e.toString2()
	) +
	if na->size() > 0 then
		'>'
		+ na->iterate(e; acc : String = '' |
			acc + 
			if e.oclIsKindOf(XML!Text) then
				''
			else
				'\r\n'
			endif
			+ e.toString2(indent + '  ')
		) +
		if na->first().oclIsKindOf(XML!Text) then
			'</' + self.name + '>'
			else
				'\r\n' + indent + '</' + self.name + '>'
		endif
	else
		'/>'
	endif;

	
helper context XML!Attribute def: toString2() : String =
	self.name + '=\""' + self.value + '\""';


helper context XML!Text def: toString2() : String =
	self.value;
",queri xml text xml root allinst assequ first excelfil writeto c path complet excel xml extractor exampleexceljavasourc xml helper context xml root def excelfil string xml version n mso applic progid excel sheet n self tostr helper context xml element def tostr indent string string let na sequenc xml node self children select e e ocliskindof xml attribut let sequenc xml node self children select e e ocliskindof xml attribut indent self name iter e acc string acc e tostr na size na iter e acc string acc e ocliskindof xml text els r n endif e tostr indent na first ocliskindof xml text self name els r n indent self name endif els endif helper context xml attribut def tostr string self name self valu helper context xml text def tostr string self valu,5
112,112,P56-XML2SpreadsheetMLSimplified.atl,"module XML2SpreadsheetMLSimplified; -- Module Template
create OUT : SpreadsheetMLSimplified from IN : XML;

-- This helper permits to recover the value of a string attribute thanks to its name.
-- It returns an empty string if the attribute doesn't exist.
-- CONTEXT: XML!Element
-- RETURN: String
helper context XML!Element def: getStringAttrValue(attrName : String) : String =
	let eltC : Sequence(XML!Attribute) = 
		self.children->select(a | a.oclIsTypeOf(XML!Attribute) and a.name = attrName)->asSequence()
	in
		if eltC->notEmpty() 
		then
			eltC->first().value
		else
			''
		endif;


-- This helper permits to recover the element's set of children thanks to their name.
-- CONTEXT: XML!Element
-- RETURN: Set(XML!Element)
helper context XML!Element def: getChildrenByName(name : String) : Set(XML!Element) =
	self.children->select(e | e.oclIsTypeOf(XML!Element) and e.name = name);


-- This helper permits to recover the value of an optional integer attribute
-- if it exists
-- CONTEXT: XML!Element
-- RETURN: Integer
helper context XML!Element def: getOptIntAttrValue(attrName : String) : Integer =
	let val : String = self.getStringAttrValue(attrName)
	in
		if val <> ''
		then
			val.toInteger()
		else
			Integer
		endif;


-- This helper permits to recover the value of an optional boolean attribute
-- if it exists
-- CONTEXT: XML!Element
-- RETURN: Boolean
helper context XML!Element def: getOptBoolAttrValue(attrName : String) : Boolean =
	let val : String = self.getStringAttrValue(attrName)
	in
		if val <> ''
		then
			if val = '0'
			then
					false
			else 
					true
			endif
		else
			Boolean
		endif;


-- This helper permits to recover the value of an optional real attribute
-- if it exists
-- CONTEXT: XML!Element
-- RETURN: Real
helper context XML!Element def: getOptRealAttrValue(attrName : String) : Real =
	let val : String = self.getStringAttrValue(attrName)
	in
		if val <> ''
		then
			val.toReal()
		else
			Real
		endif;


-- This helper permits to recover the value of an optional string attribute
-- if it exists
-- CONTEXT: XML!Element
-- RETURN: String
helper context XML!Element def: getOptStringAttrValue(attrName : String) : String =
	let val : String = self.getStringAttrValue(attrName)
	in
		if val <> ''
		then
			val
		else
			String
		endif;


-- This helper permits to recover the value of a string data.
-- The string have to be sometimes reconstructed.
-- It returns an empty string if the value doesn't exist.
-- CONTEXT: XML!Element
-- RETURN: String
helper context XML!Element def: getStringDataValue() : String =
	let eltC : Sequence(XML!Text) = 
		self.children->select(d | d.oclIsTypeOf(XML!Text))->asSequence()
	in
		if eltC->notEmpty() 
		then
				eltC->iterate(txt; res : String = '' |  
					res.concat(txt.value)
				)
		else
			''
		endif;


-- This helper permits to recover the value of a simple string data.
-- It returns an empty string if the value doesn't exist.
-- CONTEXT: XML!Element
-- RETURN: String
helper context XML!Element def: getSimpleStringDataValue() : String =
	let eltC : Sequence(XML!Text) = 
		self.children->select(d | d.oclIsTypeOf(XML!Text))->asSequence()
	in
		if eltC->notEmpty() 
		then
			eltC->first().value
		else
			''
		endif;


-- This helper permits to recover the value of a number data.
-- It returns 0.0 if the value doesn't exist.
-- CONTEXT: XML!Element
-- RETURN: Real
helper context XML!Element def: getNumberDataValue() : Real =
	let val : String = self.getSimpleStringDataValue()
	in
		if val <> ''
		then
			val.toReal()
		else
			0.0
		endif;


-- This helper permits to recover the value of a boolean data.
-- It returns false if the value doesn't exist.
-- CONTEXT: XML!Element
-- RETURN: Boolean
helper context XML!Element def: getBooleanDataValue() : Boolean =
	let val : String = self.getSimpleStringDataValue()
	in
		if val <> ''
		then
			if val = '0'
			then
				false
			else
				true
			endif
		else
			false
		endif;



-- Rule 'Workbook'
-- This rule generates the workbook which is the 
-- root container of a SpreadsheetML document
rule Workbook {
	from
		rw : XML!Root (
			rw.name = 'Workbook'
		)
	
	to
		wb : SpreadsheetMLSimplified!Workbook (
			wb_worksheets <- Sequence{rw.getChildrenByName('Worksheet')->collect(e | thisModule.resolveTemp(e, 'ws'))}
		)	
}


-- Rule 'Worksheet'
-- This rule generates the worksheets that are contained
-- in a workbook.
rule Worksheet {
	from
		ew : XML!Element (
			ew.name = 'Worksheet'
		)
	
	to
		ws : SpreadsheetMLSimplified!Worksheet (
			name <- ew.getStringAttrValue('ss:Name'),
			ws_table <- Sequence{ew.getChildrenByName('Table')->first()}->collect(e | thisModule.resolveTemp(e, 'tab'))->first()
		)	
}


-- Rule 'Table'
-- This rule generates the table for a worksheet.
-- It's the table which contains the columns and rows.
rule Table {
	from
		et : XML!Element (
			et.name = 'Table'
		)
	
	to
		tab : SpreadsheetMLSimplified!Table (
			t_cols <- Sequence{et.getChildrenByName('Column')->collect(e | thisModule.resolveTemp(e, 'col'))},
			t_rows <- Sequence{et.getChildrenByName('Row')->collect(e | thisModule.resolveTemp(e, 'row'))}
		)	
}


-- Rule 'Column'
-- This rule generates the columns contained in a table.
-- They don't store the data but they give some specific information about columns format.
rule Column {
	from
		ec : XML!Element (
			ec.name = 'Column'
		)
	
	to
		col : SpreadsheetMLSimplified!Column (
			index <- ec.getOptIntAttrValue('ss:Index'),	
			hidden <- ec.getOptBoolAttrValue('ss:Hidden'),
			span <- ec.getOptIntAttrValue('ss:Span'),
			autoFitWidth <- ec.getOptBoolAttrValue('ss:AutoFitWidth'),
			width <- ec.getOptRealAttrValue('ss:Width')
		)	
}


-- Rule 'Row'
-- This rule generates the rows contained in a table.
-- They store the data (in the cells) and give some specific information about rows format.
rule Row {
	from
		er : XML!Element (
			er.name = 'Row'
		)
	
	to
		row : SpreadsheetMLSimplified!Row (
			r_cells <- Sequence{er.getChildrenByName('Cell')->collect(e | thisModule.resolveTemp(e, 'cell'))},
			index <- er.getOptIntAttrValue('ss:Index'),	
			hidden <- er.getOptBoolAttrValue('ss:Hidden'),
			span <- er.getOptIntAttrValue('ss:Span'),
			autoFitHeight <- er.getOptBoolAttrValue('ss:AutoFitHeight'),
			height <- er.getOptRealAttrValue('ss:Height')
		)	
}


-- Rule 'Cell'
-- This rule generates the cells of the table.
-- They are contained in the rows and they store the data.
rule Cell {
	from
		ece : XML!Element (
			ece.name = 'Cell'
		)
	
	to
		cell : SpreadsheetMLSimplified!Cell (
			index <- ece.getOptIntAttrValue('ss:Index'),
			arrayRange <- ece.getOptStringAttrValue('ss:ArrayRange'),
			formula <- ece.getOptStringAttrValue('ss:Formula'),
			hRef <- ece.getOptStringAttrValue('ss:Href'),
			mergeAcross <- ece.getOptRealAttrValue('ss:Href'),
			mergeDown <- ece.getOptRealAttrValue('ss:Href')	
		)	
}


-- Rule 'StringData'
-- This rule generates the string data of the table.
-- They are contained in the cells.
rule StringData {
	from
		esd : XML!Element (
			esd.name = 'Data' and esd.getStringAttrValue('ss:Type')='String'
		)
	
	to
		sdata : SpreadsheetMLSimplified!Data (
			d_cell <- Sequence{esd.parent}->collect(e | thisModule.resolveTemp(e, 'cell'))->first(),
			value <- sv
		),		
		sv : SpreadsheetMLSimplified!StringValue (
			value <- esd.getStringDataValue()
		)
}

-- Rule 'NumberData'
-- This rule generates the number data of the table.
-- They are contained in the cells.
rule NumberData {
	from
		end : XML!Element (
			end.name = 'Data' and end.getStringAttrValue('ss:Type')='Number'
		)
	
	to
		ndata : SpreadsheetMLSimplified!Data (
			d_cell <- Sequence{end.parent}->collect(e | thisModule.resolveTemp(e, 'cell'))->first(),
			value <- nv
		),		
		nv : SpreadsheetMLSimplified!NumberValue (
			value <- end.getNumberDataValue()
		)
}

-- Rule 'BooleanData'
-- This rule generates the boolean data of the table.
-- They are contained in the cells.
rule BooleanData {
	from
		ebd : XML!Element (
			ebd.name = 'Data' and ebd.getStringAttrValue('ss:Type')='Boolean'
		)
	
	to
		bdata : SpreadsheetMLSimplified!Data (
			d_cell <- Sequence{ebd.parent}->collect(e | thisModule.resolveTemp(e, 'cell'))->first(),
			value <- bv
		),		
		bv : SpreadsheetMLSimplified!BooleanValue (
			value <- ebd.getBooleanDataValue()
		)
}

-- Rule 'DateTimeData'
-- This rule generates the ""DateTime"" data of the table.
-- They are contained in the cells.
rule DateTimeData {
	from
		edtd : XML!Element (
			edtd.name = 'Data' and edtd.getStringAttrValue('ss:Type')='DateTime'
		)
		
	using {
		dateTimeString : String = edtd.getSimpleStringDataValue();
	}
	
	to
		dtdata : SpreadsheetMLSimplified!Data (
			d_cell <- Sequence{edtd.parent}->collect(e | thisModule.resolveTemp(e, 'cell'))->first(),
			value <- dttv
		),		
		dttv : SpreadsheetMLSimplified!DateTimeTypeValue (
			value <- dt
		),
		-- The format for date/time fields in Excel is : yyyy-mm-ddThh:mm:ssZ
		dt : SpreadsheetMLSimplified!DateTimeType (
			year <-	dateTimeString.substring(1,4).toInteger(),
			month <- dateTimeString.substring(6,7).toInteger(),
			day <- dateTimeString.substring(9,10).toInteger(),
			hour <- dateTimeString.substring(12,13).toInteger(),
			minute <- dateTimeString.substring(15,16).toInteger(),
			second <- dateTimeString.substring(18,19).toInteger()
		)
}

-- Rule 'ErrorData'
-- This rule generates the ""error"" data of the table.
-- They are contained in the cells.
rule ErrorData {
	from
		eed : XML!Element (
			eed.name = 'Data' and eed.getStringAttrValue('ss:Type')='Error'
		)
	
	to
		edata : SpreadsheetMLSimplified!Data (
			d_cell <- Sequence{eed.parent}->collect(e | thisModule.resolveTemp(e, 'cell'))->first(),
			value <- ev
		),		
		ev : SpreadsheetMLSimplified!ErrorValue ()
}

",modul xml spreadsheetmlsimplifi modul templat creat out spreadsheetmlsimplifi in xml this helper permit recov valu string attribut thank name it return empti string attribut exist context xml element return string helper context xml element def getstringattrvalu attrnam string string let eltc sequenc xml attribut self children select oclistypeof xml attribut name attrnam assequ eltc notempti eltc first valu els endif this helper permit recov element set children thank name context xml element return set xml element helper context xml element def getchildrenbynam name string set xml element self children select e e oclistypeof xml element e name name this helper permit recov valu option integ attribut exist context xml element return integ helper context xml element def getoptintattrvalu attrnam string integ let val string self getstringattrvalu attrnam val val tointeg els integ endif this helper permit recov valu option boolean attribut exist context xml element return boolean helper context xml element def getoptboolattrvalu attrnam string boolean let val string self getstringattrvalu attrnam val val fals els true endif els boolean endif this helper permit recov valu option real attribut exist context xml element return real helper context xml element def getoptrealattrvalu attrnam string real let val string self getstringattrvalu attrnam val val toreal els real endif this helper permit recov valu option string attribut exist context xml element return string helper context xml element def getoptstringattrvalu attrnam string string let val string self getstringattrvalu attrnam val val els string endif this helper permit recov valu string data the string sometim reconstruct it return empti string valu exist context xml element return string helper context xml element def getstringdatavalu string let eltc sequenc xml text self children select oclistypeof xml text assequ eltc notempti eltc iter txt res string res concat txt valu els endif this helper permit recov valu simpl string data it return empti string valu exist context xml element return string helper context xml element def getsimplestringdatavalu string let eltc sequenc xml text self children select oclistypeof xml text assequ eltc notempti eltc first valu els endif this helper permit recov valu number data it return valu exist context xml element return real helper context xml element def getnumberdatavalu real let val string self getsimplestringdatavalu val val toreal els endif this helper permit recov valu boolean data it return fals valu exist context xml element return boolean helper context xml element def getbooleandatavalu boolean let val string self getsimplestringdatavalu val val fals els true endif els fals endif rule workbook this rule generat workbook root contain spreadsheetml document rule workbook rw xml root rw name workbook wb spreadsheetmlsimplifi workbook wb worksheet sequenc rw getchildrenbynam worksheet collect e thismodul resolvetemp e ws rule worksheet this rule generat worksheet contain workbook rule worksheet ew xml element ew name worksheet ws spreadsheetmlsimplifi worksheet name ew getstringattrvalu ss name ws tabl sequenc ew getchildrenbynam tabl first collect e thismodul resolvetemp e tab first rule tabl this rule generat tabl worksheet it tabl contain column row rule tabl et xml element et name tabl tab spreadsheetmlsimplifi tabl col sequenc et getchildrenbynam column collect e thismodul resolvetemp e col row sequenc et getchildrenbynam row collect e thismodul resolvetemp e row rule column this rule generat column contain tabl they store data give specif inform column format rule column ec xml element ec name column col spreadsheetmlsimplifi column index ec getoptintattrvalu ss index hidden ec getoptboolattrvalu ss hidden span ec getoptintattrvalu ss span autofitwidth ec getoptboolattrvalu ss autofitwidth width ec getoptrealattrvalu ss width rule row this rule generat row contain tabl they store data cell give specif inform row format rule row er xml element er name row row spreadsheetmlsimplifi row r cell sequenc er getchildrenbynam cell collect e thismodul resolvetemp e cell index er getoptintattrvalu ss index hidden er getoptboolattrvalu ss hidden span er getoptintattrvalu ss span autofitheight er getoptboolattrvalu ss autofitheight height er getoptrealattrvalu ss height rule cell this rule generat cell tabl they contain row store data rule cell ece xml element ece name cell cell spreadsheetmlsimplifi cell index ece getoptintattrvalu ss index arrayrang ece getoptstringattrvalu ss arrayrang formula ece getoptstringattrvalu ss formula href ece getoptstringattrvalu ss href mergeacross ece getoptrealattrvalu ss href mergedown ece getoptrealattrvalu ss href rule stringdata this rule generat string data tabl they contain cell rule stringdata esd xml element esd name data esd getstringattrvalu ss type string sdata spreadsheetmlsimplifi data cell sequenc esd parent collect e thismodul resolvetemp e cell first valu sv sv spreadsheetmlsimplifi stringvalu valu esd getstringdatavalu rule numberdata this rule generat number data tabl they contain cell rule numberdata end xml element end name data end getstringattrvalu ss type number ndata spreadsheetmlsimplifi data cell sequenc end parent collect e thismodul resolvetemp e cell first valu nv nv spreadsheetmlsimplifi numbervalu valu end getnumberdatavalu rule booleandata this rule generat boolean data tabl they contain cell rule booleandata ebd xml element ebd name data ebd getstringattrvalu ss type boolean bdata spreadsheetmlsimplifi data cell sequenc ebd parent collect e thismodul resolvetemp e cell first valu bv bv spreadsheetmlsimplifi booleanvalu valu ebd getbooleandatavalu rule datetimedata this rule generat datetim data tabl they contain cell rule datetimedata edtd xml element edtd name data edtd getstringattrvalu ss type datetim use datetimestr string edtd getsimplestringdatavalu dtdata spreadsheetmlsimplifi data cell sequenc edtd parent collect e thismodul resolvetemp e cell first valu dttv dttv spreadsheetmlsimplifi datetimetypevalu valu dt the format date time field excel yyyi mm ddthh mm ssz dt spreadsheetmlsimplifi datetimetyp year datetimestr substr tointeg month datetimestr substr tointeg day datetimestr substr tointeg hour datetimestr substr tointeg minut datetimestr substr tointeg second datetimestr substr tointeg rule errordata this rule generat error data tabl they contain cell rule errordata eed xml element eed name data eed getstringattrvalu ss type error edata spreadsheetmlsimplifi data cell sequenc eed parent collect e thismodul resolvetemp e cell first valu ev ev spreadsheetmlsimplifi errorvalu,11
113,113,P57-HTML2XML.atl,"--@atlcompiler	atl2006
--@name			HTML2XML
--@version		2.0
--@domains		HTML, Table
--@authors		Eric Vepa (evepa <at> sodius.com) for SODIUS (www.sodius.com)
--@date			2007/05/28
--@description	HTML extractor for a subset of the HTML metamodel (table representation).

module HTML2XML; -- Module Template
create OUT : XML from IN : HTML;

--@begin rule HTML
rule HTML {
	from
		html : HTML!HTML
	to
		xml : XML!Root (
			name <- 'html',
			children <- html.head,
			children <- html.body
		)
}	
--@end rule HTML

--@begin rule HTMLElement
rule HTMLElement {
	from
		html : HTML!HTMLElement
	to
		xml : XML!Element (
			children <-  html.children
		)
}	
--@end rule HTMLElement

--@begin rule HEAD
rule HEAD extends HTMLElement {
	from
		html : HTML!HEAD
	to
		xml : XML!Element (
			name <- 'head',
			children <- html.headElements
		)
}	
--@end rule HEAD

--@begin abstract rule HEADElement
abstract rule HEADElement extends HTMLElement {
	from
		html : HTML!HEADElement
	to
		xml : XML!Element
}	
--@end abstract rule HEADElement

--@begin rule TITLE
rule TITLE extends HEADElement {
	from
		html : HTML!TITLE
	to
		xml : XML!Element (
			name <- 'title',
			children <- thisModule.Text(html.value)
		)
}	
--@end rule TITLE

--@begin rule BODY
rule BODY extends HTMLElement {
	from
		html : HTML!BODY
	to
		xml : XML!Element (
			name <- 'body',
			children <- html.bodyElements
		)
}	
--@end rule BODY

--@begin abstract rule BODYElement
abstract rule BODYElement extends HTMLElement {
	from
		html : HTML!BODYElement
	to
		xml : XML!Element
}	
--@end abstract rule BODYElement

--@begin abstract rule TABLEElement
abstract rule TABLEElement extends BODYElement {
	from
		html : HTML!TABLEElement
	to
		xml : XML!Element
}	
--@end abstract rule TABLEElement

--@begin rule TABLE
rule TABLE extends TABLEElement {
	from
		html : HTML!TABLE
	to
		xml : XML!Element (
			name <- 'table',
			children <- thisModule.Attribute('border',
				if not html.border.oclIsUndefined()
					then html.border
					else '0'
				endif),
			children <- html.trs
		)
}	
--@end rule TABLE

--@begin rule TR
rule TR extends TABLEElement {
	from
		html : HTML!TR
	to
		xml : XML!Element (
			name <- 'tr',
			children <- html.tds
		)
}	
--@end rule TR

--@begin rule TD
rule TD extends TABLEElement {
	from
		html : HTML!TD
	to
		xml : XML!Element (
			name <- 'td',
			children <- thisModule.Text(html.value)
		)
	do {
		if (not html.align.oclIsUndefined()) {
			xml.children <- thisModule.Attribute('align', html.align);
		}
	}
}	
--@end rule TD

--@begin rule TH
rule TH extends TD {
	from
		html : HTML!TH
	to
		xml : XML!Element (
			name <- 'th'
		)
}	
--@end rule TH

--@begin called rule Attribute
rule Attribute(attrName : String, attrValue : String) {
	to
		attr : XML!Attribute (
			name <- attrName,
			value <- attrValue
		)
	do {
		attr;
	}
}	
--@end called rule Attribute

--@begin called rule Text
rule Text(value : String) {
	to
		text : XML!Text (
			value <-
				if not value.oclIsUndefined()
					then value
					else ''
				endif
		)
	do {
		text;
	}
}	
--@end called rule Text",atlcompil atl name html xml version domain html tabl author eric vepa evepa sodius com sodius www sodius com date descript html extractor subset html metamodel tabl represent modul html xml modul templat creat out xml in html begin rule html rule html html html html xml xml root name html children html head children html bodi end rule html begin rule htmlelement rule htmlelement html html htmlelement xml xml element children html children end rule htmlelement begin rule head rule head extend htmlelement html html head xml xml element name head children html headel end rule head begin abstract rule headel abstract rule headel extend htmlelement html html headel xml xml element end abstract rule headel begin rule titl rule titl extend headel html html titl xml xml element name titl children thismodul text html valu end rule titl begin rule bodi rule bodi extend htmlelement html html bodi xml xml element name bodi children html bodyel end rule bodi begin abstract rule bodyel abstract rule bodyel extend htmlelement html html bodyel xml xml element end abstract rule bodyel begin abstract rule tableel abstract rule tableel extend bodyel html html tableel xml xml element end abstract rule tableel begin rule tabl rule tabl extend tableel html html tabl xml xml element name tabl children thismodul attribut border html border oclisundefin html border els endif children html trs end rule tabl begin rule tr rule tr extend tableel html html tr xml xml element name tr children html tds end rule tr begin rule td rule td extend tableel html html td xml xml element name td children thismodul text html valu html align oclisundefin xml children thismodul attribut align html align end rule td begin rule th rule th extend td html html th xml xml element name th end rule th begin call rule attribut rule attribut attrnam string attrvalu string attr xml attribut name attrnam valu attrvalu attr end call rule attribut begin call rule text rule text valu string text xml text valu valu oclisundefin valu els endif text end call rule text,9
114,114,P57-KM32Measure.atl,"--@atlcompiler	atl2006
--@name			KM32Measure
--@version		2.1
--@domains		KM3, measurement data, metrics
--@authors		Eric Vepa (evepa <at> sodius.com) for SODIUS (www.sodius.com)
--@date			2007/08/02
--@description	This transformation is used to collect measurement data on a KM3 metamodel, using libraries implementing some metrics (MOOD, MOOD2, MOOSE, EMOOSE  and QMOOD).
--@see			Baroni, A.L.: Formal Definition of Object-Oriented Design Metrics. Master Thesis, Vrije University, Brussel, Belgium, 2002.

module KM32Measure; -- Module Template
create OUT : Measure from IN : KM3;

uses FLAME4KM3;
uses MOOD4KM3;
uses EMOOSE4KM3;
uses QMOOD4KM3;

--@begin attribute helpers measureLevel
--@comments Defines the measure level among {#package,#class}. 
--@comments The package level allows measures on packages.
--@comments The class level allows measures on packages and classes.
helper def : measureLevel : Measure!ElementKind = #class;
--@end attribute helper measureLevel

--@begin attribute helper root
--@comments The root measure set.
helper def : root : Measure!RootMeasureSet = OclUndefined;
--@end attribute helper root

--@begin attribute helper MetricByName
--@comments The map of metrics by name.
helper def : MetricByName : Map(String, Measure!Metric) = Map{};
--@end attribute helper MetricByName

--@begin entrypoint rule Metrics
--@comments Registers the MOOD, MOOD2, MOOSE, EMOOSE and QMOOD metrics implemented in libraries.
entrypoint rule Metrics() {
	to
		root : Measure!RootMeasureSet (
			modelType <- #KM3
		)
	do {
		thisModule.root <- root;
		
		if ((thisModule.measureLevel = #package) or
			(thisModule.measureLevel = #class)) {
			-- ==================================================
			-- MOOD Metrics : Intra-Specification Level Metrics =
			-- ==================================================
			root.categories <-
				thisModule.Category('MOOD','Metrics for Object-Oriented Design');
			thisModule.Metric('MOOD','AIF','Attributes Inheritance Factor');
			thisModule.Metric('MOOD','RIF','References Inheritance Factor');
			thisModule.Metric('MOOD','CCF','Class Coupling Factor');
			thisModule.Metric('MOOD','ICF','Internal Coupling Factor');
				
			-- ===================================================
			-- MOOD2 Metrics : Intra-Specification Level Metrics =
			-- ===================================================
			root.categories <-
				thisModule.Category('MOOD2',
					'Metrics for Object-Oriented Design 2');
			thisModule.Metric('MOOD2','IIF','Internal Inheritance Factor');
		}
		
		if (thisModule.measureLevel = #class) {
			-- ===============
			-- MOOSE Metrics =
			-- ===============
			root.categories <-
				thisModule.Category('MOOSE',
				'Metrics for Object-Oriented Software Engineering');
			thisModule.Metric('MOOSE','WRC','Weighted References per Class');
			thisModule.Metric('MOOSE','DIT','Depth of Inheritance Tree');
			thisModule.Metric('MOOSE','NOC','Number of Children');
			thisModule.Metric('MOOSE','CBO','Coupling Between Objects');
		
			-- ================
			-- EMOOSE Metrics =
			-- ================
			root.categories <-
				thisModule.Category('EMOOSE','Extended MOOSE');
			thisModule.Metric('EMOOSE','SIZE2','Number of local Attributes ' +
				'and References defined in the Class');
		}
		
		if ((thisModule.measureLevel = #package) or
			(thisModule.measureLevel = #class)) {
			-- ===============
			-- QMOOD Metrics =
			-- ===============
			root.categories <-
				thisModule.Category('QMOOD',
				'Quality Model for Object-Oriented Design');		
			thisModule.Metric('QMOOD','DSC','Design Size in Classes');
			thisModule.Metric('QMOOD','NOH','Number of Hierarchies');
			thisModule.Metric('QMOOD','NIC','Number of Independent Classes');
			thisModule.Metric('QMOOD','NSI','Number of Single Inheritance');
			thisModule.Metric('QMOOD','NMI','Number of Multiple Inheritance');
			thisModule.Metric('QMOOD','NNC','Number of Internal Classes');
			thisModule.Metric('QMOOD','NAC','Number of Abstract Classes');
			thisModule.Metric('QMOOD','NLC','Number of Leaf Classes');
			thisModule.Metric('QMOOD','ADI','Average Depth of Inheritance');
			thisModule.Metric('QMOOD','AWI','Average Width of Inheritance');
			thisModule.Metric('QMOOD','ANA','Average Number of Ancestors');
		}
			
		if (thisModule.measureLevel = #class) {			
			thisModule.Metric('QMOOD','MAA','Measure of Attribute Abstraction');
			thisModule.Metric('QMOOD','MRA','Measure of Reference Abstraction');
			thisModule.Metric('QMOOD','MOA','Measure of Aggregation');
			thisModule.Metric('QMOOD','MRM','Modeled Relationship Measure');
			thisModule.Metric('QMOOD','NOA','Number of Ancestors');
			thisModule.Metric('QMOOD','NOR','Number of References');
			thisModule.Metric('QMOOD','NOD','Number of Attributes');
			thisModule.Metric('QMOOD','NAD','Number of Abstract Data Types');
			thisModule.Metric('QMOOD','CSM','Class Size Metric');
			thisModule.Metric('QMOOD','DCC','Direct Class Coupling');
			thisModule.Metric('QMOOD','MCC','Maximum Class Coupling');
			thisModule.Metric('QMOOD','DAC','Direct Attribute Based Coupling');
			thisModule.Metric('QMOOD','DRC','Direct Reference Based Coupling');
			thisModule.Metric('QMOOD','CCD','Class Complexity Based on Data');
		}
	}
}
--@end entrypoint rule Metrics

--@begin rule Package2MeasureSet
--@comments Collects measurement data on a package (measureLevel must be set to #package or #class).
rule Package2MeasureSet {
	from
		ne : KM3!Package (
			(thisModule.measureLevel = #package) or
			(thisModule.measureLevel = #class)
		)
	to
		ms : Measure!MeasureSet (
			elementName <-
				if ne.CN() > 0
					then ne.name.debug('Processing metrics on package')
					else ne.name
				endif,
	   		elementType <- #package,
			subsets <- ne.contents
		)
	do {
		if (ne.package.oclIsUndefined()) {
			thisModule.root.measureSets <- ms;
		}
		
		if (ne.CN() > 0) {
			-- ==================================================
			-- MOOD Metrics : Intra-Specification Level Metrics =
			-- ==================================================
			ms.measures <- thisModule.PercentageMeasure('AIF',ne.AIF());
			ms.measures <- thisModule.PercentageMeasure('RIF',ne.RIF());
			ms.measures <- thisModule.PercentageMeasure('CCF',ne.CCF());
			ms.measures <- thisModule.PercentageMeasure('ICF',ne.ICF());
				
			-- =============================================================
			-- MOOD2 Metrics : Intra and Inter-Specification Level Metrics =
			-- =============================================================
			ms.measures <- thisModule.PercentageMeasure('IIF',ne.IIF());
		
			-- ===============
			-- QMOOD Metrics =
			-- ===============
			ms.measures <- thisModule.IntegerMeasure('DSC',ne.DSC());
			ms.measures <- thisModule.IntegerMeasure('NOH',ne.NOH());
			ms.measures <- thisModule.IntegerMeasure('NIC',ne.NIC());
			ms.measures <- thisModule.IntegerMeasure('NSI',ne.NSI());
			ms.measures <- thisModule.IntegerMeasure('NMI',ne.NMI());
			ms.measures <- thisModule.IntegerMeasure('NNC',ne.NNC());
			ms.measures <- thisModule.IntegerMeasure('NAC',ne.NAC());
			ms.measures <- thisModule.IntegerMeasure('NLC',ne.NLC());
			ms.measures <- thisModule.DoubleMeasure('ADI',ne.ADI());
			ms.measures <- thisModule.DoubleMeasure('AWI',ne.AWI());
			ms.measures <- thisModule.DoubleMeasure('ANA',ne.ANA());
		}
	}
}
--@end rule Package2MeasureSet

--@begin rule Class2MeasureSet
--@comments Collects measurement data on a class (measureLevel must be set to #class).
rule Class2MeasureSet {
	from
		ne : KM3!Class (
			thisModule.measureLevel = #class
		)
	to
		ms : Measure!MeasureSet (
			elementName <- ne.name.debug('Processing metrics on class'),
	   		elementType <- #class
		)
	do {
		-- ===============
		-- MOOSE Metrics =
		-- ===============
		ms.measures <- thisModule.IntegerMeasure('WRC',ne.WRC());
		ms.measures <- thisModule.IntegerMeasure('DIT',ne.DIT());
		ms.measures <- thisModule.IntegerMeasure('NOC',ne.NOC());
		ms.measures <- thisModule.IntegerMeasure('CBO',ne.CBO());
	
		-- ================
		-- EMOOSE Metrics =
		-- ================
		ms.measures <- thisModule.IntegerMeasure('SIZE2',ne.SIZE2());
	
		-- ===============
		-- QMOOD Metrics =
		-- ===============
		ms.measures <- thisModule.PercentageMeasure('MAA',ne.MAA());
		ms.measures <- thisModule.PercentageMeasure('MRA',ne.MRA());
		ms.measures <- thisModule.IntegerMeasure('MOA',ne.MOA());
		ms.measures <- thisModule.IntegerMeasure('MRM',ne.MRM());
		ms.measures <- thisModule.IntegerMeasure('NOA',ne.NOA());
		ms.measures <- thisModule.IntegerMeasure('NOR',ne.NOR());
		ms.measures <- thisModule.IntegerMeasure('NOD',ne.NOD());
		ms.measures <- thisModule.IntegerMeasure('NAD',ne.NAD());
		ms.measures <- thisModule.IntegerMeasure('CSM',ne.CSM());
		ms.measures <- thisModule.IntegerMeasure('DCC',ne.DCC());
		ms.measures <- thisModule.IntegerMeasure('MCC',ne.MCC());
		ms.measures <- thisModule.IntegerMeasure('DAC',ne.DAC());
		ms.measures <- thisModule.IntegerMeasure('DRC',ne.DRC());
		ms.measures <- thisModule.IntegerMeasure('CCD',ne.CCD());
	}
}
--@end rule Class2MeasureSet
		
--@begin called rule Category
--@comments Creates a category for metric classification with a name and a description.
rule Category(name : String, desc : String) {
	to
		cat : Measure!Category (
			name <- name,
			desc <- desc
		)
	do {
		cat;
	}
}
--@end called rule Category
		
--@begin called rule Metric
--@comments Creates a metric for a category with a name and a description (the default preferred value for the metric is set to not equal to zero ['!=0']).
rule Metric(catName : String, name : String, desc : String) {
	to
		metric : Measure!Metric (
			name <- name,
			desc <- desc,
			preferredValue <- '!=0',
			category <- thisModule.root.categories->
				select(cat|cat.name = catName)->first()
		)
	do {
		thisModule.MetricByName <-
			thisModule.MetricByName.including(metric.name,metric);
	}
}
--@end called rule Metric
		
--@begin called rule MetricWithPreferredValue
--@comments Creates a metric for a category with a name, a description and a preferred value for the metric (an operator [<, <=, =, !=, >=, >] followed by a number).
rule MetricWithPreferredValue(catName : String, name : String, desc : String, preferredValue : String) {
	to
		metric : Measure!Metric (
			name <- name,
			desc <- desc,
			preferredValue <- preferredValue,
			category <- thisModule.root.categories->
				select(cat|cat.name = catName)->first()
		)
	do {
		thisModule.MetricByName <-
			thisModule.MetricByName.including(metric.name,metric);
	}
}
--@end called rule MetricWithPreferredValue
		
--@begin called rule IntegerMeasure
--@comments Stores an Integer measure for the metric which name and value are given.
rule IntegerMeasure(name : String, value : Integer) {
	to
		meas : Measure!IntegerMeasure (
			metric <- thisModule.MetricByName.get(name),
			value <- value
		)
	do {
		meas;
	}
}
--@end called rule IntegerMeasure
		
--@begin called rule DoubleMeasure
--@comments Stores a Double measure for the metric which name and value are given.
rule DoubleMeasure(name : String, value : Real) {
	to
		meas : Measure!DoubleMeasure (
			metric <- thisModule.MetricByName.get(name),
			value <- value
		)
	do {
		meas;
	}
}
--@end called rule DoubleMeasure
		
--@begin called rule PercentageMeasure
--@comments Stores a Percentage measure for the metric which name and value are given.
rule PercentageMeasure(name : String, value : Real) {
	to
		meas : Measure!PercentageMeasure (
			metric <- thisModule.MetricByName.get(name),
			value <- value
		)
	do {
		meas;
	}
}
--@end called rule PercentageMeasure",atlcompil atl name km measur version domain km measur data metric author eric vepa evepa sodius com sodius www sodius com date descript this transform use collect measur data km metamodel use librari implement metric mood mood moos emoos qmood see baroni a l formal definit object orient design metric master thesi vrije univers brussel belgium modul km measur modul templat creat out measur in km use flame km use mood km use emoos km use qmood km begin attribut helper measurelevel comment defin measur level among packag class comment the packag level allow measur packag comment the class level allow measur packag class helper def measurelevel measur elementkind class end attribut helper measurelevel begin attribut helper root comment the root measur set helper def root measur rootmeasureset oclundefin end attribut helper root begin attribut helper metricbynam comment the map metric name helper def metricbynam map string measur metric map end attribut helper metricbynam begin entrypoint rule metric comment regist mood mood moos emoos qmood metric implement librari entrypoint rule metric root measur rootmeasureset modeltyp km thismodul root root thismodul measurelevel packag thismodul measurelevel class mood metric intra specif level metric root categori thismodul categori mood metric object orient design thismodul metric mood aif attribut inherit factor thismodul metric mood rif refer inherit factor thismodul metric mood ccf class coupl factor thismodul metric mood icf intern coupl factor mood metric intra specif level metric root categori thismodul categori mood metric object orient design thismodul metric mood iif intern inherit factor thismodul measurelevel class moos metric root categori thismodul categori moos metric object orient softwar engin thismodul metric moos wrc weight refer per class thismodul metric moos dit depth inherit tree thismodul metric moos noc number children thismodul metric moos cbo coupl between object emoos metric root categori thismodul categori emoos extend moos thismodul metric emoos size number local attribut refer defin class thismodul measurelevel packag thismodul measurelevel class qmood metric root categori thismodul categori qmood qualiti model object orient design thismodul metric qmood dsc design size class thismodul metric qmood noh number hierarchi thismodul metric qmood nic number independ class thismodul metric qmood nsi number singl inherit thismodul metric qmood nmi number multipl inherit thismodul metric qmood nnc number intern class thismodul metric qmood nac number abstract class thismodul metric qmood nlc number leaf class thismodul metric qmood adi averag depth inherit thismodul metric qmood awi averag width inherit thismodul metric qmood ana averag number ancestor thismodul measurelevel class thismodul metric qmood maa measur attribut abstract thismodul metric qmood mra measur refer abstract thismodul metric qmood moa measur aggreg thismodul metric qmood mrm model relationship measur thismodul metric qmood noa number ancestor thismodul metric qmood nor number refer thismodul metric qmood nod number attribut thismodul metric qmood nad number abstract data type thismodul metric qmood csm class size metric thismodul metric qmood dcc direct class coupl thismodul metric qmood mcc maximum class coupl thismodul metric qmood dac direct attribut base coupl thismodul metric qmood drc direct refer base coupl thismodul metric qmood ccd class complex base data end entrypoint rule metric begin rule packag measureset comment collect measur data packag measurelevel must set packag class rule packag measureset ne km packag thismodul measurelevel packag thismodul measurelevel class ms measur measureset elementnam ne cn ne name debug process metric packag els ne name endif elementtyp packag subset ne content ne packag oclisundefin thismodul root measureset ms ne cn mood metric intra specif level metric ms measur thismodul percentagemeasur aif ne aif ms measur thismodul percentagemeasur rif ne rif ms measur thismodul percentagemeasur ccf ne ccf ms measur thismodul percentagemeasur icf ne icf mood metric intra inter specif level metric ms measur thismodul percentagemeasur iif ne iif qmood metric ms measur thismodul integermeasur dsc ne dsc ms measur thismodul integermeasur noh ne noh ms measur thismodul integermeasur nic ne nic ms measur thismodul integermeasur nsi ne nsi ms measur thismodul integermeasur nmi ne nmi ms measur thismodul integermeasur nnc ne nnc ms measur thismodul integermeasur nac ne nac ms measur thismodul integermeasur nlc ne nlc ms measur thismodul doublemeasur adi ne adi ms measur thismodul doublemeasur awi ne awi ms measur thismodul doublemeasur ana ne ana end rule packag measureset begin rule class measureset comment collect measur data class measurelevel must set class rule class measureset ne km class thismodul measurelevel class ms measur measureset elementnam ne name debug process metric class elementtyp class moos metric ms measur thismodul integermeasur wrc ne wrc ms measur thismodul integermeasur dit ne dit ms measur thismodul integermeasur noc ne noc ms measur thismodul integermeasur cbo ne cbo emoos metric ms measur thismodul integermeasur size ne size qmood metric ms measur thismodul percentagemeasur maa ne maa ms measur thismodul percentagemeasur mra ne mra ms measur thismodul integermeasur moa ne moa ms measur thismodul integermeasur mrm ne mrm ms measur thismodul integermeasur noa ne noa ms measur thismodul integermeasur nor ne nor ms measur thismodul integermeasur nod ne nod ms measur thismodul integermeasur nad ne nad ms measur thismodul integermeasur csm ne csm ms measur thismodul integermeasur dcc ne dcc ms measur thismodul integermeasur mcc ne mcc ms measur thismodul integermeasur dac ne dac ms measur thismodul integermeasur drc ne drc ms measur thismodul integermeasur ccd ne ccd end rule class measureset begin call rule categori comment creat categori metric classif name descript rule categori name string desc string cat measur categori name name desc desc cat end call rule categori begin call rule metric comment creat metric categori name descript default prefer valu metric set equal zero rule metric catnam string name string desc string metric measur metric name name desc desc preferredvalu categori thismodul root categori select cat cat name catnam first thismodul metricbynam thismodul metricbynam includ metric name metric end call rule metric begin call rule metricwithpreferredvalu comment creat metric categori name descript prefer valu metric oper follow number rule metricwithpreferredvalu catnam string name string desc string preferredvalu string metric measur metric name name desc desc preferredvalu preferredvalu categori thismodul root categori select cat cat name catnam first thismodul metricbynam thismodul metricbynam includ metric name metric end call rule metricwithpreferredvalu begin call rule integermeasur comment store integ measur metric name valu given rule integermeasur name string valu integ mea measur integermeasur metric thismodul metricbynam get name valu valu mea end call rule integermeasur begin call rule doublemeasur comment store doubl measur metric name valu given rule doublemeasur name string valu real mea measur doublemeasur metric thismodul metricbynam get name valu valu mea end call rule doublemeasur begin call rule percentagemeasur comment store percentag measur metric name valu given rule percentagemeasur name string valu real mea measur percentagemeasur metric thismodul metricbynam get name valu valu mea end call rule percentagemeasur,14
115,115,P57-Measure2Table.atl,"--@atlcompiler	atl2006
--@name			Measure2Table
--@version		2.0
--@domains		measurement data, metrics, generic table
--@authors		Eric Vepa (evepa <at> sodius.com) for SODIUS (www.sodius.com)
--@date			2007/08/28
--@description	This transformation is used to represent measurement data from terminal models as a generic table representation.

module Measure2Table; -- Module Template
create OUT : Table from IN : Measure;

uses MeasureHelpers;

--@begin helper modelKind
--@comments String values for model type of a measure set.
helper def : modelKind : Map(String,String) =
	Map {('KM3','KM3'),
		('UML2','UML2')};
--@end helper modelKind

--@begin helper elementKind
--@comments String values for element type of a measure set.
helper def : elementKind : Map(String,String) =
	Map {('metamodel','Metamodel'),
		('model','Model'),
		('package','Package'),
		('interface','Interface'),
		('class','Class')};
--@end helper elementKind

--@begin entrypoint rule Tables
--@comments Creates tables from the collected measurement data.
entrypoint rule Tables() {
	using {
		allMetamodelMeasuresSets : Sequence(Measure!MeasureSet) =
			thisModule.allMeasureSets(#metamodel);
		allModelMeasuresSets : Sequence(Measure!MeasureSet) =
			thisModule.allMeasureSets(#model);
		allPackageMeasuresSets : Sequence(Measure!MeasureSet) =
			thisModule.allMeasureSets(#package);
		allInterfaceMeasuresSets : Sequence(Measure!MeasureSet) =
			thisModule.allMeasureSets(#interface);
		allClassMeasuresSets : Sequence(Measure!MeasureSet) =
			thisModule.allMeasureSets(#class);
	}
	do {
		if (allMetamodelMeasuresSets->notEmpty()) {
			thisModule.AllMeasureSet2Table(allMetamodelMeasuresSets);
		}
		if (allModelMeasuresSets->notEmpty()) {
			thisModule.AllMeasureSet2Table(allModelMeasuresSets);
		}
		if (allPackageMeasuresSets->notEmpty()) {
			thisModule.AllMeasureSet2Table(allPackageMeasuresSets);
		}
		if (allInterfaceMeasuresSets->notEmpty()) {
			thisModule.AllMeasureSet2Table(allInterfaceMeasuresSets);
		}
		if (allClassMeasuresSets->notEmpty()) {
			thisModule.AllMeasureSet2Table(allClassMeasuresSets);
		}
	}
}
--@end entrypoint rule Tables

--@begin called rule AllMeasureSet2Table
--@comments Creates a table for all measure sets for one kind of element.
rule AllMeasureSet2Table(allMeasSet : Sequence(Measure!MeasureSet)) {
	to
		t : Table!Table (
			rows <- thisModule.MeasureSet2HdrRow(allMeasSet->first()),
			rows <- allMeasSet->
				collect(ms|thisModule.MeasureSet2ValueRow(ms))
		)
}
--@end called rule AllMeasureSet2Table

--@begin called rule MeasureSet2HdrRow
--@comments Creates a header row with the names of all metrics for this kind of element.
rule MeasureSet2HdrRow(ms : Measure!MeasureSet) {
	to
		hdrRow : Table!Row (
			cells <- thisModule.String2Cell(ms.getElementKind()),
			cells <- ms.allMeasures->
				collect(meas|thisModule.String2Cell(meas.metricName()))
		)
	do {
		hdrRow;
	}
}
--@end called rule MeasureSet2HdrRow

--@begin called rule MeasureSet2ValueRow
--@comments Creates a row with the values for simple measures of a measure set.
rule MeasureSet2ValueRow(ms : Measure!MeasureSet) {
	to
		valueRow : Table!Row (
			cells <- thisModule.String2Cell(ms.absoluteName()),
			cells <- ms.allMeasures->
				collect(meas|thisModule.String2Cell(meas.stringValue()))
		)
	do {
		valueRow;
	}
}
--@end called rule MeasureSet2ValueRow

--@begin called rule Sequence2Row
--@comments Creates a rows with the cells given.
rule Sequence2Row(cells : Sequence(OclAny)) {
	to
		row : Table!Row (
			cells <- cells
		)
	do {
		row;
	}
}
--@end called rule Sequence2Row

--@begin called rule String2Cell
--@comments Creates a cell with the content given.
rule String2Cell(content : String) {
	to
		cell : Table!Cell (
			content <- content
		)
	do {
		cell;
	}
}
--@end called rule String2Cell",atlcompil atl name measur tabl version domain measur data metric generic tabl author eric vepa evepa sodius com sodius www sodius com date descript this transform use repres measur data termin model generic tabl represent modul measur tabl modul templat creat out tabl in measur use measurehelp begin helper modelkind comment string valu model type measur set helper def modelkind map string string map km km uml uml end helper modelkind begin helper elementkind comment string valu element type measur set helper def elementkind map string string map metamodel metamodel model model packag packag interfac interfac class class end helper elementkind begin entrypoint rule tabl comment creat tabl collect measur data entrypoint rule tabl use allmetamodelmeasuresset sequenc measur measureset thismodul allmeasureset metamodel allmodelmeasuresset sequenc measur measureset thismodul allmeasureset model allpackagemeasuresset sequenc measur measureset thismodul allmeasureset packag allinterfacemeasuresset sequenc measur measureset thismodul allmeasureset interfac allclassmeasuresset sequenc measur measureset thismodul allmeasureset class allmetamodelmeasuresset notempti thismodul allmeasureset tabl allmetamodelmeasuresset allmodelmeasuresset notempti thismodul allmeasureset tabl allmodelmeasuresset allpackagemeasuresset notempti thismodul allmeasureset tabl allpackagemeasuresset allinterfacemeasuresset notempti thismodul allmeasureset tabl allinterfacemeasuresset allclassmeasuresset notempti thismodul allmeasureset tabl allclassmeasuresset end entrypoint rule tabl begin call rule allmeasureset tabl comment creat tabl measur set one kind element rule allmeasureset tabl allmeasset sequenc measur measureset tabl tabl row thismodul measureset hdrrow allmeasset first row allmeasset collect ms thismodul measureset valuerow ms end call rule allmeasureset tabl begin call rule measureset hdrrow comment creat header row name metric kind element rule measureset hdrrow ms measur measureset hdrrow tabl row cell thismodul string cell ms getelementkind cell ms allmeasur collect mea thismodul string cell mea metricnam hdrrow end call rule measureset hdrrow begin call rule measureset valuerow comment creat row valu simpl measur measur set rule measureset valuerow ms measur measureset valuerow tabl row cell thismodul string cell ms absolutenam cell ms allmeasur collect mea thismodul string cell mea stringvalu valuerow end call rule measureset valuerow begin call rule sequenc row comment creat row cell given rule sequenc row cell sequenc oclani row tabl row cell cell row end call rule sequenc row begin call rule string cell comment creat cell content given rule string cell content string cell tabl cell content content cell end call rule string cell,12
116,116,P57-Measure2XHTML.atl,"--@atlcompiler	atl2006
--@name			Measure2XHTML
--@version		2.0
--@domains		measurement data, metrics, XHTML
--@authors		Eric Vepa (evepa <at> sodius.com) for SODIUS (www.sodius.com)
--@date			2007/08/28
--@description	This transformation is used to represent measurement data from terminal models as an XHTML document

module Measure2XHTML; -- Module Template
create OUT : XHTML from IN : Measure;

uses MeasureHelpers;

--@begin helper useCCSFile
--@comments A flag for using a CSS file or an embedded CSS using the getStyleSheet() helper at the end of this file (XHTML link or style tags).
helper def : useCSSFile : Boolean = false;
--@end helper useCCSFile

--@begin helper useJSFile
--@comments A flag for using a JavaScript file or an embedded script using the getJavaScript() helper at the end of this file (XHTML script tag).
helper def : useJSFile : Boolean = false;
--@end helper useJSFile

--@begin helper metricDefLocation
--@comments The URL of the metrics definition page.
helper def : metricDefLocation : String =
	'http://www.mdworkbench.com/measurement/metrics/definition.htm';
--@end helper metricDefLocation

--@begin helper modelKind
--@comments String values for model type of a measure set.
helper def : modelKind : Map(String,String) =
	Map {('KM3','KM3'),
		('UML2','UML2')};
--@end helper modelKind

--@begin helper elementKind
--@comments String values for element type of a measure set.
helper def : elementKind : Map(String,String) =
	Map {('metamodel','Metamodel'),
		('model','Model'),
		('package','Package'),
		('interface','Interface'),
		('class','Class')};
--@end helper elementKind

--@begin attribute helper html
--@comments The root HTML tag.
helper def : html : XHTML!HTML = OclUndefined;
--@end attribute helper html

--@begin rule RootMeasureSet
--@comments Creates the unique XHTML, head, title, link or style and body tags.
rule RootMeasureSet {
	from
		root : Measure!RootMeasureSet
	using {
		allMetamodelMeasuresSets : Sequence(Measure!MeasureSet) =
			thisModule.allMeasureSets(#metamodel);
		allModelMeasuresSets : Sequence(Measure!MeasureSet) =
			thisModule.allMeasureSets(#model);
		allPackageMeasuresSets : Sequence(Measure!MeasureSet) =
			thisModule.allMeasureSets(#package);
		allInterfaceMeasuresSets : Sequence(Measure!MeasureSet) =
			thisModule.allMeasureSets(#interface);
		allClassMeasuresSets : Sequence(Measure!MeasureSet) =
			thisModule.allMeasureSets(#class);
	}
	do {		
		if (not (allMetamodelMeasuresSets->isEmpty() and
			allModelMeasuresSets->isEmpty() and
				allPackageMeasuresSets->isEmpty() and
					allInterfaceMeasuresSets->isEmpty() and
						allClassMeasuresSets->isEmpty())) {
			thisModule.html <- thisModule.HTML();
		
			for (cat in root.categories) {
				if (allMetamodelMeasuresSets->notEmpty()) {
					if (allMetamodelMeasuresSets->
							first().categories()->includes(cat)) {
						thisModule.html.body.blocks->last().flows <-
							thisModule.TABLE(allMetamodelMeasuresSets,cat);
					}
				}
				if (allModelMeasuresSets->notEmpty()) {
					if (allModelMeasuresSets->
							first().categories()->includes(cat)) {
						thisModule.html.body.blocks->last().flows <-
							thisModule.TABLE(allModelMeasuresSets,cat);
					}
				}
				if (allPackageMeasuresSets->notEmpty()) {
					if (allPackageMeasuresSets->
							first().categories()->includes(cat)) {
						thisModule.html.body.blocks->last().flows <-
							thisModule.TABLE(allPackageMeasuresSets,cat);
					}
				}
				if (allInterfaceMeasuresSets->notEmpty()) {
					if (allInterfaceMeasuresSets->
							first().categories()->includes(cat)) {
						thisModule.html.body.blocks->last().flows <-
							thisModule.TABLE(allInterfaceMeasuresSets,cat);
					}
				}
				if (allClassMeasuresSets->notEmpty()) {
					if (allClassMeasuresSets->
							first().categories()->includes(cat)) {
						thisModule.html.body.blocks->last().flows <-
							thisModule.TABLE(allClassMeasuresSets,cat);
					}
				}
			}
		}
	}
}
--@end rule RootMeasureSet

--@begin called rule HTML
--@comments Creates the XHTML document structure.
rule HTML() {
	to
		html : XHTML!HTML (
            xmllang <- xmllang,
			head <- head,
			body <- body
		),
		xmllang : XHTML!LanguageCode (
			value <- 'en-US'
		),
		head : XHTML!HEAD (
			title <- title,
			headMiscs <- meta,
			headMiscs <-
				if (thisModule.useCSSFile)
					then thisModule.LINK()
					else thisModule.STYLE()
				endif,
			headMiscs <-
				if (thisModule.useJSFile)
					then thisModule.SCRIPT()
					else thisModule.EmbeddedSCRIPT()
				endif,
			headMiscs <- thisModule.NOSCRIPT()
        ),
        title : XHTML!TITLE (
            pcdata <- thisModule.PCDATA('Interactive metric report on a ' +
            	thisModule.getModelKind() + ' model')
        ),
        meta : XHTML!META (
            httpequiv <- thisModule.CDATA('Content-Type'),
            content <- thisModule.CDATA('text/html; charset=utf-8')
        ),
		body : XHTML!BODY (
			blocks <- thisModule.HowToDIV()
		)
	do {			
		html;
	}
}
--@end called rule HTML

--@begin called rule LINK
--@comments Creates a link on the default .css file used by the generated document.
rule LINK() {	
	to
		link : XHTML!LINK (
			href <- href,
			type <- type,
			rel <- rel
		),
		href : XHTML!URI (
			value <- 'stylesheet.css'
		),
		type : XHTML!ContentType (
			value <- 'text/css'
		),
		rel : XHTML!LinkTypes (
			value <- 'stylesheet'
		)
	do {
		link;
	}
}
--@end called rule LINK

--@begin called rule STYLE
--@comments Creates a XHTML style using the stylesheet returned by the getStyleSheet() helper from MeasureHelpers library.
rule STYLE() {	
	to
		style : XHTML!STYLE (
			type <- type,
			pcdata <- thisModule.PCDATA(thisModule.getStyleSheet())
		),
		type : XHTML!ContentType (
			value <- 'text/css'
		)
	do {
		style;
	}
}
--@end called rule STYLE

--@begin called rule SCRIPT
--@comments Creates a XHTML script using the default script.js used by the generated document.
rule SCRIPT() {	
	to
		script : XHTML!SCRIPT (
			type <- type,
			src <- src
		),
		type : XHTML!ContentType (
			value <- 'text/javascript'
		),
		src : XHTML!URI (
			value <- 'script.js'
		)
	do {		
		script;
	}
}
--@end called rule SCRIPT

--@begin called rule EmbeddedSCRIPT
--@comments Creates a XHTML script using the script returned by the getJavaScript() helper from MeasureHelpers library.
rule EmbeddedSCRIPT() {	
	to
		embeddedScript : XHTML!SCRIPT (
			type <- type,
			pcdata <- thisModule.PCDATA(thisModule.getJavaScript())
		),
		type : XHTML!ContentType (
			value <- 'text/javascript'
		)
	do {		
		embeddedScript;
	}
}
--@end called rule EmbeddedSCRIPT

--@begin called rule NOSCRIPT
--@comments Creates a XHTML noscript, for preventing user activatoing JavaScript in his browser
rule NOSCRIPT() { 
    to
        noscript : XHTML!NOSCRIPT (
            blocks <- fieldset
        ),
        fieldset : XHTML!FIELDSET (
            fieldsetElements <- legend, 
            fieldsetElements <- p
        ),
        legend : XHTML!LEGEND (
            inlines <- thisModule.PCDATA('Warning')
        ),
        p : XHTML!P (
            inlines <- thisModule.PCDATA('In order to use the interactive features, you must enable JavaScript in your browser.')
        )
    do {        
        noscript;
    }
}
--@end called rule NOSCRIPT

--@begin called rule ACRONYM
--@comments Creates an XHTML acronym with a value and a title.
rule ACRONYM(value : String, title : String) {
	to
		acronym : XHTML!ACRONYM (
			title <- titleText,
			inlines <- thisModule.PCDATA(value)
		),
		titleText : XHTML!Text (
			value <- title
		)
	do {
		acronym;
	}
}
--@end called rule ACRONYM

--begin called rule LI
--@comments Creates an XHTML li with a text content.
rule LI(text : String) {
    to
        li : XHTML!LI (
            flows <- thisModule.PCDATA(text)
        )
    do {
        li;
    }
}
--end called rule LI

--begin called rule BR
--@comments Creates an XHTML br.
rule BR() {
    to
        br : XHTML!BR
    do {
        br;
    }
}
--end called rule BR

--@begin called rule HowToDIV
--@comments Creates a XHTML div with the validation for the XHTML and CSS content of the generated document.
rule HowToDIV() {
    to
        howtoDiv : XHTML!DIV (
            flows <- fieldset,
            flows <- thisModule.BR(),
            flows <- thisModule.BR()
        ),
        fieldset : XHTML!FIELDSET (
            fieldsetElements <- legend, 
            fieldsetElements <- p1,
            fieldsetElements <- p2,
            fieldsetElements <- operatorsUl,
            fieldsetElements <- p3,
            fieldsetElements <- p4,
            fieldsetElements <- samplesUl
        ),
        legend : XHTML!LEGEND (
            inlines <- thisModule.PCDATA('How To')
        ),
        p1 : XHTML!P (
            inlines <- thisModule.PCDATA('A predicate can be set for each metric column (an operator followed by a number).' +
                     ' The values for the metric that respect the given predicate are emphasized.')
        ),
        p2 : XHTML!P (
            inlines <- thisModule.PCDATA('Operators for the predicate are among:')
        ),
        operatorsUl : XHTML!UL (
            lis <- thisModule.LI('lower than (&lt;)'),
            lis <- thisModule.LI('lower or equal than (&lt;=)'),
            lis <- thisModule.LI('equal to (= or ==)'),
            lis <- thisModule.LI('not equal to (!= or !)'),
            lis <- thisModule.LI('greater or equal than (&gt;)'),
            lis <- thisModule.LI('greater than (&gt;=)')
        ),
        p3 : XHTML!P (
            inlines <- thisModule.PCDATA('Unit for percentage values are not necessary.' +
                     ' If no operator is given, the operator lower or equal than (&lt;=) is used.' +
                     ' If the predicate is incorrect, no value is emphasized.')
        ),
        p4 : XHTML!P (
            inlines <- thisModule.PCDATA('Predicate samples:')
        ),
        samplesUl : XHTML!UL (
            lis <- thisModule.LI('&gt;1'),
            lis <- thisModule.LI('=33.3')
        )
    do {
        howtoDiv;
    }
}
--@end called rule HowToDIV

--@begin called rule TABLE
--@comments Creates a table for the measures of a category and on a type of model element.
rule TABLE(allMeasSet : Sequence(Measure!MeasureSet), cat : Measure!Category) {
	to
		table : XHTML!TABLE (
			caption <- caption,
			thead <- thead,
			tfoot <- tfoot,
			tableElements <- tbody
		),
		caption : XHTML!CAPTION (
			inlines <- thisModule.PCDATA(cat.desc + ' on ' +
                allMeasSet->first().getElementKind() + ' elements')
		),
		thead : XHTML!THEAD (
			trs <-thisModule.FirstHeaderRow(cat,
				allMeasSet->first().allMeasures(cat)->size()),
			trs <-thisModule.HeaderRow(allMeasSet->first(),cat)
		),
		tfoot : XHTML!TFOOT (
			trs <-thisModule.HeaderRow(allMeasSet->first(),cat)
		),
		tbody : XHTML!TBODY (
			trs <-thisModule.InputTextRow(allMeasSet->
				first().allMeasures(cat)),
			trs <-allMeasSet->
				collect(ms|thisModule.DataRow(ms,cat))
		)
	do {
		table;
	}
}
--@end called rule TABLE

--@begin called rule FirstHeaderRow
--@comments Creates an XHTML table header row with the category and the number of column.
rule FirstHeaderRow(cat : Measure!Category, colspan : Integer) {
	to
		tr : XHTML!TR (
			trElements <- emptyTh,
			trElements <- th			
		),
		emptyTh : XHTML!TH (
			class <- thisModule.CDATA('empty')
		),
		th : XHTML!TH (
			class <- thisModule.CDATA('category'),
			colspan <- colspanNumber,
			flows <- a
		),
		colspanNumber : XHTML!Number (
			value <- colspan.toString()
		),
		a : XHTML!A (
			href <- href,
			onclick <- onclick,
			aContents <- thisModule.ACRONYM(cat.name,cat.desc)
		),
		href : XHTML!URI (
			value <- thisModule.metricDefLocation + '#' + cat.name  +
				'4' + thisModule.getModelKind()
		),
		onclick : XHTML!Script (
			value <- 'window.open(this.href,""_blank""); return false;'
		)
	do {
		tr;
	}
}
--@end called rule FirstHeaderRow

--@begin lazy rule HeaderRow
--@comments Creates a table row with table header cells for the names of all metrics for this kind of element and for a category.
lazy rule HeaderRow {
	from
		ms : Measure!MeasureSet,
		cat : Measure!Category
	to
		tr : XHTML!TR (
			trElements <- thisModule.FirstHeaderCell(ms.getElementKind()),
			trElements <- ms.allMeasures(cat)->
				collect(meas|thisModule.HeaderCell(meas.metric))
		)
}
--@end lazy rule HeaderRow

--@begin called rule FirstHeaderCell
--@comments Creates an XHTML table header cell with the kind of model element.
rule FirstHeaderCell(elementType : String) {
	to
		th : XHTML!TH (
			class <- thisModule.CDATA('element'),
			flows <- thisModule.PCDATA(elementType)
		)
	do {
		th;
	}
}
--@end called rule FirstHeaderCell

--@begin lazy rule HeaderCell
--@comments Creates an XHTML table header cell with an acronym for the metric given.
lazy rule HeaderCell {
	from
		metric : Measure!Metric
	to
		th : XHTML!TH (
			class <- thisModule.CDATA('metric'),
			flows <- a
		),
		a : XHTML!A (
			href <- href,
			onclick <- onclick,
			aContents <- thisModule.ACRONYM(metric.name,metric.desc)
		),
		href : XHTML!URI (
			value <- thisModule.metricDefLocation +
				'#' + metric.category.name + '4' + thisModule.getModelKind() +
				'::' + metric.name
		),
		onclick : XHTML!Script (
			value <- 'window.open(this.href,""_blank""); return false;'
		)
}
--@end called rule HeaderCell

--@begin lazy rule 	
--@comments Creates an XHTML table row with input text fields for all measures of a category.
rule InputTextRow(allMeas : Sequence(Measure!Measure)) {
	to
		tr : XHTML!TR (
			class <- thisModule.CDATA('bound'),
			trElements <- firstTh
		),
		firstTh : XHTML!TH
	do {
		for (meas in allMeas) {
			tr.trElements <- thisModule.InputTextCell(meas);
		}
		
		tr;
	}
}
--@end called rule InputTextRow

--@begin called rule InputTextCell
--@comments Creates an XHTML table data cell with an input text field for a given measure.
rule InputTextCell(meas : Measure!Measure) {
	to
		th : XHTML!TH (
			flows <- inputText
		),
		inputText : XHTML!INPUT (
			type <- #text,
			size <- thisModule.CDATA('3'),
			maxlength <- thisModule.CDATA('7'),
			value <- thisModule.CDATA(meas.metric.preferredValue),
			onchange <- onchange,
			onkeypress <- onkeypress
		),
		onchange : XHTML!Script (
			value <- 'changeStyle(this);'
		),
		onkeypress : XHTML!Script (
			value <- 'changeStyleOnEnter(event,this);'
		)
	do {
		th;
	}
}
--@end called rule InputTextCell

--@begin lazy rule DataRow
--@comments Creates XHTML rows with the values for the measures of a measure set and for a category.
lazy rule DataRow {
	from
		ms : Measure!MeasureSet,
		cat : Measure!Category
	to
		tr : XHTML!TR (
			trElements <- thisModule.FirstDataCell(ms.absoluteName()),
			trElements <- ms.allMeasures(cat)->
				collect(meas|thisModule.DataCell(meas))
		)
}
--@end lazy rule DataRow

--@begin called rule FirstDataCell
--@comments Creates an XHTML table data cell with a value.
rule FirstDataCell(elementName : String) {
	to
		td : XHTML!TD (
			class <- thisModule.CDATA('first'),
			flows <- thisModule.PCDATA(elementName)
		)
	do {
		td;
	}
}
--@end called rule FirstDataCell

--@begin lazy rule DataCell
--@comments Creates an XHTML table data cell for a measure.
lazy rule DataCell {
	from
		meas : Measure!Measure
	to
		td : XHTML!TD (
			flows <- thisModule.PCDATA(meas.stringValue())
		)
	do {
		if (not meas.matchPreferredValue()) {
			td.class <- thisModule.CDATA('ignoredValue');
		}
		
		td;
	}
}
--@end lazy rule DataCell

--begin called rule CDATA
--@comments Creates an XHTML CDATA for the value given.
rule CDATA(value : String) {
    to
		cdata : XHTML!CDATA (
            value <- value
        )
    do {
        cdata;
    }
}
--end called rule CDATA

--begin called rule PCDATA
--@comments Creates an XHTML PCDATA with a CDATA for the value given.
rule PCDATA(value : String) {
    to
        pcdata : XHTML!PCDATA (
            inlines <- thisModule.CDATA(value)
        )
    do {
        pcdata;
    }
}
--end called rule PCDATA

--@begin helper getStyleSheet
--@comments Returns a String containing the stylesheet used by the generated HTML document.
helper def : getStyleSheet() : String = '
<!--/*--><![CDATA[/*><!--*/
html
{
    font-family: arial,helvetica,sans-serif;
    font-size: small;
    font-style: normal;
    font-weight: normal;
    text-align: justify;
}

fieldset
{
    padding: 0px 10px 0px 10px;
}

legend
{
    font-weight: bold;
}

caption
{
    font-style: italic;
    font-weight: bold;
    margin-left: auto;
    margin-right: auto;
    padding-bottom: 5px;
}

table
{
    border: none;
    border-collapse: collapse;
    margin: 5px auto 40px auto;
}

tr.bound, th.metric, th.element
{
    background: #c8c8ff;
    text-align: center;
}

th
{
    border: 1px solid black;
    padding: 1px 4px 4px 4px;
    text-align: center;
    white-space: nowrap;
}

th.empty
{
    border: none;
}

th.category
{
    background: #9696ff;
}

acronym
{
    border-bottom: 1px dotted;
}

input
{
    border: 1px solid gray;
    padding-right: 2px;
    text-align: right;
}

td
{
    background: #e5e5ef;
    border: 1px solid black;
    color: #0000ff;
    font-family: courier,monospace;
    padding: 2px 5px 2px 5px;
    text-align: right;
    white-space: nowrap;
}

td.first
{
    color: #000000;
    font-family: arial,helvetica,sans-serif;
    text-align: left;
}

td.ignoredValue
{
    background: #ffffff;
    color: #adadad;
    text-align: right;
}

a
{
    color: blue;
    text-decoration: none;
}

a:hover
{
    text-decoration: underline;
}
/*]]>*/-->
';
--@end helper getStyleSheet

--@begin helper getJavaScript
--@comments Returns a String containing the script used by the generated HTML document.
helper def : getJavaScript() : String =	'
<!--//--><![CDATA[//><!--
function indexOf(node, item)
{
  var index = 0;
  var current = first_child(node);
  
  while (current != null)
  {
    if (current == item)
    {
      return index;
    }
    else
    {
      current = node_after(current);
      index++;
    }
  }
  
  return 0;
}

function at(node, index)
{
  var i = 0;
  var current = first_child(node);
  
  while (current != null)
  {
    if (i == index)
    {
      return current;
    }
    else
    {
      current = node_after(current);
      i++;
    }
  }
  
  return current;
}

function matchPreferredValue(rawValue, inputText)
{    
  var result = false;
  var value = parseFloat(rawValue);
  
  if (inputText.value.substring(0,2) == ""<="")
  {
    result = (value <= parseFloat(inputText.value.substring(2,inputText.value.length)));
  }
  else if (inputText.value.substring(0,2) == "">="")
  {
    result = (value >= parseFloat(inputText.value.substring(2,inputText.value.length)));
  }
  else if (inputText.value.substring(0,2) == ""=="")
  {
    result = (value == parseFloat(inputText.value.substring(2,inputText.value.length)));
  }
  else if (inputText.value.substring(0,2) == ""!="")
  {
    result = (value != parseFloat(inputText.value.substring(2,inputText.value.length)));
  }
  else if (inputText.value.substring(0,1) == ""<"")
  {
    result = (value < parseFloat(inputText.value.substring(1,inputText.value.length)));
  }
  else if (inputText.value.substring(0,1) == "">"")
  {
    result = (value > parseFloat(inputText.value.substring(1,inputText.value.length)));
  }
  else if (inputText.value.substring(0,1) == ""="")
  {
    result = (value == parseFloat(inputText.value.substring(1,inputText.value.length)));
  } 
  else if (inputText.value.substring(0,1) == ""!"")
  {
    result = (value != parseFloat(inputText.value.substring(1,inputText.value.length)));
    }
  else
  {
    result = (value <= parseFloat(inputText.value));
    if (inputText.value != """")
    {
      inputText.value = ""<="" + inputText.value
    }
  }
  
  return result;
}function changeStyleOnEnter(event, inputText)
{
  if (event.keyCode == 13)
  {
  	changeStyle(inputText);
  }
}

function changeStyle(inputText)
{
  var tdInputText = inputText.parentNode;
  var index = indexOf(tdInputText.parentNode,tdInputText);
     
  if (index != -1)
  {
    for (var trValue = node_after(tdInputText.parentNode); trValue != null; trValue = node_after(trValue))
    {
      var tdValue = at(trValue,index)
    
      if (matchPreferredValue(tdValue.innerHTML,inputText))
      {
        tdValue.className = """";
      }
      else
      {
        tdValue.className = ""ignoredValue"";
      }
    }
  }
}

function is_all_ws(nod)
{
  return !(/[^\\t\\n\\r ]/.test(nod.data));
}

function is_ignorable(nod)
{
  return (nod.nodeType == 8) ||
         ((nod.nodeType == 3) && is_all_ws(nod));
}
function node_after(sib)
{
  while ((sib = sib.nextSibling)) {
    if (!is_ignorable(sib)) return sib;
  }
  return null;
}
function first_child(par)
{
  var res=par.firstChild;
  while (res) {
    if (!is_ignorable(res)) return res;
    res = res.nextSibling;
  }
  return null;
}
//--><!]]>
';
--@end helper getJavaScript",atlcompil atl name measur xhtml version domain measur data metric xhtml author eric vepa evepa sodius com sodius www sodius com date descript this transform use repres measur data termin model xhtml document modul measur xhtml modul templat creat out xhtml in measur use measurehelp begin helper useccsfil comment a flag use css file embed css use getstylesheet helper end file xhtml link style tag helper def usecssfil boolean fals end helper useccsfil begin helper usejsfil comment a flag use javascript file embed script use getjavascript helper end file xhtml script tag helper def usejsfil boolean fals end helper usejsfil begin helper metricdefloc comment the url metric definit page helper def metricdefloc string http www mdworkbench com measur metric definit htm end helper metricdefloc begin helper modelkind comment string valu model type measur set helper def modelkind map string string map km km uml uml end helper modelkind begin helper elementkind comment string valu element type measur set helper def elementkind map string string map metamodel metamodel model model packag packag interfac interfac class class end helper elementkind begin attribut helper html comment the root html tag helper def html xhtml html oclundefin end attribut helper html begin rule rootmeasureset comment creat uniqu xhtml head titl link style bodi tag rule rootmeasureset root measur rootmeasureset use allmetamodelmeasuresset sequenc measur measureset thismodul allmeasureset metamodel allmodelmeasuresset sequenc measur measureset thismodul allmeasureset model allpackagemeasuresset sequenc measur measureset thismodul allmeasureset packag allinterfacemeasuresset sequenc measur measureset thismodul allmeasureset interfac allclassmeasuresset sequenc measur measureset thismodul allmeasureset class allmetamodelmeasuresset isempti allmodelmeasuresset isempti allpackagemeasuresset isempti allinterfacemeasuresset isempti allclassmeasuresset isempti thismodul html thismodul html cat root categori allmetamodelmeasuresset notempti allmetamodelmeasuresset first categori includ cat thismodul html bodi block last flow thismodul tabl allmetamodelmeasuresset cat allmodelmeasuresset notempti allmodelmeasuresset first categori includ cat thismodul html bodi block last flow thismodul tabl allmodelmeasuresset cat allpackagemeasuresset notempti allpackagemeasuresset first categori includ cat thismodul html bodi block last flow thismodul tabl allpackagemeasuresset cat allinterfacemeasuresset notempti allinterfacemeasuresset first categori includ cat thismodul html bodi block last flow thismodul tabl allinterfacemeasuresset cat allclassmeasuresset notempti allclassmeasuresset first categori includ cat thismodul html bodi block last flow thismodul tabl allclassmeasuresset cat end rule rootmeasureset begin call rule html comment creat xhtml document structur rule html html xhtml html xmllang xmllang head head bodi bodi xmllang xhtml languagecod valu en us head xhtml head titl titl headmisc meta headmisc thismodul usecssfil thismodul link els thismodul style endif headmisc thismodul usejsfil thismodul script els thismodul embeddedscript endif headmisc thismodul noscript titl xhtml titl pcdata thismodul pcdata interact metric report thismodul getmodelkind model meta xhtml meta httpequiv thismodul cdata content type content thismodul cdata text html charset utf bodi xhtml bodi block thismodul howtodiv html end call rule html begin call rule link comment creat link default css file use generat document rule link link xhtml link href href type type rel rel href xhtml uri valu stylesheet css type xhtml contenttyp valu text css rel xhtml linktyp valu stylesheet link end call rule link begin call rule style comment creat xhtml style use stylesheet return getstylesheet helper measurehelp librari rule style style xhtml style type type pcdata thismodul pcdata thismodul getstylesheet type xhtml contenttyp valu text css style end call rule style begin call rule script comment creat xhtml script use default script js use generat document rule script script xhtml script type type src src type xhtml contenttyp valu text javascript src xhtml uri valu script js script end call rule script begin call rule embeddedscript comment creat xhtml script use script return getjavascript helper measurehelp librari rule embeddedscript embeddedscript xhtml script type type pcdata thismodul pcdata thismodul getjavascript type xhtml contenttyp valu text javascript embeddedscript end call rule embeddedscript begin call rule noscript comment creat xhtml noscript prevent user activato javascript browser rule noscript noscript xhtml noscript block fieldset fieldset xhtml fieldset fieldsetel legend fieldsetel p legend xhtml legend inlin thismodul pcdata warn p xhtml p inlin thismodul pcdata in order use interact featur must enabl javascript browser noscript end call rule noscript begin call rule acronym comment creat xhtml acronym valu titl rule acronym valu string titl string acronym xhtml acronym titl titletext inlin thismodul pcdata valu titletext xhtml text valu titl acronym end call rule acronym begin call rule li comment creat xhtml li text content rule li text string li xhtml li flow thismodul pcdata text li end call rule li begin call rule br comment creat xhtml br rule br br xhtml br br end call rule br begin call rule howtodiv comment creat xhtml div valid xhtml css content generat document rule howtodiv howtodiv xhtml div flow fieldset flow thismodul br flow thismodul br fieldset xhtml fieldset fieldsetel legend fieldsetel p fieldsetel p fieldsetel operatorsul fieldsetel p fieldsetel p fieldsetel samplesul legend xhtml legend inlin thismodul pcdata how to p xhtml p inlin thismodul pcdata a predic set metric column oper follow number the valu metric respect given predic emphas p xhtml p inlin thismodul pcdata oper predic among operatorsul xhtml ul lis thismodul li lower lt lis thismodul li lower equal lt lis thismodul li equal lis thismodul li equal lis thismodul li greater equal gt lis thismodul li greater gt p xhtml p inlin thismodul pcdata unit percentag valu necessari if oper given oper lower equal lt use if predic incorrect valu emphas p xhtml p inlin thismodul pcdata predic sampl samplesul xhtml ul lis thismodul li gt lis thismodul li howtodiv end call rule howtodiv begin call rule tabl comment creat tabl measur categori type model element rule tabl allmeasset sequenc measur measureset cat measur categori tabl xhtml tabl caption caption thead thead tfoot tfoot tableel tbodi caption xhtml caption inlin thismodul pcdata cat desc allmeasset first getelementkind element thead xhtml thead trs thismodul firstheaderrow cat allmeasset first allmeasur cat size trs thismodul headerrow allmeasset first cat tfoot xhtml tfoot trs thismodul headerrow allmeasset first cat tbodi xhtml tbodi trs thismodul inputtextrow allmeasset first allmeasur cat trs allmeasset collect ms thismodul datarow ms cat tabl end call rule tabl begin call rule firstheaderrow comment creat xhtml tabl header row categori number column rule firstheaderrow cat measur categori colspan integ tr xhtml tr trelement emptyth trelement th emptyth xhtml th class thismodul cdata empti th xhtml th class thismodul cdata categori colspan colspannumb flow colspannumb xhtml number valu colspan tostr xhtml a href href onclick onclick acont thismodul acronym cat name cat desc href xhtml uri valu thismodul metricdefloc cat name thismodul getmodelkind onclick xhtml script valu window open href blank return fals tr end call rule firstheaderrow begin lazi rule headerrow comment creat tabl row tabl header cell name metric kind element categori lazi rule headerrow ms measur measureset cat measur categori tr xhtml tr trelement thismodul firstheadercel ms getelementkind trelement ms allmeasur cat collect mea thismodul headercel mea metric end lazi rule headerrow begin call rule firstheadercel comment creat xhtml tabl header cell kind model element rule firstheadercel elementtyp string th xhtml th class thismodul cdata element flow thismodul pcdata elementtyp th end call rule firstheadercel begin lazi rule headercel comment creat xhtml tabl header cell acronym metric given lazi rule headercel metric measur metric th xhtml th class thismodul cdata metric flow xhtml a href href onclick onclick acont thismodul acronym metric name metric desc href xhtml uri valu thismodul metricdefloc metric categori name thismodul getmodelkind metric name onclick xhtml script valu window open href blank return fals end call rule headercel begin lazi rule comment creat xhtml tabl row input text field measur categori rule inputtextrow allmea sequenc measur measur tr xhtml tr class thismodul cdata bound trelement firstth firstth xhtml th mea allmea tr trelement thismodul inputtextcel mea tr end call rule inputtextrow begin call rule inputtextcel comment creat xhtml tabl data cell input text field given measur rule inputtextcel mea measur measur th xhtml th flow inputtext inputtext xhtml input type text size thismodul cdata maxlength thismodul cdata valu thismodul cdata mea metric preferredvalu onchang onchang onkeypress onkeypress onchang xhtml script valu changestyl onkeypress xhtml script valu changestyleonent event th end call rule inputtextcel begin lazi rule datarow comment creat xhtml row valu measur measur set categori lazi rule datarow ms measur measureset cat measur categori tr xhtml tr trelement thismodul firstdatacel ms absolutenam trelement ms allmeasur cat collect mea thismodul datacel mea end lazi rule datarow begin call rule firstdatacel comment creat xhtml tabl data cell valu rule firstdatacel elementnam string td xhtml td class thismodul cdata first flow thismodul pcdata elementnam td end call rule firstdatacel begin lazi rule datacel comment creat xhtml tabl data cell measur lazi rule datacel mea measur measur td xhtml td flow thismodul pcdata mea stringvalu mea matchpreferredvalu td class thismodul cdata ignoredvalu td end lazi rule datacel begin call rule cdata comment creat xhtml cdata valu given rule cdata valu string cdata xhtml cdata valu valu cdata end call rule cdata begin call rule pcdata comment creat xhtml pcdata cdata valu given rule pcdata valu string pcdata xhtml pcdata inlin thismodul cdata valu pcdata end call rule pcdata begin helper getstylesheet comment return string contain stylesheet use generat html document helper def getstylesheet string cdata html font famili arial helvetica san serif font size small font style normal font weight normal text align justifi fieldset pad px px px px legend font weight bold caption font style ital font weight bold margin left auto margin right auto pad bottom px tabl border none border collaps collaps margin px auto px auto tr bound th metric th element background c c ff text align center th border px solid black pad px px px px text align center white space nowrap th empti border none th categori background ff acronym border bottom px dot input border px solid gray pad right px text align right td background e e ef border px solid black color ff font famili courier monospac pad px px px px text align right white space nowrap td first color font famili arial helvetica san serif text align left td ignoredvalu background ffffff color adadad text align right color blue text decor none hover text decor underlin end helper getstylesheet begin helper getjavascript comment return string contain script use generat html document helper def getjavascript string cdata function indexof node item var index var current first child node current null current item return index els current node current index return function node index var var current first child node current null index return current els current node current return current function matchpreferredvalu rawvalu inputtext var result fals var valu parsefloat rawvalu inputtext valu substr result valu parsefloat inputtext valu substr inputtext valu length els inputtext valu substr result valu parsefloat inputtext valu substr inputtext valu length els inputtext valu substr result valu parsefloat inputtext valu substr inputtext valu length els inputtext valu substr result valu parsefloat inputtext valu substr inputtext valu length els inputtext valu substr result valu parsefloat inputtext valu substr inputtext valu length els inputtext valu substr result valu parsefloat inputtext valu substr inputtext valu length els inputtext valu substr result valu parsefloat inputtext valu substr inputtext valu length els inputtext valu substr result valu parsefloat inputtext valu substr inputtext valu length els result valu parsefloat inputtext valu inputtext valu inputtext valu inputtext valu return result function changestyleonent event inputtext event keycod changestyl inputtext function changestyl inputtext var tdinputtext inputtext parentnod var index indexof tdinputtext parentnod tdinputtext index var trvalu node tdinputtext parentnod trvalu null trvalu node trvalu var tdvalu trvalu index matchpreferredvalu tdvalu innerhtml inputtext tdvalu classnam els tdvalu classnam ignoredvalu function ws nod return n r test nod data function ignor nod return nod nodetyp nod nodetyp ws nod function node sib sib sib nextsibl ignor sib return sib return null function first child par var res par firstchild res ignor res return res res res nextsibl return null end helper getjavascript,12
117,117,P57-SVG2XML.atl,"--@atlcompiler	atl2006
--@name			SVG2XML
--@version		2.0
--@domains		SVG, extractor
--@authors		Eric Vepa (evepa <at> sodius.com) for SODIUS (www.sodius.com)
--@date			2007/05/28
--@description	SVG extractor for a subset of the SVG metamodel.

module SVG2XML; -- Module Template
create OUT : XML from IN : SVG;

--@begin helper notNull
--@comments Returns true if the value is not null (0 or 0.0).
helper context Real
def : notNull() : Boolean =
	self <> 0 and self <> 0.0;
--@end helper notNull

--@begin helper scale
--@comments Returns the string value for a scale transformation attribute.
helper context SVG!Scale
def : scale() : String =
	if (self.sx = 1 or self.sx = 1.0)
		then ''
		else 'scale(' + self.sx.toString() +
			if self.sy = self.sx
				then ''
				else ',' + self.sy.toString()
			endif + ')'
	endif;
--@end helper scale

--@begin helper translate
--@comments Returns the string value for a translate transformation attribute.
helper context SVG!Translate
def : translate() : String =
	if self.tx.notNull() or self.ty.notNull()
		then 'translate(' + self.tx.toString() + ',' + self.ty.toString() + ')'
		else ''
	endif;
--@end helper translate

--@begin helper rotate
--@comments Returns the string value for a rotate transformation attribute.
helper context SVG!Rotate
def : rotate() : String =
	if self.angle.notNull()
		then 'rotate(' + self.angle.toString() + ')'
		else ''
	endif;
--@end helper rotate

--@begin rule Svg
rule Svg {
	from
		svg : SVG!Svg
	to
		root : XML!Root (
			name <- 'svg',
			children <- xmlns,
			children <- version,
			children <- thisModule.Attribute('width',
				if not svg.size.oclIsUndefined()
					then svg.size.width.toString()
					else '100%'
				endif),
			children <- thisModule.Attribute('height',
				if not svg.size.oclIsUndefined()
					then svg.size.height.toString()
					else '100%'
				endif),
			children <- svg.children
		),
		xmlns : XML!Attribute (
			name <- 'xmlns',
			value <- svg.namespace
		),
		version : XML!Attribute (
			name <- 'version',
			value <- svg.version
		)
	do {
		if (not svg.viewBox.oclIsUndefined()) {
			root.children <- thisModule.Attribute('viewBox', svg.viewBox);
		}
	}
}	
--@end rule Svg

--@begin rule G
rule G {
	from
		g : SVG!G
	using {
		transforms : Sequence(SVG!Transform) =
			g.attribute->select(a|a.oclIsKindOf(SVG!Transform));
		transformValue : String =
			transforms->iterate(transf; str : String = ''|
				str +
				if transf.oclIsTypeOf(SVG!Scale)
					then transf.scale()
					else if transf.oclIsTypeOf(SVG!Translate)
						then transf.translate()
						else if transf.oclIsTypeOf(SVG!Rotate)
							then transf.rotate()
							else ''
						endif
					endif
				endif +
				if (transf <> transforms->last())
					then ' '
					else ''
				endif);
	}
	to
		elmt : XML!Element (
			name <- 'g',
			children <- g.groupContent
		)
	do {
		if (not g.fill.oclIsUndefined()) {
			if (g.fill <> 'black') {
				elmt.children <- thisModule.Attribute('fill', g.fill);
			}
		}
		if (transforms->notEmpty()) {
			if (transformValue <> '') {
				elmt.children <- thisModule.Attribute('transform',
					transformValue);
			}
		}
	}
}	
--@end rule G

--@begin rule Rect
rule Rect {
	from
		rect : SVG!Rect
	to
		elmt : XML!Element (
			name <- 'rect',
			children <- thisModule.Attribute('width',
				if not rect.size.oclIsUndefined()
					then rect.size.width.toString()
					else '100%'
				endif),
			children <- thisModule.Attribute('height',
				if not rect.size.oclIsUndefined()
					then rect.size.height.toString()
					else '100%'
				endif)
		)
	do {
		if (not rect.position.oclIsUndefined()) {
			if (rect.position.x.notNull()) {
				elmt.children <- thisModule.Attribute('x',
					rect.position.x.toString());
			}
		}
		if (not rect.position.oclIsUndefined()) {
			if (rect.position.y.notNull()) {
				elmt.children <- thisModule.Attribute('y',
					rect.position.y.toString());
			}
		}
		if (not rect.fill.oclIsUndefined()) {
			if (rect.fill <> 'black') {
				elmt.children <- thisModule.Attribute('fill', rect.fill);
			}
		}
		if (not rect.stroke.oclIsUndefined()) {
			if (rect.stroke <> 'none') {
				elmt.children <- thisModule.Attribute('stroke', rect.stroke);
			}
		}
	}
}	
--@end rule Rect

--@begin rule Circle
rule Circle {
	from
		circ : SVG!Circle
	to
		elmt : XML!Element (
			name <- 'circle',
			children <- thisModule.Attribute('r',
				if not circ.size.oclIsUndefined()
					then circ.size.width.toString()
					else '0'
				endif)
		)
	do {
		if (not circ.position.oclIsUndefined()) {
			if (circ.position.x.notNull()) {
				elmt.children <- thisModule.Attribute('x',
					circ.position.x.toString());
			}
		}
		if (not circ.position.oclIsUndefined()) {
			if (circ.position.y.notNull()) {
				elmt.children <- thisModule.Attribute('y',
					circ.position.y.toString());
			}
		}
		if (not circ.fill.oclIsUndefined()) {
			if (circ.fill <> 'black') {
				elmt.children <- thisModule.Attribute('fill', circ.fill);
			}
		}
		if (not circ.stroke.oclIsUndefined()) {
			if (circ.stroke <> 'none') {
				elmt.children <- thisModule.Attribute('stroke', circ.stroke);
			}
		}
	}
}	
--@end rule Circle

--@begin rule Path
rule Path {
	from
		path : SVG!Path
	to
		elmt : XML!Element (
			name <- 'path',
			children <- thisModule.Attribute('d', path.d)
		)
	do {
		if (not path.fill.oclIsUndefined()) {
			if (path.fill <> 'black') {
				elmt.children <- thisModule.Attribute('fill', path.fill);
			}
		}
		if (not path.stroke.oclIsUndefined()) {
			if (path.stroke <> 'none') {
				elmt.children <- thisModule.Attribute('stroke', path.stroke);
			}
		}
	}
}	
--@end rule Path

--@begin rule Text
rule Text {
	from
		text : SVG!Text
	to
		elmt : XML!Element (
			name <- 'text',
			children <- txt
		),
		txt : XML!Text (
			value <- text.content
		)
	do {
		if (not text.position.oclIsUndefined()) {
			if (text.position.x.notNull()) {
				elmt.children <- thisModule.Attribute('x',
					text.position.x.toString());
			}
		}
		if (not text.position.oclIsUndefined()) {
			if (text.position.y.notNull()) {
				elmt.children <- thisModule.Attribute('y',
					text.position.y.toString());
			}
		}
		if (not text.stroke.oclIsUndefined()) {
			if (text.stroke <> 'none') {
				elmt.children <- thisModule.Attribute('stroke', text.stroke);
			}
		}
		if (not text.fontSize.oclIsUndefined()) {
			if (text.fontSize <> 'medium') {
				elmt.children <- thisModule.Attribute('font-size',
					text.fontSize);
			}
		}
		--@comments text-anchor value stored in lengthAdjust attribute
		if (not text.lengthAdjust.oclIsUndefined()) {
			if (text.lengthAdjust <> 'start') {
				elmt.children <- thisModule.Attribute('text-anchor',
					text.lengthAdjust);
			}
		}
	}
}	
--@end rule Text

--@begin called rule Attribute
rule Attribute(attrName : String, attrValue : String) {
	to
		attr : XML!Attribute (
			name <- attrName,
			value <- attrValue
		)
	do {
		attr;
	}
}	
--@end called rule Attribute",atlcompil atl name svg xml version domain svg extractor author eric vepa evepa sodius com sodius www sodius com date descript svg extractor subset svg metamodel modul svg xml modul templat creat out xml in svg begin helper notnul comment return true valu null helper context real def notnul boolean self self end helper notnul begin helper scale comment return string valu scale transform attribut helper context svg scale def scale string self sx self sx els scale self sx tostr self sy self sx els self sy tostr endif endif end helper scale begin helper translat comment return string valu translat transform attribut helper context svg translat def translat string self tx notnul self ty notnul translat self tx tostr self ty tostr els endif end helper translat begin helper rotat comment return string valu rotat transform attribut helper context svg rotat def rotat string self angl notnul rotat self angl tostr els endif end helper rotat begin rule svg rule svg svg svg svg root xml root name svg children xmlns children version children thismodul attribut width svg size oclisundefin svg size width tostr els endif children thismodul attribut height svg size oclisundefin svg size height tostr els endif children svg children xmlns xml attribut name xmlns valu svg namespac version xml attribut name version valu svg version svg viewbox oclisundefin root children thismodul attribut viewbox svg viewbox end rule svg begin rule g rule g g svg g use transform sequenc svg transform g attribut select ocliskindof svg transform transformvalu string transform iter transf str string str transf oclistypeof svg scale transf scale els transf oclistypeof svg translat transf translat els transf oclistypeof svg rotat transf rotat els endif endif endif transf transform last els endif elmt xml element name g children g groupcont g fill oclisundefin g fill black elmt children thismodul attribut fill g fill transform notempti transformvalu elmt children thismodul attribut transform transformvalu end rule g begin rule rect rule rect rect svg rect elmt xml element name rect children thismodul attribut width rect size oclisundefin rect size width tostr els endif children thismodul attribut height rect size oclisundefin rect size height tostr els endif rect posit oclisundefin rect posit x notnul elmt children thismodul attribut x rect posit x tostr rect posit oclisundefin rect posit notnul elmt children thismodul attribut rect posit tostr rect fill oclisundefin rect fill black elmt children thismodul attribut fill rect fill rect stroke oclisundefin rect stroke none elmt children thismodul attribut stroke rect stroke end rule rect begin rule circl rule circl circ svg circl elmt xml element name circl children thismodul attribut r circ size oclisundefin circ size width tostr els endif circ posit oclisundefin circ posit x notnul elmt children thismodul attribut x circ posit x tostr circ posit oclisundefin circ posit notnul elmt children thismodul attribut circ posit tostr circ fill oclisundefin circ fill black elmt children thismodul attribut fill circ fill circ stroke oclisundefin circ stroke none elmt children thismodul attribut stroke circ stroke end rule circl begin rule path rule path path svg path elmt xml element name path children thismodul attribut path path fill oclisundefin path fill black elmt children thismodul attribut fill path fill path stroke oclisundefin path stroke none elmt children thismodul attribut stroke path stroke end rule path begin rule text rule text text svg text elmt xml element name text children txt txt xml text valu text content text posit oclisundefin text posit x notnul elmt children thismodul attribut x text posit x tostr text posit oclisundefin text posit notnul elmt children thismodul attribut text posit tostr text stroke oclisundefin text stroke none elmt children thismodul attribut stroke text stroke text fontsiz oclisundefin text fontsiz medium elmt children thismodul attribut font size text fontsiz comment text anchor valu store lengthadjust attribut text lengthadjust oclisundefin text lengthadjust start elmt children thismodul attribut text anchor text lengthadjust end rule text begin call rule attribut rule attribut attrnam string attrvalu string attr xml attribut name attrnam valu attrvalu attr end call rule attribut,9
118,118,P57-Table2SVGBarChart.atl,"--@atlcompiler	atl2006
--@name			Table2SVGBarChart
--@version		2.0
--@domains		Table, SVG, bar chart
--@authors		Eric Vepa (evepa <at> sodius.com) for SODIUS (www.sodius.com)
--@date			2007/08/28
--@description	This transformation is used to transform generic tables into SVG bar charts. A bar chart is produced for a table with values (excluding the header row and the first cell of each other row).

module Table2SVGBarChart; -- Module Template
create OUT : SVG from IN : Table;

uses TableHelpers;

--@comments ===================================
--@comments Values used for the SVG rendering =
--@comments ===================================

--@begin attribute helper scale
--@comments The 'scale' value used in the SVG document.
helper def : scale : Real = 1;
--@end attribute helper scale

--@begin attribute helper barPattern
--@comments The 'fill' value used by bar in the SVG document.
helper def : barPattern : String = 'grey';
--@end attribute helper barPattern

--@begin attribute helper barMaxWidth
--@comments Returns the max width of a bar of the chart.
helper def : barMaxWidth : Real = 150 * thisModule.scale;
--@end attribute helper barWidth

--@begin attribute helper fill
--@comments The 'fill' value used in the SVG document.
helper def : fill : String = 'none';
--@end attribute helper fill

--@begin attribute helper stroke
--@comments The 'stroke' value used in the SVG document.
helper def : stroke : String = 'black';
--@end attribute helper stroke

--@begin attribute helper margin
--@comments The margin value used in the SVG document between charts.
helper def : margin : Real = 10;
--@end attribute helper margin

--@begin attribute helper titleFontSize
--@comments The 'fontSize' value used for titles in the SVG document.
helper def : titleFontSize : Real =  thisModule.barMaxWidth * 0.1;
--@end attribute helper titleFontSize

--@begin attribute helper fontSize
--@comments The 'fontSize' value used in the SVG document.
helper def : fontSize : Real = thisModule.titleFontSize * 0.85;
--@end attribute helper fontSize

--@begin attribute helper barHeight
--@comments Returns height of a bar of the chart.
helper def : barHeight : Real = thisModule.fontSize;
--@end attribute helper barHeight

--@begin attribute helper svgFile
--@comments The unique SVG file element.
helper def : svgFile : SVG!SvgFile = OclUndefined;
--@end attribute helper svgFile


--@comments ===============================
--@comments Helpers for the SVG rendering =
--@comments ===============================

--@begin helper maxSizeName
--@comments Returns the maximal size for a name of a table.
helper context Table!Table
def : maxSizeName() : Real =
	(self.rows.seqWithoutFirst()->iterate(r; maxSize : Integer = 0|
		if r.cells->first().content->size() > maxSize
			then r.cells->first().content->size()
			else maxSize
		endif) + 7) * (thisModule.fontSize / 2);
--@end helper maxSizeName

--@begin helper boundingBoxWidth
--@comments Returns the width of the bouding box computed for a table.
helper context Table!Table
def : boundingBoxWidth() : Real =
	self.maxSizeName() + thisModule.barMaxWidth +
		thisModule.barHeight + 3 * thisModule.margin;
--@end helper boundingBoxWidth

--@begin helper boundingBoxHeight
--@comments Returns the height of the bouding box computed for a table.
helper context Table!Table
def : boundingBoxHeight() : Real =
	(self.rows->size() - 1) * thisModule.barHeight +
		2 * thisModule.margin +	2 * thisModule.titleFontSize;
--@end helper boundingBoxHeight

--@begin attribute helper prevWidth
--@comments The previous width of all the charts generated.
helper def : prevWidth : Real = 0;
--@end attribute helper prevWidth

--@begin helper scaleFactor
--@comments The scale factor for adjusting bar width for the column which index is given.
helper context Table!Table
def : scaleFactor(idx : Integer) : Real =	
	let max : Real =
		self.rows->seqWithoutFirst()->
			iterate(r; max : Real = 0|
				let value : Real =
					r.cells->at(idx).realValue() in
				value->max(max)) in
	if max = 0
		then 1
		else thisModule.barMaxWidth / max
	endif;
--@end helper scaleFactor

--@begin entrypoint rule SvgFile
--@comments Creates the SVG file with one svg tag.
entrypoint rule SvgFile() {
	using {
		width : Real =
			thisModule.allValidTables->iterate(table; sum : Integer = 0|
				sum + (table.boundingBoxWidth() +
					thisModule.margin) *
						(table.rows->first().cells->size() - 1)) +
							thisModule.margin;
		height : Real =
			thisModule.allValidTables->iterate(table; max : Integer = 0|
				table.boundingBoxHeight()->max(max)) +
					2 * thisModule.titleFontSize;
	}
	to
		svgFile : SVG!SvgFile (
			tag <- svg
		),
		svg : SVG!Svg (
			size <- svgSize,
			namespace <- 'http://www.w3.org/2000/svg',
			version <- '1.1'
		),
		svgSize : SVG!Dimension (
			width <- width,
			height <- height
		)
	do {					
		if (thisModule.allValidTables->size() > 0) {
			thisModule.svgFile <- svgFile;
			thisModule.svgFile.tag.viewBox <- '0 0 ' +
				width.toString() + ' ' + height.toString();			
					
			for (table in thisModule.allValidTables) {
				for (cell in table.rows->first().cells->seqWithoutFirst()) {
					thisModule.Table2BarChart(table,
						table.rows->first().cells->indexOf(cell));
				}
			}
		}
	}
}
--@end entrypoint rule SvgFile

--@begin lazy rule Table2BarChart
--@comments Creates a bar chart (SVG group) for the metric which column index is given.
lazy rule Table2BarChart {
	from
		table : Table!Table,
		idx : Integer
	to
		g : SVG!G (
			attribute <- boundingBoxTransl,
			groupContent <- boundingBox,
			groupContent <- textTitle,
			groupContent <- axis,
			groupContent <- table.rows->seqWithoutFirst()->
				iterate(row; acc : Sequence(SVG!G) = Sequence{}|
					acc->including(thisModule.Row2Bar(row,
						table.rows->indexOf(row),idx,table.scaleFactor(idx))))
		),
		boundingBox : SVG!Rect (
			size <- boundingBoxSize,
			position <- boundingBoxCoord,
			fill <- thisModule.fill,
			stroke <- thisModule.stroke
		),
		boundingBoxSize : SVG!Dimension (
			width <- table.boundingBoxWidth(),
			height <- table.boundingBoxHeight()
		),
		boundingBoxCoord : SVG!AbsoluteCoord (
			x <- 0 - table.maxSizeName() - 2 * thisModule.margin,
			y <- 0 - thisModule.margin
		),
		boundingBoxTransl : SVG!Translate (
			tx <- thisModule.prevWidth + 3 * thisModule.margin +
				table.maxSizeName(),
			ty <- 2 * thisModule.margin
		),
		textTitle : SVG!Text (
			position <- textTitleCoord,
			stroke <- thisModule.stroke,
			fontSize <- thisModule.titleFontSize.toString(),
			--@comments text-anchor value strored in lengthAdjust attribute
			lengthAdjust <- 'middle',
			content <- table.rows->first().cells->at(idx).content
		),
		textTitleCoord : SVG!AbsoluteCoord (
			x <- boundingBoxSize.width / 2 - table.maxSizeName(),
			y <- boundingBoxSize.height - 2 * thisModule.margin
		),
		axis : SVG!Path (
			d <- 'M' + (thisModule.barMaxWidth +
				thisModule.barHeight).toString() + ',0 H0 V' +
					(table.rows->size() *
						thisModule.barHeight).toString() + ',0 z',
			fill <- thisModule.fill,
			stroke <- thisModule.stroke
		)	
	do {
		thisModule.prevWidth <- thisModule.prevWidth +
			thisModule.margin +	boundingBoxSize.width;
		thisModule.svgFile.tag.children <- g;
	}
}
--@end lazy rule Table2BarChart

--@begin lazy rule Row2Bar
--@comments Creates a bar (SVG line) for the cell at index given and with a scale factor.
lazy rule Row2Bar {
	from
		row : Table!Row,
		rowIdx : Integer,
		cellIdx : Integer,
		scaleFactor : Real
	to
		g : SVG!G (
			groupContent <- bar,
			groupContent <- textCaption
		),
		bar : SVG!Rect (
			size <- barSize,
			position <- barCoord,
			fill <- thisModule.barPattern,
			stroke <- thisModule.stroke
		),
		barSize : SVG!Dimension (
			width <- row.cells->at(cellIdx).realValue() * scaleFactor,
			height <- thisModule.barHeight
		),
		barCoord : SVG!AbsoluteCoord (
			x <- 0,
			y <- (rowIdx - 2) * barSize.height 
		),
		textCaption : SVG!Text (
			position <- textCaptionCoord,
			stroke <- thisModule.stroke,
			fontSize <- thisModule.fontSize.toString(),
			--@comments text-anchor value strored in lengthAdjust attribute
			lengthAdjust <- 'end',
			content <- row.cells->first().content +
				' (' +	row.cells->at(cellIdx).value() + ')'
		),
		textCaptionCoord : SVG!AbsoluteCoord (
			x <- 0 - thisModule.margin,
			y <- barCoord.y + barSize.height
		)
}
--@end lazy rule Row2Bar",atlcompil atl name tabl svgbarchart version domain tabl svg bar chart author eric vepa evepa sodius com sodius www sodius com date descript this transform use transform generic tabl svg bar chart a bar chart produc tabl valu exclud header row first cell row modul tabl svgbarchart modul templat creat out svg in tabl use tablehelp comment comment valu use svg render comment begin attribut helper scale comment the scale valu use svg document helper def scale real end attribut helper scale begin attribut helper barpattern comment the fill valu use bar svg document helper def barpattern string grey end attribut helper barpattern begin attribut helper barmaxwidth comment return max width bar chart helper def barmaxwidth real thismodul scale end attribut helper barwidth begin attribut helper fill comment the fill valu use svg document helper def fill string none end attribut helper fill begin attribut helper stroke comment the stroke valu use svg document helper def stroke string black end attribut helper stroke begin attribut helper margin comment the margin valu use svg document chart helper def margin real end attribut helper margin begin attribut helper titlefonts comment the fontsiz valu use titl svg document helper def titlefonts real thismodul barmaxwidth end attribut helper titlefonts begin attribut helper fontsiz comment the fontsiz valu use svg document helper def fontsiz real thismodul titlefonts end attribut helper fontsiz begin attribut helper barheight comment return height bar chart helper def barheight real thismodul fontsiz end attribut helper barheight begin attribut helper svgfile comment the uniqu svg file element helper def svgfile svg svgfile oclundefin end attribut helper svgfile comment comment helper svg render comment begin helper maxsizenam comment return maxim size name tabl helper context tabl tabl def maxsizenam real self row seqwithoutfirst iter r maxsiz integ r cell first content size maxsiz r cell first content size els maxsiz endif thismodul fontsiz end helper maxsizenam begin helper boundingboxwidth comment return width boud box comput tabl helper context tabl tabl def boundingboxwidth real self maxsizenam thismodul barmaxwidth thismodul barheight thismodul margin end helper boundingboxwidth begin helper boundingboxheight comment return height boud box comput tabl helper context tabl tabl def boundingboxheight real self row size thismodul barheight thismodul margin thismodul titlefonts end helper boundingboxheight begin attribut helper prevwidth comment the previous width chart generat helper def prevwidth real end attribut helper prevwidth begin helper scalefactor comment the scale factor adjust bar width column index given helper context tabl tabl def scalefactor idx integ real let max real self row seqwithoutfirst iter r max real let valu real r cell idx realvalu valu max max max els thismodul barmaxwidth max endif end helper scalefactor begin entrypoint rule svgfile comment creat svg file one svg tag entrypoint rule svgfile use width real thismodul allvalidt iter tabl sum integ sum tabl boundingboxwidth thismodul margin tabl row first cell size thismodul margin height real thismodul allvalidt iter tabl max integ tabl boundingboxheight max max thismodul titlefonts svgfile svg svgfile tag svg svg svg svg size svgsize namespac http www w org svg version svgsize svg dimens width width height height thismodul allvalidt size thismodul svgfile svgfile thismodul svgfile tag viewbox width tostr height tostr tabl thismodul allvalidt cell tabl row first cell seqwithoutfirst thismodul tabl barchart tabl tabl row first cell indexof cell end entrypoint rule svgfile begin lazi rule tabl barchart comment creat bar chart svg group metric column index given lazi rule tabl barchart tabl tabl tabl idx integ g svg g attribut boundingboxtransl groupcont boundingbox groupcont texttitl groupcont axi groupcont tabl row seqwithoutfirst iter row acc sequenc svg g sequenc acc includ thismodul row bar row tabl row indexof row idx tabl scalefactor idx boundingbox svg rect size boundingboxs posit boundingboxcoord fill thismodul fill stroke thismodul stroke boundingboxs svg dimens width tabl boundingboxwidth height tabl boundingboxheight boundingboxcoord svg absolutecoord x tabl maxsizenam thismodul margin thismodul margin boundingboxtransl svg translat tx thismodul prevwidth thismodul margin tabl maxsizenam ty thismodul margin texttitl svg text posit texttitlecoord stroke thismodul stroke fontsiz thismodul titlefonts tostr comment text anchor valu strore lengthadjust attribut lengthadjust middl content tabl row first cell idx content texttitlecoord svg absolutecoord x boundingboxs width tabl maxsizenam boundingboxs height thismodul margin axi svg path m thismodul barmaxwidth thismodul barheight tostr h v tabl row size thismodul barheight tostr z fill thismodul fill stroke thismodul stroke thismodul prevwidth thismodul prevwidth thismodul margin boundingboxs width thismodul svgfile tag children g end lazi rule tabl barchart begin lazi rule row bar comment creat bar svg line cell index given scale factor lazi rule row bar row tabl row rowidx integ cellidx integ scalefactor real g svg g groupcont bar groupcont textcapt bar svg rect size barsiz posit barcoord fill thismodul barpattern stroke thismodul stroke barsiz svg dimens width row cell cellidx realvalu scalefactor height thismodul barheight barcoord svg absolutecoord x rowidx barsiz height textcapt svg text posit textcaptioncoord stroke thismodul stroke fontsiz thismodul fontsiz tostr comment text anchor valu strore lengthadjust attribut lengthadjust end content row cell first content row cell cellidx valu textcaptioncoord svg absolutecoord x thismodul margin barcoord barsiz height end lazi rule row bar,2
119,119,P57-Table2SVGPieChart.atl,"--@atlcompiler	atl2006
--@name			Table2SVGPieChart
--@version		2.1
--@domains		Table, SVG, pie chart
--@authors		Eric Vepa (evepa <at> sodius.com) for SODIUS (www.sodius.com)
--@date			2007/08/28
--@description	This transformation is used to transform generic tables into SVG pie charts. A pie chart is produced for a table with values (excluding the header row and the first cell of each other row, and at least 3 columns).
--@see			Scalable Vector Graphics 1.1, World Wide Web Consortium, http://www.w3.org/TR/SVG11/

module Table2SVGPieChart; -- Module Template
create OUT : SVG from IN : Table;

uses TableHelpers;

--@comments ===================================
--@comments Values used for the SVG rendering =
--@comments ===================================

--@begin attribute helper scale
--@comments The 'scale' value used in the SVG document.
helper def : scale : Real = 1;
--@end attribute helper scale

--@begin attribute helper radius
--@comments The radius value used in the SVG document for a pie chart.
helper def : radius : Real = 100 * thisModule.scale;
--@end attribute helper radius

--@begin attribute helper fill
--@comments The 'fill' value used in the SVG document.
helper def : fill : String = 'none';
--@end attribute helper fill

--@begin attribute helper stroke
--@comments The 'stroke' value used in the SVG document.
helper def : stroke : String = 'black';
--@end attribute helper stroke

--@begin attribute helper margin
--@comments The margin value used in the SVG document between charts.
helper def : margin : Real = 10;
--@end attribute helper margin

--@begin attribute helper titleFontSize
--@comments The 'fontSize' value used for titles in the SVG document.
helper def : titleFontSize : Real = thisModule.radius * 0.2;
--@end attribute helper titleFontSize

--@begin attribute helper fontSize
--@comments The 'fontSize' value used in the SVG document.
helper def : fontSize : Real = thisModule.titleFontSize * 0.8;
--@end attribute helper fontSize

--@begin attribute helper caption
--@comments The value used in the SVG document the caption of one sector.
helper def : caption : Real = thisModule.fontSize;
--@end attribute helper caption

--@begin attribute helper svgFile
--@comments The unique SVG file element.
helper def : svgFile : SVG!SvgFile = OclUndefined;
--@end attribute helper svgFile


--@comments ===============================
--@comments Helpers for the SVG rendering =
--@comments ===============================

--@begin helper maxSizeName
--@comments Returns the maximal size for a name of the cells of the header row (adds 7 characters for the display of the value).
helper context Table!Table
def : maxSizeName() : Real =
	(self.rows.seqWithoutFirst()->iterate(r; maxSize : Integer = 0|
		if r.cells->first().content->size() > maxSize
			then r.cells->first().content->size()
			else maxSize
		endif) + 7 * 2) * (thisModule.fontSize / 2);
--@end helper maxSizeName

--@begin helper boundingBoxWidth
--@comments Returns the width of the bouding box computed for a table.
helper context Table!Table
def : boundingBoxWidth() : Real =
	self.captionBoxWidth() + 2 * thisModule.radius + 3 * thisModule.margin;
--@end helper boundingBoxWidth

--@begin attribute helper prevAngle
--@comments The previous rotation angle of the last sector generated.
helper def : prevAngle : Real = 0;
--@end attribute helper prevAngle

--@begin attribute helper prevWidth
--@comments The previous width of all the charts generated.
helper def : prevWidth : Real = 0;
--@end attribute helper prevWidth

--@begin helper captionBoxWidth
--@comments Returns the width of the caption box for a table.
helper context Table!Table
def : captionBoxWidth() : Real =
	self.maxSizeName() + thisModule.caption + 3 * thisModule.margin;
--@end helper captionBoxWidth

--@begin helper captionBoxHeight
--@comments Returns the height of the caption box for a table.
helper context Table!Table
def : captionBoxHeight() : Real =
	self.rows->size() * (thisModule.caption + thisModule.margin / 2) -
		thisModule.margin / 2;
--@end helper captionBoxHeight

--@begin helper computeColor
--@comments Computes a RGB color with the number of the element and the total number of colors to compute.
helper def : computeColor(idx : Integer, nbColor : Integer) : String =
	let value : Integer =
		(idx * 6 * 255 / nbColor).floor() in
	if value < 255
		then 'rgb(255,255,' + (255 - value).toString() + ')'
		else if value < 2 * 255
				then 'rgb(' + (2 * 255 - value).toString() + ',255,0)'
				else if value < 3 * 255
						then 'rgb(0,255,' + (255 - (3 * 255 - value)).toString() + ')'
						else if value < 4 * 255
								then 'rgb(0,' + (4 * 255 - value).toString() + ',255)'
								else if value < 5 * 255
										then 'rgb(' + (255 - (5 * 255 - value)).toString() + ',0,255)'
										else 'rgb(255,0,' + (6 * 255 - value).toString() + ')'
									endif
							endif
					endif
			endif
	endif;
--@end helper computeColor

--@begin helper ColorByElementName
--@comments Color used by sectors and captions of pie charts for each element.
helper def : ColorByElementName : Map(String,String) = Map{};
--@end helper ColorByElementName


--@begin entrypoint rule SvgFile
--@comments Creates the SVG file with one svg tag.
entrypoint rule SvgFile() {
	using {
		width : Real =
			thisModule.allValidTables->iterate(t; sum : Real = 0|
				sum + (t.captionBoxWidth() +
					2 * thisModule.radius + 4 * thisModule.margin) *
						(t.rows->first().cells->size() - 1)) +
							thisModule.margin;
		height : Real =
			let heightWithoutCaption : Real =
				2 * (thisModule.radius + 2 * thisModule.margin +
					thisModule.titleFontSize) in
			let heightWithCaption : Real =
				thisModule.allValidTables->iterate(t; max : Real = 0|
					t.captionBoxHeight()->max(max)) + 4 * thisModule.margin in
			heightWithoutCaption->max(heightWithCaption);
	}
	to
		svgFile : SVG!SvgFile (
			tag <- svg
		),
		svg : SVG!Svg (
			size <- svgSize,
			namespace <- 'http://www.w3.org/2000/svg',
			version <- '1.1'
		),
		svgSize : SVG!Dimension (
			width <- width,
			height <- height
		)
	do {
		if (thisModule.allValidTables->size() > 0) {
			thisModule.svgFile <- svgFile;
			thisModule.svgFile.tag.viewBox <- '0 0 ' +
				width.toString() + ' ' + height.toString();

			for (table in thisModule.allValidTables) {
				for (elmtName in table.rows->seqWithoutFirst()->
					collect(r|r.cells->first().content)->sortedBy(n|n)) {
					thisModule.ColorByElementName <-
						thisModule.ColorByElementName.including(elmtName,
							thisModule.computeColor(table.rows->seqWithoutFirst()->
								collect(r|r.cells->first().content)->
									sortedBy(n|n)->indexOf(elmtName),
										table.rows->seqWithoutFirst()->
											collect(r|r.cells->first().content)->
												sortedBy(n|n)->size()));
				}
				
				for (cell in table.rows->first().cells->seqWithoutFirst()) {
					thisModule.Table2PieChart(table,
						table.rows->first().cells->indexOf(cell));
				}
			}
		}
	}
}
--@end entrypoint rule SvgFile

--@begin lazy rule Table2PieChart
--@comments Creates a pie chart (SVG group) for the metric which column index is given.
lazy rule Table2PieChart {
	from
		table : Table!Table,
		idx : Integer
	using {
		valuesSum : Real =
			table.rows->seqWithoutFirst()->iterate(row; acc : Real = 0|
				acc + row.cells->at(idx).realValue());
	}
	to
		g : SVG!G (
			attribute <- boundingBoxTransl,
			groupContent <- boundingBox,
			groupContent <- textTitle,
			groupContent <-
				if table.rows->seqWithoutFirst()->
					collect(r|r.cells->at(idx))->
						select(c|c.valueNotNull())->size() = 1
					then thisModule.Table2Circle(table,idx)
					else thisModule.Table2Sectors(table,idx,valuesSum)
				endif,
			groupContent <- thisModule.Table2Captions(table,idx,valuesSum)
		),
		boundingBox : SVG!Rect (
			size <- boundingBoxSize,
			position <- boundingBoxCoord,
			fill <- thisModule.fill,
			stroke <- thisModule.stroke
		),
		boundingBoxSize : SVG!Dimension (
			width <- table.boundingBoxWidth(),
			height <- thisModule.svgFile.tag.size.height -
				2 * thisModule.margin
		),
		boundingBoxCoord : SVG!AbsoluteCoord (
			x <- 0 - boundingBoxSize.width / 2,
			y <- 0 - boundingBoxSize.height / 2
		),
		boundingBoxTransl : SVG!Translate (
			tx <- thisModule.prevWidth + boundingBoxSize.width / 2 +
				thisModule.margin,
			ty <- thisModule.svgFile.tag.size.height / 2
		),
		textTitle : SVG!Text (
			position <- textTitleCoord,
			stroke <- thisModule.stroke,
			fontSize <- thisModule.titleFontSize.toString(),
			--@comments text-anchor value strored in lengthAdjust attribute
			lengthAdjust <- 'middle',
			content <- table.rows->first().cells->at(idx).content
		),
		textTitleCoord : SVG!AbsoluteCoord (
			x <- 0 - (table.captionBoxWidth() + thisModule.margin) / 2,
			y <- (boundingBoxSize.height - thisModule.titleFontSize -
				thisModule.margin) / 2
		)
	do {
		thisModule.prevWidth <-
			thisModule.prevWidth + boundingBoxSize.width + thisModule.margin;
		thisModule.svgFile.tag.children <- g;
		--@comments initialise rotation angle
		thisModule.prevAngle <- 0;
	}
}
--@end lazy rule Table2PieChart

--@begin lazy rule Table2Circle
--@comments Creates a complete pie (SVG Circle) for the metric at index given.
lazy rule Table2Circle {
	from
		table : Table!Cell,
		idx : Integer
	to
		g : SVG!G (
			attribute <- pieTransl,
			groupContent <- pie
		),
		pieTransl : SVG!Translate (
			tx <- 0 - (table.captionBoxWidth() + thisModule.margin) / 2,
			ty <- 0 - thisModule.titleFontSize
		),
		pie : SVG!Circle (
			size <- pieSize,
			position <- pieCoord,
			fill <- thisModule.ColorByElementName.get(table.rows->
				seqWithoutFirst()->select(r|r.cells->at(idx).valueNotNull())->
					first().cells->first().content),
			stroke <- thisModule.stroke
		),
		pieSize : SVG!Dimension (
			width <- thisModule.radius,
			height <- pieSize.width
		),
		pieCoord : SVG!AbsoluteCoord (
			x <- 0,
			y <- 0
		)
}
--@end lazy rule Table2Circle

--@begin lazy rule Table2Sectors
--@comments Creates a pie with sectors (SVG paths) for the metric at index given.
lazy rule Table2Sectors {
	from
		table : Table!Table,
		idx : Integer,
		valuesSum : Real
	to
		g : SVG!G (
			attribute <- sectorsTransl,
			groupContent <- table.rows->seqWithoutFirst()->
				collect(row|thisModule.Row2Sector(row,
					table.rows->indexOf(row),idx,valuesSum))
		),
		sectorsTransl : SVG!Translate (
			tx <- 0 - (table.captionBoxWidth() + thisModule.margin) / 2,
			ty <- 0 - thisModule.titleFontSize
		)
}
--@end lazy rule Table2Sectors

--@begin lazy rule Row2Sector
--@comments Creates a sector (SVG path) for the cell at index given.
lazy rule Row2Sector {
	from
		row : Table!Row,
		rowIdx : Integer,
		cellIdx : Integer,
		valuesSum : Real
	using {
		value : Real =
			if valuesSum = 0
				then 0
				else row.cells->at(cellIdx).realValue() / valuesSum * 100
			endif;
		x : Real =
			thisModule.radius * (value * 3.6).toRadians().cos();
		y : Real =
			thisModule.radius * (value * 3.6).toRadians().sin();
	}
	to
		g : SVG!G (
			attribute <- sectorRotate,
			groupContent <- sector
		),
		sectorRotate : SVG!Rotate (
			angle <- thisModule.prevAngle
		),
		sector : SVG!Path (
			d <- 'M0,0 L' + thisModule.radius.toString() + ',0 ' +
				'A' + thisModule.radius.toString() + ',' +
					thisModule.radius.toString() + ' 0 ' +
						if 3.6 * value < 180
							then '0,1 '
							else '1,1 '
						endif +	x.toString() + ',' + y.toString() + ' z',
			fill <- thisModule.ColorByElementName.get(row.cells->
				first().content),
			stroke <- thisModule.stroke
		)
	do {
		--@comments Adds the angle value of the new sector.
		thisModule.prevAngle <- sectorRotate.angle + 3.6 * value;
	}
}
--@end lazy rule Row2Sector

--@begin lazy rule Table2Captions
--@comments Creates captions (SVG rect) for a table.
lazy rule Table2Captions {
	from
		table : Table!Cell,
		idx : Integer,
		valuesSum : Real
	to
		g : SVG!G (
			groupContent <- captionBox,
			groupContent <- table.rows.seqWithoutFirst()->
				collect(row|thisModule.Table2Caption(table,
					table.rows->indexOf(row),idx,valuesSum))
		),
		captionBox : SVG!Rect (
			size <- captionBoxSize,
			position <- captionBoxCoord,
			fill <- thisModule.fill,
			stroke <- thisModule.stroke
		),
		captionBoxSize : SVG!Dimension (
			width <- table.captionBoxWidth(),
			height <- table.captionBoxHeight()
		),
		captionBoxCoord : SVG!AbsoluteCoord (
			x <- thisModule.radius -
				(captionBoxSize.width - thisModule.margin) / 2,
			y <- 0 - captionBoxSize.height / 2
		)
}
--@end lazy rule Table2Captions

--@begin lazy rule Table2Caption
--@comments Creates a caption (SVG rect + text) for the cell at index given.
lazy rule Table2Caption {
	from
		table : Table!Table,
		rowIdx : Integer,
		cellIdx : Integer,
		valuesSum : Real
	using {
		value : String =
			let realValue : Real =
				if valuesSum = 0
					then 0
					else table.rows->at(rowIdx).cells->at(cellIdx).realValue() /
						valuesSum * 100
				endif in
			realValue.toString().value() + '%';
	}
	to
		g : SVG!G (
			groupContent <- caption,
			groupContent <- textCaption
		),
		caption : SVG!Rect (
			size <- captionSize,
			position <- captionCoord,
			fill <- thisModule.ColorByElementName.get(table.rows->
				at(rowIdx).cells->first().content),
			stroke <- thisModule.stroke
		),
		captionSize : SVG!Dimension (
			width <- thisModule.caption,
			height <- thisModule.caption
		),
		captionCoord : SVG!AbsoluteCoord (
			x <- (table.boundingBoxWidth() + thisModule.margin) / 2 -
				thisModule.margin - table.captionBoxWidth(),
			y <- (0 - table.captionBoxHeight()) / 2 - thisModule.margin +
				(rowIdx - 1) * (thisModule.caption + thisModule.margin / 2)
		),
		textCaption : SVG!Text (
			position <- textCaptionCoord,
			stroke <- thisModule.stroke,
			fontSize <- thisModule.fontSize.toString(),
			content <- '(' + value + ') ' +
				table.rows->at(rowIdx).cells->first().content +	' (' +
					table.rows->at(rowIdx).cells->at(cellIdx).value() +	')'
		),
		textCaptionCoord : SVG!AbsoluteCoord (
			x <- captionCoord.x + thisModule.caption + thisModule.fontSize,
			y <- captionCoord.y + thisModule.caption -
				thisModule.fontSize * 0.1
		)
}
--@end lazy rule Table2Caption",atlcompil atl name tabl svgpiechart version domain tabl svg pie chart author eric vepa evepa sodius com sodius www sodius com date descript this transform use transform generic tabl svg pie chart a pie chart produc tabl valu exclud header row first cell row least column see scalabl vector graphic world wide web consortium http www w org tr svg modul tabl svgpiechart modul templat creat out svg in tabl use tablehelp comment comment valu use svg render comment begin attribut helper scale comment the scale valu use svg document helper def scale real end attribut helper scale begin attribut helper radius comment the radius valu use svg document pie chart helper def radius real thismodul scale end attribut helper radius begin attribut helper fill comment the fill valu use svg document helper def fill string none end attribut helper fill begin attribut helper stroke comment the stroke valu use svg document helper def stroke string black end attribut helper stroke begin attribut helper margin comment the margin valu use svg document chart helper def margin real end attribut helper margin begin attribut helper titlefonts comment the fontsiz valu use titl svg document helper def titlefonts real thismodul radius end attribut helper titlefonts begin attribut helper fontsiz comment the fontsiz valu use svg document helper def fontsiz real thismodul titlefonts end attribut helper fontsiz begin attribut helper caption comment the valu use svg document caption one sector helper def caption real thismodul fontsiz end attribut helper caption begin attribut helper svgfile comment the uniqu svg file element helper def svgfile svg svgfile oclundefin end attribut helper svgfile comment comment helper svg render comment begin helper maxsizenam comment return maxim size name cell header row add charact display valu helper context tabl tabl def maxsizenam real self row seqwithoutfirst iter r maxsiz integ r cell first content size maxsiz r cell first content size els maxsiz endif thismodul fontsiz end helper maxsizenam begin helper boundingboxwidth comment return width boud box comput tabl helper context tabl tabl def boundingboxwidth real self captionboxwidth thismodul radius thismodul margin end helper boundingboxwidth begin attribut helper prevangl comment the previous rotat angl last sector generat helper def prevangl real end attribut helper prevangl begin attribut helper prevwidth comment the previous width chart generat helper def prevwidth real end attribut helper prevwidth begin helper captionboxwidth comment return width caption box tabl helper context tabl tabl def captionboxwidth real self maxsizenam thismodul caption thismodul margin end helper captionboxwidth begin helper captionboxheight comment return height caption box tabl helper context tabl tabl def captionboxheight real self row size thismodul caption thismodul margin thismodul margin end helper captionboxheight begin helper computecolor comment comput rgb color number element total number color comput helper def computecolor idx integ nbcolor integ string let valu integ idx nbcolor floor valu rgb valu tostr els valu rgb valu tostr els valu rgb valu tostr els valu rgb valu tostr els valu rgb valu tostr els rgb valu tostr endif endif endif endif endif end helper computecolor begin helper colorbyelementnam comment color use sector caption pie chart element helper def colorbyelementnam map string string map end helper colorbyelementnam begin entrypoint rule svgfile comment creat svg file one svg tag entrypoint rule svgfile use width real thismodul allvalidt iter sum real sum captionboxwidth thismodul radius thismodul margin row first cell size thismodul margin height real let heightwithoutcapt real thismodul radius thismodul margin thismodul titlefonts let heightwithcapt real thismodul allvalidt iter max real captionboxheight max max thismodul margin heightwithoutcapt max heightwithcapt svgfile svg svgfile tag svg svg svg svg size svgsize namespac http www w org svg version svgsize svg dimens width width height height thismodul allvalidt size thismodul svgfile svgfile thismodul svgfile tag viewbox width tostr height tostr tabl thismodul allvalidt elmtnam tabl row seqwithoutfirst collect r r cell first content sortedbi n n thismodul colorbyelementnam thismodul colorbyelementnam includ elmtnam thismodul computecolor tabl row seqwithoutfirst collect r r cell first content sortedbi n n indexof elmtnam tabl row seqwithoutfirst collect r r cell first content sortedbi n n size cell tabl row first cell seqwithoutfirst thismodul tabl piechart tabl tabl row first cell indexof cell end entrypoint rule svgfile begin lazi rule tabl piechart comment creat pie chart svg group metric column index given lazi rule tabl piechart tabl tabl tabl idx integ use valuessum real tabl row seqwithoutfirst iter row acc real acc row cell idx realvalu g svg g attribut boundingboxtransl groupcont boundingbox groupcont texttitl groupcont tabl row seqwithoutfirst collect r r cell idx select c c valuenotnul size thismodul tabl circl tabl idx els thismodul tabl sector tabl idx valuessum endif groupcont thismodul tabl caption tabl idx valuessum boundingbox svg rect size boundingboxs posit boundingboxcoord fill thismodul fill stroke thismodul stroke boundingboxs svg dimens width tabl boundingboxwidth height thismodul svgfile tag size height thismodul margin boundingboxcoord svg absolutecoord x boundingboxs width boundingboxs height boundingboxtransl svg translat tx thismodul prevwidth boundingboxs width thismodul margin ty thismodul svgfile tag size height texttitl svg text posit texttitlecoord stroke thismodul stroke fontsiz thismodul titlefonts tostr comment text anchor valu strore lengthadjust attribut lengthadjust middl content tabl row first cell idx content texttitlecoord svg absolutecoord x tabl captionboxwidth thismodul margin boundingboxs height thismodul titlefonts thismodul margin thismodul prevwidth thismodul prevwidth boundingboxs width thismodul margin thismodul svgfile tag children g comment initialis rotat angl thismodul prevangl end lazi rule tabl piechart begin lazi rule tabl circl comment creat complet pie svg circl metric index given lazi rule tabl circl tabl tabl cell idx integ g svg g attribut pietransl groupcont pie pietransl svg translat tx tabl captionboxwidth thismodul margin ty thismodul titlefonts pie svg circl size piesiz posit piecoord fill thismodul colorbyelementnam get tabl row seqwithoutfirst select r r cell idx valuenotnul first cell first content stroke thismodul stroke piesiz svg dimens width thismodul radius height piesiz width piecoord svg absolutecoord x end lazi rule tabl circl begin lazi rule tabl sector comment creat pie sector svg path metric index given lazi rule tabl sector tabl tabl tabl idx integ valuessum real g svg g attribut sectorstransl groupcont tabl row seqwithoutfirst collect row thismodul row sector row tabl row indexof row idx valuessum sectorstransl svg translat tx tabl captionboxwidth thismodul margin ty thismodul titlefonts end lazi rule tabl sector begin lazi rule row sector comment creat sector svg path cell index given lazi rule row sector row tabl row rowidx integ cellidx integ valuessum real use valu real valuessum els row cell cellidx realvalu valuessum endif x real thismodul radius valu toradian cos real thismodul radius valu toradian sin g svg g attribut sectorrot groupcont sector sectorrot svg rotat angl thismodul prevangl sector svg path m l thismodul radius tostr a thismodul radius tostr thismodul radius tostr valu els endif x tostr tostr z fill thismodul colorbyelementnam get row cell first content stroke thismodul stroke comment add angl valu new sector thismodul prevangl sectorrot angl valu end lazi rule row sector begin lazi rule tabl caption comment creat caption svg rect tabl lazi rule tabl caption tabl tabl cell idx integ valuessum real g svg g groupcont captionbox groupcont tabl row seqwithoutfirst collect row thismodul tabl caption tabl tabl row indexof row idx valuessum captionbox svg rect size captionboxs posit captionboxcoord fill thismodul fill stroke thismodul stroke captionboxs svg dimens width tabl captionboxwidth height tabl captionboxheight captionboxcoord svg absolutecoord x thismodul radius captionboxs width thismodul margin captionboxs height end lazi rule tabl caption begin lazi rule tabl caption comment creat caption svg rect text cell index given lazi rule tabl caption tabl tabl tabl rowidx integ cellidx integ valuessum real use valu string let realvalu real valuessum els tabl row rowidx cell cellidx realvalu valuessum endif realvalu tostr valu g svg g groupcont caption groupcont textcapt caption svg rect size captions posit captioncoord fill thismodul colorbyelementnam get tabl row rowidx cell first content stroke thismodul stroke captions svg dimens width thismodul caption height thismodul caption captioncoord svg absolutecoord x tabl boundingboxwidth thismodul margin thismodul margin tabl captionboxwidth tabl captionboxheight thismodul margin rowidx thismodul caption thismodul margin textcapt svg text posit textcaptioncoord stroke thismodul stroke fontsiz thismodul fontsiz tostr content valu tabl row rowidx cell first content tabl row rowidx cell cellidx valu textcaptioncoord svg absolutecoord x captioncoord x thismodul caption thismodul fontsiz captioncoord thismodul caption thismodul fontsiz end lazi rule tabl caption,2
120,120,P57-Table2TabularHTML.atl,"--@atlcompiler	atl2006
--@name			Table2TabularHTML
--@version		2.0
--@domains		Table, HTML
--@authors		Eric Vepa (evepa <at> sodius.com) for SODIUS (www.sodius.com)
--@date			2007/06/04
--@description	This transformation is used to transform generic tables into a HTML model with tables.

module Table2TabularHTML; -- Module Template
create OUT : HTML from IN : Table;

uses TableHelpers;

--@begin attribute helper html
--@comments The unique HTML tag.
helper def : html : HTML!HTML = OclUndefined;
--@end attribute helper html

--@begin entrypoint rule HTML
--@comments Creates the unique HTML, HEAD, TITLE and BODY tags.
entrypoint rule HTML() {
	to
		html : HTML!HTML (
			head <- head,
			body <- body
		),
		head : HTML!HEAD (
			headElements <- title
		),
		title : HTML!TITLE (
			value <- ''
		),
		body : HTML!BODY
	do {
		thisModule.html <- html;
	}
}
--@end entrypoint rule HTML

--@begin rule Table2TABLE
rule Table2TABLE {
	from
		table : Table!Table (
			table.rows->size() > 0
		)
	to
		tab : HTML!TABLE (
			border <- '1',
			trs <- thisModule.Row2TRwithTH(table.rows->first()),
			trs <- table.rows->subSequence(2,table.rows->size())->
				collect(row|thisModule.Row2TRwithTD(row))
		)
	do {
		thisModule.html.body.bodyElements <- tab;
	}
}
--@end rule Table2TABLE

--@begin lazy rule Row2TRwithTH
lazy rule Row2TRwithTH {
	from
		row : Table!Row
	to
		tr : HTML!TR (
			tds <- row.cells->
				collect(cell|thisModule.Cell2TH(cell))
		)
}
--@end lazy rule Row2TRwithTH

--@begin lazy rule Cell2TH
lazy rule Cell2TH {
	from
		cell : Table!Cell
	to
		th : HTML!TH (
			value <- cell.value()
		)
}
--@end lazy rule Cell2TH

--@begin lazy rule Row2TRwithTD
lazy rule Row2TRwithTD {
	from
		row : Table!Row
	to
		tr : HTML!TR (
			tds <- thisModule.Cell2TD(row.cells->first()),
			tds <- row.cells->subSequence(2,row.cells->size())->
				collect(cell|thisModule.Cell2TDRightAlign(cell))
		)
}
--@end lazy rule Row2TRwithTD

--@begin lazy rule Cell2TD
lazy rule Cell2TD {
	from
		cell : Table!Cell
	to
		td : HTML!TD (
			value <- cell.value()
		)
}
--@end lazy rule Cell2TD

--@begin lazy rule Cell2TDRightAlign
lazy rule Cell2TDRightAlign {
	from
		cell : Table!Cell
	to
		td : HTML!TD (
			value <- cell.value(),
			align <- 'right'
		)
}
--@end lazy rule Cell2TDRightAlign",atlcompil atl name tabl tabularhtml version domain tabl html author eric vepa evepa sodius com sodius www sodius com date descript this transform use transform generic tabl html model tabl modul tabl tabularhtml modul templat creat out html in tabl use tablehelp begin attribut helper html comment the uniqu html tag helper def html html html oclundefin end attribut helper html begin entrypoint rule html comment creat uniqu html head titl bodi tag entrypoint rule html html html html head head bodi bodi head html head headel titl titl html titl valu bodi html bodi thismodul html html end entrypoint rule html begin rule tabl tabl rule tabl tabl tabl tabl tabl tabl row size tab html tabl border trs thismodul row trwithth tabl row first trs tabl row subsequ tabl row size collect row thismodul row trwithtd row thismodul html bodi bodyel tab end rule tabl tabl begin lazi rule row trwithth lazi rule row trwithth row tabl row tr html tr tds row cell collect cell thismodul cell th cell end lazi rule row trwithth begin lazi rule cell th lazi rule cell th cell tabl cell th html th valu cell valu end lazi rule cell th begin lazi rule row trwithtd lazi rule row trwithtd row tabl row tr html tr tds thismodul cell td row cell first tds row cell subsequ row cell size collect cell thismodul cell tdrightalign cell end lazi rule row trwithtd begin lazi rule cell td lazi rule cell td cell tabl cell td html td valu cell valu end lazi rule cell td begin lazi rule cell tdrightalign lazi rule cell tdrightalign cell tabl cell td html td valu cell valu align right end lazi rule cell tdrightalign,12
121,121,P57-UML22Measure.atl,"--@atlcompiler	atl2006
--@name			UML22Measure
--@version		1.1
--@domains		UML2, measurement data, metrics
--@authors		Eric Vepa (evepa <at> sodius.com) for SODIUS (www.sodius.com)
--@date			2007/08/02
--@description	This transformation is used to collect measurement data on a UML2 model, using libraries implementing some metrics (MOOD, MOOD2, MOOSE, EMOOSE  and QMOOD).
--@see			Baroni, A.L.: Formal Definition of Object-Oriented Design Metrics. Master Thesis, Vrije University, Brussel, Belgium, 2002.

module UML22Measure; -- Module Template
create OUT : Measure from IN : UML2;

uses FLAME4UML2;
uses MOOD4UML2;
uses EMOOSE4UML2;
uses QMOOD4UML2;

--@begin attribute helpers measureLevel
--@comments Defines the measure level among {#package,#class}. 
--@comments The package level allows measures on packages.
--@comments The class level allows measures on packages and classes.
helper def : measureLevel : Measure!ElementKind = #class;
--@end attribute helper measureLevel

--@begin attribute helper root
--@comments The root measure set.
helper def : root : Measure!RootMeasureSet = OclUndefined;
--@end attribute helper root

--@begin attribute helper MetricByName
--@comments The map of metrics by name.
helper def : MetricByName : Map(String, Measure!Metric) = Map{};
--@end attribute helper MetricByName

--@begin helper defaultName
--@comments Returns the name of the named element or ""Anonymous"".
helper context UML2!NamedElement
def : defaultName() : String =
	if self.name.oclIsUndefined()
		then 'Anonymous'
		else self.name
	endif;
--@end helper defaultName

--@begin entrypoint rule Metrics
--@comments Registers the MOOD, MOOD2, MOOSE, EMOOSE  and QMOOD metrics implemented in libraries.
entrypoint rule Metrics() {
	to
		root : Measure!RootMeasureSet (
			modelType <- #UML2
		)
	do {
		thisModule.root <- root;
		
		if ((thisModule.measureLevel = #package) or
			(thisModule.measureLevel = #class)) {
			-- ==================================================
			-- MOOD Metrics : Intra-Specification Level Metrics =
			-- ==================================================
			root.categories <- thisModule.Category('MOOD',
					'Metrics for Object-Oriented Design');
			thisModule.Metric('MOOD','AIF','Attributes Inheritance Factor');
			thisModule.Metric('MOOD','OIF','Operations Inheritance Factor');
			thisModule.Metric('MOOD','AHF','Attributes Hiding Factor');
			thisModule.Metric('MOOD','OHF','Operations Hiding Factor');
			thisModule.Metric('MOOD','BPF','Behavioral Polymorphism Factor');
			thisModule.Metric('MOOD','CCF','Class Coupling Factor');
			thisModule.Metric('MOOD','ICF','Internal Coupling Factor');
				
			-- ===================================================
			-- MOOD2 Metrics : Intra-Specification Level Metrics =
			-- ===================================================
			root.categories <- thisModule.Category('MOOD2',
				'Metrics for Object-Oriented Design 2');
			thisModule.Metric('MOOD2','IIF','Internal Inheritance Factor');
			thisModule.Metric('MOOD2','AHEF',
				'Attributes Hiding Effectiveness Factor');
			thisModule.Metric('MOOD2','OHEF',
				'Operations Hiding Effectiveness Factor');
		}
		
		if (thisModule.measureLevel = #class) {
			-- ===============
			-- MOOSE Metrics =
			-- ===============
			root.categories <- thisModule.Category('MOOSE',
				'Metrics for Object-Oriented Software Engineering');
			thisModule.Metric('MOOSE','DIT','Depth of Inheritance Tree');
			thisModule.Metric('MOOSE','NOC','Number of Children');
			thisModule.Metric('MOOSE','CBO','Coupling Between Objects');
			thisModule.Metric('MOOSE','RFC','Response for a Class');
		
			-- ================
			-- EMOOSE Metrics =
			-- ================
			root.categories <- thisModule.Category('EMOOSE','Extended MOOSE');
			thisModule.Metric('EMOOSE','SIZE2','Number of local Attributes ' +
				'and Operations defined in the Class');
		}
		
		if ((thisModule.measureLevel = #package) or
			(thisModule.measureLevel = #class)) {
			-- ===============
			-- QMOOD Metrics =
			-- ===============
			root.categories <- thisModule.Category('QMOOD',
				'Quality Model for Object-Oriented Design');
			thisModule.Metric('QMOOD','DSC','Design Size in Classes');
			thisModule.Metric('QMOOD','NOH','Number of Hierarchies');
			thisModule.Metric('QMOOD','NIC','Number of Independent Classes');
			thisModule.Metric('QMOOD','NSI','Number of Single Inheritance');
			thisModule.Metric('QMOOD','NNC','Number of Internal Classes');
			thisModule.Metric('QMOOD','NAC','Number of Abstract Classes');
			thisModule.Metric('QMOOD','NLC','Number of Leaf Classes');
			thisModule.Metric('QMOOD','ADI','Average Depth of Inheritance');
			thisModule.Metric('QMOOD','AWI','Average Width of Inheritance');
			thisModule.Metric('QMOOD','ANA','Average Number of Ancestors');
		}			
		
		if (thisModule.measureLevel = #class) {
			thisModule.Metric('QMOOD','MFA',
				'Measure of Functional Abstraction');
			thisModule.Metric('QMOOD','MAA','Measure of Attribute Abstraction');
			thisModule.Metric('QMOOD','MAT','Measure of Abstraction');
			thisModule.Metric('QMOOD','MOA','Measure of Aggregation');
			thisModule.Metric('QMOOD','MRM','Modeled Relationship Measure');
			thisModule.MetricWithPreferredValue('QMOOD','DAM','Data Access Metric','>75');
			thisModule.MetricWithPreferredValue('QMOOD','OAM','Operation Access Metric','>75');
			thisModule.MetricWithPreferredValue('QMOOD','MAM','Member Access Metric','>75');
			thisModule.Metric('QMOOD','NOA','Number of Ancestors');
			thisModule.Metric('QMOOD','NOM','Number of Methods');
			thisModule.Metric('QMOOD','CIS','Class Interface Size');
			thisModule.Metric('QMOOD','NPT','Number of Unique Parameter Types');
			thisModule.Metric('QMOOD','NPM','Number of Parameters per Method');
			thisModule.Metric('QMOOD','NOD','Number of Attributes');
			thisModule.Metric('QMOOD','NAD','Number of Abstract Data Types');
			thisModule.Metric('QMOOD','NPA','Number of Public Attributes');
			thisModule.Metric('QMOOD','CSM','Class Size Metric');
			thisModule.Metric('QMOOD','CAM','Cohesion Among Methods of Class');
			thisModule.Metric('QMOOD','DCC','Direct Class Coupling');
			thisModule.Metric('QMOOD','MCC','Maximum Class Coupling');
			thisModule.Metric('QMOOD','DAC','Direct Attribute Based Coupling');
			thisModule.Metric('QMOOD','DPC','Direct Parameter Based Coupling');
			thisModule.Metric('QMOOD','MPC','Maximum Parameter Based Coupling');
			thisModule.Metric('QMOOD','CCD','Class Complexity Based on Data');
			thisModule.Metric('QMOOD','CCP',
				'Class Complexity Based on Method Parameters');
			thisModule.Metric('QMOOD','CCM',
				'Class Complexity Based on Members');
		}
	}
}
--@end entrypoint rule Metrics

--@begin  rule Package2MeasureSet
--@comments Collects measurement data on the model (default package) or a package (measureLevel must be set to #package or #class).
rule Package2MeasureSet {
	from
		ne : UML2!Package (
			(ne.oclIsTypeOf(UML2!Package) or ne.oclIsTypeOf(UML2!Model)) and
			((thisModule.measureLevel = #package) or
			(thisModule.measureLevel = #class))
		)
	to
		ms : Measure!MeasureSet (
			elementName <-
				if ne.CN() > 0
					then ne.defaultName().debug('Processing metrics on package')
					else ne.defaultName()
				endif,
	   		elementType <-
				if (ne.oclIsTypeOf(UML2!Model))
		   			then #model
					else #package
				endif,
			subsets <- ne.contents,
			subsets <- ne.allClasses->collect(c|thisModule.Class2MeasureSet(c))
		)
	do {
		if (ne.oclIsTypeOf(UML2!Model)) {
			thisModule.root.measureSets <- ms;
		}
		
		if (ne.CN() > 0) {
			-- ==================================================
			-- MOOD Metrics : Intra-Specification Level Metrics =
			-- ==================================================
			ms.measures <- thisModule.PercentageMeasure('AIF',ne.AIF());
			ms.measures <- thisModule.PercentageMeasure('OIF',ne.OIF());
			ms.measures <- thisModule.PercentageMeasure('AHF',ne.AHF());
			ms.measures <- thisModule.PercentageMeasure('OHF',ne.OHF());
			ms.measures <- thisModule.PercentageMeasure('BPF',ne.BPF());
			ms.measures <- thisModule.PercentageMeasure('CCF',ne.CCF());
			ms.measures <- thisModule.PercentageMeasure('ICF',ne.ICF());
				
			-- =============================================================
			-- MOOD2 Metrics : Intra and Inter-Specification Level Metrics =
			-- =============================================================
			ms.measures <- thisModule.PercentageMeasure('IIF',ne.IIF());
			ms.measures <- thisModule.PercentageMeasure('AHEF',ne.AHEF());
			ms.measures <- thisModule.PercentageMeasure('OHEF',ne.OHEF());
		
			-- ===============
			-- QMOOD Metrics =
			-- ===============
			ms.measures <- thisModule.IntegerMeasure('DSC',ne.DSC());
			ms.measures <- thisModule.IntegerMeasure('NOH',ne.NOH());
			ms.measures <- thisModule.IntegerMeasure('NIC',ne.NIC());
			ms.measures <- thisModule.IntegerMeasure('NSI',ne.NSI());
			ms.measures <- thisModule.IntegerMeasure('NNC',ne.NNC());
			ms.measures <- thisModule.IntegerMeasure('NAC',ne.NAC());
			ms.measures <- thisModule.IntegerMeasure('NLC',ne.NLC());
			ms.measures <- thisModule.DoubleMeasure('ADI',ne.ADI());
			ms.measures <- thisModule.DoubleMeasure('AWI',ne.AWI());
			ms.measures <- thisModule.DoubleMeasure('ANA',ne.ANA());
		}
	}
}
--@end rule Package2MeasureSet

--@begin lazy rule Class2MeasureSet
--@comments Collects measurement data on a class (measureLevel must be set to #class).
lazy rule Class2MeasureSet {
	from
		ne : UML2!Class (
			ne.oclIsTypeOf(UML2!Class) and
			thisModule.measureLevel = #class
		)
	to
		ms : Measure!MeasureSet (
			elementName <- ne.defaultName().debug('Processing metrics on class'),
	   		elementType <- #class,
			subsets <- ne.nestedClassifier
		)
	do {
		-- ===============
		-- MOOSE Metrics =
		-- ===============
		ms.measures <- thisModule.IntegerMeasure('DIT',ne.DIT());
		ms.measures <- thisModule.IntegerMeasure('NOC',ne.NOC());
		ms.measures <- thisModule.IntegerMeasure('CBO',ne.CBO());
		ms.measures <- thisModule.IntegerMeasure('RFC',ne.RFC());
	
		-- ================
		-- EMOOSE Metrics =
		-- ================
		ms.measures <- thisModule.IntegerMeasure('SIZE2',ne.SIZE2());
		
		-- ===============
		-- QMOOD Metrics =
		-- ===============
		ms.measures <- thisModule.PercentageMeasure('MFA',ne.MFA());
		ms.measures <- thisModule.PercentageMeasure('MAA',ne.MAA());
		ms.measures <- thisModule.PercentageMeasure('MAT',ne.MAT());
		ms.measures <- thisModule.IntegerMeasure('MOA',ne.MOA());
		ms.measures <- thisModule.IntegerMeasure('MRM',ne.MRM());
		ms.measures <- thisModule.PercentageMeasure('DAM',ne.DAM());
		ms.measures <- thisModule.PercentageMeasure('OAM',ne.OAM());
		ms.measures <- thisModule.PercentageMeasure('MAM',ne.MAM());
		ms.measures <- thisModule.IntegerMeasure('NOA',ne.NOA());
		ms.measures <- thisModule.IntegerMeasure('NOM',ne.NOM());
		ms.measures <- thisModule.IntegerMeasure('CIS',ne.CIS());
		ms.measures <- thisModule.IntegerMeasure('NPT',ne.NPT());
		ms.measures <- thisModule.DoubleMeasure('NPM',ne.NPM());
		ms.measures <- thisModule.IntegerMeasure('NOD',ne.NOD());
		ms.measures <- thisModule.IntegerMeasure('NAD',ne.NAD());
		ms.measures <- thisModule.IntegerMeasure('NPA',ne.NPA());
		ms.measures <- thisModule.IntegerMeasure('CSM',ne.CSM());
		ms.measures <- thisModule.DoubleMeasure('CAM',ne.CAM());
		ms.measures <- thisModule.IntegerMeasure('DCC',ne.DCC());
		ms.measures <- thisModule.IntegerMeasure('MCC',ne.MCC());
		ms.measures <- thisModule.IntegerMeasure('DAC',ne.DAC());
		ms.measures <- thisModule.IntegerMeasure('DPC',ne.DPC());
		ms.measures <- thisModule.IntegerMeasure('MPC',ne.MPC());
		ms.measures <- thisModule.IntegerMeasure('CCD',ne.CCD());
		ms.measures <- thisModule.IntegerMeasure('CCP',ne.CCP());
		ms.measures <- thisModule.IntegerMeasure('CCM',ne.CCM());
	}
}
--@end lazy rule Class2MeasureSet
		
--@begin called rule Category
--@comments Creates a category for metric classification with a name and a description.
rule Category(name : String, desc : String) {
	to
		cat : Measure!Category (
			name <- name,
			desc <- desc
		)
	do {
		cat;
	}
}
--@end called rule Category
		
--@begin called rule Metric
--@comments Creates a metric for a category with a name and a description (the default preferred value for the metric is set to not equal to zero ['!=0']).
rule Metric(catName : String, name : String, desc : String) {
	to
		metric : Measure!Metric (
			name <- name,
			desc <- desc,
			preferredValue <- '!=0',
			category <- thisModule.root.categories->
				select(cat|cat.name = catName)->first()
		)
	do {
		thisModule.MetricByName <-
			thisModule.MetricByName.including(metric.name,metric);
	}
}
--@end called rule Metric
		
--@begin called rule MetricWithPreferredValue
--@comments Creates a metric for a category with a name, a description and a preferred value for the metric (an operator [<, <=, =, !=, >=, >] followed by a number).
rule MetricWithPreferredValue(catName : String, name : String, desc : String, preferredValue : String) {
	to
		metric : Measure!Metric (
			name <- name,
			desc <- desc,
			preferredValue <- preferredValue,
			category <- thisModule.root.categories->
				select(cat|cat.name = catName)->first()
		)
	do {
		thisModule.MetricByName <-
			thisModule.MetricByName.including(metric.name,metric);
	}
}
--@end called rule MetricWithPreferredValue
		
--@begin called rule IntegerMeasure
--@comments Stores an Integer measure for the metric which name and value are given.
rule IntegerMeasure(name : String, value : Integer) {
	to
		meas : Measure!IntegerMeasure (
			metric <- thisModule.MetricByName.get(name),
			value <- value
		)
	do {
		meas;
	}
}
--@end called rule IntegerMeasure
		
--@begin called rule DoubleMeasure
--@comments Stores a Double measure for the metric which name and value are given.
rule DoubleMeasure(name : String, value : Real) {
	to
		meas : Measure!DoubleMeasure (
			metric <- thisModule.MetricByName.get(name),
			value <- value
		)
	do {
		meas;
	}
}
--@end called rule DoubleMeasure
		
--@begin called rule PercentageMeasure
--@comments Stores a Percentage measure for the metric which name and value are given.
rule PercentageMeasure(name : String, value : Real) {
	to
		meas : Measure!PercentageMeasure (
			metric <- thisModule.MetricByName.get(name),
			value <- value
		)
	do {
		meas;
	}
}
--@end called rule PercentageMeasure",atlcompil atl name uml measur version domain uml measur data metric author eric vepa evepa sodius com sodius www sodius com date descript this transform use collect measur data uml model use librari implement metric mood mood moos emoos qmood see baroni a l formal definit object orient design metric master thesi vrije univers brussel belgium modul uml measur modul templat creat out measur in uml use flame uml use mood uml use emoos uml use qmood uml begin attribut helper measurelevel comment defin measur level among packag class comment the packag level allow measur packag comment the class level allow measur packag class helper def measurelevel measur elementkind class end attribut helper measurelevel begin attribut helper root comment the root measur set helper def root measur rootmeasureset oclundefin end attribut helper root begin attribut helper metricbynam comment the map metric name helper def metricbynam map string measur metric map end attribut helper metricbynam begin helper defaultnam comment return name name element anonym helper context uml namedel def defaultnam string self name oclisundefin anonym els self name endif end helper defaultnam begin entrypoint rule metric comment regist mood mood moos emoos qmood metric implement librari entrypoint rule metric root measur rootmeasureset modeltyp uml thismodul root root thismodul measurelevel packag thismodul measurelevel class mood metric intra specif level metric root categori thismodul categori mood metric object orient design thismodul metric mood aif attribut inherit factor thismodul metric mood oif oper inherit factor thismodul metric mood ahf attribut hide factor thismodul metric mood ohf oper hide factor thismodul metric mood bpf behavior polymorph factor thismodul metric mood ccf class coupl factor thismodul metric mood icf intern coupl factor mood metric intra specif level metric root categori thismodul categori mood metric object orient design thismodul metric mood iif intern inherit factor thismodul metric mood ahef attribut hide effect factor thismodul metric mood ohef oper hide effect factor thismodul measurelevel class moos metric root categori thismodul categori moos metric object orient softwar engin thismodul metric moos dit depth inherit tree thismodul metric moos noc number children thismodul metric moos cbo coupl between object thismodul metric moos rfc respons class emoos metric root categori thismodul categori emoos extend moos thismodul metric emoos size number local attribut oper defin class thismodul measurelevel packag thismodul measurelevel class qmood metric root categori thismodul categori qmood qualiti model object orient design thismodul metric qmood dsc design size class thismodul metric qmood noh number hierarchi thismodul metric qmood nic number independ class thismodul metric qmood nsi number singl inherit thismodul metric qmood nnc number intern class thismodul metric qmood nac number abstract class thismodul metric qmood nlc number leaf class thismodul metric qmood adi averag depth inherit thismodul metric qmood awi averag width inherit thismodul metric qmood ana averag number ancestor thismodul measurelevel class thismodul metric qmood mfa measur function abstract thismodul metric qmood maa measur attribut abstract thismodul metric qmood mat measur abstract thismodul metric qmood moa measur aggreg thismodul metric qmood mrm model relationship measur thismodul metricwithpreferredvalu qmood dam data access metric thismodul metricwithpreferredvalu qmood oam oper access metric thismodul metricwithpreferredvalu qmood mam member access metric thismodul metric qmood noa number ancestor thismodul metric qmood nom number method thismodul metric qmood cis class interfac size thismodul metric qmood npt number uniqu paramet type thismodul metric qmood npm number paramet per method thismodul metric qmood nod number attribut thismodul metric qmood nad number abstract data type thismodul metric qmood npa number public attribut thismodul metric qmood csm class size metric thismodul metric qmood cam cohes among method class thismodul metric qmood dcc direct class coupl thismodul metric qmood mcc maximum class coupl thismodul metric qmood dac direct attribut base coupl thismodul metric qmood dpc direct paramet base coupl thismodul metric qmood mpc maximum paramet base coupl thismodul metric qmood ccd class complex base data thismodul metric qmood ccp class complex base method paramet thismodul metric qmood ccm class complex base member end entrypoint rule metric begin rule packag measureset comment collect measur data model default packag packag measurelevel must set packag class rule packag measureset ne uml packag ne oclistypeof uml packag ne oclistypeof uml model thismodul measurelevel packag thismodul measurelevel class ms measur measureset elementnam ne cn ne defaultnam debug process metric packag els ne defaultnam endif elementtyp ne oclistypeof uml model model els packag endif subset ne content subset ne allclass collect c thismodul class measureset c ne oclistypeof uml model thismodul root measureset ms ne cn mood metric intra specif level metric ms measur thismodul percentagemeasur aif ne aif ms measur thismodul percentagemeasur oif ne oif ms measur thismodul percentagemeasur ahf ne ahf ms measur thismodul percentagemeasur ohf ne ohf ms measur thismodul percentagemeasur bpf ne bpf ms measur thismodul percentagemeasur ccf ne ccf ms measur thismodul percentagemeasur icf ne icf mood metric intra inter specif level metric ms measur thismodul percentagemeasur iif ne iif ms measur thismodul percentagemeasur ahef ne ahef ms measur thismodul percentagemeasur ohef ne ohef qmood metric ms measur thismodul integermeasur dsc ne dsc ms measur thismodul integermeasur noh ne noh ms measur thismodul integermeasur nic ne nic ms measur thismodul integermeasur nsi ne nsi ms measur thismodul integermeasur nnc ne nnc ms measur thismodul integermeasur nac ne nac ms measur thismodul integermeasur nlc ne nlc ms measur thismodul doublemeasur adi ne adi ms measur thismodul doublemeasur awi ne awi ms measur thismodul doublemeasur ana ne ana end rule packag measureset begin lazi rule class measureset comment collect measur data class measurelevel must set class lazi rule class measureset ne uml class ne oclistypeof uml class thismodul measurelevel class ms measur measureset elementnam ne defaultnam debug process metric class elementtyp class subset ne nestedclassifi moos metric ms measur thismodul integermeasur dit ne dit ms measur thismodul integermeasur noc ne noc ms measur thismodul integermeasur cbo ne cbo ms measur thismodul integermeasur rfc ne rfc emoos metric ms measur thismodul integermeasur size ne size qmood metric ms measur thismodul percentagemeasur mfa ne mfa ms measur thismodul percentagemeasur maa ne maa ms measur thismodul percentagemeasur mat ne mat ms measur thismodul integermeasur moa ne moa ms measur thismodul integermeasur mrm ne mrm ms measur thismodul percentagemeasur dam ne dam ms measur thismodul percentagemeasur oam ne oam ms measur thismodul percentagemeasur mam ne mam ms measur thismodul integermeasur noa ne noa ms measur thismodul integermeasur nom ne nom ms measur thismodul integermeasur cis ne cis ms measur thismodul integermeasur npt ne npt ms measur thismodul doublemeasur npm ne npm ms measur thismodul integermeasur nod ne nod ms measur thismodul integermeasur nad ne nad ms measur thismodul integermeasur npa ne npa ms measur thismodul integermeasur csm ne csm ms measur thismodul doublemeasur cam ne cam ms measur thismodul integermeasur dcc ne dcc ms measur thismodul integermeasur mcc ne mcc ms measur thismodul integermeasur dac ne dac ms measur thismodul integermeasur dpc ne dpc ms measur thismodul integermeasur mpc ne mpc ms measur thismodul integermeasur ccd ne ccd ms measur thismodul integermeasur ccp ne ccp ms measur thismodul integermeasur ccm ne ccm end lazi rule class measureset begin call rule categori comment creat categori metric classif name descript rule categori name string desc string cat measur categori name name desc desc cat end call rule categori begin call rule metric comment creat metric categori name descript default prefer valu metric set equal zero rule metric catnam string name string desc string metric measur metric name name desc desc preferredvalu categori thismodul root categori select cat cat name catnam first thismodul metricbynam thismodul metricbynam includ metric name metric end call rule metric begin call rule metricwithpreferredvalu comment creat metric categori name descript prefer valu metric oper follow number rule metricwithpreferredvalu catnam string name string desc string preferredvalu string metric measur metric name name desc desc preferredvalu preferredvalu categori thismodul root categori select cat cat name catnam first thismodul metricbynam thismodul metricbynam includ metric name metric end call rule metricwithpreferredvalu begin call rule integermeasur comment store integ measur metric name valu given rule integermeasur name string valu integ mea measur integermeasur metric thismodul metricbynam get name valu valu mea end call rule integermeasur begin call rule doublemeasur comment store doubl measur metric name valu given rule doublemeasur name string valu real mea measur doublemeasur metric thismodul metricbynam get name valu valu mea end call rule doublemeasur begin call rule percentagemeasur comment store percentag measur metric name valu given rule percentagemeasur name string valu real mea measur percentagemeasur metric thismodul metricbynam get name valu valu mea end call rule percentagemeasur,14
122,122,P57-XHTML2XML.atl,"--@atlcompiler	atl2006
--@name			XHTML2XML
--@version		2.0
--@domains		XHTML, Table
--@authors		Eric Vepa (evepa <at> sodius.com) for SODIUS (www.sodius.com)
--@date			2007/08/14
--@description	XHTML extractor for a subset of the XHTML metamodel (table representation).
--@see			<!DOCTYPE html PUBLIC ""-//W3C//DTD XHTML 1.1//EN"" ""http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"">

module XHTML2XML; -- Module Template
create OUT : XML from IN : XHTML;

rule inlines(inlines : Sequence(XHTML!Inline)) {
    using {
        seq : Sequence(XML!Node) = Sequence{};      
    }
    do {
        for (inline in inlines) {            
            if (inline.oclIsKindOf(XHTML!CDATA))
                seq <- seq->append(thisModule.Text(inline.value));
            else if (inline.oclIsKindOf(XHTML!PCDATA))
                seq <- seq->union(thisModule.inlines(inline.inlines));
            else
                seq <- seq->append(inline);
        }
        seq;
    }
}

-- -------------------------------------------------------------------------
-- Document Structure ------------------------------------------------------
-- -------------------------------------------------------------------------

rule HTML {
	from
		html : XHTML!HTML
	to
		xml : XML!Root (
			name <- 'html',
			children <- html.head,
			children <- html.body
		)
	do {
        -- Local attributes and references
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        xml.children <- thisModule.Attribute('xmlns', 'http://www.w3.org/1999/xhtml');
--        xml.children <- thisModule.Attribute('xmlns:xsi', 'http://www.w3.org/2001/XMLSchema-instance');
--        xml.children <- thisModule.Attribute('xsi:schemaLocation', 'http://www.w3.org/MarkUp/SCHEMA/xhtml11.xsd');
    	-- Inherited from Internationalization super-class
		if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
		if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
	}
}

-- -------------------------------------------------------------------------
-- Document Head -----------------------------------------------------------
-- -------------------------------------------------------------------------

rule HEAD {
    from
        html : XHTML!HEAD
    to
        xml : XML!Element (
            name <- 'head',
            children <- html.title,
            children <- html.bases,
            children <- html.headMiscs
        )
    do {
        -- Local attributes and references
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.profile.oclIsUndefined()) xml.children <- thisModule.Attribute('profile', html.profile.value);
        -- Inherited from Internationalization super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
    }
}

rule TITLE {
    from
        html : XHTML!TITLE
    to
        xml : XML!Element (
            name <- 'title',
            children <- thisModule.inlines(html.pcdata.inlines)
        )
    do {
        -- Local attributes and references
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        -- Inherited from Internationalization super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
    }
}

rule META {
    from
        html : XHTML!META
    to
        xml : XML!Element (
            name <- 'meta'
        )
    do {
        -- Local attributes and references
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.httpequiv.oclIsUndefined()) xml.children <- thisModule.Attribute('http-equiv', html.httpequiv.value);
        if (not html.name.oclIsUndefined()) xml.children <- thisModule.Attribute('name', html.name.value);
        if (not html.content.oclIsUndefined()) xml.children <- thisModule.Attribute('content', html.content.value);
        if (not html.scheme.oclIsUndefined()) xml.children <- thisModule.Attribute('scheme', html.scheme.value);
        -- Inherited from Internationalization super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
    }
}

rule LINK {
    from
        html : XHTML!LINK
    to
        xml : XML!Element (
            name <- 'link'
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Local attributes and references
        if (not html.charset.oclIsUndefined()) xml.children <- thisModule.Attribute('charset', html.charset.value);
        if (not html.href.oclIsUndefined()) xml.children <- thisModule.Attribute('href', html.href.value);
        if (not html.hreflang.oclIsUndefined()) xml.children <- thisModule.Attribute('hreflang', html.hreflang.value);
        if (not html.type.oclIsUndefined()) xml.children <- thisModule.Attribute('type', html.type.value);
        if (not html.rel.oclIsUndefined()) xml.children <- thisModule.Attribute('rel', html.rel.value);
        if (not html.rev.oclIsUndefined()) xml.children <- thisModule.Attribute('rev', html.rev.value);
        if (not html.media.oclIsUndefined()) xml.children <- thisModule.Attribute('media', html.media.value);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

rule STYLE {
    from
        html : XHTML!STYLE
    to
        xml : XML!Element (
            name <- 'style',
            children <- thisModule.inlines(html.pcdata.inlines)
        )
    do {
        -- Local attributes and references
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        xml.children <- thisModule.Attribute('type', html.type.value);
        if (not html.media.oclIsUndefined()) xml.children <- thisModule.Attribute('media', html.media.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
    }
}

rule SCRIPT {
    from
        html : XHTML!SCRIPT
    to
        xml : XML!Element (
            name <- 'script',
            children <- if (not html.pcdata.oclIsUndefined())
			                 then thisModule.inlines(html.pcdata.inlines)
							 else thisModule.Text('')
			             endif
        )
    do {
        -- Local attributes and references
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.charset.oclIsUndefined()) xml.children <- thisModule.Attribute('charset', html.charset.value);
        xml.children <- thisModule.Attribute('type', html.type.value);
        if (not html.src.oclIsUndefined()) xml.children <- thisModule.Attribute('src', html.src.value);
        if (not html.defer.oclIsUndefined()) xml.children <- thisModule.Attribute('defer', html.defer.value);
    }
}

rule NOSCRIPT {
    from
        html : XHTML!NOSCRIPT
    to
        xml : XML!Element (
            name <- 'noscript',
            children <- thisModule.inlines(html.blocks)
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

-- -------------------------------------------------------------------------
-- Document Body -----------------------------------------------------------
-- -------------------------------------------------------------------------

rule BODY {
    from
        html : XHTML!BODY
    to
        xml : XML!Element (
            name <- 'body',
            children <- thisModule.inlines(html.blocks)
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Local attributes and references
        if (not html.onload.oclIsUndefined()) xml.children <- thisModule.Attribute('onload', html.onload.value);
        if (not html.onunload.oclIsUndefined()) xml.children <- thisModule.Attribute('onunload', html.onunload.value);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

rule DIV {
    from
        html : XHTML!DIV
    to
        xml : XML!Element (
            name <- 'div',
            children <- thisModule.inlines(html.flows)
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

-- -------------------------------------------------------------------------
-- Paragraphs --------------------------------------------------------------
-- -------------------------------------------------------------------------

rule P {
    from
        html : XHTML!P
    to
        xml : XML!Element (
            name <- 'p',
            children <- thisModule.inlines(html.inlines)
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

-- -------------------------------------------------------------------------
-- Lists -------------------------------------------------------------------
-- -------------------------------------------------------------------------

-- UL or OL
rule AbstractList {
    from
        html : XHTML!AbstractList
    to
        xml : XML!Element (
            name <- if (html.oclIsKindOf(XHTML!UL))
                       then 'ul'
                       else 'ol'
                    endif,
			children <- html.lis
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

rule LI {
    from
        html : XHTML!LI
    to
        xml : XML!Element (
            name <- 'li',
            children <- thisModule.inlines(html.flows)
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

-- -------------------------------------------------------------------------
-- Horizontal Rule --------------------------------------------------
-- -------------------------------------------------------------------------

rule HR {
    from
        html : XHTML!HR
    to
        xml : XML!Element (
            name <- 'hr'
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

-- -------------------------------------------------------------------------
-- Preformatted Text -------------------------------------------------------
-- -------------------------------------------------------------------------

rule PRE {
    from
        html : XHTML!PRE
    to
        xml : XML!Element (
            name <- 'pre',
			children <- thisModule.inlines(html.preContents)
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

-- -------------------------------------------------------------------------
-- The Anchor Element ------------------------------------------------------
-- -------------------------------------------------------------------------

rule A {
    from
        html : XHTML!A
    to
        xml : XML!Element (
            name <- 'a',
            children <- thisModule.inlines(html.aContents)
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Local attributes and references
        if (not html.charset.oclIsUndefined()) xml.children <- thisModule.Attribute('charset', html.charset.value);
        if (not html.type.oclIsUndefined()) xml.children <- thisModule.Attribute('type', html.type.value);
        if (not html.href.oclIsUndefined()) xml.children <- thisModule.Attribute('href', html.href.value);
        if (not html.hreflang.oclIsUndefined()) xml.children <- thisModule.Attribute('hreflang', html.hreflang.value);
        if (not html.rel.oclIsUndefined()) xml.children <- thisModule.Attribute('rel', html.rel.value);
        if (not html.rev.oclIsUndefined()) xml.children <- thisModule.Attribute('rev', html.rev.value);
        if (not (html.shape = #rect)) xml.children <- thisModule.Attribute('shape', html.shape);
        if (not html.coords.oclIsUndefined()) xml.children <- thisModule.Attribute('coords', html.coords.value);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
        -- Inherited from Focus super-class
        if (not html.accesskey.oclIsUndefined()) xml.children <- thisModule.Attribute('accesskey', html.accesskey.value);
        if (not html.tabindex.oclIsUndefined()) xml.children <- thisModule.Attribute('tabindex', html.tabindex.value);
        if (not html.onfocus.oclIsUndefined()) xml.children <- thisModule.Attribute('onfocus', html.onfocus.value);
        if (not html.onblur.oclIsUndefined()) xml.children <- thisModule.Attribute('onblur', html.onblur.value);
    }
}

-- -------------------------------------------------------------------------
-- Inline Elements ---------------------------------------------------------
-- -------------------------------------------------------------------------

rule BR {
    from
        html : XHTML!BR
    to
        xml : XML!Element (
            name <- 'br'
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
    }
}

-- STRONG or ACRONYM
rule Phrase {
    from
        html : XHTML!Phrase
    to
        xml : XML!Element (
            name <- if (html.oclIsKindOf(XHTML!STRONG))
		            	then 'strong'
		            	else 'acronym'
					endif,
            children <- thisModule.inlines(html.inlines)
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

-- I
rule Fontstyle {
    from
        html : XHTML!Fontstyle
    to
        xml : XML!Element (
            name <- 'i',
            children <- thisModule.inlines(html.inlines)
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

-- -------------------------------------------------------------------------
-- Images ------------------------------------------------------------------
-- -------------------------------------------------------------------------

rule IMG {
    from
        html : XHTML!IMG
    to
        xml : XML!Element (
            name <- 'img'
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Local attributes and references
        xml.children <- thisModule.Attribute('src', html.src.value); 
        xml.children <- thisModule.Attribute('alt', html.alt.value); 
        if (not html.longdesc.oclIsUndefined()) xml.children <- thisModule.Attribute('longdesc', html.longdesc.value); 
        if (not html.height.oclIsUndefined()) xml.children <- thisModule.Attribute('height', html.height.value); 
        if (not html.width.oclIsUndefined()) xml.children <- thisModule.Attribute('width', html.width.value); 
        if (not html.usemap.oclIsUndefined()) xml.children <- thisModule.Attribute('usemap', html.usemap.value);
        if (html.ismap) xml.children <- thisModule.Attribute('ismap', 'ismap');
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

-- -------------------------------------------------------------------------
-- Forms -------------------------------------------------------------------
-- -------------------------------------------------------------------------

rule INPUT {
    from
        html : XHTML!INPUT
    to
        xml : XML!Element (
            name <- 'input'
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Local attributes and references
		if (not (html.type = #text)) xml.children <- thisModule.Attribute('type', html.type);
        if (not html.name.oclIsUndefined()) xml.children <- thisModule.Attribute('name', html.name.value);
        if (not html.value.oclIsUndefined()) xml.children <- thisModule.Attribute('value', html.value.value);
        if (html.checked) xml.children <- thisModule.Attribute('checked', 'checked');
        if (html.disabled) xml.children <- thisModule.Attribute('disabled', 'disabled');
        if (html.readonly) xml.children <- thisModule.Attribute('readonly', 'readonly');
        if (not html.size.oclIsUndefined()) xml.children <- thisModule.Attribute('size', html.size.value);
        if (not html.maxlength.oclIsUndefined()) xml.children <- thisModule.Attribute('maxlength', html.maxlength.value);
        if (not html.src.oclIsUndefined()) xml.children <- thisModule.Attribute('src', html.src.value);
        if (not html.alt.oclIsUndefined()) xml.children <- thisModule.Attribute('alt', html.alt.value);
        if (not html.usemap.oclIsUndefined()) xml.children <- thisModule.Attribute('usemap', html.usemap.value);
        if (not html.onselect.oclIsUndefined()) xml.children <- thisModule.Attribute('onselect', html.onselect.value);
        if (not html.onchange.oclIsUndefined()) xml.children <- thisModule.Attribute('onchange', html.onchange.value);
        if (not html.accept.oclIsUndefined()) xml.children <- thisModule.Attribute('accept', html.accept.value);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
        -- Inherited from Focus super-class
        if (not html.accesskey.oclIsUndefined()) xml.children <- thisModule.Attribute('accesskey', html.accesskey.value);
        if (not html.tabindex.oclIsUndefined()) xml.children <- thisModule.Attribute('tabindex', html.tabindex.value);
        if (not html.onfocus.oclIsUndefined()) xml.children <- thisModule.Attribute('onfocus', html.onfocus.value);
        if (not html.onblur.oclIsUndefined()) xml.children <- thisModule.Attribute('onblur', html.onblur.value);
    }
}

rule FIELDSET {
    from
        html : XHTML!FIELDSET
    to
        xml : XML!Element (
            name <- 'fieldset',
			children <- html.fieldsetElements
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

rule LEGEND {
    from
        html : XHTML!LEGEND
    to
        xml : XML!Element (
            name <- 'legend',
            children <- thisModule.inlines(html.inlines)
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Local attributes and references
        if (not html.accesskey.oclIsUndefined()) xml.children <- thisModule.Attribute('accesskey', html.accesskey.value);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

-- -------------------------------------------------------------------------
-- Tables ------------------------------------------------------------------
-- -------------------------------------------------------------------------

rule TABLE {
    from
        html : XHTML!TABLE
    to
        xml : XML!Element (
            name <- 'table',
            children <- html.caption,
            children <- html.colElements,
            children <- html.thead,
            children <- html.tfoot,
            children <- html.tableElements
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Local attributes and references
        if (not html.summary.oclIsUndefined()) xml.children <- thisModule.Attribute('summary', html.summary.value); 
        if (not html.width.oclIsUndefined()) xml.children <- thisModule.Attribute('width', html.width.value); 
        if (not html.border.oclIsUndefined()) xml.children <- thisModule.Attribute('border', html.border.value); 
        if (not (html.frame = #void)) xml.children <- thisModule.Attribute('frame', html.frame); 
        if (not (html.rules = #none)) xml.children <- thisModule.Attribute('rules', html.rules); 
        if (not html.cellspacing.oclIsUndefined()) xml.children <- thisModule.Attribute('cellspacing', html.cellspacing.value); 
        if (not html.cellpadding.oclIsUndefined()) xml.children <- thisModule.Attribute('cellpadding', html.cellpadding.value); 
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

rule CAPTION {
    from
        html : XHTML!CAPTION
    to
        xml : XML!Element (
            name <- 'caption',
            children <- thisModule.inlines(html.inlines)
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

-- THEAD, TFOOT or TBODY
rule TElement {
    from
        html : XHTML!TElement
    to
        xml : XML!Element (
            name <- if (html.oclIsKindOf(XHTML!TBODY))
            	       then 'tbody'
					   else if (html.oclIsKindOf(XHTML!TFOOT))
		                       then 'tfoot'
		                       else 'thead'
		                    endif
					endif,
            children <- html.trs
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Inherited from CellHAlign super-class
        if (not (html.align = #left)) xml.children <- thisModule.Attribute('align', html.align);
        if (not html.charoff.oclIsUndefined()) xml.children <- thisModule.Attribute('charoff', html.charoff.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
        -- Inherited from CellVAlign super-class
        if (not (html.valign = #top)) xml.children <- thisModule.Attribute('valign', html.valign);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

rule TR {
    from
        html : XHTML!TR
    to
        xml : XML!Element (
            name <- 'tr',
            children <- html.trElements
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Inherited from CellHAlign super-class
        if (not (html.align = #left)) xml.children <- thisModule.Attribute('align', html.align);
        if (not html.charoff.oclIsUndefined()) xml.children <- thisModule.Attribute('charoff', html.charoff.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
        -- Inherited from CellVAlign super-class
        if (not (html.valign = #top)) xml.children <- thisModule.Attribute('valign', html.valign);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

-- TD or TH
rule TRElement {
    from
        html : XHTML!TRElement
    to
        xml : XML!Element (
            name <- if (html.oclIsKindOf(XHTML!TD))
                       then 'td'
                       else 'th'
                    endif,
            children <- thisModule.inlines(html.flows)
        )
    do {
        -- Inherited from CoreAttrs super-super-class
        if (not html.id.oclIsUndefined()) xml.children <- thisModule.Attribute('id', html.id.value);
        if (not html.class.oclIsUndefined()) xml.children <- thisModule.Attribute('class', html.class.value);
        if (not html.style.oclIsUndefined()) xml.children <- thisModule.Attribute('style', html.style.value);
        if (not html.title.oclIsUndefined()) xml.children <- thisModule.Attribute('title', html.title.value);
        -- Inherited from Internationalization super-super-class
        if (not html.""xmllang"".oclIsUndefined()) xml.children <- thisModule.Attribute('xml:lang', html.xmllang.value);
        if (not (html.dir = #ltr)) xml.children <- thisModule.Attribute('dir', html.dir);
        -- Local attributes and references
        if (not html.abbr.oclIsUndefined()) xml.children <- thisModule.Attribute('abbr', html.abbr.value);
        if (not html.headers.oclIsUndefined()) xml.children <- thisModule.Attribute('headers', html.headers.value);
        if (not (html.scope = #none)) xml.children <- thisModule.Attribute('scope', html.scope);
        if (not html.rowspan.oclIsUndefined()) xml.children <- thisModule.Attribute('rowspan', html.rowspan.value);
        if (not html.colspan.oclIsUndefined()) xml.children <- thisModule.Attribute('colspan', html.colspan.value);
        -- Inherited from CellHAlign super-class        if (not (html.align = #left)) xml.children <- thisModule.Attribute('align', html.align);
        if (not html.charoff.oclIsUndefined()) xml.children <- thisModule.Attribute('charoff', html.charoff.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
        -- Inherited from CellVAlign super-class
        if (not (html.valign = #top)) xml.children <- thisModule.Attribute('valign', html.valign);
        -- Inherited from Events super-super-class
        if (not html.onclick.oclIsUndefined()) xml.children <- thisModule.Attribute('onclick', html.onclick.value);
        if (not html.ondblclick.oclIsUndefined()) xml.children <- thisModule.Attribute('ondblclick', html.ondblclick.value);
        if (not html.onmousedown.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousedown', html.onmousedown.value);
        if (not html.onmouseup.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseup', html.onmouseup.value);
        if (not html.onmousemove.oclIsUndefined()) xml.children <- thisModule.Attribute('onmousemove', html.onmousemove.value);
        if (not html.onmouseout.oclIsUndefined()) xml.children <- thisModule.Attribute('onmouseout', html.onmouseout.value);
        if (not html.onkeypress.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeypress', html.onkeypress.value);
        if (not html.onkeydown.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeydown', html.onkeydown.value);
        if (not html.onkeyup.oclIsUndefined()) xml.children <- thisModule.Attribute('onkeyup', html.onkeyup.value);
    }
}

-- -------------------------------------------------------------------------
-- XML Attribute and Text --------------------------------------------------
-- -------------------------------------------------------------------------

--@begin called rule Attribute
rule Attribute(attrName : String, attrValue : String) {
	to
		attr : XML!Attribute (
			name <- attrName,
			value <- attrValue
		)
	do {
		attr;
	}
}	
--@end called rule Attribute

--@begin called rule Attribute
rule Attribute(attrName : String, attrValue : Integer) {
	to
		attr : XML!Attribute (
			name <- attrName,
			value <- attrValue.toString()
		)
	do {
		attr;
	}
}	
--@end called rule Attribute

--@begin called rule Text
rule Text(value : String) {
	to
		text : XML!Text (
			value <-
				if not value.oclIsUndefined()
					then value
					else ''
				endif
		)
	do {
		text;
	}
}	
--@end called rule Text",atlcompil atl name xhtml xml version domain xhtml tabl author eric vepa evepa sodius com sodius www sodius com date descript xhtml extractor subset xhtml metamodel tabl represent see doctyp html public w c dtd xhtml en http www w org tr xhtml dtd xhtml dtd modul xhtml xml modul templat creat out xml in xhtml rule inlin inlin sequenc xhtml inlin use seq sequenc xml node sequenc inlin inlin inlin ocliskindof xhtml cdata seq seq append thismodul text inlin valu els inlin ocliskindof xhtml pcdata seq seq union thismodul inlin inlin inlin els seq seq append inlin seq document structur rule html html xhtml html xml xml root name html children html head children html bodi local attribut refer html id oclisundefin xml children thismodul attribut id html id valu xml children thismodul attribut xmlns http www w org xhtml xml children thismodul attribut xmlns xsi http www w org xmlschema instanc xml children thismodul attribut xsi schemaloc http www w org markup schema xhtml xsd inherit internation super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir document head rule head html xhtml head xml xml element name head children html titl children html base children html headmisc local attribut refer html id oclisundefin xml children thismodul attribut id html id valu html profil oclisundefin xml children thismodul attribut profil html profil valu inherit internation super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir rule titl html xhtml titl xml xml element name titl children thismodul inlin html pcdata inlin local attribut refer html id oclisundefin xml children thismodul attribut id html id valu inherit internation super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir rule meta html xhtml meta xml xml element name meta local attribut refer html id oclisundefin xml children thismodul attribut id html id valu html httpequiv oclisundefin xml children thismodul attribut http equiv html httpequiv valu html name oclisundefin xml children thismodul attribut name html name valu html content oclisundefin xml children thismodul attribut content html content valu html scheme oclisundefin xml children thismodul attribut scheme html scheme valu inherit internation super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir rule link html xhtml link xml xml element name link inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir local attribut refer html charset oclisundefin xml children thismodul attribut charset html charset valu html href oclisundefin xml children thismodul attribut href html href valu html hreflang oclisundefin xml children thismodul attribut hreflang html hreflang valu html type oclisundefin xml children thismodul attribut type html type valu html rel oclisundefin xml children thismodul attribut rel html rel valu html rev oclisundefin xml children thismodul attribut rev html rev valu html media oclisundefin xml children thismodul attribut media html media valu inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu rule style html xhtml style xml xml element name style children thismodul inlin html pcdata inlin local attribut refer html id oclisundefin xml children thismodul attribut id html id valu xml children thismodul attribut type html type valu html media oclisundefin xml children thismodul attribut media html media valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir rule script html xhtml script xml xml element name script children html pcdata oclisundefin thismodul inlin html pcdata inlin els thismodul text endif local attribut refer html id oclisundefin xml children thismodul attribut id html id valu html charset oclisundefin xml children thismodul attribut charset html charset valu xml children thismodul attribut type html type valu html src oclisundefin xml children thismodul attribut src html src valu html defer oclisundefin xml children thismodul attribut defer html defer valu rule noscript html xhtml noscript xml xml element name noscript children thismodul inlin html block inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu document bodi rule bodi html xhtml bodi xml xml element name bodi children thismodul inlin html block inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir local attribut refer html onload oclisundefin xml children thismodul attribut onload html onload valu html onunload oclisundefin xml children thismodul attribut onunload html onunload valu inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu rule div html xhtml div xml xml element name div children thismodul inlin html flow inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu paragraph rule p html xhtml p xml xml element name p children thismodul inlin html inlin inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu list ul ol rule abstractlist html xhtml abstractlist xml xml element name html ocliskindof xhtml ul ul els ol endif children html lis inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu rule li html xhtml li xml xml element name li children thismodul inlin html flow inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu horizont rule rule hr html xhtml hr xml xml element name hr inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu preformat text rule pre html xhtml pre xml xml element name pre children thismodul inlin html precont inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu the anchor element rule a html xhtml a xml xml element name children thismodul inlin html acont inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir local attribut refer html charset oclisundefin xml children thismodul attribut charset html charset valu html type oclisundefin xml children thismodul attribut type html type valu html href oclisundefin xml children thismodul attribut href html href valu html hreflang oclisundefin xml children thismodul attribut hreflang html hreflang valu html rel oclisundefin xml children thismodul attribut rel html rel valu html rev oclisundefin xml children thismodul attribut rev html rev valu html shape rect xml children thismodul attribut shape html shape html coord oclisundefin xml children thismodul attribut coord html coord valu inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu inherit focus super class html accesskey oclisundefin xml children thismodul attribut accesskey html accesskey valu html tabindex oclisundefin xml children thismodul attribut tabindex html tabindex valu html onfocus oclisundefin xml children thismodul attribut onfocus html onfocus valu html onblur oclisundefin xml children thismodul attribut onblur html onblur valu inlin element rule br html xhtml br xml xml element name br inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu strong acronym rule phrase html xhtml phrase xml xml element name html ocliskindof xhtml strong strong els acronym endif children thismodul inlin html inlin inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu i rule fontstyl html xhtml fontstyl xml xml element name children thismodul inlin html inlin inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu imag rule img html xhtml img xml xml element name img inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir local attribut refer xml children thismodul attribut src html src valu xml children thismodul attribut alt html alt valu html longdesc oclisundefin xml children thismodul attribut longdesc html longdesc valu html height oclisundefin xml children thismodul attribut height html height valu html width oclisundefin xml children thismodul attribut width html width valu html usemap oclisundefin xml children thismodul attribut usemap html usemap valu html ismap xml children thismodul attribut ismap ismap inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu form rule input html xhtml input xml xml element name input inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir local attribut refer html type text xml children thismodul attribut type html type html name oclisundefin xml children thismodul attribut name html name valu html valu oclisundefin xml children thismodul attribut valu html valu valu html check xml children thismodul attribut check check html disabl xml children thismodul attribut disabl disabl html readon xml children thismodul attribut readon readon html size oclisundefin xml children thismodul attribut size html size valu html maxlength oclisundefin xml children thismodul attribut maxlength html maxlength valu html src oclisundefin xml children thismodul attribut src html src valu html alt oclisundefin xml children thismodul attribut alt html alt valu html usemap oclisundefin xml children thismodul attribut usemap html usemap valu html onselect oclisundefin xml children thismodul attribut onselect html onselect valu html onchang oclisundefin xml children thismodul attribut onchang html onchang valu html accept oclisundefin xml children thismodul attribut accept html accept valu inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu inherit focus super class html accesskey oclisundefin xml children thismodul attribut accesskey html accesskey valu html tabindex oclisundefin xml children thismodul attribut tabindex html tabindex valu html onfocus oclisundefin xml children thismodul attribut onfocus html onfocus valu html onblur oclisundefin xml children thismodul attribut onblur html onblur valu rule fieldset html xhtml fieldset xml xml element name fieldset children html fieldsetel inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu rule legend html xhtml legend xml xml element name legend children thismodul inlin html inlin inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir local attribut refer html accesskey oclisundefin xml children thismodul attribut accesskey html accesskey valu inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu tabl rule tabl html xhtml tabl xml xml element name tabl children html caption children html colel children html thead children html tfoot children html tableel inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir local attribut refer html summari oclisundefin xml children thismodul attribut summari html summari valu html width oclisundefin xml children thismodul attribut width html width valu html border oclisundefin xml children thismodul attribut border html border valu html frame void xml children thismodul attribut frame html frame html rule none xml children thismodul attribut rule html rule html cellspac oclisundefin xml children thismodul attribut cellspac html cellspac valu html cellpad oclisundefin xml children thismodul attribut cellpad html cellpad valu inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu rule caption html xhtml caption xml xml element name caption children thismodul inlin html inlin inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu thead tfoot tbodi rule telement html xhtml telement xml xml element name html ocliskindof xhtml tbodi tbodi els html ocliskindof xhtml tfoot tfoot els thead endif endif children html trs inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir inherit cellhalign super class html align left xml children thismodul attribut align html align html charoff oclisundefin xml children thismodul attribut charoff html charoff valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu inherit cellvalign super class html valign top xml children thismodul attribut valign html valign inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu rule tr html xhtml tr xml xml element name tr children html trelement inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir inherit cellhalign super class html align left xml children thismodul attribut align html align html charoff oclisundefin xml children thismodul attribut charoff html charoff valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu inherit cellvalign super class html valign top xml children thismodul attribut valign html valign inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu td th rule trelement html xhtml trelement xml xml element name html ocliskindof xhtml td td els th endif children thismodul inlin html flow inherit coreattr super super class html id oclisundefin xml children thismodul attribut id html id valu html class oclisundefin xml children thismodul attribut class html class valu html style oclisundefin xml children thismodul attribut style html style valu html titl oclisundefin xml children thismodul attribut titl html titl valu inherit internation super super class html xmllang oclisundefin xml children thismodul attribut xml lang html xmllang valu html dir ltr xml children thismodul attribut dir html dir local attribut refer html abbr oclisundefin xml children thismodul attribut abbr html abbr valu html header oclisundefin xml children thismodul attribut header html header valu html scope none xml children thismodul attribut scope html scope html rowspan oclisundefin xml children thismodul attribut rowspan html rowspan valu html colspan oclisundefin xml children thismodul attribut colspan html colspan valu inherit cellhalign super class html align left xml children thismodul attribut align html align html charoff oclisundefin xml children thismodul attribut charoff html charoff valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu inherit cellvalign super class html valign top xml children thismodul attribut valign html valign inherit event super super class html onclick oclisundefin xml children thismodul attribut onclick html onclick valu html ondblclick oclisundefin xml children thismodul attribut ondblclick html ondblclick valu html onmousedown oclisundefin xml children thismodul attribut onmousedown html onmousedown valu html onmouseup oclisundefin xml children thismodul attribut onmouseup html onmouseup valu html onmousemov oclisundefin xml children thismodul attribut onmousemov html onmousemov valu html onmouseout oclisundefin xml children thismodul attribut onmouseout html onmouseout valu html onkeypress oclisundefin xml children thismodul attribut onkeypress html onkeypress valu html onkeydown oclisundefin xml children thismodul attribut onkeydown html onkeydown valu html onkeyup oclisundefin xml children thismodul attribut onkeyup html onkeyup valu xml attribut text begin call rule attribut rule attribut attrnam string attrvalu string attr xml attribut name attrnam valu attrvalu attr end call rule attribut begin call rule attribut rule attribut attrnam string attrvalu integ attr xml attribut name attrnam valu attrvalu tostr attr end call rule attribut begin call rule text rule text valu string text xml text valu valu oclisundefin valu els endif text end call rule text,9
123,123,P58-Monitor2Semaphore.atl,"module Monitor2Semaphore;
create OUT : Program from IN : Program;


-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- This helper provides access to the root Program element.
-- CONTEXT: thisModule
-- RETURN: Program!Program
helper def: rootElt : Program!Program =
	Program!Program.allInstances()->asSequence()->first();

-- This helper builds the set of 'condition' VariableDeclaration elements.
-- CONTEXT: thisModule
-- RETURN: Set(Program!VariableDeclaration)
helper def: allCondVariables : Set(Program!VariableDeclaration) =
	Program!VariableDeclaration.allInstances()
		->select(c | c.type.name = 'condition');

-- This helper builds the set of Monitor elements.
-- CONTEXT: thisModule
-- RETURN: Set(Program!Monitor)
helper def: allMonitors : Set(Program!Monitor) =
	Program!Monitor.allInstances();

-- This helper provides a boolean indicating if monitors (at least one) are
-- defined in the input model.
-- CONTEXT: thisModule
-- RETURN: Boolean
helper def: monitorsDefined : Boolean =
	thisModule.allMonitors->notEmpty();

-- This helper builds the set of 'condition' calls VariableExp elements.
-- CONTEXT: thisModule
-- RETURN: Set(Program!VariableExp)
helper def: allCondCalls : Set(Program!VariableExp) =
	Program!ProcedureCallExp.allInstances()->collect(e | e.source);
--		->collect(e | allCondVariables->includes(e.source.declaration));

-- This helper computes the Structure (Program, Monitor, Procedure) element
-- the context VariableDeclaration has to be attached to:
--  * a standalone declaration is attached to the Program element;
--  * a monitor declaration is attached to the Program element;
--  * an in-procedure declaration is attached to its Procedure element.
-- CONTEXT: Program!VariableDeclaration
-- RETURN: Program!Structure
helper context Program!VariableDeclaration
	def: getTargetStructure() : Program!Structure =
	let v_container : Program!Structure = self.structure in
	if v_container.oclIsKindOf(Program!Monitor) then
		v_container.program
	else
		v_container
	endif;

-- This helper returns the Type of a VariableDeclaration (which may be a
-- Parameter) when:
--  1- this variable is of 'integer' or 'boolean' type;
--  2- at least 1 monitor has been defined in the input program.
-- CONTEXT: Program!VariableDeclaration
-- RETURN: Program!Type
helper context Program!VariableDeclaration
	def: getType() : Program!Type =
	if self.type.name = 'integer' then
		thisModule.resolveTemp(thisModule.rootElt, 'integer_type')
	else
		thisModule.resolveTemp(thisModule.rootElt, 'boolean_type')
	endif;
	
-- This helper computes a boolean indicating whether the context variable is
-- declared within a monitor or a procedure of a monitor.
-- CONTEXT: Program!VariableDeclaration
-- RETURN: Boolean
helper context Program!VariableDeclaration
	def: isDeclaredInMonitor() : Boolean =
	let v_container : Program!Structure = self.structure in
	if v_container.oclIsKindOf(Program!Monitor) then
		true
	else
		if v_container.oclIsKindOf(Program!Procedure) then
			v_container.container.oclIsKindOf(Program!Monitor)
		else
			false
		endif
	endif;

-- This helper computes the set of Procedure elements to be attached to the
-- root Program element. This set includes:
--  * the defined standalone procedures;
--  * the 'signal', and 'wait' procedures generated for each input Monitor
--    element;
--  * the 'cond_wait' and 'cond_signal' procedures generated for each input
--    'condition' element.
-- CONTEXT: Program!Program
-- RETURN: Set(Program!Procedure)
helper context Program!Program
	def: getProcedures() : Set(Program!Procedure) =
	self.monitors->collect(e | e.procedures)
		->union(thisModule.allCondVariables
			->collect(e | thisModule.resolveTemp(e, 'cond_wait')))
		->union(thisModule.allCondVariables
			->collect(e | thisModule.resolveTemp(e, 'cond_signal')))
		->union(self.procedures);

-- This helper computes the set of VariableDeclaration elements to be attached
-- to the root Program element. This set includes:
--  * the defined standalone variables;
--  * the 'mutex', 'urgent' and 'urgentcount' variables generated for each
--    input Monitor element;
--  * the 'condsem' and 'count' variables generated for each input
--    'condition' element.
-- CONTEXT: Program!Program
-- RETURN: Set(Program!VariableDeclaration)
helper context Program!Program
	def: getVariables() : Set(Program!VariableDeclaration) =
	self.variables
		->union(thisModule.allCondVariables
			->collect(e | thisModule.resolveTemp(e, 'condsem')))
		->union(thisModule.allCondVariables
			->collect(e | thisModule.resolveTemp(e, 'count')))
		->union(thisModule.allMonitors
			->collect(e | thisModule.resolveTemp(e, 'mutex')))
		->union(thisModule.allMonitors
			->collect(e | thisModule.resolveTemp(e, 'urgent')))
		->union(thisModule.allMonitors
			->collect(e | thisModule.resolveTemp(e, 'urgentcount')));



-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'MainWithMonitors'.
-- This rule generates the structure of the root Program element when the
-- input element contains monitors (1-*).
rule MainWithMonitors {
	from
		i : Program!Program (
			thisModule.monitorsDefined
		)
	to
		prg : Program!Program (
			name <- i.name,
			variables <- i.getVariables(),
			procedures <- i.getProcedures(),
			monitors <- Set{}
		),
		
		-- 'this' variable delcaration: this variable is used for generated
		-- condition procedure calls.
		this_var : Program!VariableDeclaration (
			name <- 'this',
			type <- this_type
		),
		-- 'this' type is 'program'
		this_type : Program!Type (
			name <- 'program'
		),

		-- Basic types required for generated semaphore-based
		-- procedures.
		boolean_type : Program!Type (
			name <- 'boolean'
		),
		integer_type : Program!Type (
			name <- 'integer'
		)
}

-- Rule 'MainWithoutMonitors'.
-- This rule generates the structure of the root Program element when the
-- input element contains no monitors.
rule MainWithoutMonitors {
	from
		i : Program!Program (
			not thisModule.monitorsDefined
		)
	to
		prg : Program!Program (
			name <- i.name,
			variables <- i.variables,
			procedures <- i.procedures,
			monitors <- Set{}
		)
}

-- Rule 'Monitor'.
-- This rule generates a set of variable and procedure declarations that are
-- associated with each defined monitor in the input model:
--  * the 'urgent' variable initialized to 'false';
--  * the 'urgentcount' variable initialized to '0';
--  * the 'mutex' variable initialized to 'true'.
rule Monitor {
	from
		i : Program!Monitor
	to
		-- Generation of a semaphore ('mutex') for mutual exclusion:
		--   * its name is prefixed by the monitor name;
		--   * its type is 'boolean';
		--   * its initial value is 'true'.
		mutex : Program!VariableDeclaration (
			name <- i.name + '_mutex',
			type <- thisModule.resolveTemp(thisModule.rootElt, 'boolean_type'),
			initialValue <- true_value,
			structure <- i.program
		),
		
		-- Generation of a second semaphore ('urgent'):
		--   * its name is prefixed by the monitor name;
		--   * its type is 'boolean';
		--   * its initial value is 'false'.
		urgent : Program!VariableDeclaration (
			name <- i.name + '_urgent',
			type <- thisModule.resolveTemp(thisModule.rootElt, 'boolean_type'),
			initialValue <- false_value,
			structure <- i.program
		),

		-- Generation of an integer counter ('urgentcount'):
		--   * its name is prefixed by the monitor name;
		--   * its type is 'integer';
		--   * its initial value is '0'.
		urgentcount : Program!VariableDeclaration (
			name <- i.name + '_urgentcount',
			type <- thisModule.resolveTemp(thisModule.rootElt, 'integer_type'),
			initialValue <- zero_value,
			structure <- i.program
		),

		-- Basic values elements required for generated variables
		-- initialization.
		true_value : Program!BooleanExp (
			symbol <- true
		),
		false_value : Program!BooleanExp (
			symbol <- false
		),
		zero_value : Program!IntegerExp (
			symbol <- 0
		)
}

-- Rule 'Condition'.
-- This rule generates a set of variable and procedure declarations that are
-- associated with each defined 'condition' variable of the input model:
--  * the 'sem' variable initialized to 'false';
--  * the 'count' variable initialized to '0';
--  * the condition 'wait' procedure declaration;
--  * the condition 'signal' procedure declaration.
rule Condition {
	from
		condition : Program!VariableDeclaration (
			thisModule.allCondVariables->includes(condition)
		)
	to
		-- Generation of the 'sem' boolean variable:
		--   * its name is prefixed both by the monitor and the condition
		---    names;
		--   * its type is 'boolean';
		--   * its initial value is 'false'.
		condsem : Program!VariableDeclaration (
			name <- condition.structure.name + '_' + condition.name +'_sem',
			type <- thisModule.resolveTemp(thisModule.rootElt, 'boolean_type'),
			initialValue <- false_value,
			structure <- condition.structure.program
		),
		
		-- Generation of the 'count' integer variable:
		--   * its name is prefixed both by the monitor and the condition
		---    names;
		--   * its type is 'integer';
		--   * its initial value is '0'.
		count : Program!VariableDeclaration (
			name <- condition.structure.name + '_' + condition.name + '_count',
			type <- thisModule.resolveTemp(thisModule.rootElt, 'integer_type'),
			initialValue <- zero_value_1,
			structure <- condition.structure.program
		),


		-----------------------------------------------------------------------
		-----------------------------------------------------------------------
		-- Generation of the 'wait' procedure associated with a condition.
		-- The procedure name is built by associating: the monitor name, the
		-- condition name, and the 'wait' constant.
		-- It is composed of four statements:
		--   [1] condcount := condcount + 1;
		--   [2] if urgentcount > 0 then V(urgent) else V(mutex);
		--   [3] P(condsem);
		--   [4] condcount := condcount -1;
		cond_wait : Program!Procedure (
			name <- condition.structure.name + '_' + condition.name + '_wait',
			statements <-
				Sequence{wait_stat1, wait_stat2, wait_stat3, wait_stat4},
			container <- condition.structure.program
		),
		wait_stat1 : Program!AssignmentStat (
			target <- count_exp_1,
			value <- plus
		),
		wait_stat2 : Program!ConditionalStat (
			condition <- urgentcount_test,
			thenStats <- Sequence{then_st},
			elseStats <- Sequence{else_st}
		),
		wait_stat3 : Program!ExpressionStat (
			expression <- third_exp
		),
		wait_stat4 : Program!AssignmentStat (
			target <- count_exp_3,
			value <- less
		),
	
		-- [Wait_1] condcount := condcount + 1;
		count_exp_1 : Program!VariableExp (
			declaration <- count
		),
		plus : Program!OperatorCallExp (
			name <- '+',
			source <- count_exp_2,
			right <- one_value_1
		),
		count_exp_2 : Program!VariableExp (
			declaration <- count
		),
		-- [Wait_2] if urgentcount > 0 then V(urgent) else V(mutex);
		urgentcount_test : Program!OperatorCallExp (
			name <- '>',
			source <- urgentcount_exp_3,
			right <- zero_value_2
		),
		urgentcount_exp_3 : Program!VariableExp (
			declaration <-
				thisModule.resolveTemp(condition.structure, 'urgentcount')
		),
		then_st : Program!ExpressionStat (
			expression <- then_exp
		),
		then_exp : Program!ProcedureCallExp (
			name <- 'v',
			source <-  urgent_exp_1,
			arguments <- Sequence{}
		),
		urgent_exp_1 : Program!VariableExp (
			declaration <-
				thisModule.resolveTemp(condition.structure, 'urgent')
		),
		else_st : Program!ExpressionStat (
			expression <- else_exp
		),
		else_exp : Program!ProcedureCallExp (
			name <- 'v',
			source <- mutex_exp,
			arguments <- Sequence{}
		),
		mutex_exp : Program!VariableExp (
			declaration <- thisModule.resolveTemp(condition.structure, 'mutex')
		),
		-- [Wait_3] P(condsem);
		third_exp : Program!ProcedureCallExp (
			name <- 'p',
			source <- condsem_exp_1,
			arguments <- Sequence{}
		),
		condsem_exp_1 : Program!VariableExp (
			declaration <- condsem
		),
		-- [Wait_4] condcount := condcount -1;
		count_exp_3 : Program!VariableExp (
			declaration <- count
		),
		less : Program!OperatorCallExp (
			name <- '-',
			source <- count_exp_4,
			right <- one_value_2
		),
		count_exp_4 : Program!VariableExp (
			declaration <- count
		),

		
		-----------------------------------------------------------------------
		-----------------------------------------------------------------------		
		-- Generation of the 'signal' procedure associated with a condition.
		-- The procedure name is built by associating: the monitor name, the
		-- condition name, and the 'signal' constant.
		-- It is composed of three statements:
		--   [1] urgentcount := urgentcount +1;
		--   [2] if condcount > 0 then {V(condsem); P(urgent)};
		--   [3] urgentcount := urgentcount -1
		cond_signal : Program!Procedure (
			name <-
				condition.structure.name + '_' + condition.name + '_signal',
			statements <- Sequence{signal_stat1, signal_stat2, signal_stat3},
			container <- condition.structure.program
		),
		signal_stat1 : Program!AssignmentStat (
			target <-urgentcount_exp_1,
			value <- urgentcount_plus
		),
		signal_stat2 : Program!ConditionalStat (
			condition <- condcount_test,
			thenStats <- Sequence{signal_condsem_stat, wait_urgent_stat}
		),
		signal_stat3 : Program!AssignmentStat (
			target <-urgentcount_exp_2,
			value <- urgentcount_less
		),

		-- [Signal_1] urgentcount := urgentcount +1;
		urgentcount_exp_1 : Program!VariableExp (
			declaration <-
				thisModule.resolveTemp(condition.structure, 'urgentcount')
		),
		urgentcount_plus : Program!OperatorCallExp (
			name <- '+',
			source <- urgentcount_exp_4,
			right <- one_value_3
		),
		urgentcount_exp_4 : Program!VariableExp (
			declaration <-
				thisModule.resolveTemp(condition.structure, 'urgentcount')
		),
		-- [Signal_2] if condcount > 0 then {V(condsem); P(urgent)};	
		condcount_test : Program!OperatorCallExp (
			name <- '>',
			source <- count_exp_5,
			right <- zero_value_3
		),
		count_exp_5 : Program!VariableExp (
			declaration <- count
		),
		signal_condsem_stat : Program!ExpressionStat (
			expression <- signal_condsem
		),
		signal_condsem : Program!ProcedureCallExp (
			name <- 'v',
			source <- condsem_exp_2,
			arguments <- Sequence{}
		),
		condsem_exp_2 : Program!VariableExp (
			declaration <- condsem
		),
		wait_urgent_stat : Program!ExpressionStat	(
			expression <- wait_urgent
		),
		wait_urgent : Program!ProcedureCallExp (
			name <- 'p',
			source <- urgent_exp_2,
			arguments <- Sequence{}
		),
		urgent_exp_2 : Program!VariableExp (
			declaration <-
				thisModule.resolveTemp(condition.structure, 'urgent')
		),
		-- [Signal_3] urgentcount := urgentcount -1
		urgentcount_exp_2 : Program!VariableExp (
			declaration <-
				thisModule.resolveTemp(condition.structure, 'urgentcount')
		),
		urgentcount_less : Program!OperatorCallExp (
			name <- '-',
			source <- urgentcount_exp_5,
			right <- one_value_4
		),
		urgentcount_exp_5 : Program!VariableExp (
			declaration <-
				thisModule.resolveTemp(condition.structure, 'urgentcount')
		),


		-- Basic values elements required for generated variables
		-- initialization.
		false_value : Program!BooleanExp (
			symbol <- false
		),
		one_value_1 : Program!IntegerExp (
			symbol <- 1
		),
		one_value_2 : Program!IntegerExp (
			symbol <- 1
		),
		one_value_3 : Program!IntegerExp (
			symbol <- 1
		),
		one_value_4 : Program!IntegerExp (
			symbol <- 1
		),
		zero_value_1 : Program!IntegerExp (
			symbol <- 0
		),
		zero_value_2 : Program!IntegerExp (
			symbol <- 0
		),
		zero_value_3 : Program!IntegerExp (
			symbol <- 0
		)
}

-- Rule 'StandaloneProcedure'.
-- This rule copies each standalone procedure defined in the input model to the
-- output model.
rule StandaloneProcedure {
	from
		i : Program!Procedure (
			i.container.oclIsKindOf(Program!Program)
		)
	to
		o : Program!Procedure (
			name <- i.name,
			parameters <- i.parameters,
			variables <- i.variables,
			statements <- i.statements,
			container <- i.container
		)
}

-- Rule 'MonitorProcedure'.
-- This rule copies each procedure defined in an input model monitor to the
-- output model.
-- The name of the generated procedure is prefixed by the monitor name.
-- The input procedure statements are preceded by a monitor entering statement
-- and followed by a monitor leaving statement.
rule MonitorProcedure {
	from
		i : Program!Procedure (
			i.container.oclIsKindOf(Program!Monitor)
		)
	to
		-- Generated procedure
		proc : Program!Procedure (
			name <- i.container.name + '_' + i.name,
			parameters <- i.parameters,
			variables <- i.variables,
			statements <- Sequence{in_stat, i.statements, out_stat},
			container <- i.container.program
		),
		
		-- Monitor entering statement: P(mutex)
		in_stat : Program!ExpressionStat (
			expression <- in_exp
		),
		in_exp : Program!ProcedureCallExp (
			name <- 'p',
			source <- mutex_exp1,
			arguments <- Sequence{}
		),
		mutex_exp1 : Program!VariableExp (
			declaration <- thisModule.resolveTemp(i.container, 'mutex')
		),
		
		-- Monitor leaving statement:
		-- if urgentcount > 0 then V(urgent); else V(mutex);
		out_stat : Program!ConditionalStat (
			condition <- urgentcount_test,
			thenStats <- Sequence{then_st},
			elseStats <- Sequence{else_st}
		),
		-- Condition
		urgentcount_test : Program!OperatorCallExp (
			name <- '>',
			source <- count_exp,
			right <- zero_value
		),
		count_exp : Program!VariableExp (
			declaration <- thisModule.resolveTemp(i.container, 'urgentcount')
		),
		zero_value : Program!IntegerExp (
			symbol <- 0
		),
		-- 'then' statement
		then_st : Program!ExpressionStat (
			expression <- then_exp
		),
		then_exp : Program!ProcedureCallExp (
			name <- 'v',
			source <- urgent_exp,
			arguments <- Sequence{}
		),
		urgent_exp : Program!VariableExp (
			declaration <- thisModule.resolveTemp(i.container, 'urgent')
		),
		-- 'else' statement
		else_st : Program!ExpressionStat (
			expression <- else_exp
		),
		else_exp : Program!ProcedureCallExp (
			name <- 'v',
			source <- mutex_exp2,
			arguments <- Sequence{}
		),
		mutex_exp2 : Program!VariableExp (
			declaration <- thisModule.resolveTemp(i.container, 'mutex')
		)
}

-- Rule 'Type'.
-- This rule copies some of the types defined in the input model into the
-- output model. Each matched type must:
--  *  not be a 'condition' type, if no monitors are defined;
--  *  not be a 'condition', an 'integer' or a 'boolean' type, if some
--     monitors are defined (in this case, 'integer' and 'boolean' types
--     are generated once into the 'MainWithMonitors' rule).
rule Type {
	from
		i : Program!Type (
			i.name <> 'condition' and
			(
				(not thisModule.monitorsDefined) or
				(
					thisModule.monitorsDefined and
					i.name <> 'boolean' and
					i.name <> 'integer'
				)
			)
		)
	to
		o : Program!Type (
			name <- i.name
		)
}

-- Rule 'BooleanIntegerMonitorVariableDeclaration'.
-- This rule performs a copy of variable declarations of type 'integer' or
-- 'boolean 'that are declared either within a monitor or a procedure of a 
-- monitor.
rule BooleanIntegerMonitorVariableDeclaration {
	from
		i : Program!VariableDeclaration (
			i.oclIsTypeOf(Program!VariableDeclaration) and
			i.isDeclaredInMonitor() and
			(
				i.type.name = 'integer' or
				i.type.name = 'boolean'
			)
		)
	to
		o : Program!VariableDeclaration (
			name <- i.structure.name + '_' + i.name,
			type <- i.getType(),
			initialValue <- i.initialValue,
			structure <- i.getTargetStructure()
		)
}

-- Rule 'MonitorVariableDeclaration'.
-- This rule performs a copy of each variable declaration which type is different of
-- 'integer', 'boolean' and 'condition', and that is declared either within a monitor
-- or a procedure of a monitor.
rule MonitorVariableDeclaration {
	from
		i : Program!VariableDeclaration (
			i.oclIsTypeOf(Program!VariableDeclaration) and
			i.isDeclaredInMonitor() and
			i.type.name <> 'condition' and
			i.type.name <> 'integer' and
			i.type.name <> 'boolean'
		)
	to
		o : Program!VariableDeclaration (
			name <- i.structure.name + '_' + i.name,
			type <- i.type,
			initialValue <- i.initialValue,
			structure <- i.getTargetStructure()
		)
}

-- Rule 'BooleanIntegerVariableDeclaration'.
-- This rule performs a copy of variable declarations of type 'integer' or
-- 'boolean' that are declared either within the root program or a standalone
-- procedure.
rule BooleanIntegerStandaloneVariableDeclaration {
	from
		i : Program!VariableDeclaration (
			i.oclIsTypeOf(Program!VariableDeclaration) and
			not i.isDeclaredInMonitor() and
			(
				i.type.name = 'integer'
				or
				i.type.name = 'boolean'
			)
		)
	to
		o : Program!VariableDeclaration (
			name <- i.name,
			type <- i.getType(),
			initialValue <- i.initialValue,
			structure <- i.structure
		)
}

-- Rule 'StandaloneVariableDeclaration'.
-- This rule performs of each variable declaration which type is different of
-- 'integer', 'boolean' and 'condition', and that is declared either within the
-- root program or a standalone procedure.
rule StandaloneVariableDeclaration {
	from
		i : Program!VariableDeclaration (
			i.oclIsTypeOf(Program!VariableDeclaration) and
			not i.isDeclaredInMonitor() and
			i.type.name <> 'condition' and
			i.type.name <> 'integer' and
			i.type.name <> 'boolean'
		)
	to
		o : Program!VariableDeclaration (
			name <- i.name,
			type <- i.type,
			initialValue <- i.initialValue,
			structure <- i.structure
		)
}

-- Rule 'BooleanIntegerMonitorParameter'.
-- If monitors are defined in the input program, this rule performs a copy,
-- from the input model to the output model, of each parameter of type
-- 'integer' or 'boolean'.
rule BooleanIntegerMonitorParameter {
	from
		i : Program!Parameter (
			thisModule.monitorsDefined and
			(
			 	i.type.name = 'integer' or
			 	i.type.name = 'boolean'
			)
		)
	to
		o : Program!Parameter (
			name <- i.name,
			type <- i.getType(),
			initialValue <- i.initialValue,
			direction <- i.direction,
			procedure <- i.procedure
		)
}

-- Rule 'Parameter'.
-- This rule performs a copy, from the input model to the output model, of a
-- parameter when:
--  * no monitors are defined in the input program;
--  * or monitors are defined in the input program but the parameter is not
--    of type 'integer' or 'boolean'.
rule Parameter {
	from
		i : Program!Parameter (
			not thisModule.monitorsDefined or
			(
				thisModule.monitorsDefined and
			 	i.type.name <> 'integer' and
			 	i.type.name <> 'boolean'
			 )
		)
	to
		o : Program!Parameter (
			name <- i.name,
			type <- i.type,
			initialValue <- i.initialValue,
			direction <- i.direction,
			procedure <- i.procedure
		)
}

-------------
-- Statements
-------------
-- Rule 'ExpressionStat'.
-- This rule copies each expression statement from the input model to the
-- output model.
rule ExpressionStat {
	from
		i : Program!ExpressionStat
	to
		o : Program!ExpressionStat (
			expression <- i.expression
		)
}

-- Rule 'WhileStat'.
-- This rule copies each while statement from the input model to the
-- output model.
rule WhileStat {
	from
		i : Program!WhileStat
	to
		o : Program!WhileStat (
			condition <- i.condition,
			doStats <- i.doStats
		)
}

-- Rule 'ConditionalStat'.
-- This rule copies each conditional statement from the input model to the
-- output model.
rule ConditionalStat {
	from
		i : Program!ConditionalStat
	to
		o : Program!ConditionalStat (
			condition <- i.condition,
			thenStats <- i.thenStats,
			elseStats <- i.elseStats
		)
}

-- Rule 'AssignmentStat'.
-- This rule copies each assignment statement from the input model to the
-- output model.
rule AssignmentStat {
	from
		i : Program!AssignmentStat
	to
		o : Program!AssignmentStat (
			target <- i.target,
			value <- i.value
		)
}

--------------
-- Expressions
--------------
-- Rule 'OperatorCallExp'.
-- This rule copies each operator call expression from the input model to the
-- output model.
rule OperatorCallExp {
	from
		i : Program!OperatorCallExp
	to
		o : Program!OperatorCallExp (
			right <- i.right,
			source <- i.source,
			name <- i.name
		)
}

-- Rule 'AttributeCallExp'.
-- This rule copies each attribute call expression from the input model to the
-- output model.
rule AttributeCallExp {
	from
		i : Program!AttributeCallExp
	to
		o : Program!AttributeCallExp (
			source <- i.source,
			name <- i.name
		)
}

-- Rule 'ProcedureCallExp'.
-- This rule copies each procedure call expression, whose source is different
-- from 'condition', from the input model to the output model.
rule ProcedureCallExp {
	from
		i : Program!ProcedureCallExp (
			i.source.declaration.type.name <> 'condition'
		)
	to
		o : Program!ProcedureCallExp (
			arguments <- i.arguments,
			source <- i.source,
			name <- i.name
		)
}

-- Rule 'ConditionProcCallExp'.
-- This rule copies each 'condition' call expression from the input model to
-- the output model.
-- In the output model, the source call is set to the global 'this' variable
-- defined in the 'MainWithMonitors' rule.
rule ConditionProcCallExp {
	from
		i : Program!ProcedureCallExp (
			i.source.declaration.type.name = 'condition'
		)
	to
		call_exp : Program!ProcedureCallExp (
			arguments <- i.arguments,
			source <- source_exp,
			name <- i.source.declaration.structure.name + '_'
				+ i.source.declaration.name + '_' + i.name
		),
		source_exp : Program!VariableExp (
			declaration <-
				thisModule.resolveTemp(thisModule.rootElt, 'this_var')
		)
}

-- Rule 'VariableExp'.
-- This rule copies each variable expression, which is not a 'condition'
-- variable, from the input model to the output model.
rule VariableExp {
	from
		i : Program!VariableExp (
			thisModule.allCondCalls->excludes(i)
		)
	to
		o : Program!VariableExp (
			declaration <- i.declaration
		)
}

-- Rule 'BooleanExp'.
-- This rule copies each boolean value from the input model to the output
-- model.
rule BooleanExp {
	from
		i : Program!BooleanExp
	to
		o : Program!BooleanExp (
			symbol <- i.symbol
		)
}

-- Rule 'IntegerExp'.
-- This rule copies each integer value from the input model to the output
-- model.
rule IntegerExp {
	from
		i : Program!IntegerExp
	to
		o : Program!IntegerExp (
			symbol <- i.symbol
		)
}
",modul monitor semaphor creat out program in program helper this helper provid access root program element context thismodul return program program helper def rootelt program program program program allinst assequ first this helper build set condit variabledeclar element context thismodul return set program variabledeclar helper def allcondvari set program variabledeclar program variabledeclar allinst select c c type name condit this helper build set monitor element context thismodul return set program monitor helper def allmonitor set program monitor program monitor allinst this helper provid boolean indic monitor least one defin input model context thismodul return boolean helper def monitorsdefin boolean thismodul allmonitor notempti this helper build set condit call variableexp element context thismodul return set program variableexp helper def allcondcal set program variableexp program procedurecallexp allinst collect e e sourc collect e allcondvari includ e sourc declar this helper comput structur program monitor procedur element context variabledeclar attach standalon declar attach program element monitor declar attach program element procedur declar attach procedur element context program variabledeclar return program structur helper context program variabledeclar def gettargetstructur program structur let v contain program structur self structur v contain ocliskindof program monitor v contain program els v contain endif this helper return type variabledeclar may paramet variabl integ boolean type least monitor defin input program context program variabledeclar return program type helper context program variabledeclar def gettyp program type self type name integ thismodul resolvetemp thismodul rootelt integ type els thismodul resolvetemp thismodul rootelt boolean type endif this helper comput boolean indic whether context variabl declar within monitor procedur monitor context program variabledeclar return boolean helper context program variabledeclar def isdeclaredinmonitor boolean let v contain program structur self structur v contain ocliskindof program monitor true els v contain ocliskindof program procedur v contain contain ocliskindof program monitor els fals endif endif this helper comput set procedur element attach root program element this set includ defin standalon procedur signal wait procedur generat input monitor element cond wait cond signal procedur generat input condit element context program program return set program procedur helper context program program def getprocedur set program procedur self monitor collect e e procedur union thismodul allcondvari collect e thismodul resolvetemp e cond wait union thismodul allcondvari collect e thismodul resolvetemp e cond signal union self procedur this helper comput set variabledeclar element attach root program element this set includ defin standalon variabl mutex urgent urgentcount variabl generat input monitor element condsem count variabl generat input condit element context program program return set program variabledeclar helper context program program def getvari set program variabledeclar self variabl union thismodul allcondvari collect e thismodul resolvetemp e condsem union thismodul allcondvari collect e thismodul resolvetemp e count union thismodul allmonitor collect e thismodul resolvetemp e mutex union thismodul allmonitor collect e thismodul resolvetemp e urgent union thismodul allmonitor collect e thismodul resolvetemp e urgentcount rule rule mainwithmonitor this rule generat structur root program element input element contain monitor rule mainwithmonitor program program thismodul monitorsdefin prg program program name name variabl getvari procedur getprocedur monitor set variabl delcar variabl use generat condit procedur call var program variabledeclar name type type type program type program type name program basic type requir generat semaphor base procedur boolean type program type name boolean integ type program type name integ rule mainwithoutmonitor this rule generat structur root program element input element contain monitor rule mainwithoutmonitor program program thismodul monitorsdefin prg program program name name variabl variabl procedur procedur monitor set rule monitor this rule generat set variabl procedur declar associ defin monitor input model urgent variabl initi fals urgentcount variabl initi mutex variabl initi true rule monitor program monitor generat semaphor mutex mutual exclus name prefix monitor name type boolean initi valu true mutex program variabledeclar name name mutex type thismodul resolvetemp thismodul rootelt boolean type initialvalu true valu structur program generat second semaphor urgent name prefix monitor name type boolean initi valu fals urgent program variabledeclar name name urgent type thismodul resolvetemp thismodul rootelt boolean type initialvalu fals valu structur program generat integ counter urgentcount name prefix monitor name type integ initi valu urgentcount program variabledeclar name name urgentcount type thismodul resolvetemp thismodul rootelt integ type initialvalu zero valu structur program basic valu element requir generat variabl initi true valu program booleanexp symbol true fals valu program booleanexp symbol fals zero valu program integerexp symbol rule condit this rule generat set variabl procedur declar associ defin condit variabl input model sem variabl initi fals count variabl initi condit wait procedur declar condit signal procedur declar rule condit condit program variabledeclar thismodul allcondvari includ condit generat sem boolean variabl name prefix monitor condit name type boolean initi valu fals condsem program variabledeclar name condit structur name condit name sem type thismodul resolvetemp thismodul rootelt boolean type initialvalu fals valu structur condit structur program generat count integ variabl name prefix monitor condit name type integ initi valu count program variabledeclar name condit structur name condit name count type thismodul resolvetemp thismodul rootelt integ type initialvalu zero valu structur condit structur program generat wait procedur associ condit the procedur name built associ monitor name condit name wait constant it compos four statement condcount condcount urgentcount v urgent els v mutex p condsem condcount condcount cond wait program procedur name condit structur name condit name wait statement sequenc wait stat wait stat wait stat wait stat contain condit structur program wait stat program assignmentstat target count exp valu plus wait stat program conditionalstat condit urgentcount test thenstat sequenc st elsestat sequenc els st wait stat program expressionstat express third exp wait stat program assignmentstat target count exp valu less wait condcount condcount count exp program variableexp declar count plus program operatorcallexp name sourc count exp right one valu count exp program variableexp declar count wait urgentcount v urgent els v mutex urgentcount test program operatorcallexp name sourc urgentcount exp right zero valu urgentcount exp program variableexp declar thismodul resolvetemp condit structur urgentcount st program expressionstat express exp exp program procedurecallexp name v sourc urgent exp argument sequenc urgent exp program variableexp declar thismodul resolvetemp condit structur urgent els st program expressionstat express els exp els exp program procedurecallexp name v sourc mutex exp argument sequenc mutex exp program variableexp declar thismodul resolvetemp condit structur mutex wait p condsem third exp program procedurecallexp name p sourc condsem exp argument sequenc condsem exp program variableexp declar condsem wait condcount condcount count exp program variableexp declar count less program operatorcallexp name sourc count exp right one valu count exp program variableexp declar count generat signal procedur associ condit the procedur name built associ monitor name condit name signal constant it compos three statement urgentcount urgentcount condcount v condsem p urgent urgentcount urgentcount cond signal program procedur name condit structur name condit name signal statement sequenc signal stat signal stat signal stat contain condit structur program signal stat program assignmentstat target urgentcount exp valu urgentcount plus signal stat program conditionalstat condit condcount test thenstat sequenc signal condsem stat wait urgent stat signal stat program assignmentstat target urgentcount exp valu urgentcount less signal urgentcount urgentcount urgentcount exp program variableexp declar thismodul resolvetemp condit structur urgentcount urgentcount plus program operatorcallexp name sourc urgentcount exp right one valu urgentcount exp program variableexp declar thismodul resolvetemp condit structur urgentcount signal condcount v condsem p urgent condcount test program operatorcallexp name sourc count exp right zero valu count exp program variableexp declar count signal condsem stat program expressionstat express signal condsem signal condsem program procedurecallexp name v sourc condsem exp argument sequenc condsem exp program variableexp declar condsem wait urgent stat program expressionstat express wait urgent wait urgent program procedurecallexp name p sourc urgent exp argument sequenc urgent exp program variableexp declar thismodul resolvetemp condit structur urgent signal urgentcount urgentcount urgentcount exp program variableexp declar thismodul resolvetemp condit structur urgentcount urgentcount less program operatorcallexp name sourc urgentcount exp right one valu urgentcount exp program variableexp declar thismodul resolvetemp condit structur urgentcount basic valu element requir generat variabl initi fals valu program booleanexp symbol fals one valu program integerexp symbol one valu program integerexp symbol one valu program integerexp symbol one valu program integerexp symbol zero valu program integerexp symbol zero valu program integerexp symbol zero valu program integerexp symbol rule standaloneprocedur this rule copi standalon procedur defin input model output model rule standaloneprocedur program procedur contain ocliskindof program program program procedur name name paramet paramet variabl variabl statement statement contain contain rule monitorprocedur this rule copi procedur defin input model monitor output model the name generat procedur prefix monitor name the input procedur statement preced monitor enter statement follow monitor leav statement rule monitorprocedur program procedur contain ocliskindof program monitor generat procedur proc program procedur name contain name name paramet paramet variabl variabl statement sequenc stat statement stat contain contain program monitor enter statement p mutex stat program expressionstat express exp exp program procedurecallexp name p sourc mutex exp argument sequenc mutex exp program variableexp declar thismodul resolvetemp contain mutex monitor leav statement urgentcount v urgent els v mutex stat program conditionalstat condit urgentcount test thenstat sequenc st elsestat sequenc els st condit urgentcount test program operatorcallexp name sourc count exp right zero valu count exp program variableexp declar thismodul resolvetemp contain urgentcount zero valu program integerexp symbol statement st program expressionstat express exp exp program procedurecallexp name v sourc urgent exp argument sequenc urgent exp program variableexp declar thismodul resolvetemp contain urgent els statement els st program expressionstat express els exp els exp program procedurecallexp name v sourc mutex exp argument sequenc mutex exp program variableexp declar thismodul resolvetemp contain mutex rule type this rule copi type defin input model output model each match type must condit type monitor defin condit integ boolean type monitor defin case integ boolean type generat mainwithmonitor rule rule type program type name condit thismodul monitorsdefin thismodul monitorsdefin name boolean name integ program type name name rule booleanintegermonitorvariabledeclar this rule perform copi variabl declar type integ boolean declar either within monitor procedur monitor rule booleanintegermonitorvariabledeclar program variabledeclar oclistypeof program variabledeclar isdeclaredinmonitor type name integ type name boolean program variabledeclar name structur name name type gettyp initialvalu initialvalu structur gettargetstructur rule monitorvariabledeclar this rule perform copi variabl declar type differ integ boolean condit declar either within monitor procedur monitor rule monitorvariabledeclar program variabledeclar oclistypeof program variabledeclar isdeclaredinmonitor type name condit type name integ type name boolean program variabledeclar name structur name name type type initialvalu initialvalu structur gettargetstructur rule booleanintegervariabledeclar this rule perform copi variabl declar type integ boolean declar either within root program standalon procedur rule booleanintegerstandalonevariabledeclar program variabledeclar oclistypeof program variabledeclar isdeclaredinmonitor type name integ type name boolean program variabledeclar name name type gettyp initialvalu initialvalu structur structur rule standalonevariabledeclar this rule perform variabl declar type differ integ boolean condit declar either within root program standalon procedur rule standalonevariabledeclar program variabledeclar oclistypeof program variabledeclar isdeclaredinmonitor type name condit type name integ type name boolean program variabledeclar name name type type initialvalu initialvalu structur structur rule booleanintegermonitorparamet if monitor defin input program rule perform copi input model output model paramet type integ boolean rule booleanintegermonitorparamet program paramet thismodul monitorsdefin type name integ type name boolean program paramet name name type gettyp initialvalu initialvalu direct direct procedur procedur rule paramet this rule perform copi input model output model paramet monitor defin input program monitor defin input program paramet type integ boolean rule paramet program paramet thismodul monitorsdefin thismodul monitorsdefin type name integ type name boolean program paramet name name type type initialvalu initialvalu direct direct procedur procedur statement rule expressionstat this rule copi express statement input model output model rule expressionstat program expressionstat program expressionstat express express rule whilestat this rule copi statement input model output model rule whilestat program whilestat program whilestat condit condit dostat dostat rule conditionalstat this rule copi condit statement input model output model rule conditionalstat program conditionalstat program conditionalstat condit condit thenstat thenstat elsestat elsestat rule assignmentstat this rule copi assign statement input model output model rule assignmentstat program assignmentstat program assignmentstat target target valu valu express rule operatorcallexp this rule copi oper call express input model output model rule operatorcallexp program operatorcallexp program operatorcallexp right right sourc sourc name name rule attributecallexp this rule copi attribut call express input model output model rule attributecallexp program attributecallexp program attributecallexp sourc sourc name name rule procedurecallexp this rule copi procedur call express whose sourc differ condit input model output model rule procedurecallexp program procedurecallexp sourc declar type name condit program procedurecallexp argument argument sourc sourc name name rule conditionproccallexp this rule copi condit call express input model output model in output model sourc call set global variabl defin mainwithmonitor rule rule conditionproccallexp program procedurecallexp sourc declar type name condit call exp program procedurecallexp argument argument sourc sourc exp name sourc declar structur name sourc declar name name sourc exp program variableexp declar thismodul resolvetemp thismodul rootelt var rule variableexp this rule copi variabl express condit variabl input model output model rule variableexp program variableexp thismodul allcondcal exclud program variableexp declar declar rule booleanexp this rule copi boolean valu input model output model rule booleanexp program booleanexp program booleanexp symbol symbol rule integerexp this rule copi integ valu input model output model rule integerexp program integerexp program integerexp symbol symbol,0
124,124,P59-MySQL2KM3.atl,"-- @path XML=/MySQL2KM3/Metamodels/XML.ecore
-- @path MySQL=/MySQL2KM3/Metamodels/MySQL.ecore
-- @path KM3=/MySQL2KM3/Metamodels/KM3.ecore

module MySQL2KM3;
create OUT : KM3 from IN : MySQL;


-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- HELPER:	databaseElt
-- Returns the root Database entity of the input MySQM model.
-- CONTEXT:	thisModule
-- OUT:		MySQL!DataBase
helper def: dataBaseElt : MySQL!DataBase =
	MySQL!DataBase.allInstances()->asSequence()->first();

-- HELPER:	isStringType()
-- Returns a boolean stating whether the contextual string encodes a KM3 String
-- type.
-- CONTEXT:	String
-- OUT:		Boolean
helper context String def: isStringType() : Boolean =
	self = 'varchar';

-- HELPER:	isIntegerType()
-- Returns a boolean stating whether the contextual string encodes a KM3
-- Integer type.
-- CONTEXT:	String
-- OUT:		Boolean
helper context String def: isIntegerType() : Boolean =
	self = 'tinyint' or self = 'int';

-- HELPER:	isDoubleType()
-- Returns a boolean stating whether the contextual string encodes a KM3 Double
-- type.
-- CONTEXT:	String
-- OUT:		Boolean
helper context String def: isDoubleType() : Boolean =
	self = 'float' or self = 'double';

-- HELPER:	isUnsupportedType()
-- Returns a boolean stating whether the contextual string encodes a KM3
-- Unsupported type.
-- CONTEXT:	String
-- OUT:		Boolean
helper context String def: isUnsupportedType() : Boolean =
	self = 'date' or self = 'time' or self = 'blob' or self = 'longblob';

-- HELPER:	km3TypeExistsIn
-- Returns a boolean stationg whether the KM3 type encoded by the contextual
-- MySQL!Column is already defined within the set passed as parameter.
-- CONTEXT:	MySQL!Column
-- IN:		Set(MySQL!Column)
-- OUT:		Boolean
helper context MySQL!Column
		def: km3TypeExistsIn(s: Set(MySQL!Column)) : Boolean =
	s->iterate(e; res: Boolean = false |
		if self.type.isStringType()
		then
			if e.type.isStringType() or e.type.isUnsupportedType()
			then
				true
			else
				res
			endif
		else
			if self.type.isIntegerType()
			then
				if e.type.isIntegerType()
				then
					true
				else
					res
				endif
			else
				if self.type.isDoubleType()
				then
					if e.type.isDoubleType()
					then
						true
					else
						res
					endif
				else
					if self.type.isUnsupportedType()
					then
						if e.type.isStringType() or e.type.isUnsupportedType()
						then
							true
						else
							res
						endif
					else
						res
					endif
				endif
			endif
		endif
	);

-- HELPER:	isForeignKey
-- Returns a boolean stating whether the contextual MySQL!Column is a foreign
-- key.
-- CONTEXT:	MySQL!Column
-- OUT:		Boolean
helper context MySQL!Column def: isForeignKey : Boolean =
	self.comment.size() <> 0;

-- HELPER:	isDefinedIn
-- Returns a boolean stating whether the contextual MySQL!EnumItem is also
-- defined within the set passed as parameter.
-- CONTEXT:	MySQL!EnumItem
-- IN:		Set(MySQL!EnumItem)
-- OUT:		Boolean
helper context MySQL!EnumItem
		def: isDefinedIn(s: Set(MySQL!EnumItem)) : Boolean =
	s->iterate(i; res: Boolean = false |
		if self.name = i.name
		then
			true
		else
			res
		endif
	);

-- HELPER:	isEquivalentTo
-- Returns a boolean stating whether the contextual MySQL!EnumSet is equivalent to
-- the MySQL!EnumSet passed as parameter.
-- CONTEXT:	MySQL!EnumSet
-- IN:		MySQL!EnumSet
-- OUT:		Boolean
helper context MySQL!EnumSet def: isEquivalentTo(e: MySQL!EnumSet) : Boolean =
	if self.enumItems->size() <> e.enumItems->size()
	then
		false
	else
		self.enumItems->iterate(i; res: Boolean = true |
			if i.isDefinedIn( e.enumItems )
			then
				res
			else
				false
			endif
		)	
	endif;

-- HELPER:	enumExistsIn
-- Returns a boolean stating whether the contextual MySQL!EnumSet appears in
-- the sequence passed as parameter.
-- CONTEXT:	MySQL!EnumSet
-- IN:		Sequence(MySQL!EnumSet)
-- OUT:		Boolean
helper context MySQL!EnumSet
		def: enumExistsIn(s: Sequence(MySQL!EnumSet)) : Boolean =
	s->iterate(e; res: Boolean = false |
		if e.isEquivalentTo(self)
		then
			true
		else
			res
		endif
	);

-- HELPER:	enumSet
-- Returns a sequence of MySQL!EnumSet that contains one exemplary of the
-- different EnumSet defined in the input MySQL model.
-- CONTEXT:	thisModule
-- OUT:		Sequence(MySQL!EnumSet)
helper def: enumSet : Sequence(MySQL!EnumSet) =
	MySQL!EnumSet.allInstances()
		->asSet()
		->iterate(e; acc: Sequence(MySQL!EnumSet) = Sequence{} |
			if not e.enumExistsIn(acc)
			then
				acc.append(e)
			else
				acc
			endif
		);

-- HELPER:	dbTypeSet
-- Returns a set of MySQL!Column that contains one column of the different MySQL
-- datatypes present in the input MySQL model.
-- CONTEXT:	thisModule
-- OUT:		Set(MySQL!Column)
helper def: dbTypeSet : Set(MySQL!Column) =
	MySQL!Column.allInstances()
		->select(c | c.type <> 'enum' and not c.isForeignKey)
		->asSet();

-- HELPER:	km3TypeSet
-- Returns a set of MySQL!Column that contains one column of the different KM3
-- datatypes corresponding to the MySQL datatypes present in the input MySQL
-- model.
-- CONTEXT:	thisModule
-- OUT:		Set(MySQL!Column)
helper def: km3TypeSet : Set(MySQL!Column) =
	thisModule.dbTypeSet
		->iterate(c; acc: Set(MySQL!Column) = Set{} |
			if not c.km3TypeExistsIn(acc)
			then
				acc.including(c)
			else
				acc
			endif
		);

-- HELPER:	getTableNameRec()
-- Returns a string containing the name of the Table encoded by the contextual
-- string (recursive helper).
-- CONTEXT:	String
-- OUT:		String
helper context String def: getTableNameRec() : String =
	let char : String = self.substring(1 ,1) in
	if char = ':'
	then
		''
	else
		char.concat( self.substring(2, self.size()).getTableNameRec() )
	endif;

-- HELPER:	getTableName()
-- Returns a string encoding the name of a Table from the contextual string
-- that contains the Comment property of a MySQL!Column.
-- CONTEXT:	String
-- OUT:		String
helper context String def: getTableName() : String =
	self.getTableNameRec();

-- HELPER:	getReferredTable
-- Returns the MySQL!Table that contains the Column that is referred by the
-- contexual MySQL!Column.
-- CONTEXT:	MySQL!Column
-- OUT:		MySQL!Table
helper context MySQL!Column def: getReferredTable : MySQL!Table =
	let t_name : String = self.comment.getTableName() in
	MySQL!Table.allInstances()
		->select(t | t.name = t_name)
		->asSequence()->first();

-- HELPER:	getKM3TypeName()
-- Returns a string encoding the KM3 type corresponding to the type encoded by
-- the contextual string.
-- CONTEXT: String
-- OUT:		String
helper context String def: getKM3TypeName() : String =
	if self.isStringType()
	then
		'String'
	else
		if self.isIntegerType()
		then
			'Integer'
		else
			if self.isDoubleType()
			then
				'Double'
			else
				-- Default
				'String'
			endif
		endif
	endif;


-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'Metamodel'
-- Creates a Metamodel, a 'PrimitiveTypes' Package, and an empty Package from
-- the input Database element.
rule Metamodel {
	from
        i : MySQL!DataBase
	to
		o : KM3!Metamodel (
			location <- '',
			contents <- Sequence{p, pt}
		),
		p : KM3!Package (
			location <- '',
			name <- i.name,
			package <- OclUndefined,
			metamodel <- o,
			contents <- Sequence{}
		),
		pt : KM3!Package (
			location <- '',
			name <- 'PrimitiveTypes',
			package <- OclUndefined,
			metamodel <- o,
			contents <- 
				thisModule.km3TypeSet
					->collect(e | thisModule.resolveTemp(e, 'd'))
		)
}


-- Rule 'Class1'
-- Creates a Class from a Table that contains no foreign key.
rule Class1 {
	from
        i : MySQL!Table (
        	not i.columns->exists(c | c.isForeignKey)
        )
	to
		o : KM3!Class (
			location <- '',
			name <- i.name,
			package <- thisModule.resolveTemp(thisModule.dataBaseElt, 'p'),
			isAbstract <- false,
			supertypes <- Set{},
			structuralFeatures <-
				Sequence{
					i.columns->select(e | not e.isForeignKey),
					MySQL!Column.allInstances()
						->select(c |
							c.isForeignKey and
							not c.table.columns
								->exists(e | not e.isForeignKey) and
							c.table.columns->size() > 2)
						->select(c | c.getReferredTable = i)
						->collect(r | thisModule.resolveTemp(r, 'o2')),
					MySQL!Column.allInstances()
						->select(c |
							c.isForeignKey and
							not c.table.columns->exists(e | not e.isForeignKey) and
							c.table.columns->size() = 2)
						->select(c | c.getReferredTable = i)
				}->flatten(),
			operations <- Sequence{}
		)
}


-- Rule 'Class2'
-- Creates a Class from a Table that contains both foreign key and non foreign
-- key columns.
rule Class2 {
	from
        i : MySQL!Table (
        	i.columns->exists(c | c.isForeignKey) and
        	i.columns->exists(c | not c.isForeignKey)
        )
	to
		o : KM3!Class (
			location <- '',
			name <- i.name,
			package <- thisModule.resolveTemp(thisModule.dataBaseElt, 'p'),
			isAbstract <- false,
			supertypes <- Set{},
			structuralFeatures <-
				Sequence{
					i.columns,
					MySQL!Column.allInstances()
						->select(c |
							c.isForeignKey and
							not c.table.columns
								->exists(e | not e.isForeignKey) and
							c.table.columns->size() > 2)
						->select(c | c.getReferredTable = i)
						->collect(r | thisModule.resolveTemp(r, 'o2')),
					MySQL!Column.allInstances()
						->select(c |
							c.isForeignKey and
							not c.table.columns->exists(e | not e.isForeignKey) and
							c.table.columns->size() = 2)
						->select(c | c.getReferredTable = i)
				}->flatten(),
			operations <- Sequence{}
		)
}


-- Rule 'Class3'
-- Creates a Class from a Table that contains only no foreign key columns, and
-- whose columns number is > 2 .
rule Class3 {
	from
        i : MySQL!Table (
			not i.columns->exists(c | not c.isForeignKey) and
			i.columns->size() > 2
        )
	to
		o : KM3!Class (
			location <- '',
			name <- i.name,
			package <- thisModule.resolveTemp(thisModule.dataBaseElt, 'p'),
			isAbstract <- false,
			supertypes <- Set{},
			structuralFeatures <- i.columns,
			operations <- Sequence{}
		)
}


-- Rule 'Attribute1'
-- Creates an Attribute from a Column that is not a foreign key and that does
-- not belong to thisModule.km3TypeSet.
rule Attribute1 {
	from
        i : MySQL!Column (
        	not i.isForeignKey and
			not thisModule.km3TypeSet->exists(c | c = i)
        )
	to
		o : KM3!Attribute (
			location <- '',
			name <- i.name,
			package <- OclUndefined,
			lower <- 1,
			upper <- 1,
			isOrdered <- false,
			isUnique <- false,
			type <-
				if i.type = 'enum'
				then
					thisModule.enumSet
						->select(e | e.isEquivalentTo(i.enumSet))
						->asSequence()->first()
				else
					thisModule.resolveTemp(
						thisModule.km3TypeSet
							->select(e |
								e.type.getKM3TypeName() = i.type.getKM3TypeName())
							->asSequence()->first(),
						'd'
					)
				endif,
			owner <- i.table,
			subsetOf <- Set{},
			derivedFrom <- Set{}
		)
}


-- Rule 'Attribute2'
-- Creates an Attribute and a DataType from a Column that is not a foreign key
-- but that belongs to thisModule.km3TypeSet.
rule Attribute2 {
	from
        i : MySQL!Column (
        	not i.isForeignKey and
			thisModule.km3TypeSet->exists(c | c = i)
        )
	to
		o : KM3!Attribute (
			location <- '',
			name <- i.name,
			package <- OclUndefined,
			lower <- 1,
			upper <- 1,
			isOrdered <- false,
			isUnique <- false,
			type <- d,
			owner <- i.table,
			subsetOf <- Set{},
			derivedFrom <- Set{}
		),
		d : KM3!DataType (
			location <- '',
			name <- i.type.getKM3TypeName(),
			package <- thisModule.resolveTemp(thisModule.dataBaseElt, 'pt')
		)
}


-- Rule 'Reference1'
-- Creates a Reference from a foreign key Column embedded in a Table that also
-- contains non foreign key columns.
rule Reference1 {
	from
        i : MySQL!Column (
        	i.isForeignKey and
			i.table.columns->exists(c | not c.isForeignKey)
        )
	to
		o : KM3!Reference (
			location <- '',
			name <- i.name,
			package <- OclUndefined,
			lower <- 1,
			upper <- 1,
			isOrdered <- false,
			isUnique <- false,
			type <- i.getReferredTable,
			owner <- i.table,
			subsetOf <- Set{},
			derivedFrom <- Set{},
			isContainer <- false,
			opposite <- OclUndefined
		)
}


-- Rule 'Reference2'
-- Creates a Reference from a foreign key Column embedded in a 2 columns Table
-- that only contains foreign key columns.
rule Reference2 {
	from
        i : MySQL!Column (
        	i.isForeignKey and
			not i.table.columns->exists(c | not c.isForeignKey) and
			i.table.columns->size() = 2
        )
	to
		o : KM3!Reference (
			location <- '',
			name <- i.name,
			package <- OclUndefined,
			lower <- 0,
			upper <- 0-1,
			isOrdered <- false,
			isUnique <- false,
			type <- i.getReferredTable,
			owner <-
				i.table.columns
					->select(c | c <> i)
					->asSequence()->first().getReferredTable,
			subsetOf <- Set{},
			derivedFrom <- Set{},
			isContainer <- false,
			opposite <-
				i.table.columns->select(c | c <> i)->asSequence()->first()
		)
}


-- Rule 'Reference3'
-- Creates a couple of References from a foreign key Column embedded in a Table
-- with more than 2 columns, and that only contains foreign key columns (such
-- tables are created by rule 'Class3').
rule Reference3 {
	from
        i : MySQL!Column (
        	i.isForeignKey and
			not i.table.columns->exists(c | not c.isForeignKey) and
			i.table.columns->size() > 2
        )
	to
		-- Reference owned by the Table only composed of foreign keys
		o1 : KM3!Reference (
			location <- '',
			name <- i.name,
			package <- OclUndefined,
			lower <- 0,
			upper <- 0-1,
			isOrdered <- false,
			isUnique <- false,
			type <- i.getReferredTable,
			owner <- i.table,
			subsetOf <- Set{},
			derivedFrom <- Set{},
			isContainer <- false,
			opposite <- o2
		),
		-- Reference owned by the referred Table
		o2 : KM3!Reference (
			location <- '',
			name <- i.table.name,
			package <- OclUndefined,
			lower <- 0,
			upper <- 0-1,
			isOrdered <- false,
			isUnique <- false,
			type <- i.table,
			owner <- i.getReferredTable,
			subsetOf <- Set{},
			derivedFrom <- Set{},
			isContainer <- false,
			opposite <- o1
		)
}


-- Rule 'Enumeration'
-- Creates an Enumeration from an EnumSet that belongs to thisModule.enumSet.
rule Enumeration {
	from
        i : MySQL!EnumSet (
        	thisModule.enumSet->exists(e | e = i)
        )
	to
		o : KM3!Enumeration (
			location <- '',
			name <- 'Enum_'.concat(thisModule.enumSet->indexOf(i).toString()),
			package <- thisModule.resolveTemp(thisModule.dataBaseElt, 'p'),
			literals <- i.enumItems
		)
}


-- Rule 'EnumLiteral'
-- Creates an EnumLiteral from an EnumItem defined within an EnumSet that
-- belongs to thisModule.enumSet.
rule EnumLiteral {
	from
        i : MySQL!EnumItem (
        	thisModule.enumSet->exists(e | e = i.enumSet)
        )
	to
		o : KM3!EnumLiteral (
			location <- '',
			name <- i.name,
			package <- OclUndefined
		)
}
",path xml mysql km metamodel xml ecor path mysql mysql km metamodel mysql ecor path km mysql km metamodel km ecor modul mysql km creat out km in mysql helper helper databaseelt return root databas entiti input mysqm model context thismodul out mysql databas helper def databaseelt mysql databas mysql databas allinst assequ first helper isstringtyp return boolean state whether contextu string encod km string type context string out boolean helper context string def isstringtyp boolean self varchar helper isintegertyp return boolean state whether contextu string encod km integ type context string out boolean helper context string def isintegertyp boolean self tinyint self int helper isdoubletyp return boolean state whether contextu string encod km doubl type context string out boolean helper context string def isdoubletyp boolean self float self doubl helper isunsupportedtyp return boolean state whether contextu string encod km unsupport type context string out boolean helper context string def isunsupportedtyp boolean self date self time self blob self longblob helper km typeexistsin return boolean stationg whether km type encod contextu mysql column alreadi defin within set pass paramet context mysql column in set mysql column out boolean helper context mysql column def km typeexistsin set mysql column boolean iter e res boolean fals self type isstringtyp e type isstringtyp e type isunsupportedtyp true els res endif els self type isintegertyp e type isintegertyp true els res endif els self type isdoubletyp e type isdoubletyp true els res endif els self type isunsupportedtyp e type isstringtyp e type isunsupportedtyp true els res endif els res endif endif endif endif helper isforeignkey return boolean state whether contextu mysql column foreign key context mysql column out boolean helper context mysql column def isforeignkey boolean self comment size helper isdefinedin return boolean state whether contextu mysql enumitem also defin within set pass paramet context mysql enumitem in set mysql enumitem out boolean helper context mysql enumitem def isdefinedin set mysql enumitem boolean iter res boolean fals self name name true els res endif helper isequivalentto return boolean state whether contextu mysql enumset equival mysql enumset pass paramet context mysql enumset in mysql enumset out boolean helper context mysql enumset def isequivalentto e mysql enumset boolean self enumitem size e enumitem size fals els self enumitem iter res boolean true isdefinedin e enumitem res els fals endif endif helper enumexistsin return boolean state whether contextu mysql enumset appear sequenc pass paramet context mysql enumset in sequenc mysql enumset out boolean helper context mysql enumset def enumexistsin sequenc mysql enumset boolean iter e res boolean fals e isequivalentto self true els res endif helper enumset return sequenc mysql enumset contain one exemplari differ enumset defin input mysql model context thismodul out sequenc mysql enumset helper def enumset sequenc mysql enumset mysql enumset allinst asset iter e acc sequenc mysql enumset sequenc e enumexistsin acc acc append e els acc endif helper dbtypeset return set mysql column contain one column differ mysql datatyp present input mysql model context thismodul out set mysql column helper def dbtypeset set mysql column mysql column allinst select c c type enum c isforeignkey asset helper km typeset return set mysql column contain one column differ km datatyp correspond mysql datatyp present input mysql model context thismodul out set mysql column helper def km typeset set mysql column thismodul dbtypeset iter c acc set mysql column set c km typeexistsin acc acc includ c els acc endif helper gettablenamerec return string contain name tabl encod contextu string recurs helper context string out string helper context string def gettablenamerec string let char string self substr char els char concat self substr self size gettablenamerec endif helper gettablenam return string encod name tabl contextu string contain comment properti mysql column context string out string helper context string def gettablenam string self gettablenamerec helper getreferredt return mysql tabl contain column refer contexu mysql column context mysql column out mysql tabl helper context mysql column def getreferredt mysql tabl let name string self comment gettablenam mysql tabl allinst select name name assequ first helper getkm typenam return string encod km type correspond type encod contextu string context string out string helper context string def getkm typenam string self isstringtyp string els self isintegertyp integ els self isdoubletyp doubl els default string endif endif endif rule rule metamodel creat metamodel primitivetyp packag empti packag input databas element rule metamodel mysql databas km metamodel locat content sequenc p pt p km packag locat name name packag oclundefin metamodel content sequenc pt km packag locat name primitivetyp packag oclundefin metamodel content thismodul km typeset collect e thismodul resolvetemp e rule class creat class tabl contain foreign key rule class mysql tabl column exist c c isforeignkey km class locat name name packag thismodul resolvetemp thismodul databaseelt p isabstract fals supertyp set structuralfeatur sequenc column select e e isforeignkey mysql column allinst select c c isforeignkey c tabl column exist e e isforeignkey c tabl column size select c c getreferredt collect r thismodul resolvetemp r mysql column allinst select c c isforeignkey c tabl column exist e e isforeignkey c tabl column size select c c getreferredt flatten oper sequenc rule class creat class tabl contain foreign key non foreign key column rule class mysql tabl column exist c c isforeignkey column exist c c isforeignkey km class locat name name packag thismodul resolvetemp thismodul databaseelt p isabstract fals supertyp set structuralfeatur sequenc column mysql column allinst select c c isforeignkey c tabl column exist e e isforeignkey c tabl column size select c c getreferredt collect r thismodul resolvetemp r mysql column allinst select c c isforeignkey c tabl column exist e e isforeignkey c tabl column size select c c getreferredt flatten oper sequenc rule class creat class tabl contain foreign key column whose column number rule class mysql tabl column exist c c isforeignkey column size km class locat name name packag thismodul resolvetemp thismodul databaseelt p isabstract fals supertyp set structuralfeatur column oper sequenc rule attribut creat attribut column foreign key belong thismodul km typeset rule attribut mysql column isforeignkey thismodul km typeset exist c c km attribut locat name name packag oclundefin lower upper isord fals isuniqu fals type type enum thismodul enumset select e e isequivalentto enumset assequ first els thismodul resolvetemp thismodul km typeset select e e type getkm typenam type getkm typenam assequ first endif owner tabl subsetof set derivedfrom set rule attribut creat attribut datatyp column foreign key belong thismodul km typeset rule attribut mysql column isforeignkey thismodul km typeset exist c c km attribut locat name name packag oclundefin lower upper isord fals isuniqu fals type owner tabl subsetof set derivedfrom set km datatyp locat name type getkm typenam packag thismodul resolvetemp thismodul databaseelt pt rule refer creat refer foreign key column embed tabl also contain non foreign key column rule refer mysql column isforeignkey tabl column exist c c isforeignkey km refer locat name name packag oclundefin lower upper isord fals isuniqu fals type getreferredt owner tabl subsetof set derivedfrom set iscontain fals opposit oclundefin rule refer creat refer foreign key column embed column tabl contain foreign key column rule refer mysql column isforeignkey tabl column exist c c isforeignkey tabl column size km refer locat name name packag oclundefin lower upper isord fals isuniqu fals type getreferredt owner tabl column select c c assequ first getreferredt subsetof set derivedfrom set iscontain fals opposit tabl column select c c assequ first rule refer creat coupl refer foreign key column embed tabl column contain foreign key column tabl creat rule class rule refer mysql column isforeignkey tabl column exist c c isforeignkey tabl column size refer own tabl compos foreign key km refer locat name name packag oclundefin lower upper isord fals isuniqu fals type getreferredt owner tabl subsetof set derivedfrom set iscontain fals opposit refer own refer tabl km refer locat name tabl name packag oclundefin lower upper isord fals isuniqu fals type tabl owner getreferredt subsetof set derivedfrom set iscontain fals opposit rule enumer creat enumer enumset belong thismodul enumset rule enumer mysql enumset thismodul enumset exist e e km enumer locat name enum concat thismodul enumset indexof tostr packag thismodul resolvetemp thismodul databaseelt p liter enumitem rule enumliter creat enumliter enumitem defin within enumset belong thismodul enumset rule enumliter mysql enumitem thismodul enumset exist e e enumset km enumliter locat name name packag oclundefin,18
125,125,P59-XML2MySQL.atl,"-- @path XML=/MySQL2KM3/Metamodels/XML.ecore
-- @path MySQL=/MySQL2KM3/Metamodels/MySQL.ecore
-- @path KM3=/MySQL2KM3/Metamodels/KM3.ecore

module XML2MySQL;
create OUT : MySQL from IN : XML;


-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- HELPER:	rootElt
-- Returns the root Root element of the XML input model.
-- CONTEXT:	thisModule
-- OUT:		XML!Root
helper def: rootElt : XML!Root =
	XML!Root.allInstances()->asSequence()->first();

-- HELPER:	getAttrVal
-- Returns a string corresponding to the value of the attribute (identified by
-- the string passed as parameter) of the contextual XML!Element.
-- CONTEXT:	XML!Element
-- IN:		String
-- OUT:		String
helper context XML!Element def: getAttrVal(name : String) : String =
    self.children
		->select(c | c.oclIsKindOf(XML!Attribute) and c.name = name)
		->first().value;

-- HELPER:	getElementsByName
-- Returns the XML!Element corresponding to the children (identified by the
-- string passed as parameter) of the contextual XML!Element.
-- CONTEXT:	XML!Element
-- IN:		String
-- OUT:		Set(XML!Element)
helper context XML!Element
	def: getElementsByName(name : String) : Set(XML!Element) =
	self.children->select(c | c.oclIsKindOf(XML!Element) and c.name = name);

-- HELPER:	getFirstElementByName
-- Returns the XML!Element corresponding to the first child (identified by the
-- string passed as parameter) of the contextual XML!Element.
-- CONTEXT:	XML!Element
-- IN:		String
-- OUT:		XML!Element
helper context XML!Element
	def: getFirstElementByName(name : String) : XML!Element =
	self.getElementsByName(name)->first();

-- HELPER:	getTextValue()
-- Returns a string contraining the value of the Text which is the child of the
-- contextual XML!Element.
-- CONTEXT:	XML!Element
-- OUT:		String
helper context XML!Element def: getTextValue() : String =
	if self.children->isEmpty()
	then
		''
	else
		if self.children->first().oclIsUndefined()
		then
			''
		else
			self.children->first().value
		endif
	endif;

-- HELPER:	isIntegerType()
-- Returns a boolean stating whether the contextual String encodes a MySQL
-- integer type.
-- CONTEXT:	String
-- OUT:		Boolean
helper context String def: isIntegerType() : Boolean =
	self.startsWith('tinyint') or self.startsWith('int');

-- HELPER:	getItemListRec
-- Returns a sequence of strings corresponding to the different EnumItems
-- encoded within the contextual String.
-- The String passed as parameter contains the EnumItem being parsed.
-- CONTEXT:	String
-- IN:		String
-- OUT:		Sequence(String)
helper context String def: getItemListRec(it : String) : Sequence(String) =
	let char : String = self.substring(1, 1) in
	if self.size() = 1
	then
		Sequence{}
	else
		if char = ','
		then
			self.substring(2, self.size()).getItemListRec('')
		else
			if char = '\''
			then
				if it = ''
				then
					self.substring(2, self.size()).getItemListRec('')
				else
					Sequence{
						it,
						self.substring(2, self.size()).getItemListRec('')
					}->flatten()
				endif
			else
				self.substring(2, self.size()).getItemListRec(it.concat(char))
			endif
		endif
	endif;
		
-- HELPER:	getItemList
-- Returns a sequence of strings corresponding to the different EnumItems encoded
-- within the contextual String.
-- CONTEXT:	String
-- OUT:		Sequence(String)
helper context String def: getItemList() : Sequence(String) =
	let list : String = self.substring(6, self.size()) in
	list.getItemListRec('');

-- HELPER:	getTypeNameRec
-- Returns a string containing the name of the type encoded by the contextual
-- string (recursive helper).
-- CONTEXT:	String
-- OUT:		String
helper context String def: getTypeNameRec() : String =
	let char : String = self.substring(1, 1) in
	if self.size() = 1
	then
		''
	else
		if char = '(' or char = ' '
		then
			''
		else
			char.concat( self.substring(2, self.size()).getTypeNameRec() )
		endif
	endif;

-- HELPER:	getTypeName()
-- Returns a String encoding the name of the type that is contained within the
-- contextual Sring.
-- CONTEXT:	String
-- OUT:		String
helper context String def: getTypeName() : String =
	self.concat('#').getTypeNameRec();


-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'DataBase'
-- Creates a DataBase from the root Root element.
rule DataBase {
	from
        i : XML!Root
	to
		o : MySQL!DataBase (
			name <- i.getAttrVal('name'),
			tables <- XML!Element.allInstances()
						->select(e | e.name = 'WINDEV_TABLE')
		)
}


-- Rule 'Table'
-- Creates a Table from an XML!Element named 'WINDEV_TABLE'.
rule Table {
	from
        i : XML!Element (
        	i.name = 'WINDEV_TABLE'
        )
	to
		o : MySQL!Table (
			name <- i.getAttrVal('name'),
			columns <-
				i.getElementsByName('TableInfoTable')->asSequence()
					->select(e |
						e.getFirstElementByName('Type').getTextValue().startsWith('tinyint')
					),
			database <- thisModule.rootElt
		)
}


-- Rule 'IntegerColumn'
-- Creates an IntegerColumn from an XML!Element named 'TableInfoTable' having
-- an integer type.
rule IntegerColumn {
	from
        i : XML!Element (
        	if i.name = 'TableInfoTable'
			then
				i.getFirstElementByName('Type').getTextValue().isIntegerType()
			else
				false
			endif
        )
	to
		o : MySQL!IntegerColumn (
			name <- i.getFirstElementByName('Field').getTextValue(),
			type <-
				i.getFirstElementByName('Type').getTextValue().getTypeName(),
			isPrimaryKey <-
				i.getFirstElementByName('Key').getTextValue() = 'PRI',
			null <- i.getFirstElementByName('Null').getTextValue() = 'YES',
			defaultValue <- i.getFirstElementByName('Default').getTextValue(),
			comment <- i.getFirstElementByName('Comment').getTextValue(),
			isAutoIncrement <-
				i.getFirstElementByName('Extra').getTextValue() = 'auto_increment',
			table <- i.parent
		)
}


-- Rule 'EnumColumn'
-- Creates an EnumColumn from an XML!Element named 'TableInfoTable' having
-- an enumeration type.
rule EnumColumn {
	from
        i : XML!Element (
        	if i.name = 'TableInfoTable'
			then
				i.getFirstElementByName('Type').getTextValue().startsWith('enum')
			else
				false
			endif
        )
	using {
       	items : Sequence(String) =
       		i.getFirstElementByName('Type').getTextValue().getItemList();
	}
	to
		o : MySQL!EnumColumn (
			name <- i.getFirstElementByName('Field').getTextValue(),
			type <- 'enum',
			isPrimaryKey <-
				i.getFirstElementByName('Key').getTextValue() = 'PRI',
			null <- i.getFirstElementByName('Null').getTextValue() = 'YES',
			defaultValue <- i.getFirstElementByName('Default').getTextValue(),
			comment <- i.getFirstElementByName('Comment').getTextValue(),
			table <- i.parent,
			enumSet <- e1
		),
		e1 : MySQL!EnumSet (
			enumItems <- items -> collect(it | thisModule.EnumItems(it, e1))
--			enumItems <- e2
		)
--		e2 : distinct MySQL!EnumItem foreach(i in items) (
--			name <- i,
--			enumSet <- e1
--		)
}

lazy rule EnumItems {
	from
		item: String,
		e1: MySQL!EnumSet 
	to
		e2: MySQL!EnumItem (
			name <- item,
			enumSet <- e1
		)
}


-- Rule 'Column'
-- Creates a Column from an XML!Element named 'TableInfoTable' having neither
-- an integer nor an enumeration type.
rule Column {
	from
        i : XML!Element (
        	if i.name = 'TableInfoTable'
			then
				let type : String =
					i.getFirstElementByName('Type').getTextValue() in
				not type.isIntegerType() and not type.startsWith('enum')
			else
				false
			endif
        )
	to
		o : MySQL!Column (
			name <- i.getFirstElementByName('Field').getTextValue(),
			type <-
				i.getFirstElementByName('Type').getTextValue().getTypeName(),
			isPrimaryKey <-
				i.getFirstElementByName('Key').getTextValue() = 'PRI',
			null <- i.getFirstElementByName('Null').getTextValue() = 'YES',
			defaultValue <- i.getFirstElementByName('Default').getTextValue(),
			comment <- i.getFirstElementByName('Comment').getTextValue(),
			table <- i.parent
		)
}
",path xml mysql km metamodel xml ecor path mysql mysql km metamodel mysql ecor path km mysql km metamodel km ecor modul xml mysql creat out mysql in xml helper helper rootelt return root root element xml input model context thismodul out xml root helper def rootelt xml root xml root allinst assequ first helper getattrv return string correspond valu attribut identifi string pass paramet contextu xml element context xml element in string out string helper context xml element def getattrv name string string self children select c c ocliskindof xml attribut c name name first valu helper getelementsbynam return xml element correspond children identifi string pass paramet contextu xml element context xml element in string out set xml element helper context xml element def getelementsbynam name string set xml element self children select c c ocliskindof xml element c name name helper getfirstelementbynam return xml element correspond first child identifi string pass paramet contextu xml element context xml element in string out xml element helper context xml element def getfirstelementbynam name string xml element self getelementsbynam name first helper gettextvalu return string contrain valu text child contextu xml element context xml element out string helper context xml element def gettextvalu string self children isempti els self children first oclisundefin els self children first valu endif endif helper isintegertyp return boolean state whether contextu string encod mysql integ type context string out boolean helper context string def isintegertyp boolean self startswith tinyint self startswith int helper getitemlistrec return sequenc string correspond differ enumitem encod within contextu string the string pass paramet contain enumitem pars context string in string out sequenc string helper context string def getitemlistrec string sequenc string let char string self substr self size sequenc els char self substr self size getitemlistrec els char self substr self size getitemlistrec els sequenc self substr self size getitemlistrec flatten endif els self substr self size getitemlistrec concat char endif endif endif helper getitemlist return sequenc string correspond differ enumitem encod within contextu string context string out sequenc string helper context string def getitemlist sequenc string let list string self substr self size list getitemlistrec helper gettypenamerec return string contain name type encod contextu string recurs helper context string out string helper context string def gettypenamerec string let char string self substr self size els char char els char concat self substr self size gettypenamerec endif endif helper gettypenam return string encod name type contain within contextu sring context string out string helper context string def gettypenam string self concat gettypenamerec rule rule databas creat databas root root element rule databas xml root mysql databas name getattrv name tabl xml element allinst select e e name windev tabl rule tabl creat tabl xml element name windev tabl rule tabl xml element name windev tabl mysql tabl name getattrv name column getelementsbynam tableinfot assequ select e e getfirstelementbynam type gettextvalu startswith tinyint databas thismodul rootelt rule integercolumn creat integercolumn xml element name tableinfot integ type rule integercolumn xml element name tableinfot getfirstelementbynam type gettextvalu isintegertyp els fals endif mysql integercolumn name getfirstelementbynam field gettextvalu type getfirstelementbynam type gettextvalu gettypenam isprimarykey getfirstelementbynam key gettextvalu pri null getfirstelementbynam null gettextvalu yes defaultvalu getfirstelementbynam default gettextvalu comment getfirstelementbynam comment gettextvalu isautoincr getfirstelementbynam extra gettextvalu auto increment tabl parent rule enumcolumn creat enumcolumn xml element name tableinfot enumer type rule enumcolumn xml element name tableinfot getfirstelementbynam type gettextvalu startswith enum els fals endif use item sequenc string getfirstelementbynam type gettextvalu getitemlist mysql enumcolumn name getfirstelementbynam field gettextvalu type enum isprimarykey getfirstelementbynam key gettextvalu pri null getfirstelementbynam null gettextvalu yes defaultvalu getfirstelementbynam default gettextvalu comment getfirstelementbynam comment gettextvalu tabl parent enumset e e mysql enumset enumitem item collect thismodul enumitem e enumitem e e distinct mysql enumitem foreach item name enumset e lazi rule enumitem item string e mysql enumset e mysql enumitem name item enumset e rule column creat column xml element name tableinfot neither integ enumer type rule column xml element name tableinfot let type string getfirstelementbynam type gettextvalu type isintegertyp type startswith enum els fals endif mysql column name getfirstelementbynam field gettextvalu type getfirstelementbynam type gettextvalu gettypenam isprimarykey getfirstelementbynam key gettextvalu pri null getfirstelementbynam null gettextvalu yes defaultvalu getfirstelementbynam default gettextvalu comment getfirstelementbynam comment gettextvalu tabl parent,0
126,126,P59-XML2XML.atl,"-- @path XML=/MySQL2KM3/Metamodels/XML.ecore
-- @path MySQL=/MySQL2KM3/Metamodels/MySQL.ecore
-- @path KM3=/MySQL2KM3/Metamodels/KM3.ecore

module XML2XML;
create OUT : XML from IN : XML;


-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- HELPER:	toKeep
-- Returns a boolean stating whether the contextual Node has to be copied from
-- the input to the output XML model.
-- CONTEXT:	XML!Node
-- OUT:		Boolean
helper context XML!Node def: toKeep : Boolean =
	if self.oclIsTypeOf(XML!Text)
	then
		self.value.trim() <> ''
	else
		false
	endif;


-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'Attribute'
-- Copies the input Attribute to the out one.
rule Attribute {
	from
        i : XML!Attribute
	to
		o : XML!Attribute (
			startLine <- i.startLine,
			endLine <- i.endLine,
			startColumn <- i.startColumn,
			endColumn <- i.endColumn,
			name <- i.name,
			value <- i.value,
			parent <- i.parent
	)
}

-- Rule 'Text'
-- Copies a Text that is not composed of only blank characters.
rule Text {
	from
        i : XML!Text (
			i.value.trim() <> ''
		)
	to
		o : XML!Text (
			startLine <- i.startLine,
			endLine <- i.endLine,
			startColumn <- i.startColumn,
			endColumn <- i.endColumn,
			name <- i.name,
			value <- i.value,
			parent <- i.parent
	)
}

-- Rule 'Element'
-- Copies the input Element to the out one. Children of the generated Element
-- are filtered using the toKeep helper.
rule Element {
	from
        i : XML!Element (
        	i.oclIsTypeOf(XML!Element)
        )
	to
		o : XML!Element (
			startLine <- i.startLine,
			endLine <- i.endLine,
			startColumn <- i.startColumn,
			endColumn <- i.endColumn,
			name <- i.name,
			value <- i.value,
			parent <- i.parent,
			children <- i.children->select(e | e.toKeep)
	)
}

-- Rule 'Root'
-- Copies the input Root to the out one. Children of the generated Element
-- are filtered using the toKeep helper.
rule Root {
	from
        i : XML!Root
	to
		o : XML!Root (
			startLine <- i.startLine,
			endLine <- i.endLine,
			startColumn <- i.startColumn,
			endColumn <- i.endColumn,
			name <- i.name,
			value <- i.value,
			parent <- i.parent,
			children <- i.children->select(e | e.toKeep)
	)
}
",path xml mysql km metamodel xml ecor path mysql mysql km metamodel mysql ecor path km mysql km metamodel km ecor modul xml xml creat out xml in xml helper helper tokeep return boolean state whether contextu node copi input output xml model context xml node out boolean helper context xml node def tokeep boolean self oclistypeof xml text self valu trim els fals endif rule rule attribut copi input attribut one rule attribut xml attribut xml attribut startlin startlin endlin endlin startcolumn startcolumn endcolumn endcolumn name name valu valu parent parent rule text copi text compos blank charact rule text xml text valu trim xml text startlin startlin endlin endlin startcolumn startcolumn endcolumn endcolumn name name valu valu parent parent rule element copi input element one children generat element filter use tokeep helper rule element xml element oclistypeof xml element xml element startlin startlin endlin endlin startcolumn startcolumn endcolumn endcolumn name name valu valu parent parent children children select e e tokeep rule root copi input root one children generat element filter use tokeep helper rule root xml root xml root startlin startlin endlin endlin startcolumn startcolumn endcolumn endcolumn name name valu valu parent parent children children select e e tokeep,0
127,127,P6-BibTeX2DocBook.atl,"module BibTeX2DocBook;
create OUT : DocBook from IN : BibTeX;


-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- This helper builds the set of distinct authors referenced in the input BibTeX
-- model.
-- Built set is sorted by author name.
-- RETURN: Sequence(BibTeX!Author)
helper def: authorSet : Sequence(BibTeX!Author) = BibTeX!Author.allInstances()->iterate(e; ret : Sequence(BibTeX!Author) = Sequence {} |
				if ret->collect(e | e.author)->includes(e.author) then
					ret
				else
					ret->including(e)
				endif
			)->sortedBy(e | e.author);

-- This helper builds the set of distinct titles referenced in the input BibTeX
-- model.
-- Built set is sorted by title.
-- RETURN: Sequence(BibTeX!TitledEntry)
helper def: titledEntrySet : Sequence(BibTeX!TitledEntry) = BibTeX!TitledEntry.allInstances()->iterate(e; ret : Sequence(BibTeX!TitledEntry) = Sequence {} |
				if ret->collect(e | e.title)->includes(e.title) then
					ret
				else
					ret->including(e)
				endif
			)->sortedBy(e | e.title);

-- This helper builds the set of distinct journals referenced in the input BibTeX
-- model.
-- Built set is sorted by journal name.
-- RETURN: Sequence(BibTeX!Article)
helper def: articleSet : Sequence(BibTeX!Article) = BibTeX!Article.allInstances()->iterate(e; ret : Sequence(BibTeX!Article) = Sequence {} |
				if ret->collect(e | e.journal)->includes(e.journal) then
					ret
				else
					ret->including(e)
				endif
			)->sortedBy(e | e.journal);

-- This helper builds a string containing all information on a given BibTeXEntry.
-- Content of the generated string depends on the entry type.
-- IN: BibTeX!BibTeXEntry
-- RETURN: Sequence(BibTeX!Author)
helper context BibTeX!BibTeXEntry def: buildEntryPara() : String =
	'[' + self.id + ']'
	+ ' ' + self.oclType().name
	+ (if self.oclIsKindOf(BibTeX!TitledEntry) then ' ' + self.title else '' endif)
	+ (if self.oclIsKindOf(BibTeX!AuthoredEntry) 
	   then self.authors->iterate(e; str : String = '' | str + ' ' + e.author)
	   else ''
	   endif)
	+ (if self.oclIsKindOf(BibTeX!DatedEntry) then ' ' + self.year else '' endif)
	+ (if self.oclIsKindOf(BibTeX!BookTitledEntry) then ' ' + self.booktitle else '' endif)
	+ (if self.oclIsKindOf(BibTeX!ThesisEntry) then ' ' +  self.school else '' endif)
	+ (if self.oclIsKindOf(BibTeX!Article) then ' ' + self.journal else '' endif)
	+ (if self.oclIsKindOf(BibTeX!Unpublished) then ' ' + self.note else '' endif)
	+ (if self.oclIsKindOf(BibTeX!Book) then ' ' + self.publisher else '' endif)
	+ (if self.oclIsKindOf(BibTeX!InBook) then ' ' + self.chapter.toString() else '' endif)
	;


-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'Main'
-- This rule generates the structure of the DocBook model from a BibTeXFile element
rule Main {
	from
        bib : BibTeX!BibTeXFile
	to 
		doc : DocBook!DocBook (
			books <- boo
		),
		boo : DocBook!Book (
			articles <- art
		),
		art : DocBook!Article (
			title <- 'BibTeXML to DocBook',
			sections_1 <- Sequence{se1, se2, se3, se4}
		),
		se1 : DocBook!Sect1 (
			title <- 'References List',
			paras <- BibTeX!BibTeXEntry.allInstances()->sortedBy(e | e.id)
		),
		se2 : DocBook!Sect1 (
			title <- 'Authors list',
			paras <- thisModule.authorSet
		),
		se3 : DocBook!Sect1 (
			title <- 'Titles List',
			paras <- thisModule.titledEntrySet->collect(e | thisModule.resolveTemp(e, 'title_para'))
		),
		se4 : DocBook!Sect1 (
			title <- 'Journals List',
			paras <- thisModule.articleSet->collect(e | thisModule.resolveTemp(e, 'journal_para'))
		)
}

-- Rule 'Author'
-- This rule generates a section_2 paragraph for each distinct author.
rule Author {
	from
		a : BibTeX!Author (
			  thisModule.authorSet->includes(a)
			)
	to
		p1 : DocBook!Para (
			content <- a.author
		)
}

-- Rule 'UntitledEntry'
-- This rule generates a section_1 paragraph for each untitled entry.
rule UntitledEntry {
	from
		e : BibTeX!BibTeXEntry (
			not e.oclIsKindOf(BibTeX!TitledEntry)
		)
	to
		p : DocBook!Para (
			content <- e.buildEntryPara()
		)
}

-- Rule 'TitledEntry_Title_NoArticle'
-- [titledEntrySet contains a subset of TitledEntry, so that each title
-- appears only once in the set]
-- For each ""no article"" titled entry that belongs to titledEntrySet,
-- this rule generates:
--   * a section_1 paragraph;
--   * a section_3 paragraph.
rule TitledEntry_Title_NoArticle {
	from
		e : BibTeX!TitledEntry (
			thisModule.titledEntrySet->includes(e) and
			not e.oclIsKindOf(BibTeX!Article)
		)
	to
		entry_para : DocBook!Para (
			content <- e.buildEntryPara()
		),
		title_para : DocBook!Para (
			content <- e.title
		)
}

-- Rule 'TitledEntry_NoTitle_NoArticle'
-- [titledEntrySet contains a subset of TitledEntry, so that each title
-- appears only once in the set]
-- For each ""no article"" titled entry that does not belong to titledEntrySet,
-- this rule generates:
--   * a section_1 paragraph;
rule TitledEntry_NoTitle_NoArticle {
	from
		e : BibTeX!TitledEntry (
			not thisModule.titledEntrySet->includes(e) and
			not e.oclIsKindOf(BibTeX!Article)
		)
	to
		entry_para : DocBook!Para (
			content <- e.buildEntryPara()
		)
}

-- Rule 'Article_Title_Journal'
-- [titledEntrySet contains a subset of TitledEntry, so that each title
-- appears only once in the set]
-- [articleSet contains a subset of Article, so that each journal
-- appears only once in the set]
-- For each article entry that belongs to articleSet, this rule generates:
--   * a section_1 paragraph;
--   * a section_3 paragraph;
--   * a section_4 paragraph.
rule Article_Title_Journal {
	from
		e : BibTeX!Article (
			thisModule.titledEntrySet->includes(e) and
			thisModule.articleSet->includes(e)
		)
	to
		entry_para : DocBook!Para (
			content <- e.buildEntryPara()
		),
		title_para : DocBook!Para (
			content <- e.title
		),
		journal_para : DocBook!Para (
			content <- e.journal
		)
}

-- Rule 'Article_NoTitle_Journal'
-- [titledEntrySet contains a subset of TitledEntry, so that each title
-- appears only once in the set]
-- [articleSet contains a subset of Article, so that each journal
-- appears only once in the set]
-- For each article entry that belongs to articleSet, this rule generates:
--   * a section_1 paragraph;
--   * a section_4 paragraph.
rule Article_NoTitle_Journal {
	from
		e : BibTeX!Article (
			not thisModule.titledEntrySet->includes(e) and
			thisModule.articleSet->includes(e)
		)
	to
		entry_para : DocBook!Para (
			content <- e.buildEntryPara()
		),
		journal_para : DocBook!Para (
			content <- e.journal
		)
}

-- Rule 'Article_Title_NoJournal'
-- [titledEntrySet contains a subset of TitledEntry, so that each title
-- appears only once in the set]
-- [articleSet contains a subset of Article, so that each journal
-- appears only once in the set]
-- For each article entry that belongs to articleSet, this rule generates:
--   * a section_1 paragraph;
--   * a section_3 paragraph.
rule Article_Title_NoJournal {
	from
		e : BibTeX!Article (
			thisModule.titledEntrySet->includes(e) and
			not thisModule.articleSet->includes(e)
		)
	to
		entry_para : DocBook!Para (
			content <- e.buildEntryPara()
		),
		title_para : DocBook!Para (
			content <- e.title
		)
}

-- Rule 'Article_NoTitle_NoJournal'
-- [titledEntrySet contains a subset of TitledEntry, so that each title
-- appears only once in the set]
-- [articleSet contains a subset of Article, so that each journal
-- appears only once in the set]
-- For each article entry that belongs to articleSet, this rule generates:
--   * a section_1 paragraph;
rule Article_NoTitle_NoJournal {
	from
		e : BibTeX!Article (
			not thisModule.titledEntrySet->includes(e) and
			not thisModule.articleSet->includes(e)
		)
	to
		entry_para : DocBook!Para (
			content <- e.buildEntryPara()
		)
}
",modul bibtex docbook creat out docbook in bibtex helper this helper build set distinct author referenc input bibtex model built set sort author name return sequenc bibtex author helper def authorset sequenc bibtex author bibtex author allinst iter e ret sequenc bibtex author sequenc ret collect e e author includ e author ret els ret includ e endif sortedbi e e author this helper build set distinct titl referenc input bibtex model built set sort titl return sequenc bibtex titledentri helper def titledentryset sequenc bibtex titledentri bibtex titledentri allinst iter e ret sequenc bibtex titledentri sequenc ret collect e e titl includ e titl ret els ret includ e endif sortedbi e e titl this helper build set distinct journal referenc input bibtex model built set sort journal name return sequenc bibtex articl helper def articleset sequenc bibtex articl bibtex articl allinst iter e ret sequenc bibtex articl sequenc ret collect e e journal includ e journal ret els ret includ e endif sortedbi e e journal this helper build string contain inform given bibtexentri content generat string depend entri type in bibtex bibtexentri return sequenc bibtex author helper context bibtex bibtexentri def buildentrypara string self id self ocltyp name self ocliskindof bibtex titledentri self titl els endif self ocliskindof bibtex authoredentri self author iter e str string str e author els endif self ocliskindof bibtex datedentri self year els endif self ocliskindof bibtex booktitledentri self booktitl els endif self ocliskindof bibtex thesisentri self school els endif self ocliskindof bibtex articl self journal els endif self ocliskindof bibtex unpublish self note els endif self ocliskindof bibtex book self publish els endif self ocliskindof bibtex inbook self chapter tostr els endif rule rule main this rule generat structur docbook model bibtexfil element rule main bib bibtex bibtexfil doc docbook docbook book boo boo docbook book articl art art docbook articl titl bibtexml docbook section sequenc se se se se se docbook sect titl refer list para bibtex bibtexentri allinst sortedbi e e id se docbook sect titl author list para thismodul authorset se docbook sect titl titl list para thismodul titledentryset collect e thismodul resolvetemp e titl para se docbook sect titl journal list para thismodul articleset collect e thismodul resolvetemp e journal para rule author this rule generat section paragraph distinct author rule author bibtex author thismodul authorset includ p docbook para content author rule untitledentri this rule generat section paragraph untitl entri rule untitledentri e bibtex bibtexentri e ocliskindof bibtex titledentri p docbook para content e buildentrypara rule titledentri titl noarticl titledentryset contain subset titledentri titl appear set for articl titl entri belong titledentryset rule generat section paragraph section paragraph rule titledentri titl noarticl e bibtex titledentri thismodul titledentryset includ e e ocliskindof bibtex articl entri para docbook para content e buildentrypara titl para docbook para content e titl rule titledentri notitl noarticl titledentryset contain subset titledentri titl appear set for articl titl entri belong titledentryset rule generat section paragraph rule titledentri notitl noarticl e bibtex titledentri thismodul titledentryset includ e e ocliskindof bibtex articl entri para docbook para content e buildentrypara rule articl titl journal titledentryset contain subset titledentri titl appear set articleset contain subset articl journal appear set for articl entri belong articleset rule generat section paragraph section paragraph section paragraph rule articl titl journal e bibtex articl thismodul titledentryset includ e thismodul articleset includ e entri para docbook para content e buildentrypara titl para docbook para content e titl journal para docbook para content e journal rule articl notitl journal titledentryset contain subset titledentri titl appear set articleset contain subset articl journal appear set for articl entri belong articleset rule generat section paragraph section paragraph rule articl notitl journal e bibtex articl thismodul titledentryset includ e thismodul articleset includ e entri para docbook para content e buildentrypara journal para docbook para content e journal rule articl titl nojourn titledentryset contain subset titledentri titl appear set articleset contain subset articl journal appear set for articl entri belong articleset rule generat section paragraph section paragraph rule articl titl nojourn e bibtex articl thismodul titledentryset includ e thismodul articleset includ e entri para docbook para content e buildentrypara titl para docbook para content e titl rule articl notitl nojourn titledentryset contain subset titledentri titl appear set articleset contain subset articl journal appear set for articl entri belong articleset rule generat section paragraph rule articl notitl nojourn e bibtex articl thismodul titledentryset includ e thismodul articleset includ e entri para docbook para content e buildentrypara,0
128,128,P60-OCL2R2ML.atl,"--@atlcompiler atl2006

-- ============================================================
-- Transforms an OCL metamodel into R2ML metamodel.
-- Created as part of M.Sc. theses at GOOD OLD AI Laboratory
-- Author: Milan Milanovic (milan at milanovic.org)
-- Works for R2ML v0.4 (Integrity  rules)
-- Licence: GNU General Public License, version 2
-- ============================================================

module OCL2R2ML; -- Module Template
create OUT : R2ML from IN : OCL;

uses strings;

-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- HELPER: getDefaultIntegerLiteralExp
-- Returns always the same IntegerLiteralExp.
-- OUT:		IntegerLiteralExp
helper def: getDefaultIntegerLiteralExp() : OCL!IntegerLiteralExp = 
	 OCL!IntegerLiteralExp.allInstancesFrom('IN')->asSequence()->first();

-- HELPER: getDefaultStringLiteralExp
-- Returns always the same StringLiteralExp.
-- OUT:		StringLiteralExp
helper def: getDefaultStringLiteralExp() : OCL!StringLiteralExp = 
	 OCL!StringLiteralExp.allInstancesFrom('IN')->asSequence()->first();

-- HELPER: getDefaultBooleanLiteralExp
-- Returns always the same BooleanLiteralExp.
-- OUT:		BooleanLiteralExp
helper def: getDefaultBooleanLiteralExp() : OCL!BooleanLiteralExp = 
	 OCL!BooleanLiteralExp.allInstancesFrom('IN')->asSequence()->first();

-- HELPER: getInvariantForElement
-- Returns Ivariant for this element up in hierarchy.
-- CONTEXT:	OclExpression
-- OUT:		Invariant
helper context OCL!OclExpression def: getInvariantForElement() : OCL!Invariant = 
	if self.refImmediateComposite().oclIsTypeOf(OCL!Invariant) then
		self.refImmediateComposite()
	else self.refImmediateComposite().getInvariantForElement()
	endif;

-- HELPER: haveCollectionExpInSources
-- Checks if there is CollectionOperation in sources (source.source.etc) of expression.
-- CONTEXT:	CallExp
-- OUT:		Boolean
helper context OCL!CallExp def: haveCollectionExpInSources() : Boolean = 
	if self.source.oclIsTypeOf(OCL!CollectionOperationCallExp) then
		true
	else if not self.source.oclIsUndefined() then
			if self.source.oclIsKindOf(OCL!CallExp) then
				self.source.haveCollectionExpInSources()
			else false
			endif
		 else false
		 endif
	endif;

-- HELPER: haveCollectionExpInArguments
-- Checks if there is CollectionOperation in arguments of expression.
-- CONTEXT:	OperationCallExp
-- OUT:		Boolean
helper context OCL!OperationCallExp def: haveCollectionExpInArguments() : Boolean = 
	if self.argument->asSequence()->first().oclIsTypeOf(OCL!CollectionOperationCallExp) then
		true
	else if self.argument->size() > 0 then
			if self.argument->asSequence()->first().oclIsKindOf(OCL!OperationCallExp) then
				self.argument->asSequence()->first().haveCollectionExpInArguments()
			else false
			endif
		 else false
		 endif
	endif;

-- HELPER: haveIteratorExpInSources
-- Checks if there is Iterator expression in sources of expression.
-- CONTEXT:	CallExp
-- OUT:		Boolean
helper context OCL!CallExp def: haveIteratorExpInSources() : Boolean = 
	if self.source.oclIsTypeOf(OCL!IteratorExp) then
		true
	else if not self.source.oclIsUndefined() then
			if self.source.oclIsKindOf(OCL!CallExp) then
				self.source.haveIteratorExpInSources()
			else false
			endif
		 else false
		 endif
	endif;

-- HELPER: hasIteratorExpInParents
-- Checks if there is Iterator expression in parents of expression.
-- CONTEXT:	OclExpression
-- OUT:		Boolean
helper context OCL!OclExpression def: hasIteratorExpInParents() : Boolean = 
	if self.refImmediateComposite().oclIsTypeOf(OCL!IteratorExp) then
		true
	else if not self.refImmediateComposite().oclIsUndefined() then
			if self.refImmediateComposite().oclIsKindOf(OCL!OclExpression) then
				self.refImmediateComposite().hasIteratorExpInParents()
			else false
			endif
		 else false
		 endif
	endif;

-- HELPER: getIteratorExpFromSources
-- Find Iterator expression in sources and returns it.
-- CONTEXT:	CallExp
-- OUT:		IteratorExp
helper context OCL!CallExp def: getIteratorExpFromSources() : OCL!IteratorExp = 
	if self.source.oclIsTypeOf(OCL!IteratorExp) then
		self.source
	else if not self.source.oclIsUndefined() then
			if self.source.oclIsKindOf(OCL!CallExp) then
				self.source.getIteratorExpFromSources()
			else OclUndefined
			endif
		 else OclUndefined
		 endif
	endif;

-- HELPER: getIteratorExpFromParents
-- Find Iterator expression in parents and returns it.
-- CONTEXT:	OclExpression
-- OUT:		IteratorExp
helper context OCL!OclExpression def: getIteratorExpFromParents() : OCL!IteratorExp = 
	if self.refImmediateComposite().oclIsTypeOf(OCL!IteratorExp) then
		self.refImmediateComposite()
	else if not self.refImmediateComposite().oclIsUndefined() then
			if self.refImmediateComposite().oclIsKindOf(OCL!OclExpression) then
				self.refImmediateComposite().getIteratorExpFromParents()
			else OclUndefined
			endif
		 else OclUndefined
		 endif
	endif;

-- HELPER: hasPropertyCallExpInParents
-- Checks is there any property calls in parents.
-- CONTEXT:	OclExpression
-- OUT:		Boolean
helper context OCL!OclExpression def: hasPropertyCallExpInParents() : Boolean = 
	if self.refImmediateComposite().oclIsTypeOf(OCL!PropertyCallExp) then
		true
	else if not self.refImmediateComposite().oclIsUndefined() then
			if self.refImmediateComposite().oclIsKindOf(OCL!OclExpression) then
				self.refImmediateComposite().hasPropertyCallExpInParents()
			else false
			endif
		 else false
		 endif
	endif;
				
-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'OclModule2RuleBase'
-- Create RuleBase and IntegrityRuleSet elements from the OclModule element 
rule OclModule2RuleBase {
	from i : OCL!OclModule (
			i.oclIsTypeOf(OCL!OclModule)
		)
	to o : R2ML!RuleBase(
			ruleBaseID <- 'OCL',
			rules <- irs
		),
		irs : R2ML!IntegrityRuleSet (
			rules <- i.ownedElements
		)
}

-- Rule 'Invariant2AlethicIntegrityRule'
-- Create AlethicIntegrityRule with UniversallyQuantifiedFormula as it formula,
-- from the Invariant OCL element 
rule Invariant2AlethicIntegrityRule {
	from i : OCL!Invariant(
			i.oclIsTypeOf(OCL!Invariant)
		)
	to o : R2ML!AlethicIntegrityRule (
			constraint <- uqf,
			ruleID <- if not i.name.oclIsUndefined() then
						i.name
					  else OclUndefined
					  endif
		),
	   uqf : R2ML!UniversallyQuantifiedFormula (
	   		variables <- if i.specification.oclIsTypeOf(OCL!IteratorExp) then
							Sequence { thisModule.Class2ObjectVariable(i.contextDefinition.contextElement),
	   								   i.specification.iterator->collect(c | thisModule.Iterator2ObjectVariable(c))->flatten()	   			
							   		}
						 else thisModule.Class2ObjectVariable(i.contextDefinition.contextElement)
						 endif,
			formula <- if i.specification.oclIsTypeOf(OCL!OperatorCallExp) and i.specification.name = 'not' then -- jump over not 
						i.specification.source
					   else if i.specification.oclIsTypeOf(OCL!IteratorExp) and i.specification.name = 'forAll' then -- in case of expr.allInstances()->forAll(...)
								if i.specification.source.oclIsTypeOf(OCL!OperationCallExp) then
									if i.specification.source.name = 'allInstances' then
										i.specification.body
									else OclUndefined
									endif
								else i.specification
								endif
							else if i.specification.oclIsKindOf(OCL!CallExp) then -- check if we have IteratorExp, and
					   			   		if i.specification.haveIteratorExpInSources() then -- if is go to it
					  						i.specification.getIteratorExpFromSources()
					   			   		else i.specification
								   		endif
						   	     	 else i.specification
							         endif
							endif
					   endif
	   	)
}

-- Lazy Rule 'Class2ObjectVariable'
-- Create R2ML ObjectVariable from the Class OCL element (in context of Invariant)
unique lazy rule Class2ObjectVariable {
	from i : OCL!Class
	to o : R2ML!ObjectVariable (
			name <- i.name.toLower(),
			classRef <- thisModule.Class2Class(i)
		)
}
	
-- Lazy Rule 'Class2Class'
-- Create R2ML Class from the Class OCL element 
unique lazy rule Class2Class {
	from i : OCL!Class
	to o : R2ML!Class (
			name <- i.name
		)
}

-- Lazy Rule 'VariableExp2ObjectVariable'
-- Create R2ML ObjectVariable from the VariableExp OCL element 
unique lazy rule VariableExp2ObjectVariable {
	from i : OCL!VariableExp
	to o : R2ML!ObjectVariable (
			name <- i.referredVariable.name
		)
}

-- Lazy Rule 'Iterator2ObjectVariable'
-- Create R2ML ObjectVariable from the Iterator OCL element 
unique lazy rule Iterator2ObjectVariable {
	from i : OCL!Iterator
	to o : R2ML!ObjectVariable (
			name <- i.name
		)
}

-- Lazy Rule 'PropertyCallExp2DataVariable'
-- Create R2ML DataVariable from the PropertyCallExp OCL element 
unique lazy rule PropertyCallExp2DataVariable {
	from i : OCL!PropertyCallExp
	to o : R2ML!DataVariable (
			name <- i.name,
			typeCategory <- #bag
		)
}
-- Lazy Rule 'VariableExp2Class'
-- Create R2ML Class from the VariableExp OCL element (for isKindOf, isTypeOf)
unique lazy rule VariableExp2Class {
	from i : OCL!VariableExp
	to o : R2ML!Class (
			name <- i.referredVariable.name
		)
}

-- Lazy Rule 'Variable2DataVariable'
-- Create R2ML DataVariable from the Variable OCL element
unique lazy rule Variable2DataVariable {
	from i : OCL!Variable
	to o : R2ML!DataVariable (
			name <- i.name.toLower(),
			typeCategory <- #bag
		)
}

-- Lazy Rule 'VariableExp2GenericVariable'
-- Create R2ML GenericVariable from the VariVariableExpable OCL element
unique lazy rule VariableExp2GenericVariable {
	from i : OCL!VariableExp
	to o : R2ML!GenericVariable (
			name <- if not i.referredVariable.oclIsUndefined() then
						i.referredVariable.name.concat('_member')
					else 'member'
				    endif
		)
}

-- Rule 'OperatorCallExp2DatatypePredicateAtom'
-- Create R2ML atatypePredicateAtom from the OperatorCallExp OCL element,
-- with relation operators.
-- E.g. age >= 18
rule OperatorCallExp2DatatypePredicateAtom {
	from i : OCL!OperatorCallExp (
			i.oclIsTypeOf(OCL!OperatorCallExp) and 
			not i.haveIteratorExpInSources() and -- select(...)->operation (<, >, ...)
			( i.name = '>=' or i.name = '>' or i.name = '<' or i.name = '<='
			or ( if i.name = '=' or i.name = '<>' then
					  i.haveCollectionExpInSources() or
				      i.haveCollectionExpInArguments() or
					  -- because of exp.var = val in select(...)
					  i.refImmediateComposite().oclIsTypeOf(OCL!IteratorExp)
				 else false
				 endif
				)
			)
			-- because of expr.var >= 0
			and if i.source.oclIsTypeOf(OCL!OperationCallExp) or i.source.oclIsTypeOf(OCL!PropertyCallExp) or i.source.oclIsTypeOf(OCL!VariableExp) then
					true
				else if not i.haveCollectionExpInSources() and not i.haveCollectionExpInArguments() then
						not i.argument->asSequence()->first().oclIsKindOf(OCL!LiteralExp)
					else true
					endif
				endif
			or ( i.name = '<>' and if i.source.oclIsTypeOf(OCL!VariableExp) and 
									  i.argument->asSequence()->first().oclIsTypeOf(OCL!VariableExp)
									  then false
									  else true
									  endif
				)
		)
	to o : R2ML!DatatypePredicateAtom (
			predicate <- dtp,
			dataArguments <- Sequence { if i.source.oclIsTypeOf(OCL!VariableExp) or i.source.oclIsTypeOf(OCL!PropertyCallExp) or i.source.oclIsTypeOf(OCL!OperationCallExp) then
											i.source
											 else if not i.source.source.oclIsUndefined() then
										  	         if i.source.source.oclIsTypeOf(OCL!VariableExp) then
													    i.source.source
												     else  i.source
												     endif 
											      else i.source
											      endif
											 endif, 
										if i.argument->asSequence()->first().oclIsTypeOf(OCL!CollectionOperationCallExp) then
											i.argument->asSequence()->first().source
										else i.argument->asSequence()->first()
										endif
										},
			isNegated <- if i.name = '<>' then
							true		
						else OclUndefined
						endif
		),
	   dtp : R2ML!DatatypePredicate (
	   		name <- if i.name = '=' then
						if (i.source.oclIsTypeOf(OCL!CollectionOperationCallExp) and i.source.name = 'size') 
							or i.argument->asSequence()->first().oclIsTypeOf(OCL!CollectionOperationCallExp) then
					  		'swrlb:length'
						else if i.source.oclIsTypeOf(OCL!PropertyCallExp) or i.source.oclIsTypeOf(OCL!VariableExp) then 
								'swrlb:equal'
							 else OclUndefined
							 endif	
						endif
			  		else if i.name = '>=' then
							'swrlb:greaterThanOrEqual'
					  	 else if i.name = '>' then
								'swrlb:greaterThan'
						      else if i.name = '<' then
						 			 'swrlb:lessThan'
							       else if i.name = '<=' then
							  			     'swrlb:lessThanOrEqual'
								   	    else if i.name = '<>' then
												'swrlb:equal'
											 else OclUndefined
											 endif
								   		endif
							  	   endif
						      endif
					      endif
					endif
	   	)
}

-- Rule 'OperatorCallExp2Disjunction'
-- Create R2ML Disjunction from the OperatorCallExp OCL element with 'or' as name.
rule OperatorCallExp2Disjunction {
	from i : OCL!OperatorCallExp (
			i.oclIsTypeOf(OCL!OperatorCallExp) and i.name = 'or'
		)
	to o : R2ML!Disjunction (
			formulas <-  Sequence {  if i.source.oclIsTypeOf(OCL!OperatorCallExp) and i.source.name = 'not' then -- jump over not 
										i.source.source
					   				else i.source
					   				endif,
								  	if i.argument->asSequence()->first().oclIsTypeOf(OCL!OperatorCallExp) and i.argument->asSequence()->first().name = 'not' then -- jump over not 
										i.argument->asSequence()->first().source
					   				else i.argument->asSequence()->first()
					   				endif 
						}
		)
}

-- Rule 'OperatorCallExp2Conjuction'
-- Create R2ML Conjuction from the OperatorCallExp OCL element with 'and' as name.
rule OperatorCallExp2Conjuction {
	from i : OCL!OperatorCallExp (
			i.oclIsTypeOf(OCL!OperatorCallExp) and i.name = 'and'
		)
	to o : R2ML!Conjuction (
			formulas <- Sequence {  if i.source.oclIsTypeOf(OCL!OperatorCallExp) and i.source.name = 'not' then -- jump over not 
										i.source.source
					   				else i.source
					   				endif,
								  	if i.argument->asSequence()->first().oclIsTypeOf(OCL!OperatorCallExp) and i.argument->asSequence()->first().name = 'not' then -- jump over not 
										i.argument->asSequence()->first().source
					   				else i.argument->asSequence()->first()
					   				endif 
						}
		)
}

-- Rule 'OperatorCallExp2AttributionAtom'
-- Create R2ML AttributionAtom from the OperatorCallExp OCL element with '=' 
-- as name, and have Variable as it source or Property with source Variable (self).
-- E.g. title = 'Mr.' or self.name = 'Mona'
rule OperatorCallExp2AttributionAtom {
	from i : OCL!OperatorCallExp (
			i.oclIsTypeOf(OCL!OperatorCallExp) and i.name = '='
			and ( i.source.oclIsTypeOf(OCL!VariableExp) or
				  ( if i.source.oclIsTypeOf(OCL!PropertyCallExp) then
						if not i.source.source.oclIsUndefined() then
							if i.source.source.oclIsTypeOf(OCL!VariableExp) then
								 i.source.source.referredVariable.name = 'self'
							else false
							endif
						else false
						endif
					else false 
					endif
				   )
				)
			and i.argument->asSequence()->first().oclIsKindOf(OCL!LiteralExp)
		)
	to o : R2ML!AttributionAtom (
			attribute <- atr,
			subject <- thisModule.Class2ObjectVariable(i.getInvariantForElement().contextDefinition.contextElement),
			dataValue <- i.argument->asSequence()->first()
		),
		atr : R2ML!Attribute (
				name <- if i.source.oclIsTypeOf(OCL!VariableExp) then
							i.source.referredVariable.name
						else i.source.name
						endif
			)
}

-- Rule 'OperatorCallExp2EqualityAtom'
-- Create R2ML EqualityAtom from the OperatorCallExp OCL element with '<>'.
-- E.g. iterator variables c1 <> c2 in forAll
rule OperatorCallExp2EqualityAtom {
	from i : OCL!OperatorCallExp (
		i.oclIsTypeOf(OCL!OperatorCallExp) and ( i.name = '<>' or i.name = '=' )and
		if i.source.oclIsTypeOf(OCL!VariableExp) then
			if i.source.referredVariable.oclIsTypeOf(OCL!Iterator) then
			   true
			else i.argument->asSequence()->first().oclIsTypeOf(OCL!VariableExp)
			endif
		else false
		endif
	)
	to o : R2ML!EqualityAtom (
			terms <- Sequence { thisModule.Iterator2ObjectVariable(i.source.referredVariable), 
								thisModule.Iterator2ObjectVariable(i.argument->asSequence()->first().referredVariable)
								},
			isNegated <- if i.name = '<>' then
							true
						 else if i.name = '=' then
						 	    false
							  else OclUndefined
							  endif
						 endif
		)
}

-- Rule 'OperatorCallExp2ReferencePropertyAtom'
-- Create R2ML ReferencePropertyAtom from the OperatorCallExp OCL element with '=' 
-- as name, and have Property as it source and Variable as argument.
-- E.g. card.customer = customer
rule OperatorCallExp2ReferencePropertyAtom {
	from i : OCL!OperatorCallExp (
			i.oclIsTypeOf(OCL!OperatorCallExp) and i.name = '=' 
			and if i.argument->asSequence()->size() = 1 then
					i.argument->asSequence()->first().oclIsTypeOf(OCL!VariableExp)
				else false
				endif
			and i.source.oclIsTypeOf(OCL!PropertyCallExp)
			)
	to o : R2ML!ReferencePropertyAtom ( 
			-- Test is variable 'self' or iterator variable or just simple variable.
			-- Same is for object.
			subject <- if i.source.source.oclIsTypeOf(OCL!VariableExp) then
							if i.source.source.referredVariable.name = 'self' then
						  		thisModule.Class2ObjectVariable(i.getInvariantForElement().contextDefinition.contextElement)				
					   		else if i.source.source.referredVariable.oclIsTypeOf(OCL!Iterator) then
					   				thisModule.Iterator2ObjectVariable(i.source.source.referredVariable)
								 else i.source.source
						         endif
					   		endif
					  else i.source.source
					  endif,
			object <- if i.argument->asSequence()->first().referredVariable.name = 'self' then
						thisModule.Class2ObjectVariable(i.getInvariantForElement().contextDefinition.contextElement)				
					  else if i.argument->asSequence()->first().referredVariable.oclIsTypeOf(OCL!Iterator) then
					  			thisModule.Iterator2ObjectVariable(i.argument->asSequence()->first().referredVariable)
					  	   else i.argument->asSequence()->first()
						   endif
					  endif,
			referenceProperty <- refProp
		),
	   refProp : R2ML!ReferenceProperty(
	   		name <- i.source.name
	   	)
}

-- Rule 'OperatorCallExp2Implicaton'
-- Create R2ML Implication from the OperatorCallExp OCL element with name 'implies'.
rule OperatorCallExp2Implicaton {
	from i : OCL!OperatorCallExp (
			i.oclIsTypeOf(OCL!OperatorCallExp) and i.name = 'implies'
		)
	to o : R2ML!Implication (
			antecedent <- i.source,
			consequent <- i.argument->asSequence()->first()
		)
}

-- Rule 'OperationCallExp2DataOperationTerm'
-- Create R2ML DataOperationTerm from the OperationCallExp OCL element.
-- e.g. expr.operation()
rule OperationCallExp2DataOperationTerm {
	from i : OCL!OperationCallExp (
			i.oclIsTypeOf(OCL!OperationCallExp)
			and i.name <> 'isKindOf' and i.name <> 'isTypeOf'
			and i.name <> 'allInstances'
		)
	to o : R2ML!DataOperationTerm (
			dataOperationRef <- dor,
			contextArgument <- if i.source.oclIsTypeOf(OCL!VariableExp) then
								if not i.source.referredVariable.oclIsUndefined() then
									if i.source.referredVariable.name = 'self' then
										thisModule.Class2ObjectVariable(i.getInvariantForElement().contextDefinition.contextElement)
									else i.source
									endif
								else OclUndefined
								endif
							   else i.source
							   endif
		),
		dor : R2ML!DataOperation (
				name <- i.name
			)
}

-- Rule 'OperationCallExp2ObjectClassificationAtom'
-- Create R2ML ObjectClassificationAtom from the OperationCallExp OCL element with
-- names 'isKindOf' or 'isTypeOf'
rule OperationCallExp2ObjectClassificationAtom {
	from i : OCL!OperationCallExp (
			i.oclIsTypeOf(OCL!OperationCallExp) and
			( i.name = 'isKindOf' or i.name = 'isTypeOf' ) 
		)
	to o : R2ML!ObjectClassificationAtom (
			term <- if not i.source.oclIsUndefined() then
						if i.source.oclIsTypeOf(OCL!VariableExp) then
						  if not i.source.referredVariable.oclIsUndefined() then
								if i.source.referredVariable.name = 'self' then
									thisModule.Class2ObjectVariable(i.getInvariantForElement().contextDefinition.contextElement)
								else thisModule.VariableExp2ObjectVariable(i.source)
								endif
						  else OclUndefined
						  endif
						else i.source
						endif
					else OclUndefined
				    endif,
			type <- thisModule.VariableExp2Class(i.argument->asSequence()->first())
		)
}

-- Rule 'CollectionOperationCallExp2DatatypePredicateAtom'
-- Create R2ML DatatypePredicateAtom from the CollectionOperationCallExp OCL element.
-- E.g. expr->isEmpty()
rule CollectionOperationCallExp2DatatypePredicateAtom {
	from i : OCL!CollectionOperationCallExp (
			i.oclIsTypeOf(OCL!CollectionOperationCallExp) and i.name <> 'includesAll' and
			OCL!OperatorCallExp.allInstancesFrom('IN')->asSequence()->select(e | e.name <> 'not' and e.name <> 'implies')->collect(e | e.source)->flatten()->excludes(i) and
			OCL!OperatorCallExp.allInstancesFrom('IN')->asSequence()->select(e | e.name <> 'or' and e.name <> 'and' and e.name <> 'implies')->collect(e | e.argument)->flatten()->excludes(i) and
			OCL!PropertyCallExp.allInstancesFrom('IN')->asSequence()->collect(e | e.source)->flatten()->excludes(i)
			and not i.source.oclIsTypeOf(OCL!IteratorExp)
		)
	to o : R2ML!DatatypePredicateAtom (
			predicate <- dtp,
			dataArguments <- Sequence { i.source },
			isNegated <- let parent : OclAny = i.refImmediateComposite() in 
							if not parent.oclIsUndefined() then
							if parent.oclIsTypeOf(OCL!OperatorCallExp) then
								if parent.name = 'not' then
									true
								else false
								endif
							else false
							endif
						 else false
						 endif
		),
	   dtp : R2ML!DatatypePredicate (
	   		name <- if i.name = 'isEmpty' then
						'swrlb:empty'
					else OclUndefined
					endif
	   	)
}

-- Rule 'CollectionOperationCallExp2ObjectOperationTerm'
-- Create R2ML ObjectOperationTerm from the CollectionOperationCallExp OCL element.
-- E.g. in expr->collectionOperation().attr
rule CollectionOperationCallExp2ObjectOperationTerm {
	from i : OCL!CollectionOperationCallExp (
			i.oclIsTypeOf(OCL!CollectionOperationCallExp) and i.name <> 'includesAll' and
			OCL!PropertyCallExp.allInstancesFrom('IN')->asSequence()->collect(e | e.source)->flatten()->includes(i)
			and not i.source.oclIsTypeOf(OCL!IteratorExp)
		)
	to o : R2ML!ObjectOperationTerm (
			operation <- op,
			contextArgument <- i.source
		),
	   op : R2ML!ObjectOperation (
	   		name <- i.name
	   	)
}

-- Rule 'CollectionOperationCallExp2DatatypeFunctionTerm'
-- Create R2ML DatatypeFunctionTerm from the CollectionOperationCallExp OCL element.
-- E.g. in collection->operation() 
rule CollectionOperationCallExp2DatatypeFunctionTerm {
	from i : OCL!CollectionOperationCallExp (
			i.oclIsTypeOf(OCL!CollectionOperationCallExp) and i.name <> 'includesAll' and
			OCL!OperatorCallExp.allInstancesFrom('IN')->asSequence()->select(c | c.name <> '=' and c.name <> 'not')->collect(e | e.source)->flatten()->includes(i)
			and not i.source.oclIsTypeOf(OCL!IteratorExp)
		)
	to o : R2ML!DatatypeFunctionTerm (
			function <- dtf,
			dataArguments <- i.source
		),
		dtf : R2ML!DatatypeFunction (
				name <- if i.name = 'size' then
							'fn:count'
						else OclUndefined
						endif
			)

}

-- Rule 'CollectionOperationCallExp2Implication'
-- Create R2ML Implication from the CollectionOperationCallExp OCL element,
-- with name ""includesAll""
rule CollectionOperationCallExp2Implication {
	from i : OCL!CollectionOperationCallExp (
			i.oclIsTypeOf(OCL!CollectionOperationCallExp) and i.name = 'includesAll'
		)
	to o : R2ML!Implication (
			consequent <- conAtom,
			antecedent <- antAtom
		),
	   conAtom : R2ML!GenericAtom (
	   		predicate <- atomPredicate,
			arguments <- Sequence { thisModule.VariableExp2GenericVariable(i.source), i.argument->asSequence()->first()}
	   	),
	   antAtom : R2ML!GenericAtom (
	   		predicate <- atomPredicate,
		    arguments <- Sequence { thisModule.VariableExp2GenericVariable(i.source), i.source}
	   	),
	   atomPredicate : R2ML!GenericPredicate (
	   		name <- 'swrlb:member'
	   	)
}

-- Rule 'IteratorExpFromForAll2Conjunction'
-- Create R2ML Conjuction from the IteratorExp OCL element,
-- with name ""forAll"".
rule IteratorExpFromForAll2Conjunction {
	from i : OCL!IteratorExp (
			i.oclIsTypeOf(OCL!IteratorExp) and i.name = 'forAll' and
			if i.source.oclIsTypeOf(OCL!OperationCallExp) then -- it is not created when expr.allInstances()->forAll(...)
				if i.source.name = 'allInstances' then
					false
				else true
				endif
			else true
			endif
		)
	to o : R2ML!Conjuction (
			formulas <- Sequence { i.source, univQuantForm }
		),
	  univQuantForm : R2ML!UniversallyQuantifiedFormula (
	  		formula <- i.body,
			variables <- i.iterator->asSequence()->collect(c | thisModule.Iterator2ObjectVariable(c))
	  	)
}

-- Rule 'IteratorExpFromSelect2Conjunction'
-- Create R2ML Conjuction from the IteratorExp OCL element,
-- with name ""select"".
-- ANNOTATION: There is no general support in R2ML for OCL iterator expressions.
rule IteratorExpFromSelect2Conjunction {
	from i : OCL!IteratorExp (
			i.oclIsTypeOf(OCL!IteratorExp) and i.name = 'select'
			and if not i.refImmediateComposite().oclIsUndefined() then
					if i.refImmediateComposite().oclIsTypeOf(OCL!CollectionOperationCallExp) then
						if i.refImmediateComposite().name = 'notEmpty' or i.refImmediateComposite().name = 'size' then
							true
						else false
						endif
					else false
					endif
				else false
				endif
		)
	to o : R2ML!Conjuction (
			formulas <- Sequence { i.source, existQuantForm }
		),
	  existQuantForm : R2ML!ExistentiallyQuantifiedFormula (
	  		formula <- conj,
			variables <- i.iterator->asSequence()->collect(c | thisModule.Iterator2ObjectVariable(c))
	  	),
	  conj : R2ML!Conjuction (
	  		formulas <- Sequence { antAtom , i.body}
	  	),
	 antAtom : R2ML!GenericAtom (
	   		predicate <- atomPredicate,
			arguments <- Sequence { i.iterator->asSequence()->collect( c | thisModule.Iterator2ObjectVariable(c)), 
	   								if i.source.oclIsTypeOf(OCL!PropertyCallExp) then
										thisModule.PropertyCallExp2DataVariable(i.source)
									else if i.source.oclIsTypeOf(OCL!VariableExp) then
											thisModule.Variable2DataVariable(i.source.referredVariable)
										 else OclUndefined
										 endif
									endif
						   		  }
	   	),
	   atomPredicate : R2ML!GenericPredicate (
	   		name <- 'swrlb:member'
	   	)
}

-- Rule 'VariableExp2AttributeFunctionTerm'
-- Create R2ML AttributeFunctionTerm from the VariableExp which is source of Operation.
-- E.g. age in "" age >= 18 ""
rule VariableExp2AttributeFunctionTerm {
	from i : OCL!VariableExp (
			i.oclIsTypeOf(OCL!VariableExp) and i.referredVariable.name <> 'self' and 
			not i.referredVariable.oclIsTypeOf(OCL!Iterator) and
			( OCL!OperatorCallExp.allInstancesFrom('IN')->asSequence()->select(c | c.name <> '=')->collect(e | e.source)->flatten()->includes(i) or
			    ( OCL!CollectionOperationCallExp.allInstancesFrom('IN')->asSequence()->collect(e | e.source)->flatten()->includes(i)
			    	and 
				  not i.hasPropertyCallExpInParents()
			    )	
			 )
		-- if variableExp = expr->collectionExp()
		or if i.refImmediateComposite().oclIsTypeOf(OCL!OperatorCallExp) then
				if i.refImmediateComposite().name = '=' or i.refImmediateComposite().name = '<>' then
					if i.refImmediateComposite().argument->asSequence()->first().oclIsTypeOf(OCL!CollectionOperationCallExp) then
						true
					else false
					endif
				else false
				endif
		   else false
		   endif
		)
	to o : R2ML!AttributeFunctionTerm (
			attribute <- atr,
			contextArgument <- thisModule.Class2ObjectVariable(i.getInvariantForElement().contextDefinition.contextElement),
			typeCategory <- if OCL!CollectionOperationCallExp.allInstancesFrom('IN')->asSequence()->collect(e | e.source)->flatten()->includes(i) then
								#bag
							else OclUndefined
							endif
		),
		atr : R2ML!Attribute (
				name <- i.referredVariable.name
			)
}

-- Rule 'VariableExp2ReferencePropertyFunctionTerm'
-- Create R2ML ReferencePropertyFunctionTerm from the VariableExp which is
-- source of PropertyCallExp or argument of OperatorCallExp.
-- E.g. owner in "" owner.age >= 18 "" or customer in "" card.customer = customer ""
-- or "" members.age() > 21 "" (if possible)
rule VariableExp2ReferencePropertyFunctionTerm {
	from i : OCL!VariableExp(
			i.oclIsTypeOf(OCL!VariableExp) and i.referredVariable.name <> 'self' and
			not i.referredVariable.oclIsTypeOf(OCL!Iterator) and
			( OCL!PropertyCallExp.allInstancesFrom('IN')->asSequence()->collect(e | e.source)->flatten()->includes(i) or
			  OCL!OperatorCallExp.allInstancesFrom('IN')->asSequence()->collect(e | e.argument)->flatten()->includes(i) or
  		  	  OCL!OperationCallExp.allInstancesFrom('IN')->asSequence()->select(c | c.oclIsTypeOf(OCL!OperationCallExp))->select(c | c.name <> 'allInstances')->collect(e | e.source)->flatten()->includes(i)			
			  or ( OCL!CollectionOperationCallExp.allInstancesFrom('IN')->asSequence()->collect(e | e.source)->flatten()->includes(i)
			    	and 
					i.hasPropertyCallExpInParents()
			    )	
			)
		)
	to o : R2ML!ReferencePropertyFunctionTerm (
			contextArgument <- thisModule.Class2ObjectVariable(i.getInvariantForElement().contextDefinition.contextElement),
			referencePropertyRef <- refProp
		),
	   refProp : R2ML!ReferenceProperty (
	   		name <- i.referredVariable.name
	   	)
}

-- Rule 'VariableExp2AttributionAtom'
-- Create R2ML AttributionAtom from the VariableExp which have
-- parent Iterator expression, like var->select(...).
rule VariableExp2AttributionAtom {
	from i : OCL!VariableExp (
			i.oclIsTypeOf(OCL!VariableExp) and 
			i.refImmediateComposite().oclIsTypeOf(OCL!IteratorExp)
		)
	to o : R2ML!AttributionAtom (
			attribute <- attr,
			subject <- thisModule.Class2ObjectVariable(i.getInvariantForElement().contextDefinition.contextElement),
			dataValue <- thisModule.Variable2DataVariable(i.referredVariable)
		),
	   attr : R2ML!Attribute (
	   		name <- i.referredVariable.name
	   	)
}

-- Rule 'PropertyCallExp2AttributionAtom'
-- Create R2ML AttributionAtom from the PropertyCallExp which have
-- parent Iterator expression, like self.var->select(...).
rule PropertyCallExp2AttributionAtom {
	from i : OCL!PropertyCallExp (
			i.oclIsTypeOf(OCL!PropertyCallExp) and 
			i.refImmediateComposite().oclIsTypeOf(OCL!IteratorExp)
		)
	to o : R2ML!AttributionAtom (
			attribute <- attr,
			subject <- thisModule.Class2ObjectVariable(i.getInvariantForElement().contextDefinition.contextElement),
			dataValue <- thisModule.PropertyCallExp2DataVariable(i)
		),
	   attr : R2ML!Attribute (
	   		name <- i.name
	   	)
}

-- Rule 'PropertyCallExp2AttributeFunctionTerm'
-- Create R2ML AttributeFunctionTerm from the PropertyCallExp which is
-- source of Operator without ""="" as name.
-- E.g. age in "" owner.age >= 18 ""
rule PropertyCallExp2AttributeFunctionTerm {
	from i : OCL!PropertyCallExp (
			i.oclIsTypeOf(OCL!PropertyCallExp) and
			( OCL!OperatorCallExp.allInstancesFrom('IN')->asSequence()->select(e | e.name <> '=')->collect(e | e.source)->flatten()->includes(i) 
				or
			  i.source.oclIsTypeOf(OCL!CollectionOperationCallExp)
			  or i.refImmediateComposite().oclIsTypeOf(OCL!CollectionOperationCallExp)
			  or ( if i.refImmediateComposite().oclIsTypeOf(OCL!OperatorCallExp) then
			  			if i.refImmediateComposite().name = '<>' then
							true
						else if i.hasIteratorExpInParents() then -- because of select( ... | t.p = number)
						         -- ANNOTATION: Here is checking is Iterator expression 
								 -- 'forAll' called with allInstances, then it is false
								  let iter : OCL!IteratorExp = i.getIteratorExpFromParents() in
								  	if not iter.oclIsUndefined() then
										if iter.source.oclIsTypeOf(OCL!OperationCallExp) then
											if iter.source.name = 'allInstances' then
												false
											else true
											endif
										else true
										endif
									else true
									endif
							 else false
							 endif
						endif
				   else false
				   endif		  		
			  	)
			)
		)
	to o :  R2ML!AttributeFunctionTerm (
			attribute <- atr,
			contextArgument <- if i.source.oclIsTypeOf(OCL!VariableExp) then
								 if not i.source.referredVariable.oclIsUndefined() then
								 	if i.source.referredVariable.name = 'self' then
										 thisModule.Class2ObjectVariable(i.getInvariantForElement().contextDefinition.contextElement)
									else if i.source.referredVariable.oclIsTypeOf(OCL!Iterator) then
											thisModule.Iterator2ObjectVariable(i.source.referredVariable)
										 else i.source
										 endif
									endif
								 else OclUndefined
								 endif
							   else i.source
							   endif,
			typeCategory <- if i.refImmediateComposite().oclIsTypeOf(OCL!CollectionOperationCallExp) then
								#bag
							else OclUndefined
							endif
		),
	atr : R2ML!Attribute (
				name <- i.name
			)
}

-- Rule 'PropertyCallExp2ReferencePropertyFunctionTerm'
-- Create R2ML ReferencePropertyFunctionTerm from the PropertyCallExp which is
-- source of another PropertyCallExp.
-- E.g. card or members in "" members.card.customer = customer ""
rule PropertyCallExp2ReferencePropertyFunctionTerm {
	from i : OCL!PropertyCallExp (
		i.oclIsTypeOf(OCL!PropertyCallExp) and
		OCL!PropertyCallExp.allInstancesFrom('IN')->asSequence()->collect(e | e.source)->flatten()->includes(i)	
		)
	to o : R2ML!ReferencePropertyFunctionTerm (
			contextArgument <- if i.source.oclIsTypeOf(OCL!VariableExp) then
									if i.source.referredVariable.name = 'self' then
										thisModule.Class2ObjectVariable(i.getInvariantForElement().contextDefinition.contextElement)
									else i.source
									endif
							   else i.source
							   endif,
			referencePropertyRef <- refProp
		),
	   refProp : R2ML!ReferenceProperty (
	   		name <- i.name
	   	)
}

-- Rule 'StringLiteralExp2TypedLiteral'
-- Create R2ML TypedLiteral from the StringLiteralExp.
rule StringLiteralExp2TypedLiteral {
	from i : OCL!StringLiteralExp(
			i.oclIsTypeOf(OCL!StringLiteralExp)
		)
	to o : R2ML!TypedLiteral (
		lexicalValue <- i.stringSymbol,
		type <- thisModule.StringLiteralExp2Datatype(thisModule.getDefaultStringLiteralExp())
		)
}

-- Rule 'IntegerLiteralExp2TypedLiteral'
-- Create R2ML TypedLiteral from the IntegerLiteralExp.
rule IntegerLiteralExp2TypedLiteral {
	from i : OCL!IntegerLiteralExp(
			i.oclIsTypeOf(OCL!IntegerLiteralExp)
		)
	to o : R2ML!TypedLiteral (
			lexicalValue <- i.integerSymbol.toString(),
			type <- thisModule.IntegerLiteralExp2Datatype(thisModule.getDefaultIntegerLiteralExp())
		)
}

-- Rule 'BooleanLiteralExp2TypedLiteral'
-- Create R2ML TypedLiteral from the BooleanLiteralExp.
rule BooleanLiteralExp2TypedLiteral {
	from i : OCL!BooleanLiteralExp (
			i.oclIsTypeOf(OCL!BooleanLiteralExp)
		)
	to o : R2ML!TypedLiteral (
			lexicalValue <- i.booleanSymbol.toString(),
			type <- thisModule.BooleanLiteralExp2Datatype(thisModule.getDefaultBooleanLiteralExp())
		)
}

-- Rule 'BooleanLiteralExp2Datatype'
-- Create R2ML Datatype (xs:positiveInteger) from the BooleanLiteralExp.
unique lazy rule BooleanLiteralExp2Datatype {
	from i : OCL!BooleanLiteralExp
	to o : R2ML!Datatype (
		name <- 'xs:boolean'
		)
}

-- Rule 'IntegerLiteralExp2Datatype'
-- Create R2ML Datatype (xs:positiveInteger) from the IntegerLiteralExp.
unique lazy rule IntegerLiteralExp2Datatype {
	from i : OCL!IntegerLiteralExp
	to o : R2ML!Datatype (
		name <- 'xs:positiveInteger'
		)
}

-- Rule 'StringLiteralExp2Datatype'
-- Create R2ML Datatype (xs:string) from the StringLiteralExp.
unique lazy rule StringLiteralExp2Datatype {
	from i : OCL!StringLiteralExp
	to o : R2ML!Datatype (
		name <- 'xs:string'
		)
}",atlcompil atl transform ocl metamodel r ml metamodel creat part m sc these good old ai laboratori author milan milanov milan milanov org work r ml v integr rule licenc gnu general public licens version modul ocl r ml modul templat creat out r ml in ocl use string helper helper getdefaultintegerliteralexp return alway integerliteralexp out integerliteralexp helper def getdefaultintegerliteralexp ocl integerliteralexp ocl integerliteralexp allinstancesfrom in assequ first helper getdefaultstringliteralexp return alway stringliteralexp out stringliteralexp helper def getdefaultstringliteralexp ocl stringliteralexp ocl stringliteralexp allinstancesfrom in assequ first helper getdefaultbooleanliteralexp return alway booleanliteralexp out booleanliteralexp helper def getdefaultbooleanliteralexp ocl booleanliteralexp ocl booleanliteralexp allinstancesfrom in assequ first helper getinvariantforel return ivari element hierarchi context oclexpress out invari helper context ocl oclexpress def getinvariantforel ocl invari self refimmediatecomposit oclistypeof ocl invari self refimmediatecomposit els self refimmediatecomposit getinvariantforel endif helper havecollectionexpinsourc check collectionoper sourc sourc sourc etc express context callexp out boolean helper context ocl callexp def havecollectionexpinsourc boolean self sourc oclistypeof ocl collectionoperationcallexp true els self sourc oclisundefin self sourc ocliskindof ocl callexp self sourc havecollectionexpinsourc els fals endif els fals endif endif helper havecollectionexpinargu check collectionoper argument express context operationcallexp out boolean helper context ocl operationcallexp def havecollectionexpinargu boolean self argument assequ first oclistypeof ocl collectionoperationcallexp true els self argument size self argument assequ first ocliskindof ocl operationcallexp self argument assequ first havecollectionexpinargu els fals endif els fals endif endif helper haveiteratorexpinsourc check iter express sourc express context callexp out boolean helper context ocl callexp def haveiteratorexpinsourc boolean self sourc oclistypeof ocl iteratorexp true els self sourc oclisundefin self sourc ocliskindof ocl callexp self sourc haveiteratorexpinsourc els fals endif els fals endif endif helper hasiteratorexpinpar check iter express parent express context oclexpress out boolean helper context ocl oclexpress def hasiteratorexpinpar boolean self refimmediatecomposit oclistypeof ocl iteratorexp true els self refimmediatecomposit oclisundefin self refimmediatecomposit ocliskindof ocl oclexpress self refimmediatecomposit hasiteratorexpinpar els fals endif els fals endif endif helper getiteratorexpfromsourc find iter express sourc return context callexp out iteratorexp helper context ocl callexp def getiteratorexpfromsourc ocl iteratorexp self sourc oclistypeof ocl iteratorexp self sourc els self sourc oclisundefin self sourc ocliskindof ocl callexp self sourc getiteratorexpfromsourc els oclundefin endif els oclundefin endif endif helper getiteratorexpfrompar find iter express parent return context oclexpress out iteratorexp helper context ocl oclexpress def getiteratorexpfrompar ocl iteratorexp self refimmediatecomposit oclistypeof ocl iteratorexp self refimmediatecomposit els self refimmediatecomposit oclisundefin self refimmediatecomposit ocliskindof ocl oclexpress self refimmediatecomposit getiteratorexpfrompar els oclundefin endif els oclundefin endif endif helper haspropertycallexpinpar check properti call parent context oclexpress out boolean helper context ocl oclexpress def haspropertycallexpinpar boolean self refimmediatecomposit oclistypeof ocl propertycallexp true els self refimmediatecomposit oclisundefin self refimmediatecomposit ocliskindof ocl oclexpress self refimmediatecomposit haspropertycallexpinpar els fals endif els fals endif endif rule rule oclmodul rulebas creat rulebas integrityruleset element oclmodul element rule oclmodul rulebas ocl oclmodul oclistypeof ocl oclmodul r ml rulebas rulebaseid ocl rule ir ir r ml integrityruleset rule ownedel rule invari alethicintegrityrul creat alethicintegrityrul universallyquantifiedformula formula invari ocl element rule invari alethicintegrityrul ocl invari oclistypeof ocl invari r ml alethicintegrityrul constraint uqf ruleid name oclisundefin name els oclundefin endif uqf r ml universallyquantifiedformula variabl specif oclistypeof ocl iteratorexp sequenc thismodul class objectvari contextdefinit contextel specif iter collect c thismodul iter objectvari c flatten els thismodul class objectvari contextdefinit contextel endif formula specif oclistypeof ocl operatorcallexp specif name jump specif sourc els specif oclistypeof ocl iteratorexp specif name foral case expr allinst foral specif sourc oclistypeof ocl operationcallexp specif sourc name allinst specif bodi els oclundefin endif els specif endif els specif ocliskindof ocl callexp check iteratorexp specif haveiteratorexpinsourc go specif getiteratorexpfromsourc els specif endif els specif endif endif endif lazi rule class objectvari creat r ml objectvari class ocl element context invari uniqu lazi rule class objectvari ocl class r ml objectvari name name tolow classref thismodul class class lazi rule class class creat r ml class class ocl element uniqu lazi rule class class ocl class r ml class name name lazi rule variableexp objectvari creat r ml objectvari variableexp ocl element uniqu lazi rule variableexp objectvari ocl variableexp r ml objectvari name referredvari name lazi rule iter objectvari creat r ml objectvari iter ocl element uniqu lazi rule iter objectvari ocl iter r ml objectvari name name lazi rule propertycallexp datavari creat r ml datavari propertycallexp ocl element uniqu lazi rule propertycallexp datavari ocl propertycallexp r ml datavari name name typecategori bag lazi rule variableexp class creat r ml class variableexp ocl element iskindof istypeof uniqu lazi rule variableexp class ocl variableexp r ml class name referredvari name lazi rule variabl datavari creat r ml datavari variabl ocl element uniqu lazi rule variabl datavari ocl variabl r ml datavari name name tolow typecategori bag lazi rule variableexp genericvari creat r ml genericvari varivariableexp ocl element uniqu lazi rule variableexp genericvari ocl variableexp r ml genericvari name referredvari oclisundefin referredvari name concat member els member endif rule operatorcallexp datatypepredicateatom creat r ml atatypepredicateatom operatorcallexp ocl element relat oper e g age rule operatorcallexp datatypepredicateatom ocl operatorcallexp oclistypeof ocl operatorcallexp haveiteratorexpinsourc select oper name name name name name name havecollectionexpinsourc havecollectionexpinargu exp var val select refimmediatecomposit oclistypeof ocl iteratorexp els fals endif expr var sourc oclistypeof ocl operationcallexp sourc oclistypeof ocl propertycallexp sourc oclistypeof ocl variableexp true els havecollectionexpinsourc havecollectionexpinargu argument assequ first ocliskindof ocl literalexp els true endif endif name sourc oclistypeof ocl variableexp argument assequ first oclistypeof ocl variableexp fals els true endif r ml datatypepredicateatom predic dtp dataargu sequenc sourc oclistypeof ocl variableexp sourc oclistypeof ocl propertycallexp sourc oclistypeof ocl operationcallexp sourc els sourc sourc oclisundefin sourc sourc oclistypeof ocl variableexp sourc sourc els sourc endif els sourc endif endif argument assequ first oclistypeof ocl collectionoperationcallexp argument assequ first sourc els argument assequ first endif isneg name true els oclundefin endif dtp r ml datatypepred name name sourc oclistypeof ocl collectionoperationcallexp sourc name size argument assequ first oclistypeof ocl collectionoperationcallexp swrlb length els sourc oclistypeof ocl propertycallexp sourc oclistypeof ocl variableexp swrlb equal els oclundefin endif endif els name swrlb greaterthanorequ els name swrlb greaterthan els name swrlb lessthan els name swrlb lessthanorequ els name swrlb equal els oclundefin endif endif endif endif endif endif rule operatorcallexp disjunct creat r ml disjunct operatorcallexp ocl element name rule operatorcallexp disjunct ocl operatorcallexp oclistypeof ocl operatorcallexp name r ml disjunct formula sequenc sourc oclistypeof ocl operatorcallexp sourc name jump sourc sourc els sourc endif argument assequ first oclistypeof ocl operatorcallexp argument assequ first name jump argument assequ first sourc els argument assequ first endif rule operatorcallexp conjuct creat r ml conjuct operatorcallexp ocl element name rule operatorcallexp conjuct ocl operatorcallexp oclistypeof ocl operatorcallexp name r ml conjuct formula sequenc sourc oclistypeof ocl operatorcallexp sourc name jump sourc sourc els sourc endif argument assequ first oclistypeof ocl operatorcallexp argument assequ first name jump argument assequ first sourc els argument assequ first endif rule operatorcallexp attributionatom creat r ml attributionatom operatorcallexp ocl element name variabl sourc properti sourc variabl self e g titl mr self name mona rule operatorcallexp attributionatom ocl operatorcallexp oclistypeof ocl operatorcallexp name sourc oclistypeof ocl variableexp sourc oclistypeof ocl propertycallexp sourc sourc oclisundefin sourc sourc oclistypeof ocl variableexp sourc sourc referredvari name self els fals endif els fals endif els fals endif argument assequ first ocliskindof ocl literalexp r ml attributionatom attribut atr subject thismodul class objectvari getinvariantforel contextdefinit contextel datavalu argument assequ first atr r ml attribut name sourc oclistypeof ocl variableexp sourc referredvari name els sourc name endif rule operatorcallexp equalityatom creat r ml equalityatom operatorcallexp ocl element e g iter variabl c c foral rule operatorcallexp equalityatom ocl operatorcallexp oclistypeof ocl operatorcallexp name name sourc oclistypeof ocl variableexp sourc referredvari oclistypeof ocl iter true els argument assequ first oclistypeof ocl variableexp endif els fals endif r ml equalityatom term sequenc thismodul iter objectvari sourc referredvari thismodul iter objectvari argument assequ first referredvari isneg name true els name fals els oclundefin endif endif rule operatorcallexp referencepropertyatom creat r ml referencepropertyatom operatorcallexp ocl element name properti sourc variabl argument e g card custom custom rule operatorcallexp referencepropertyatom ocl operatorcallexp oclistypeof ocl operatorcallexp name argument assequ size argument assequ first oclistypeof ocl variableexp els fals endif sourc oclistypeof ocl propertycallexp r ml referencepropertyatom test variabl self iter variabl simpl variabl same object subject sourc sourc oclistypeof ocl variableexp sourc sourc referredvari name self thismodul class objectvari getinvariantforel contextdefinit contextel els sourc sourc referredvari oclistypeof ocl iter thismodul iter objectvari sourc sourc referredvari els sourc sourc endif endif els sourc sourc endif object argument assequ first referredvari name self thismodul class objectvari getinvariantforel contextdefinit contextel els argument assequ first referredvari oclistypeof ocl iter thismodul iter objectvari argument assequ first referredvari els argument assequ first endif endif referenceproperti refprop refprop r ml referenceproperti name sourc name rule operatorcallexp implicaton creat r ml implic operatorcallexp ocl element name impli rule operatorcallexp implicaton ocl operatorcallexp oclistypeof ocl operatorcallexp name impli r ml implic anteced sourc consequ argument assequ first rule operationcallexp dataoperationterm creat r ml dataoperationterm operationcallexp ocl element e g expr oper rule operationcallexp dataoperationterm ocl operationcallexp oclistypeof ocl operationcallexp name iskindof name istypeof name allinst r ml dataoperationterm dataoperationref dor contextargu sourc oclistypeof ocl variableexp sourc referredvari oclisundefin sourc referredvari name self thismodul class objectvari getinvariantforel contextdefinit contextel els sourc endif els oclundefin endif els sourc endif dor r ml dataoper name name rule operationcallexp objectclassificationatom creat r ml objectclassificationatom operationcallexp ocl element name iskindof istypeof rule operationcallexp objectclassificationatom ocl operationcallexp oclistypeof ocl operationcallexp name iskindof name istypeof r ml objectclassificationatom term sourc oclisundefin sourc oclistypeof ocl variableexp sourc referredvari oclisundefin sourc referredvari name self thismodul class objectvari getinvariantforel contextdefinit contextel els thismodul variableexp objectvari sourc endif els oclundefin endif els sourc endif els oclundefin endif type thismodul variableexp class argument assequ first rule collectionoperationcallexp datatypepredicateatom creat r ml datatypepredicateatom collectionoperationcallexp ocl element e g expr isempti rule collectionoperationcallexp datatypepredicateatom ocl collectionoperationcallexp oclistypeof ocl collectionoperationcallexp name includesal ocl operatorcallexp allinstancesfrom in assequ select e e name e name impli collect e e sourc flatten exclud ocl operatorcallexp allinstancesfrom in assequ select e e name e name e name impli collect e e argument flatten exclud ocl propertycallexp allinstancesfrom in assequ collect e e sourc flatten exclud sourc oclistypeof ocl iteratorexp r ml datatypepredicateatom predic dtp dataargu sequenc sourc isneg let parent oclani refimmediatecomposit parent oclisundefin parent oclistypeof ocl operatorcallexp parent name true els fals endif els fals endif els fals endif dtp r ml datatypepred name name isempti swrlb empti els oclundefin endif rule collectionoperationcallexp objectoperationterm creat r ml objectoperationterm collectionoperationcallexp ocl element e g expr collectionoper attr rule collectionoperationcallexp objectoperationterm ocl collectionoperationcallexp oclistypeof ocl collectionoperationcallexp name includesal ocl propertycallexp allinstancesfrom in assequ collect e e sourc flatten includ sourc oclistypeof ocl iteratorexp r ml objectoperationterm oper op contextargu sourc op r ml objectoper name name rule collectionoperationcallexp datatypefunctionterm creat r ml datatypefunctionterm collectionoperationcallexp ocl element e g collect oper rule collectionoperationcallexp datatypefunctionterm ocl collectionoperationcallexp oclistypeof ocl collectionoperationcallexp name includesal ocl operatorcallexp allinstancesfrom in assequ select c c name c name collect e e sourc flatten includ sourc oclistypeof ocl iteratorexp r ml datatypefunctionterm function dtf dataargu sourc dtf r ml datatypefunct name name size fn count els oclundefin endif rule collectionoperationcallexp implic creat r ml implic collectionoperationcallexp ocl element name includesal rule collectionoperationcallexp implic ocl collectionoperationcallexp oclistypeof ocl collectionoperationcallexp name includesal r ml implic consequ conatom anteced antatom conatom r ml genericatom predic atompred argument sequenc thismodul variableexp genericvari sourc argument assequ first antatom r ml genericatom predic atompred argument sequenc thismodul variableexp genericvari sourc sourc atompred r ml genericpred name swrlb member rule iteratorexpfromforal conjunct creat r ml conjuct iteratorexp ocl element name foral rule iteratorexpfromforal conjunct ocl iteratorexp oclistypeof ocl iteratorexp name foral sourc oclistypeof ocl operationcallexp creat expr allinst foral sourc name allinst fals els true endif els true endif r ml conjuct formula sequenc sourc univquantform univquantform r ml universallyquantifiedformula formula bodi variabl iter assequ collect c thismodul iter objectvari c rule iteratorexpfromselect conjunct creat r ml conjuct iteratorexp ocl element name select annot there general support r ml ocl iter express rule iteratorexpfromselect conjunct ocl iteratorexp oclistypeof ocl iteratorexp name select refimmediatecomposit oclisundefin refimmediatecomposit oclistypeof ocl collectionoperationcallexp refimmediatecomposit name notempti refimmediatecomposit name size true els fals endif els fals endif els fals endif r ml conjuct formula sequenc sourc existquantform existquantform r ml existentiallyquantifiedformula formula conj variabl iter assequ collect c thismodul iter objectvari c conj r ml conjuct formula sequenc antatom bodi antatom r ml genericatom predic atompred argument sequenc iter assequ collect c thismodul iter objectvari c sourc oclistypeof ocl propertycallexp thismodul propertycallexp datavari sourc els sourc oclistypeof ocl variableexp thismodul variabl datavari sourc referredvari els oclundefin endif endif atompred r ml genericpred name swrlb member rule variableexp attributefunctionterm creat r ml attributefunctionterm variableexp sourc oper e g age age rule variableexp attributefunctionterm ocl variableexp oclistypeof ocl variableexp referredvari name self referredvari oclistypeof ocl iter ocl operatorcallexp allinstancesfrom in assequ select c c name collect e e sourc flatten includ ocl collectionoperationcallexp allinstancesfrom in assequ collect e e sourc flatten includ haspropertycallexpinpar variableexp expr collectionexp refimmediatecomposit oclistypeof ocl operatorcallexp refimmediatecomposit name refimmediatecomposit name refimmediatecomposit argument assequ first oclistypeof ocl collectionoperationcallexp true els fals endif els fals endif els fals endif r ml attributefunctionterm attribut atr contextargu thismodul class objectvari getinvariantforel contextdefinit contextel typecategori ocl collectionoperationcallexp allinstancesfrom in assequ collect e e sourc flatten includ bag els oclundefin endif atr r ml attribut name referredvari name rule variableexp referencepropertyfunctionterm creat r ml referencepropertyfunctionterm variableexp sourc propertycallexp argument operatorcallexp e g owner owner age custom card custom custom member age possibl rule variableexp referencepropertyfunctionterm ocl variableexp oclistypeof ocl variableexp referredvari name self referredvari oclistypeof ocl iter ocl propertycallexp allinstancesfrom in assequ collect e e sourc flatten includ ocl operatorcallexp allinstancesfrom in assequ collect e e argument flatten includ ocl operationcallexp allinstancesfrom in assequ select c c oclistypeof ocl operationcallexp select c c name allinst collect e e sourc flatten includ ocl collectionoperationcallexp allinstancesfrom in assequ collect e e sourc flatten includ haspropertycallexpinpar r ml referencepropertyfunctionterm contextargu thismodul class objectvari getinvariantforel contextdefinit contextel referencepropertyref refprop refprop r ml referenceproperti name referredvari name rule variableexp attributionatom creat r ml attributionatom variableexp parent iter express like var select rule variableexp attributionatom ocl variableexp oclistypeof ocl variableexp refimmediatecomposit oclistypeof ocl iteratorexp r ml attributionatom attribut attr subject thismodul class objectvari getinvariantforel contextdefinit contextel datavalu thismodul variabl datavari referredvari attr r ml attribut name referredvari name rule propertycallexp attributionatom creat r ml attributionatom propertycallexp parent iter express like self var select rule propertycallexp attributionatom ocl propertycallexp oclistypeof ocl propertycallexp refimmediatecomposit oclistypeof ocl iteratorexp r ml attributionatom attribut attr subject thismodul class objectvari getinvariantforel contextdefinit contextel datavalu thismodul propertycallexp datavari attr r ml attribut name name rule propertycallexp attributefunctionterm creat r ml attributefunctionterm propertycallexp sourc oper without name e g age owner age rule propertycallexp attributefunctionterm ocl propertycallexp oclistypeof ocl propertycallexp ocl operatorcallexp allinstancesfrom in assequ select e e name collect e e sourc flatten includ sourc oclistypeof ocl collectionoperationcallexp refimmediatecomposit oclistypeof ocl collectionoperationcallexp refimmediatecomposit oclistypeof ocl operatorcallexp refimmediatecomposit name true els hasiteratorexpinpar select p number annot here check iter express foral call allinst fals let iter ocl iteratorexp getiteratorexpfrompar iter oclisundefin iter sourc oclistypeof ocl operationcallexp iter sourc name allinst fals els true endif els true endif els true endif els fals endif endif els fals endif r ml attributefunctionterm attribut atr contextargu sourc oclistypeof ocl variableexp sourc referredvari oclisundefin sourc referredvari name self thismodul class objectvari getinvariantforel contextdefinit contextel els sourc referredvari oclistypeof ocl iter thismodul iter objectvari sourc referredvari els sourc endif endif els oclundefin endif els sourc endif typecategori refimmediatecomposit oclistypeof ocl collectionoperationcallexp bag els oclundefin endif atr r ml attribut name name rule propertycallexp referencepropertyfunctionterm creat r ml referencepropertyfunctionterm propertycallexp sourc anoth propertycallexp e g card member member card custom custom rule propertycallexp referencepropertyfunctionterm ocl propertycallexp oclistypeof ocl propertycallexp ocl propertycallexp allinstancesfrom in assequ collect e e sourc flatten includ r ml referencepropertyfunctionterm contextargu sourc oclistypeof ocl variableexp sourc referredvari name self thismodul class objectvari getinvariantforel contextdefinit contextel els sourc endif els sourc endif referencepropertyref refprop refprop r ml referenceproperti name name rule stringliteralexp typedliter creat r ml typedliter stringliteralexp rule stringliteralexp typedliter ocl stringliteralexp oclistypeof ocl stringliteralexp r ml typedliter lexicalvalu stringsymbol type thismodul stringliteralexp datatyp thismodul getdefaultstringliteralexp rule integerliteralexp typedliter creat r ml typedliter integerliteralexp rule integerliteralexp typedliter ocl integerliteralexp oclistypeof ocl integerliteralexp r ml typedliter lexicalvalu integersymbol tostr type thismodul integerliteralexp datatyp thismodul getdefaultintegerliteralexp rule booleanliteralexp typedliter creat r ml typedliter booleanliteralexp rule booleanliteralexp typedliter ocl booleanliteralexp oclistypeof ocl booleanliteralexp r ml typedliter lexicalvalu booleansymbol tostr type thismodul booleanliteralexp datatyp thismodul getdefaultbooleanliteralexp rule booleanliteralexp datatyp creat r ml datatyp xs positiveinteg booleanliteralexp uniqu lazi rule booleanliteralexp datatyp ocl booleanliteralexp r ml datatyp name xs boolean rule integerliteralexp datatyp creat r ml datatyp xs positiveinteg integerliteralexp uniqu lazi rule integerliteralexp datatyp ocl integerliteralexp r ml datatyp name xs positiveinteg rule stringliteralexp datatyp creat r ml datatyp xs string stringliteralexp uniqu lazi rule stringliteralexp datatyp ocl stringliteralexp r ml datatyp name xs string,6
129,129,P60-R2ML2RDM.atl,"--@atlcompiler atl2006

-- ============================================================
-- Transforms an R2ML metamodel into RDM metamodel.
-- Created as part of M.Sc. theses at GOOD OLD AI Laboratory
-- Author: Milan Milanovic (milan at milanovic.org)
-- Works for R2ML v0.4 (Integrity and Derivation rules)
-- Licence: GNU General Public License, version 2
-- ============================================================

module R2ML2RDM; -- Module Template
create OUT : RDM from IN : R2ML;

uses strings;

-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- HELPER:	firstCharToUpper
-- Converts first character of String to upper and return complete string.
-- CONTEXT:	String
-- OUT:		String
helper context String def: firstCharToUpper() : String =
	let firstChar : String = self.substring(1, 1) in
		firstChar.toUpper() + self.substring(2, self.size());

-- HELPER:	toBoolean
-- Converts String value to Boolean value
-- CONTEXT:	String
-- IN:		String
-- OUT:		Boolean
helper context String def: toBoolean() : Boolean =
	if self = 'true'
	then true
	else false
	endif;

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	R2ML!ObjectClassificationAtom
-- OUT:		R2ML!ObjectVariable
helper context R2ML!ObjectClassificationAtom def: getTerm : R2ML!ObjectVariable = 
	self.term;

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	RDM!Disjunction
-- OUT:		R2ML!ObjectVariable
helper context R2ML!Disjunction def: getTerm : R2ML!ObjectVariable = 
	self.formulas->asSequence()->first().getTerm;

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	RDM!Conjuction
-- OUT:		R2ML!ObjectVariable
helper context R2ML!Conjuction def: getTerm : R2ML!ObjectVariable = 
	self.formulas->asSequence()->first().getTerm;

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	R2ML!UniversallyQuantifiedFormula
-- OUT:		R2ML!ObjectVariable
helper context R2ML!UniversallyQuantifiedFormula def: getTerm : R2ML!ObjectVariable = 
	self.formula.getTerm;

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	R2ML!ExistentiallyQuantifiedFormula
-- OUT:		R2ML!ObjectVariable
helper context R2ML!ExistentiallyQuantifiedFormula def: getTerm : R2ML!ObjectVariable = 
	self.formula.getTerm;

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	R2ML!ReferencePropertyAtom
-- OUT:		R2ML!ObjectVariable
helper context R2ML!ReferencePropertyAtom def: getTerm : R2ML!ObjectVariable = 
	self.subject;

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	R2ML!AtMostQuantifiedFormula
-- OUT:		R2ML!ObjectVariable
helper context R2ML!AtMostQuantifiedFormula def: getTerm : R2ML!ObjectVariable = 
	self.formula.getTerm;

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	R2ML!AtLeastQuantifiedFormula
-- OUT:		R2ML!ObjectVariable
helper context R2ML!AtLeastQuantifiedFormula def: getTerm : R2ML!ObjectVariable = 
	self.formula.getTerm;

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	R2ML!AtLeastAndAtMostQuantifiedFormula
-- OUT:		R2ML!ObjectVariable
helper context R2ML!AtLeastAndAtMostQuantifiedFormula def: getTerm : R2ML!ObjectVariable = 
	self.formula.getTerm;

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	R2ML!EqualityAtom
-- OUT:		R2ML!ObjectVariable
helper context R2ML!EqualityAtom def: getTerm : R2ML!ObjectVariable = 
	self.terms->select(e | e.oclIsTypeOf(R2ML!ObjectVariable))->first();

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	R2ML!DatatypePredicateAtom
-- OUT:		R2ML!DataVariable
helper context R2ML!DatatypePredicateAtom def: getTerm : R2ML!DataVariable = 
	self.dataArguments->select(c | c.oclIsTypeOf(R2ML!DataVariable))->first();

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	R2ML!AttributionAtom
-- OUT:		R2ML!DataVariable
helper context R2ML!AttributionAtom def: getTerm : R2ML!Variable = 
	if self.dataValue.oclIsTypeOf(R2ML!DataVariable) then -- TODO: Check this
		self.dataValue
	else self.subject
	endif;

-- HELPER: getChildren
-- Returns all children for context Implication (for both, antecedent and consequent).
-- CONTEXT:	R2ML!Implication
-- OUT:		Sequence(R2ML!LogicalFormula)
helper context R2ML!Implication def: getChildren : Sequence(R2ML!LogicalFormula) =
	self.getAntecedent->asSequence()->union(self.getConsequent->asSequence());
	
-- HELPER: getAntecedent
-- Returns antecedent children for context Implication.
-- CONTEXT:	R2ML!Implication
-- OUT:		Sequence(R2ML!LogicalFormula)
helper context R2ML!Implication def: getAntecedent : Sequence(R2ML!LogicalFormula) 	=
	 if self.antecedent.oclIsTypeOf(R2ML!Conjuction) then
	 	if self.antecedent.isConjuctionFromIntersection then
			Sequence{self.antecedent}
		else self.antecedent.formulas
		endif
	 else Sequence{self.antecedent}
	 endif;
	
-- HELPER: getConsequent
-- Returns consequent children for context Implication.
-- CONTEXT:	R2ML!Implication
-- OUT:		Sequence(R2ML!LogicalFormula)
helper context R2ML!Implication def: getConsequent : Sequence(R2ML!LogicalFormula) 	=
	if self.consequent.oclIsTypeOf(R2ML!Conjuction) then
	 	if self.consequent.isConjuctionFromIntersection then
			Sequence{self.consequent}
		else self.consequent.formulas
		endif
	 else Sequence{self.consequent}
	 endif; 
	
-- HELPER: getChildrenOfAllTopMostImplications
-- Returns all children elements (both, antecedents and consequents) for all topmost Implications (Rules).
-- OUT:		Sequence(R2ML!LogicalFormula)
helper def: getChildrenOfAllTopMostImplications() : Sequence(R2ML!LogicalFormula) =
	 let allImps : Sequence(R2ML!Implication) = thisModule.getTopMostUniversallyQuantifiedFormulas()->collect(c | c.formula)->flatten() in
  	 	allImps->collect(c | c.getChildren)->flatten();

-- HELPER: isConjuctionFromIntersection
-- Implements algorithm for checking is contextual Conjuction coming from RDM Intersection 
-- to Conjuction transformation. This is important, because Implication (RDM Rule)
-- can containts for antecedent or consequent Conjuction from multiple Atoms or from
-- Intersection.
-- CONTEXT:	R2ML!Conjuction
-- OUT:		Boolean
helper context R2ML!Conjuction def: isConjuctionFromIntersection : Boolean = 
		if R2ML!ExistentiallyQuantifiedFormula.allInstancesFrom('IN')->asSequence()->collect(c | c.formula)->flatten()->excludes(self)
			and	self.formulas->size() = 2
			and self.formulas->asSequence()->first().getTerm = self.formulas->asSequence()->last().getTerm
			and ( self.formulas->select(c | c.oclIsTypeOf(R2ML!Disjunction))->collect(e | e.formulas)->flatten()->forAll(c | c.oclIsTypeOf(R2ML!EqualityAtom))
			and self.formulas->select(c | c.oclIsTypeOf(R2ML!UniversallyQuantifiedFormula))->collect(e | e.formula)->flatten()->forAll(c | c.oclIsTypeOf(R2ML!Implication))
			and self.formulas->select(c | c.oclIsTypeOf(R2ML!ExistentiallyQuantifiedFormula))->collect(e | e.formula)->flatten()->forAll(c | c.oclIsTypeOf(R2ML!Conjuction))
			and self.formulas->select(c | c.oclIsTypeOf(R2ML!AtLeastQuantifiedFormula))->collect(e | e.formula)->flatten()->forAll(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom))
			and self.formulas->select(c | c.oclIsTypeOf(R2ML!AtMostQuantifiedFormula))->collect(e | e.formula)->flatten()->forAll(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom))
			and self.formulas->select(c | c.oclIsTypeOf(R2ML!AtLeastAndAtMostQuantifiedFormula))->collect(e | e.formula)->flatten()->forAll(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom)) 
			and self.formulas->select(c | c.oclIsTypeOf(R2ML!AttributionAtom))->size() = 0
			and self.formulas->select(c | c.oclIsTypeOf(R2ML!DatatypePredicateAtom))->size() = 0 )
			and self.formulas->collect(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom))->flatten()->size() > 0
		then true
		else false
		endif;

-- HELPER: getTopMostUniversallyQuantifiedFormulas
-- Returns all top-most UniversallyQuantifiedFormulas.
-- OUT:		 Sequence(R2ML!UniversallyQuantifiedFormula)
helper def: getTopMostUniversallyQuantifiedFormulas() : Sequence(R2ML!UniversallyQuantifiedFormula) =
	R2ML!AlethicIntegrityRule.allInstancesFrom('IN')->asSequence()->collect(c | c.constraint)->flatten();	
	
-- HELPER: isRefPropAtomForHasValue
-- Implements algorithm for checking is contextual ReferencePropertyAtom candidate
-- for RDM HasValueRestriction.
-- CONTEXT:	R2ML!ReferencePropertyAtom
-- OUT:		Boolean
helper context R2ML!ReferencePropertyAtom def: isRefPropAtomForHasValue : Boolean =
	thisModule.getChildrenOfAllTopMostImplications()->excludes(self) and
	R2ML!UniversallyQuantifiedFormula.allInstancesFrom('IN')->asSequence()->excluding(thisModule.getTopMostUniversallyQuantifiedFormulas())->select(e | e.formula.oclIsTypeOf(R2ML!Implication))->collect(c | c.formula)->flatten()->collect(c | c.antecedent)->flatten()->excludes(self) and
	R2ML!ExistentiallyQuantifiedFormula.allInstancesFrom('IN')->asSequence()->select(e | e.formula.oclIsTypeOf(R2ML!Conjuction))->collect(c | c.formula.formulas->asSequence())->flatten()->excludes(self) and
	R2ML!AtMostQuantifiedFormula.allInstancesFrom('IN')->asSequence()->collect(c | c.formula)->flatten()->excludes(self) and
	R2ML!AtLeastQuantifiedFormula.allInstancesFrom('IN')->asSequence()->collect(c | c.formula)->flatten()->excludes(self) and
	R2ML!AtLeastAndAtMostQuantifiedFormula.allInstancesFrom('IN')->asSequence()->collect(c | c.formula)->flatten()->excludes(self);

----------------------------------------------------------------------------------
-- Helpers for transforming R2ML elements which are transformed from OCL metamodel
----------------------------------------------------------------------------------

-- HELPER:	getDatatypePredicateAtomsWithSubElems
-- Returns all Datatype predicate atoms with their subelems for contextual logical formula
-- CONTEXT:	R2ML!LogicalFormula
-- OUT:		Sequence(OclAny)
helper context R2ML!LogicalFormula def: getDatatypePredicateAtomsWithSubElems() : Sequence(OclAny) =
	if self.oclIsTypeOf(R2ML!Conjuction) then
	    self.formulas->select(c | c.oclIsTypeOf(R2ML!DatatypePredicateAtom))->asSequence()->collect(c | c.getElementWithSubElems())->flatten()->asSequence()
	else if self.oclIsTypeOf(R2ML!DatatypePredicateAtom) then
			self.getElementWithSubElems()
		 else OclUndefined
		 endif
	endif;

-- HELPER:	getReferencePropertyAtomsWithTermsWithSubElems
-- Returns all Reference property atoms with terms for contextual logical formula
-- CONTEXT:	R2ML!LogicalFormula
-- OUT:		Sequence(OclAny)
helper context R2ML!LogicalFormula def: getReferencePropertyAtomsWithTermsWithSubElems() : Sequence(OclAny) =
	if self.oclIsTypeOf(R2ML!Conjuction) then
		Sequence { self.formulas->select(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom))->select(c | not c.subject.oclIsTypeOf(R2ML!ObjectVariable) or not c.object.oclIsTypeOf(R2ML!ObjectVariable))->asSequence()->collect(c | c.getElementWithSubElems())->flatten()->asSequence(),
  				   self.formulas->select(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom))->select(c | c.subject.oclIsTypeOf(R2ML!ObjectVariable) and c.object.oclIsTypeOf(R2ML!ObjectVariable))->flatten()->asSequence() -- get basic ReferencePropertyAtom's
				 }
	else if not self.subject.oclIsTypeOf(R2ML!ObjectVariable) or not self.object.oclIsTypeOf(R2ML!ObjectVariable) then
			self.getElementWithSubElems()->flatten()->asSequence()
		 else self
		 endif
	endif;

-- HELPER:	areAllObjectVariables
-- Returns all object variable in the R2ML ReferencePropertyAtom (for subject and object)
-- CONTEXT:	R2ML!ReferencePropertyAtom
-- OUT:		Boolean
helper context R2ML!ReferencePropertyAtom def: areAllObjectVariables() : Boolean =
	if self.subject.oclIsTypeOf(R2ML!ObjectVariable) then
		if self.object.oclIsTypeOf(R2ML!ObjectVariable) then
			true
		else false
		endif
	else false
	endif;

-- HELPER:	getElementWithSubElems
-- Returns contextual ReferencePropertyAtom with all sub elements
-- CONTEXT:	R2ML!ReferencePropertyAtom
-- OUT:		Sequence(OclAny)
helper context R2ML!ReferencePropertyAtom def: getElementWithSubElems() : Sequence(OclAny) = 
	Sequence{ if not self.subject.oclIsTypeOf(R2ML!ObjectVariable) then
				self.subject.getElementWithSubElems()->flatten()->asSequence()
			  else OclUndefined
			  endif,
			  if not self.object.oclIsTypeOf(R2ML!ObjectVariable) then
				self.object.getElementWithSubElems()->flatten()->asSequence()
			  else OclUndefined
			  endif
	}->flatten()->asSequence()->append(self);
	
-- HELPER:	getElementWithSubElems
-- Returns contextual DatatypePredicateAtom with all sub elements
-- CONTEXT:	R2ML!DatatypePredicateAtom
-- OUT:		Sequence(OclAny)
helper context R2ML!DatatypePredicateAtom def: getElementWithSubElems() : Sequence(OclAny) = 
	self.dataArguments->select(c | not c.oclIsKindOf(R2ML!DataLiteral))->asSequence()->collect(c | c.getElementWithSubElems())->flatten()->asSequence()->append(self);

-- HELPER:	getElementWithSubElems
-- Returns contextual AttributeFunctionTerm with all sub elements
-- CONTEXT:	R2ML!AttributeFunctionTerm
-- OUT:		Sequence(OclAny)
helper context R2ML!AttributeFunctionTerm def: getElementWithSubElems() : Sequence(OclAny) = 
	Sequence { self.contextArgument.getElementWithSubElems() }->flatten()->append(self);
	
-- HELPER:	getElementWithSubElems
-- Returns contextual ReferencePropertyFunctionTerm with all sub elements
-- CONTEXT:	R2ML!ReferencePropertyFunctionTerm
-- OUT:		Sequence(OclAny)
helper context R2ML!ReferencePropertyFunctionTerm def: getElementWithSubElems() : Sequence(OclAny) = 
	Sequence { self.contextArgument.getElementWithSubElems() }->flatten()->append(self);
	
-- HELPER:	getElementWithSubElems
-- Returns contextual DataOperationTerm with all sub elements
-- CONTEXT:	R2ML!DataOperationTerm
-- OUT:		Sequence(OclAny)
helper context R2ML!DataOperationTerm def: getElementWithSubElems() : Sequence(OclAny) = 
	Sequence { self.contextArgument.getElementWithSubElems() }->flatten()->append(self);
	
-- HELPER:	getElementWithSubElems
-- Returns contextual ObjectVariable with all sub elements (itself)
-- CONTEXT:	R2ML!ObjectVariable
-- OUT:		Sequence(OclAny)
helper context R2ML!ObjectVariable def: getElementWithSubElems() : Sequence(OclAny) = 
	Sequence { self };
	
-- HELPER:	getVariableName
-- Returns ReferencePropertyFunctionTerm contextArgument name (i.e. variable) with
-- referencePropertyRef name
-- CONTEXT:	R2ML!ReferencePropertyFunctionTerm
-- OUT:		String
helper context R2ML!ReferencePropertyFunctionTerm def: getVariableName() : String = 
		self.contextArgument.name + self.referencePropertyRef.name.firstCharToUpper();

-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'Implication2Rule'
-- Create RDM Rule element from R2ML Implication element 
rule Implication2Rule {
	from i : R2ML!Implication (
		thisModule.getTopMostUniversallyQuantifiedFormulas()->collect(c | c.formula)->flatten()->includes(i)
		)
	to o : RDM!Rule (
		hasAntecedent <- ant,
		hasConsequent <- con
		),
	ant : RDM!Antecedent (
		containsAtom <- if i.antecedent.oclIsTypeOf(R2ML!Conjuction) then
							if	i.antecedent.isConjuctionFromIntersection
							then
								i.antecedent
							else Sequence { i.antecedent.formulas->select(c | not c.oclIsTypeOf(R2ML!DatatypePredicateAtom) and not c.oclIsTypeOf(R2ML!ReferencePropertyAtom))->asSequence(),
											i.antecedent.getDatatypePredicateAtomsWithSubElems(),
											i.antecedent.getReferencePropertyAtomsWithTermsWithSubElems()
											}
							endif
						else if i.antecedent.oclIsTypeOf(R2ML!DatatypePredicateAtom) then
								i.antecedent.getDatatypePredicateAtomsWithSubElems()
							 else if i.antecedent.oclIsTypeOf(R2ML!ReferencePropertyAtom) then
							 		i.antecedent.getElementWithSubElems()
									   -- Check because of Intersection element with type of term
							 	  else if i.antecedent.oclIsTypeOf(R2ML!Disjunction) then
							 		    if i.antecedent.getTerm.oclIsTypeOf(R2ML!ObjectVariable) then
							 			   if not i.antecedent.getTerm.classRef.oclIsUndefined() then
											 -- Create Intersection with this type
											 thisModule.LogicalFormula2Intersection(i.antecedent)
										   else i.antecedent
										   endif
							 	        else i.antecedent
								        endif
								      else i.antecedent
								      endif
								 endif
							 endif
						endif
		),
	con : RDM!Consequent (
		containsAtom <- if i.consequent.oclIsTypeOf(R2ML!Conjuction) then
								if	i.consequent.isConjuctionFromIntersection
							then
								i.consequent
							else Sequence { i.consequent.formulas->select(c | not c.oclIsTypeOf(R2ML!DatatypePrediacateAtom) and not c.oclIsTypeOf(R2ML!ReferencePropertyAtom))->asSequence(),
											i.consequent.getDatatypePredicateAtomsWithSubElems(),
											i.consequent.getReferencePropertyAtomsWithTermsWithSubElems()
											}
							endif
						else if i.consequent.oclIsTypeOf(R2ML!DatatypePredicateAtom) then
								i.consequent.getDatatypePredicateAtomsWithSubElems()
							 else if i.consequent.oclIsTypeOf(R2ML!ReferencePropertyAtom) then
							 		i.consequent.getElementWithSubElems()
							 		   -- Check because of Intersection element with type of term
							 	  else if i.consequent.oclIsTypeOf(R2ML!Disjunction) then
							 		       if i.consequent.getTerm.oclIsTypeOf(R2ML!ObjectVariable) then
							 			       if not i.consequent.getTerm.classRef.oclIsUndefined() then
											      -- Create Intersection with this type
										      	thisModule.LogicalFormula2Intersection(i.consequent)
										       else i.consequent
										       endif
							 	          else i.consequent
								          endif
								       else i.consequent
								       endif
							     endif
							 endif
						endif
		)
}

-- Lazy rule 'LogicalFormula2Intersection'
-- Creates IntersectionClass RDM element from LogicalFormula R2ML element.
unique lazy rule LogicalFormula2Intersection {
	from i : R2ML!LogicalFormula
	to o :  RDM!Atom (
				name <- 'ClassAtom',
				hasPredicateSymbol <- intCla,
				terms <- thisModule.ObjectVariable2IndividualVariable(i.getTerm)
			),
		intCla : RDM!IntersectionClass (
			intersectionOf <- Sequence { thisModule.Class2Class(i.getTerm.classRef),
										 i
									   }
			)	
}

-- IndividualPropertyAtom

-- Rule 'ReferencePropertyAtom2IndividualPropertyAtom'
-- Creates Atom RDM element (IndividualPropertyAtom) from ReferencePropertyAtom R2ML element.
rule ReferencePropertyAtom2IndividualPropertyAtom {
	from i : R2ML!ReferencePropertyAtom (
		not i.isRefPropAtomForHasValue and i.areAllObjectVariables()
		)
	to o : RDM!Atom (
		name <- 'IndividualPropertyAtom',
		hasPredicateSymbol <- thisModule.ReferenceProperty2ObjectProperty(i.referenceProperty),
		terms <- Sequence { thisModule.ObjectVariable2IndividualVariable(i.object),
							thisModule.ObjectVariable2IndividualVariable(i.subject)}
		)
}

-- Rule 'ReferenceProperty2ObjectProperty'
-- Transformation from R2ML ReferenceProperty element to RDM ObjectProperty element.
unique lazy rule ReferenceProperty2ObjectProperty {
	from i : R2ML!ReferenceProperty
	to o : RDM!ObjectProperty (
			name <- i.name
		)
}

-- Rule 'ReferenceProperty2DatatypeProperty'
-- Transformation from R2ML ReferenceProperty element to RDM DatatypeProperty element.
unique lazy rule ReferenceProperty2DatatypeProperty {
	from i : R2ML!ReferenceProperty
	to o : RDM!DatatypeProperty (
			name <- i.name
		)
}

-- Rule 'ObjectVariable2IndividualVariable'
-- Create RDM IndividualVariable from R2ML ObjectVariable.
unique lazy rule ObjectVariable2IndividualVariable {
	from i : R2ML!ObjectVariable
	to o : RDM!IndividualVariable (
			name <- i.name,
			classRef <- if not i.classRef.oclIsUndefined() then
							thisModule.Class2Class(i.classRef)
						else OclUndefined
						endif
		)		
}

-- Rule 'DataVariable2IndividualVariable'
-- Create RDM IndividualVariable from R2ML DataVariable.
unique lazy rule DataVariable2IndividualVariable {
	from i : R2ML!DataVariable
	to o : RDM!IndividualVariable (
			name <- i.name
		)		
}

-- ClassAtom

-- Rule 'Conjuction2ClassAtom'
-- Create RDM ClassAtom with Intersection predicate symbol from R2ML Conjuction
rule Conjuction2ClassAtom {
	from i : R2ML!Conjuction (
		i.isConjuctionFromIntersection and
		-- Because of defining type with Intersection
			if i.formulas->asSequence()->first().getTerm.oclIsTypeOf(R2ML!ObjectVariable) then
				if not i.formulas->asSequence()->first().getTerm.classRef.oclIsUndefined() then
					false
				else true
				endif
			else true
			endif
 	)
	to o : RDM!Atom (
		name <- 'ClassAtom',
		hasPredicateSymbol <- intCla,
		terms <- thisModule.ObjectVariable2IndividualVariable(i.formulas->asSequence()->first().getTerm)
		),
		intCla : RDM!IntersectionClass (
			intersectionOf <- Sequence { i.formulas->asSequence()->select(c | c.oclIsTypeOf(R2ML!ObjectClassificationAtom))->collect(e | thisModule.Class2Class(e.type)),
								  		 i.formulas->asSequence()->select(c | not c.oclIsTypeOf(R2ML!ObjectClassificationAtom))
									   }
			)	
}

-- Rule 'DisjunctionAtom2Union'
-- Create RDM ClassAtom with UnionClass predicate symbol from R2ML Disjunction,
-- which not have EqualityAtom or DatatypePredicateAtom as its formula, and it is
-- children of top-most Implication.
rule DisjunctionAtom2Union {
	from i : R2ML!Disjunction (
		R2ML!Conjuction.allInstancesFrom('IN')->asSequence()->select(c | c.isConjuctionFromIntersection)->collect(e | e.formulas)->flatten()->excludes(i) and
		R2ML!Disjunction.allInstancesFrom('IN')->asSequence()->select(e | e.formulas->asSequence()->first().oclIsTypeOf(R2ML!EqualityAtom) or e.formulas->asSequence()->first().oclIsTypeOf(R2ML!DatatypePredicateAtom))->excludes(i) and
		
		  ( thisModule.getChildrenOfAllTopMostImplications()->includes(i) and 
			if i.formulas->asSequence()->first().getTerm.oclIsTypeOf(R2ML!ObjectVariable) then
				if not i.formulas->asSequence()->first().getTerm.classRef.oclIsUndefined() then
					false
				else true
				endif
			else true
			endif
		  )
		)
	to o : RDM!Atom (
		name <- 'ClassAtom',
		hasPredicateSymbol <- uniCla,
		terms <- thisModule.ObjectVariable2IndividualVariable(i.formulas->asSequence()->first().getTerm)
		),
		uniCla : RDM!UnionClass (
			unionOf <- Sequence { i.formulas->asSequence()->select(c | c.oclIsTypeOf(R2ML!ObjectClassificationAtom))->collect(e | thisModule.Class2Class(e.type)),
								  i.formulas->asSequence()->select(c | not c.oclIsTypeOf(R2ML!ObjectClassificationAtom))
								}
			)
}

-- Rule 'Disjunction2Union'
-- Create UnionClass predicateR2ML Disjunction,
-- which not have EqualityAtom or DatatypePredicateAtom as its formula, and it is
-- not children of top-most Implication.
rule Disjunction2Union {
	from i : R2ML!Disjunction (
		R2ML!Conjuction.allInstancesFrom('IN')->asSequence()->select(c | c.isConjuctionFromIntersection)->collect(e | e.formulas)->flatten()->excludes(i) and
		R2ML!Disjunction.allInstancesFrom('IN')->asSequence()->select(e | e.formulas->asSequence()->first().oclIsTypeOf(R2ML!EqualityAtom) or e.formulas->asSequence()->first().oclIsTypeOf(R2ML!DatatypePredicateAtom))->excludes(i)
		and
		
		  ( thisModule.getChildrenOfAllTopMostImplications()->excludes(i) or 
			-- Because of defining type with Intersection
			if i.formulas->asSequence()->first().getTerm.oclIsTypeOf(R2ML!ObjectVariable) then
				if not i.formulas->asSequence()->first().getTerm.classRef.oclIsUndefined() then
					true
				else false
				endif
			else true
			endif
		  )
		)
	to uniCla : RDM!UnionClass (
			unionOf <- Sequence { i.formulas->asSequence()->select(c | c.oclIsTypeOf(R2ML!ObjectClassificationAtom))->collect(e | thisModule.Class2Class(e.type)),
								  i.formulas->asSequence()->select(c | not c.oclIsTypeOf(R2ML!ObjectClassificationAtom))
								}
			)
}

-- Rule 'NegationAtom2Complement'
-- Create RDM ClassAtom with ComplementClass predicate symbol from R2ML NegationAsFailure.
rule NegationAtom2Complement {
	from i : R2ML!StrongNegation (
			i.oclIsTypeOf(R2ML!StrongNegation) and thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o : RDM!Atom (
		name <- 'ClassAtom',
		hasPredicateSymbol <- comCla,
		terms <- thisModule.ObjectVariable2IndividualVariable(i.formula.getTerm)
		),
		comCla : RDM!ComplementClass (
			complementOf <- if i.formula.oclIsTypeOf(R2ML!ObjectClassificationAtom) then
								thisModule.Class2Class(i.formula.type)
							else i.formula
							endif
			)
}

-- Rule 'Negation2Complement'
-- Create RDM ClassAtom with ComplementClass predicate symbol from R2ML NegationAsFailure.
rule Negation2Complement {
	from i : R2ML!StrongNegation (
			i.oclIsTypeOf(R2ML!StrongNegation) and thisModule.getChildrenOfAllTopMostImplications()->excludes(i)
		)
	to comCla : RDM!ComplementClass (
			complementOf <- if i.formula.oclIsTypeOf(R2ML!ObjectClassificationAtom) then
								thisModule.Class2Class(i.formula.type)
							else i.formula
							endif
			)
}

-- Rule 'Disjunction2EnumeratedClass'
-- Create EnumeratedClass from R2ML Disjunction.
rule DisjunctionFromIntersection2EnumeratedClass {
	from i : R2ML!Disjunction (
			R2ML!Conjuction.allInstancesFrom('IN')->asSequence()->select(c | c.isConjuctionFromIntersection)->collect(e | e.formulas)->flatten()->includes(i)
			and		
			i.formulas->select(e | e.oclIsTypeOf(R2ML!EqualityAtom))->size() > 0
		)
	to enumClass : RDM!EnumeratedClass (
			oneOf <- i.formulas->asSequence()->collect(c | c.terms)->flatten()->select(c | c.oclIsTypeOf(R2ML!ObjectName))->asSequence()
			)
}

-- Rule 'DisjunctionFromAtom2EnumeratedClass'
-- Create RDM ClassAtom with EnumeratedClass predicate symbol from R2ML Disjunction.
rule DisjunctionFromAtom2EnumeratedClass {
	from i : R2ML!Disjunction (
			R2ML!Conjuction.allInstancesFrom('IN')->asSequence()->select(c | c.isConjuctionFromIntersection)->collect(e | e.formulas)->flatten()->excludes(i)
			and		
			i.formulas->select(e | e.oclIsTypeOf(R2ML!EqualityAtom))->size() > 0
		)
	to o : RDM!Atom	(
			name <- 'ClassAtom',
			hasPredicateSymbol <- enumClass,
			terms <- thisModule.ObjectVariable2IndividualVariable(i.formulas->asSequence()->first().getTerm)
		),
		enumClass : RDM!EnumeratedClass (
			oneOf <- i.formulas->collect(e | e.terms)->flatten()->select(c | c.oclIsTypeOf(R2ML!ObjectName))
			)
}

-- Rule 'ObjectName2Individual'
-- Create RDM Individual from R2ML ObjectName.
rule ObjectName2Individual {
	from i : R2ML!ObjectName (
		R2ML!EqualityAtom.allInstancesFrom('IN')->asSequence()->collect(c | c.terms)->flatten()->select(e | e.oclIsTypeOf(R2ML!ObjectName))->includes(i)
		)
	to o : RDM!Individual (
		name <- i.name
		)
}

-- Rule 'ObjectClassificationAtom2ClassAtom'
-- Creates ClassAtom RDM element from R2ML ObjectClassificationAtom element.
rule ObjectClassificationAtom2ClassAtom {
	from i : R2ML!ObjectClassificationAtom (		
		thisModule.getChildrenOfAllTopMostImplications()->includes(i) and
		R2ML!Conjuction.allInstancesFrom('IN')->asSequence()->select(e | e.isConjuctionFromIntersection)->collect(e | e.formulas)->flatten()->excludes(i)
		and i.isNegated = false
		)
	to o : RDM!Atom (
		name <- 'ClassAtom',
		hasPredicateSymbol <- thisModule.Class2Class(i.type),
		terms <- thisModule.ObjectVariable2IndividualVariable(i.term)
	)
}

-- Rule 'ObjectClassificationAtom'
-- Creates ClassAtom RDM element from R2ML ObjectClassificationAtom element (that is negated).
rule ObjectClassificationAtomNegated2ComplementClassAtom {
	from i : R2ML!ObjectClassificationAtom (		
		thisModule.getChildrenOfAllTopMostImplications()->includes(i) and
		R2ML!Conjuction.allInstancesFrom('IN')->asSequence()->select(e | e.isConjuctionFromIntersection)->collect(e | e.formulas)->flatten()->excludes(i)
		and i.isNegated = true
		)
	to o : RDM!Atom (
		name <- 'ClassAtom',
		hasPredicateSymbol <- cla,
		terms <- thisModule.ObjectVariable2IndividualVariable(i.term)
	),
	cla : RDM!Class (
			subClassOf <- Sequence { cs }
		),
	cs : RDM!ComplementClass (
			complementOf <- thisModule.Class2Class(i.type)
	)
}


-- Rule 'Class2Class'
-- Create RDM Class from R2ML Class element.
unique lazy rule Class2Class {
	from i : R2ML!Class
	to cla : RDM!Class (
				name <- i.name
			)
}

-- Rule 'ExistentiallyQuantifiedFormulaClass2SomeValuesFromRestriction'
-- Creates SomeValuesFromRestriction RDM element from R2ML ExistentiallyQuantifiedFormula element,
-- which have ReferencePropertyAtoms as formulas.
rule ExistentiallyQuantifiedFormulaClass2SomeValuesFromRestriction {
	from i : R2ML!ExistentiallyQuantifiedFormula (
		thisModule.getChildrenOfAllTopMostImplications()->excludes(i) and
		i.formula.formulas->select(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom))->size() > 0
		)
	to o : RDM!SomeValuesFromRestriction (
		someValuesFromClass <- Sequence { i.formula.formulas->select(c | c.oclIsTypeOf(R2ML!ObjectClassificationAtom))->collect(c | thisModule.Class2Class(c.type))->first(),
										  i.formula.formulas->select(c | not c.oclIsTypeOf(R2ML!ReferencePropertyAtom) and not c.oclIsTypeOf(R2ML!ObjectClassificationAtom))->first()
										}->select(c | not c.oclIsUndefined())->asSequence()->first(),
		onProperty <- thisModule.ReferenceProperty2ObjectProperty(i.formula.formulas->select(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom))->first().referenceProperty)
		)
}

-- Rule 'ExistentiallyQuantifiedFormulaClass2ClassAtomSomeValuesFromRestriction'
-- Creates RDM Atom with SomeValuesFromRestriction as predicate symbol from 
-- R2ML ExistentiallyQuantifiedFormula element, which have ReferencePropertyAtoms 
-- as formulas.
rule ExistentiallyQuantifiedFormulaClass2ClassAtomSomeValuesFromRestriction {
	from i : R2ML!ExistentiallyQuantifiedFormula (
		thisModule.getChildrenOfAllTopMostImplications()->includes(i) and
		i.formula.formulas->select(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom))->size() > 0
		)
	to o : RDM!Atom (
			name <- 'ClassAtom',
			hasPredicateSymbol <- svf,
			terms <- thisModule.ObjectVariable2IndividualVariable(i.formula.formulas->select(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom))->first().getTerm)
		),
	svf : RDM!SomeValuesFromRestriction (
		someValuesFromClass <- Sequence { i.formula.formulas->select(c | c.oclIsTypeOf(R2ML!ObjectClassificationAtom))->collect(c | thisModule.Class2Class(c.type))->first(),
										  i.formula.formulas->select(c | not c.oclIsTypeOf(R2ML!ReferencePropertyAtom) and not c.oclIsTypeOf(R2ML!ObjectClassificationAtom))->first()
										}->select(c | not c.oclIsUndefined())->asSequence()->first(),
		onProperty <- thisModule.ReferenceProperty2ObjectProperty(i.formula.formulas->select(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom))->first().referenceProperty)
		)
}

-- Rule 'UniversallyQuantifiedFormulaClass2AllValuesFromRestriction'
-- Creates AllValuesFromRestriction RDM element from R2ML UniversallyQuantifiedFormula element,
-- which have Implication as its formula and ReferencePropertyAtom as antecedent.
rule UniversallyQuantifiedFormulaClass2AllValuesFromRestriction {
	from i : R2ML!UniversallyQuantifiedFormula (
		thisModule.getTopMostUniversallyQuantifiedFormulas()->excludes(i) and
		if i.formula.oclIsTypeOf(R2ML!Implication) then
			if i.formula.antecedent.oclIsTypeOf(R2ML!ReferencePropertyAtom)
			then true
			else false
			endif
		else false
		endif
		)
	to o : RDM!AllValuesFromRestriction (
		allValuesFromClass <- if i.formula.consequent.oclIsTypeOf(R2ML!ObjectClassificationAtom) then
									thisModule.Class2Class(i.formula.consequent)
							  else i.formula.consequent
							  endif,
		onProperty <- thisModule.ReferenceProperty2ObjectProperty(i.formula.antecedent.referenceProperty)
		)
}

-- Rule 'ReferencePropertyAtomClass2HasValue'
-- Creates HasValueRestriction RDM element from R2ML ReferencePropertyAtom, if
-- ReferencePropertyAtom is for this type of Restriction (uses helper isRefPropAtomForHasValue for checking).
rule ReferencePropertyAtomClass2HasValue {
	from i : R2ML!ReferencePropertyAtom (
			i.isRefPropAtomForHasValue and thisModule.getChildrenOfAllTopMostImplications()->excludes(i)
		)
	to o : RDM!HasValueRestriction (
		hasValue <- thisModule.ObjectVariable2Individual(i.object),
		onProperty <- thisModule.ReferenceProperty2ObjectProperty(i.referenceProperty)
		)
}

-- Rule 'ReferencePropertyAtomClass2ClassAtomHasValue'
-- Creates RDM Atom with HasValueRestriction as predicate symbol from 
-- R2ML ReferencePropertyAtom, if ReferencePropertyAtom is for this 
-- type of Restriction (uses helper isRefPropAtomForHasValue for checking).
rule ReferencePropertyAtomClass2ClassAtomHasValue {
	from i : R2ML!ReferencePropertyAtom (
			i.isRefPropAtomForHasValue and thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o : RDM!Atom (
		name <- 'ClassAtom',
		hasPredicateSymbol <- hvr,
		terms <- thisModule.ObjectVariable2IndividualVariable(i.subject)
		),
	hvr : RDM!HasValueRestriction (
		hasValue <- thisModule.ObjectVariable2Individual(i.object),
		onProperty <- thisModule.ReferenceProperty2ObjectProperty(i.referenceProperty)
		)
}

-- Rule 'ObjectVariable2Individual'
-- Creates Individual RDM element from R2ML ObjectVariable (lazy rule).
unique lazy rule ObjectVariable2Individual {
	from i : R2ML!ObjectVariable
	to o : RDM!Individual (
			name <- i.name
		)		
}

-- Rule 'AtLeastQuantifiedFormula2MinCardinalityRestriction'
-- Creates MinCardinalityRestriction RDM element from R2ML AtLeastQuantifiedFormula.
-- Works for DataRangeAtom and ClassAtom cardinality restrictions.
rule AtLeastQuantifiedFormula2MinCardinalityRestriction {
	from i : R2ML!AtLeastQuantifiedFormula (
			i.oclIsTypeOf(R2ML!AtLeastQuantifiedFormula) and thisModule.getChildrenOfAllTopMostImplications()->excludes(i)
		)
	to o : RDM!MinCardinalityRestriction (
		minCardinality <- card,
		onProperty <- if i.formula.oclIsTypeOf(R2ML!ReferencePropertyAtom) then
						thisModule.ReferenceProperty2ObjectProperty(i.formula.referenceProperty)
					  else thisModule.Attribute2DatatypeProperty(i.formula.attribute)
					  endif
		),
	   card : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.minCardinality.toString()
			)
}

-- Rule 'AtLeastQuantifiedFormulaInClassAtom2MinCardinalityRestriction'
-- Creates RDM Atom with MinCardinalityRestriction as predicate symbol from 
-- R2ML AtLeastQuantifiedFormula. Works for ClassAtom cardinality restrictions.
rule AtLeastQuantifiedFormulaInClassAtom2MinCardinalityRestriction {
	from i : R2ML!AtLeastQuantifiedFormula (
			i.oclIsTypeOf(R2ML!AtLeastQuantifiedFormula) and i.formula.oclIsTypeOf(R2ML!ReferencePropertyAtom)
			and thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o : RDM!Atom (
			name <- 'ClassAtom',
			hasPredicateSymbol <- mcr,
			terms <- thisModule.ObjectVariable2IndividualVariable(i.formula.subject)
		),
	  mcr : RDM!MinCardinalityRestriction (
			minCardinality <- card,
			onProperty <- thisModule.ReferenceProperty2ObjectProperty(i.formula.referenceProperty)
		),
		card : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.minCardinality.toString()
		)
}

-- Rule 'AtLeastQuantifiedFormulaInDataRangeAtom2MinCardinalityRestriction'
-- Creates RDM Atom with MinCardinalityRestriction as predicate symbol from 
-- R2ML AtLeastQuantifiedFormula. Works for DataRangeAtom cardinality restrictions.
rule AtLeastQuantifiedFormulaInDataRangeAtom2MinCardinalityRestriction {
	from i : R2ML!AtLeastQuantifiedFormula (
			i.oclIsTypeOf(R2ML!AtLeastQuantifiedFormula) and i.formula.oclIsTypeOf(R2ML!AttributionAtom)
			and thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o : RDM!Atom (
			name <- 'DataRangeAtom',
			hasPredicateSymbol <- mcr,
			terms <- thisModule.DataVariable2IndividualVariable(i.formula.dataValue)
		),
	  mcr : RDM!MinCardinalityRestriction (
			minCardinality <- card,
			onProperty <-thisModule.Attribute2DatatypeProperty(i.formula.attribute)
		),
		card : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.minCardinality.toString()
		)
}

-- Rule 'AtMostQuantifiedFormulaClass2MaxCardinalityRestriction'
-- Creates MaxCardinalityRestriction RDM element from R2ML AtMostQuantifiedFormula.
-- Works for DataRangeAtom and ClassAtom cardinality restrictions.
rule AtMostQuantifiedFormulaClass2MaxCardinalityRestriction {
	from i : R2ML!AtMostQuantifiedFormula (
			i.oclIsTypeOf(R2ML!AtMostQuantifiedFormula) and thisModule.getChildrenOfAllTopMostImplications()->excludes(i)
		)
	to o : RDM!MaxCardinalityRestriction (
		maxCardinality <- card,
		onProperty <- if i.formula.oclIsTypeOf(R2ML!ReferencePropertyAtom) then
						thisModule.ReferenceProperty2ObjectProperty(i.formula.referenceProperty)
					  else thisModule.Attribute2DatatypeProperty(i.formula.attribute)
					  endif
		),
		card : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.maxCardinality.toString()
			)
}

-- Rule 'AtMostQuantifiedFormulaInClassAtom2MaxCardinalityRestriction'
-- Creates RDM Atom with MaxCardinalityRestriction as predicate symbol from 
-- R2ML AtMostQuantifiedFormula. Works for ClassAtom cardinality restrictions.
rule AtMostQuantifiedFormulaInClassAtom2MaxCardinalityRestriction {
	from i : R2ML!AtMostQuantifiedFormula (
			i.oclIsTypeOf(R2ML!AtMostQuantifiedFormula) and i.formula.oclIsTypeOf(R2ML!ReferencePropertyAtom)
			and thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o : RDM!Atom (
			name <- 'ClassAtom',
			hasPredicateSymbol <- mcr,
			terms <- thisModule.ObjectVariable2IndividualVariable(i.formula.subject)
		),
	  mcr : RDM!MaxCardinalityRestriction (
			maxCardinality <- card,
			onProperty <- thisModule.ReferenceProperty2ObjectProperty(i.formula.referenceProperty)
		),
		card : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.maxCardinality.toString()
		)
}

-- Rule 'AtMostQuantifiedFormulaInDataRangeAtom2MaxCardinalityRestriction'
-- Creates RDM Atom with MaxCardinalityRestriction as predicate symbol from 
-- R2ML AtMostQuantifiedFormula. Works for DataRangeAtom cardinality restrictions.
rule AtMostQuantifiedFormulaInDataRangeAtom2MaxCardinalityRestriction {
	from i : R2ML!AtMostQuantifiedFormula (
			i.oclIsTypeOf(R2ML!AtMostQuantifiedFormula) and i.formula.oclIsTypeOf(R2ML!AttributionAtom)
			and thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o : RDM!Atom (
			name <- 'DataRangeAtom',
			hasPredicateSymbol <- mcr,
			terms <- thisModule.DataVariable2IndividualVariable(i.formula.dataValue)
		),
	  mcr : RDM!MaxCardinalityRestriction (
			maxCardinality <- card,
			onProperty <- thisModule.Attribute2DatatypeProperty(i.formula.attribute)
		),
		card : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.maxCardinality.toString()
		)
}

-- Rule 'AtLeastAndAtMostQuantifiedFormulaClass2CardinalityRestriction'
-- Creates CardinalityRestriction RDM element from R2ML AtLeastAndAtMostQuantifiedFormula.
-- Works for DataRangeAtom and ClassAtom cardinality restrictions.
rule AtLeastAndAtMostQuantifiedFormulaClass2CardinalityRestriction {
	from i : R2ML!AtLeastAndAtMostQuantifiedFormula (
		i.oclIsTypeOf(R2ML!AtLeastAndAtMostQuantifiedFormula) and
		i.maxCardinality = i.minCardinality and
		thisModule.getChildrenOfAllTopMostImplications()->excludes(i)
		)
	to o : RDM!CardinalityRestriction (
		cardinality <- card,
		onProperty <- if i.formula.oclIsTypeOf(R2ML!ReferencePropertyAtom) then
						thisModule.ReferenceProperty2ObjectProperty(i.formula.referenceProperty)
					  else thisModule.Attribute2DatatypeProperty(i.formula.attribute)
					  endif
		),
		card : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.maxCardinality.toString()
			)
}

-- Rule 'AtLeastAndAtMostQuantifiedFormulaInClassAtom2CardinalityRestriction'
-- Creates RDM Atom with CardinalityRestriction as predicate symbol from 
-- R2ML AtLeastAndAtMostQuantifiedFormula. Works for ClassAtom cardinality restrictions.
rule AtLeastAndAtMostQuantifiedFormulaInClassAtom2CardinalityRestriction {
	from i : R2ML!AtLeastAndAtMostQuantifiedFormula (
			i.oclIsTypeOf(R2ML!AtLeastAndAtMostQuantifiedFormula) and i.formula.oclIsTypeOf(R2ML!ReferencePropertyAtom) and
			i.maxCardinality = i.minCardinality and
			thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o : RDM!Atom (
			name <- 'ClassAtom',
			hasPredicateSymbol <- mcr,
			terms <- thisModule.ObjectVariable2IndividualVariable(i.formula.subject)
		),
	  mcr : RDM!CardinalityRestriction (
			cardinality <- card,
			onProperty <- thisModule.ReferenceProperty2ObjectProperty(i.formula.referenceProperty)
		),
		card : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.maxCardinality.toString()
		)
}

-- Rule 'AtLeastAndAtMostQuantifiedFormulaInDataRangeAtom2CardinalityRestriction'
-- Creates RDM Atom with CardinalityRestriction as predicate symbol from 
-- R2ML AtLeastAndAtMostQuantifiedFormula. Works for DataRangeAtom cardinality restrictions.
rule AtLeastAndAtMostQuantifiedFormulaInDataRangeAtom2CardinalityRestriction {
	from i : R2ML!AtLeastAndAtMostQuantifiedFormula (
			i.oclIsTypeOf(R2ML!AtLeastAndAtMostQuantifiedFormula) and i.formula.oclIsTypeOf(R2ML!AttributionAtom) and
			i.maxCardinality = i.minCardinality and
			thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o : RDM!Atom (
			name <- 'DataRangeAtom',
			hasPredicateSymbol <- mcr,
			terms <- thisModule.DataVariable2IndividualVariable(i.formula.dataValue)
		),
	  mcr : RDM!CardinalityRestriction (
			cardinality <- card,
			onProperty <- thisModule.Attribute2DatatypeProperty(i.formula.attribute)
		),
		card : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.maxCardinality.toString()
		)
}

-- Rule 'AtLeastAndAtMostQuantifiedFormulaClass2MinMaxCardinalityRestriction'
-- Creates MinCardinalityRestriction and MaxCardinalityRestriction RDM elements
-- from R2ML AtLeastAndAtMostQuantifiedFormula, which have different max and
-- min cardinality.
-- Works for DataRangeAtom and ClassAtom cardinality restrictions.
rule AtLeastAndAtMostQuantifiedFormulaClass2MinMaxCardinalityRestriction {
	from i : R2ML!AtLeastAndAtMostQuantifiedFormula (
		i.oclIsTypeOf(R2ML!AtLeastAndAtMostQuantifiedFormula) and
		i.maxCardinality <> i.minCardinality and
		thisModule.getChildrenOfAllTopMostImplications()->excludes(i)
		)
	to o : RDM!MinCardinalityRestriction (
		minCardinality <- cardMin,
		onProperty <- if i.formula.oclIsTypeOf(R2ML!ReferencePropertyAtom) then
						thisModule.ReferenceProperty2ObjectProperty(i.formula.referenceProperty)
					  else thisModule.Attribute2DatatypeProperty(i.formula.attribute)
					  endif
		),
		cardMin : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.minCardinality.toString()
		),
		u : RDM!MaxCardinalityRestriction (
			maxCardinality <- cardMax,
			onProperty <- if i.formula.oclIsTypeOf(R2ML!ReferencePropertyAtom) then
							thisModule.ReferenceProperty2ObjectProperty(i.formula.referenceProperty)
					  	  else thisModule.Attribute2DatatypeProperty(i.formula.attribute)
					      endif
		),
		cardMax : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.maxCardinality.toString()
		)
}

-- Rule 'AtLeastAndAtMostQuantifiedFormulaClassAtom2MinMaxCardinalityRestriction'
-- Creates RDM Atom with MinCardinalityRestriction as predicate symbol and 
-- MaxCardinalityRestriction RDM elementfrom R2ML AtLeastAndAtMostQuantifiedFormula, 
-- which have different max and min cardinality.
-- Works for ClassAtom cardinality restrictions.
rule AtLeastAndAtMostQuantifiedFormulaClassAtom2MinMaxCardinalityRestriction {
	from i : R2ML!AtLeastAndAtMostQuantifiedFormula (
		i.oclIsTypeOf(R2ML!AtLeastAndAtMostQuantifiedFormula) and
		i.formula.oclIsTypeOf(R2ML!ReferencePropertyAtom) and
		i.maxCardinality <> i.minCardinality and
		thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o : RDM!Atom (
			name <- 'ClassAtom',
			hasPredicateSymbol <- mcr,
			terms <- thisModule.ObjectVariable2IndividualVariable(i.formula.subject)
		),
	
	  mcr : RDM!MinCardinalityRestriction (
		minCardinality <- cardMin,
		onProperty <- thisModule.ReferenceProperty2ObjectProperty(i.formula.referenceProperty)
		),
		cardMin : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.minCardinality.toString()
		),
		u : RDM!MaxCardinalityRestriction (
			maxCardinality <- cardMax,
			onProperty <- thisModule.ReferenceProperty2ObjectProperty(i.formula.referenceProperty)
		),
		cardMax : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.maxCardinality.toString()
		)
}

-- Rule 'AtLeastAndAtMostQuantifiedFormulaDataRangeAtom2MinMaxCardinalityRestriction'
-- Creates RDM Atom with MinCardinalityRestriction as predicate symbol and 
-- MaxCardinalityRestriction RDM elementfrom R2ML AtLeastAndAtMostQuantifiedFormula, 
-- which have different max and min cardinality.
-- Works for DataRangeAtom cardinality restrictions.
rule AtLeastAndAtMostQuantifiedFormulaDataRangeAtom2MinMaxCardinalityRestriction {
	from i : R2ML!AtLeastAndAtMostQuantifiedFormula (
		i.oclIsTypeOf(R2ML!AtLeastAndAtMostQuantifiedFormula) and
		i.formula.oclIsTypeOf(R2ML!AttributionAtom) and
		i.maxCardinality <> i.minCardinality and
		thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o : RDM!Atom (
			name <- 'DataRangeAtom',
			hasPredicateSymbol <- mcr,
			terms <- thisModule.DataVariable2IndividualVariable(i.formula.dataValue)
		),
	  mcr : RDM!MinCardinalityRestriction (
		minCardinality <- cardMin,
		onProperty <- thisModule.Attribute2DatatypeProperty(i.formula.attribute)
		),
		cardMin : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.minCardinality.toString()
		),
		u : RDM!MaxCardinalityRestriction (
			maxCardinality <- cardMax,
			onProperty <- thisModule.Attribute2DatatypeProperty(i.formula.attribute)
		),
		cardMax : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.maxCardinality.toString()
		)
}

-- DataRange Atom

-- Rule 'DataClassificationAtom2DataRangeAtomOneOf'
-- Create RDM Atom from R2ML DataClassificationAtom element, which is
-- children of top most Implication.
rule DataClassificationAtom2DataRangeAtomOneOf {
	from i : R2ML!DataClassificationAtom (
		thisModule.getChildrenOfAllTopMostImplications()->includes(i)
	)
	to o : RDM!Atom (
		name <- 'DataRangeAtom',
		hasPredicateSymbol <- dtr,
		terms <- thisModule.DataVariable2IndividualVariable(i.term)
		),
		dtr : RDM!DataRange(
			datatype <- i.type
			)
}

-- Rule 'DataClassificationAtom2DataRange'
-- Create RDM DataRange from R2ML DataClassificationAtom element, which is not
-- children of top most Implication.
rule DataClassificationAtom2DataRange {
	from i : R2ML!DataClassificationAtom (
		thisModule.getChildrenOfAllTopMostImplications()->excludes(i)
	)
	to dtr : RDM!DataRange(
		datatype <- i.type
		)
}

-- Rule 'Disjunction2DataRangeAtom'
-- Create RDM Atom from R2ML Disjunction element, which is
-- children of top most Implication and have DatatypePredicateAtom as its formula.
rule Disjunction2DataRangeAtom {
	from i : R2ML!Disjunction (
		thisModule.getChildrenOfAllTopMostImplications()->includes(i) and
		i.formulas->asSequence()->first().oclIsTypeOf(R2ML!DatatypePredicateAtom)
		)
	to o : RDM!Atom (
		name <- 'DataRangeAtom',
		hasPredicateSymbol <- dtr,
		terms <- Sequence{thisModule.DataVariable2IndividualVariable(i.formulas->asSequence()->first().getTerm)}
		),
		dtr : RDM!DataRange(
			oneOf <- i.formulas
			)
}

-- Rule 'Disjunction2DataRange'
-- Create RDM DataRange from R2ML Disjunction element, which is not
-- children of top most Implication and have DatatypePredicateAtom as its formula.
rule Disjunction2DataRange {
	from i : R2ML!Disjunction (
		thisModule.getChildrenOfAllTopMostImplications()->excludes(i) and
		i.formulas->asSequence()->first().oclIsTypeOf(R2ML!DatatypePredicateAtom)
		)
	to o : RDM!DataRange (
		oneOf <- i.formulas
		)
}

-- Rule 'Datatype2PrimitiveType'
-- Create RDM PrimitiveType from R2ML Datatype element.
rule Datatype2PrimitiveType {
	from i : R2ML!Datatype (
		i.oclIsTypeOf(R2ML!Datatype)
		)
	to o : RDM!PrimitiveType (
		name <- i.name
		)
}

-- Rule 'PlainLiteral2PlainLiteral'
-- Create RDM PlainLiteral from R2ML PlainLiteral element, if it is not 
-- value of top most AttributionAtom and not dataArgument of DatatypePredicateAtom.
rule PlainLiteral2PlainLiteral {
	from i : R2ML!PlainLiteral (
		i.oclIsTypeOf(R2ML!PlainLiteral) and 
		thisModule.getChildrenOfAllTopMostImplications()->select(c | c.oclIsTypeOf(R2ML!AttributionAtom))->collect(c | c.value)->flatten()->excludes(i) and
		R2ML!DatatypePredicateAtom.allInstancesFrom('IN')->asSequence()->collect(c | c.dataArguments)->flatten()->excludes(i)
		)
	to o : RDM!PlainLiteral (
	    language <- i.languageTag,
		lexicalForm <- i.lexicalValue
		)
}

-- Rule 'TypedLiteral2TypedLiteral'
-- Create RDM TypedLiteral from R2ML TypedLiteral element.
rule TypedLiteral2TypedLiteral {
	from i : R2ML!TypedLiteral (
		i.oclIsTypeOf(R2ML!TypedLiteral) 
		and R2ML!DatatypePredicateAtom.allInstancesFrom('IN')->asSequence()->collect(c | c.dataArguments )->flatten()->excludes(i)
		)
	to o : RDM!TypedLiteral (
			theType <- i.type.name,
			lexicalForm <- i.lexicalValue
		)
}

-- Rule 'DatatypePredicateAtom2PlainLiteral'
-- Create RDM PlainLiteral from R2ML DatatypePredicateAtom element, 
-- if this Atom have as dataArgument PlainLiteral and it is not formula
-- of some Disjunction.
rule DatatypePredicateAtom2PlainLiteral {
	from i : R2ML!DatatypePredicateAtom (
		if i.dataArguments->select(c | c.oclIsTypeOf(R2ML!PlainLiteral))->size() > 0 and
			R2ML!Disjunction.allInstancesFrom('IN')->asSequence()->collect(e | e.formulas)->flatten()->includes(i) and
			i.dataArguments->select(c | c.oclIsTypeOf(R2ML!AttributeFunctionTerm))->size() = 0
		then true
		else false
		endif
		)
	to o : RDM!PlainLiteral (
		language <- i.dataArguments->select(c | c.oclIsKindOf(R2ML!DataLiteral))->asSequence()->first().languageTag,
		lexicalForm <- i.dataArguments->select(c | c.oclIsKindOf(R2ML!DataLiteral))->asSequence()->first().lexicalValue
		)
}

-- Rule 'DatatypePredicateAtom2TypedLiteral'
-- Create RDM TypedLiteral from R2ML DatatypePredicateAtom element, 
-- if this Atom have as dataArgument TypedLiteral and it is not formula
-- of some Disjunction.
rule DatatypePredicateAtom2TypedLiteral {
	from i : R2ML!DatatypePredicateAtom (
		if i.dataArguments->select(c | c.oclIsTypeOf(R2ML!TypedLiteral))->size() > 0 and
			R2ML!Disjunction.allInstancesFrom('IN')->asSequence()->collect(e | e.formulas)->flatten()->includes(i) and
			i.dataArguments->select(c | c.oclIsTypeOf(R2ML!AttributeFunctionTerm))->size() = 0
		then true
		else false
		endif
		)
	to o : RDM!TypedLiteral (
		theType <- i.dataArguments->select(c | c.oclIsTypeOf(R2ML!TypedLiteral))->asSequence()->first().type.name,
		lexicalForm <- i.dataArguments->select(c | c.oclIsTypeOf(R2ML!TypedLiteral))->asSequence()->first().lexicalValue
		)
}

-- Rule 'UniversallyQuantifiedFormulaData2AllValuesFromRestriction'
-- Creates AllValuesFromRestriction RDM element from R2ML UniversallyQuantifiedFormula element,
-- which have Implication as its formula and AttributionAtom as antecedent.
rule UniversallyQuantifiedFormulaData2AllValuesFromRestriction {
	from i : R2ML!UniversallyQuantifiedFormula (
		thisModule.getTopMostUniversallyQuantifiedFormulas()->excludes(i) and
		thisModule.getChildrenOfAllTopMostImplications()->excludes(i) and
		if i.formula.oclIsTypeOf(R2ML!Implication) then
			if i.formula.antecedent.oclIsTypeOf(R2ML!AttributionAtom) then
			true
			else false
			endif
		else false
		endif
		)
	to o : RDM!AllValuesFromRestriction (
		allValuesFromRange <- i.formula.consequent,
		onProperty <- thisModule.Attribute2DatatypeProperty(i.formula.antecedent.attribute)
		)
}

-- Rule 'UniversallyQuantifiedFormulaData2AllValuesFromRestriction'
-- Creates RDM Atom with AllValuesFromRestriction as predicate symbol from 
-- R2ML UniversallyQuantifiedFormula element, which have Implication as its 
-- formula and AttributionAtom as antecedent.
rule UniversallyQuantifiedFormulaData2DataRangeAtomAllValuesFromRestriction {
	from i : R2ML!UniversallyQuantifiedFormula (
		thisModule.getTopMostUniversallyQuantifiedFormulas()->excludes(i) and
		thisModule.getChildrenOfAllTopMostImplications()->includes(i) and
		if i.formula.oclIsTypeOf(R2ML!Implication) then
			if i.formula.antecedent.oclIsTypeOf(R2ML!AttributionAtom) then
			true
			else false
			endif
		else false
		endif
		)
	to dra : RDM!Atom (
		name <- 'DataRangeAtom',
		hasPredicateSymbol <- alr,
		terms <- thisModule.DataVariable2IndividualVariable(i.formula.antecedent.getTerm)
		),
	alr : RDM!AllValuesFromRestriction (
		allValuesFromRange <- i.formula.consequent,
		onProperty <- thisModule.Attribute2DatatypeProperty(i.formula.antecedent.attribute)
		)
}

-- Rule 'ExistentiallyQuantifiedFormulaData2SomeValuesFromRestriction'
-- Creates SomeValuesFromRestriction RDM element from R2ML ExistentiallyQuantifiedFormula element,
-- which have AttributionAtom as formulas.
rule ExistentiallyQuantifiedFormulaData2SomeValuesFromRestriction {
	from i : R2ML!ExistentiallyQuantifiedFormula (
		thisModule.getChildrenOfAllTopMostImplications()->excludes(i) and
		if i.formula.oclIsTypeOf(R2ML!Conjuction) then
			if i.formula.formulas->select(e | e.oclIsTypeOf(R2ML!AttributionAtom))->size() > 0 then
			true
			else false
			endif
		else false
		endif
		)
	to o : RDM!SomeValuesFromRestriction (
		someValuesFromRange <- i.formula.formulas->select(c | not c.oclIsTypeOf(R2ML!AttributionAtom))->first(),
		onProperty <- thisModule.Attribute2DatatypeProperty(i.formula.formulas->select(c | c.oclIsTypeOf(R2ML!AttributionAtom))->first().attribute)
		)
}

-- Rule 'ExistentiallyQuantifiedFormulaData2DataRangeAtomSomeValuesFromRestriction'
-- Creates RDM Atom with SomeValuesFromRestriction as predicate symbol from 
-- R2ML ExistentiallyQuantifiedFormula element, which have AttributionAtom as formulas.
rule ExistentiallyQuantifiedFormulaData2DataRangeAtomSomeValuesFromRestriction {
	from i : R2ML!ExistentiallyQuantifiedFormula (
		thisModule.getChildrenOfAllTopMostImplications()->includes(i) and
		if i.formula.oclIsTypeOf(R2ML!Conjuction) then
			if i.formula.formulas->select(e | e.oclIsTypeOf(R2ML!AttributionAtom))->size() > 0 then
			true
			else false
			endif
		else false
		endif
		)
	to dra : RDM!Atom (
		name <- 'DataRangeAtom',
		hasPredicateSymbol <- smr,
		terms <- thisModule.DataVariable2IndividualVariable(i.formula.antecedent.getTerm)
		),
	smr : RDM!SomeValuesFromRestriction (
		someValuesFromRange <- i.formula.formulas->select(c | not c.oclIsTypeOf(R2ML!AttributionAtom))->first(),
		onProperty <- thisModule.Attribute2DatatypeProperty(i.formula.formulas->select(c | c.oclIsTypeOf(R2ML!AttributionAtom))->first().attribute)
		)
}

-- Rule 'Attribute2DatatypeProperty'
-- Lazy rule which creates RDM DatatypeProperty from R2ML Attribute.
unique lazy rule Attribute2DatatypeProperty {
	from i : R2ML!Attribute
	to o : RDM!DatatypeProperty (
			name <- i.name
		)
}

-- Rule 'TypedLiteral2DataValue'
-- Lazy rule which creates RDM DataValue from R2ML TypedLiteral.
unique lazy rule TypedLiteral2DataValue {
	from i : R2ML!TypedLiteral
	to o : RDM!DataValue(
			value <- i.lexicalValue,
			type <- i.type
		)
}

-- Rule 'AttributeAtomData2DataValuedPropertyAtom'
-- Creates RDM Atom from R2ML AttributionAtom, which is children of
-- top most Implication.
rule AttributeAtomData2DataValuedPropertyAtom {
	from i : R2ML!AttributionAtom (
		thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o : RDM!Atom (
		name <- 'DataValuedPropertyAtom',
		hasPredicateSymbol <- thisModule.Attribute2DatatypeProperty(i.attribute),
		terms <- if i.dataValue.oclIsTypeOf(R2ML!TypedLiteral) then
					Sequence { thisModule.TypedLiteral2DataValue(i.dataValue),
							   thisModule.ObjectVariable2IndividualVariable(i.subject)
							 }
				 else
					Sequence { thisModule.DataVariable2DataVariable(i.dataValue),
				 			   thisModule.ObjectVariable2IndividualVariable(i.subject)
				 			 }
				 endif
		)
}

-- Rule 'AttributionAtomData2HasValueRestriction'
-- Creates RDM HasValueRestriction from R2ML AttributionAtom, which is not children of
-- top most Implications.
rule AttributionAtomData2HasValueRestriction {
	from i : R2ML!AttributionAtom (
		not thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o :  RDM!HasValueRestriction (
			hasLiteralValue <- i.dataValue,
			onProperty <- thisModule.Attribute2DatatypeProperty(i.attribute)
		)
}

-- Rule 'DataVariable2DataVariable'
-- Lazy rule which creates RDM DataVariable from R2ML DataVariable.
unique lazy rule DataVariable2DataVariable {
	from i : R2ML!DataVariable
	to o : RDM!DataVariable (
			name <- i.name
		)		
}

-- Rule 'EqualityAtom2SameIndividualAtom'
-- Creates RDM Atom from R2ML EqualityAtom, which is not
-- children (formulas) of Disjunction.
rule EqualityAtom2SameIndividualAtom {
	from i : R2ML!EqualityAtom (
		R2ML!Disjunction.allInstancesFrom('IN')->asSequence()->collect(e | e.formulas)->flatten()->excludes(i)
		)
	to o : RDM!Atom (
		name <- 'SameIndividualAtom',
		hasPredicateSymbol <- same,
		terms <- i.terms->select(e | e.oclIsTypeOf(R2ML!ObjectVariable))->collect(c | thisModule.ObjectVariable2IndividualVariable(c))			
		),
		same : RDM!SameAs
}

-- Rule 'InequalityAtom2DifferentIndividualAtom'
-- Creates RDM Atom from R2ML InequalityAtom.
rule InequalityAtom2DifferentIndividualAtom {
	from i : R2ML!InequalityAtom (
		i.oclIsTypeOf(R2ML!InequalityAtom)
		)
	to o : RDM!Atom (
		name <- 'DifferentIndividualAtom',
		hasPredicateSymbol <- different,
		terms <- i.terms->select(e | e.oclIsTypeOf(R2ML!ObjectVariable))->collect(c | thisModule.ObjectVariable2IndividualVariable(c))			
		),
		different : RDM!DifferentFrom
}

-- Rule 'DatatypePredicateAtom2BulitinAtom'
-- Creates RDM Atom from R2ML DatatypePredicateAtom, which is not
-- formula of some Disjunction.
rule DatatypePredicateAtom2BulitinAtom {
	from i : R2ML!DatatypePredicateAtom (
		R2ML!Disjunction.allInstancesFrom('IN')->asSequence()->collect(e | e.formulas)->flatten()->excludes(i) and
		i.dataArguments->select(c | c.oclIsTypeOf(R2ML!AttributeFunctionTerm))->size() = 0 and
		i.dataArguments->select(c | c.oclIsTypeOf(R2ML!DataOperationTerm))->size() = 0
		)
	to o : RDM!Atom (
		name <- 'BulitinAtom',
		hasPredicateSymbol <- thisModule.DatatypePredicate2BuiltIn(i.predicate),
		terms <-  Sequence { i.dataArguments->select(e | e.oclIsKindOf(R2ML!DataVariable))->collect(c | thisModule.DataVariable2DataVariable(c)),
							 i.dataArguments->select(e | e.oclIsKindOf(R2ML!TypedLiteral))->collect(c | thisModule.TypedLiteral2DataValue(c))							
						    }
		)
}

-- Rule 'DatatypePredicate2BuiltIn'
-- Lazy rule which creates RDM BuiltIn from R2ML DatatypePredicate.
unique lazy rule DatatypePredicate2BuiltIn {
	from i : R2ML!DatatypePredicate 
	to o : RDM!BuiltIn (
		buildInID <- i.name
		)
}

-----------------------------------------------------------------------------------------------------------
-- Rules for transforming R2ML elements which are transformed from the OCL metamodel
-----------------------------------------------------------------------------------------------------------

-- Rule 'ObjectVariable2ClassAtom'
-- Creates RDM ClassAtom from R2ML ObjectVariable.
rule ObjectVariable2ClassAtom {
	from i : R2ML!ObjectVariable (
		R2ML!AttributeFunctionTerm.allInstancesFrom('IN')->collect(c | c.contextArgument)->flatten()->includes(i) or
		R2ML!ReferencePropertyFunctionTerm.allInstancesFrom('IN')->collect(c | c.contextArgument)->flatten()->includes(i) or
		R2ML!DataOperationTerm.allInstancesFrom('IN')->collect(c | c.contextArgument)->flatten()->includes(i)
	)
	to o : RDM!Atom (
		name <- 'ClassAtom',
		hasPredicateSymbol <- thisModule.Class2Class(i.classRef),
		terms <- thisModule.ObjectVariable2IndividualVariable(i)
		)
}

-- Rule 'AttributeFunctionTerm2IndividualPropertyAtom'
-- Creates RDM IndividualPropertyAtom from R2ML AttributeFunctionTerm.
rule AttributeFunctionTerm2IndividualPropertyAtom {
	from i : R2ML!AttributeFunctionTerm (
		i.oclIsTypeOf(R2ML!AttributeFunctionTerm)
	)
	to o : RDM!Atom (
		name <- 'IndividualPropertyAtom',
		hasPredicateSymbol <- thisModule.Attribute2ObjectProperty(i.attribute),
		terms <- Sequence { if i.contextArgument.oclIsTypeOf(R2ML!ObjectVariable) then
					               			thisModule.ObjectVariable2IndividualVariable(i.contextArgument)
			  				             else thisModule.ReferencePropertyFunctionTerm2IndividualVariable(i.contextArgument)
				            			 endif,
						    			 thisModule.AttributeFunctionTerm2IndividualVariable(i)
				}
		)
}

-- Rule 'DatatypePredicateAtomWithAttributeFuncTerm2BuiltinAtom'
-- Creates RDM BulitinAtom from R2ML DatatypePredicateAtom.
rule DatatypePredicateAtomWithAttributeFuncTerm2BuiltinAtom {
	from i : R2ML!DatatypePredicateAtom (
		i.dataArguments->select(c | c.oclIsTypeOf(R2ML!AttributeFunctionTerm))->size() = 1 or
		i.dataArguments->select(c | c.oclIsTypeOf(R2ML!DataOperationTerm))->size() = 1
	)
	to o :  RDM!Atom (
		name <- 'BulitinAtom',
		hasPredicateSymbol <- thisModule.DatatypePredicate2BuiltIn(i.predicate),
		terms <-  Sequence {
					i.dataArguments->select(e | e.oclIsKindOf(R2ML!AttributeFunctionTerm))->asSequence()->collect(c | thisModule.AttributeFunctionTerm2IndividualVariable(c)),
					i.dataArguments->select(e | e.oclIsKindOf(R2ML!DataOperationTerm))->asSequence()->collect(c | thisModule.DataOperationTerm2IndividualVariable(c)),
				 	i.dataArguments->select(e | e.oclIsKindOf(R2ML!TypedLiteral))->collect(c | thisModule.TypedLiteral2DataValue(c))							
				  }
		)
}

-- Rule 'ReferencePropertyFunctionTerm2IndividualPropertyAtom'
-- Creates RDM IndividualPropertyAtom from R2ML ReferencePropertyFunctionTerm.
rule ReferencePropertyFunctionTerm2IndividualPropertyAtom {
	from i : R2ML!ReferencePropertyFunctionTerm (
		i.oclIsTypeOf(R2ML!ReferencePropertyFunctionTerm)
	)
	to o : RDM!Atom (
		name <- 'IndividualPropertyAtom',
		hasPredicateSymbol <- thisModule.ReferenceProperty2ObjectProperty(i.referencePropertyRef),
		terms <- Sequence {
							if i.contextArgument.oclIsTypeOf(R2ML!ObjectVariable) then
								thisModule.ObjectVariable2IndividualVariable(i.contextArgument)
							else thisModule.ReferencePropertyFunctionTerm2IndividualVariable(i.contextVariable)
							endif,
						    thisModule.ReferencePropertyFunctionTerm2IndividualVariable(i)
				}
		)
}

-- Rule 'DataOperationTerm2IndividualPropertyAtom'
-- Creates RDM IndividualPropertyAtom from R2ML DataOperationTerm.
rule DataOperationTerm2IndividualPropertyAtom {
	from i : R2ML!DataOperationTerm (
		i.oclIsTypeOf(R2ML!DataOperationTerm)
	)
	to o : RDM!Atom (
		name <- 'IndividualPropertyAtom',
		hasPredicateSymbol <- thisModule.DataOperation2ObjectProperty(i.dataOperationRef),
		terms <- Sequence {
							thisModule.ObjectVariable2IndividualVariable(i.contextArgument),
						    thisModule.DataOperationTerm2IndividualVariable(i)
				}
		)
}

-- Rule 'ReferencePropertyAtom2IndividualPropertyAtoms'
-- Creates RDM IndividualPropertyAtom from R2ML ReferencePropertyAtom.
rule ReferencePropertyAtom2IndividualPropertyAtoms {
	from i : R2ML!ReferencePropertyAtom (
		not i.isRefPropAtomForHasValue and not i.areAllObjectVariables()
		)
	to o : RDM!Atom (
		name <- 'IndividualPropertyAtom',
		hasPredicateSymbol <- thisModule.ReferenceProperty2ObjectProperty(i.referenceProperty),
		terms <- Sequence { if i.subject.oclIsTypeOf(R2ML!ObjectVariable) then
					               				thisModule.ObjectVariable2IndividualVariable(i.subject)
			 				             else thisModule.ReferencePropertyFunctionTerm2IndividualVariable(i.subject)
				            			 endif,
										 if i.object.oclIsTypeOf(R2ML!ObjectVariable) then
					               			    thisModule.ObjectVariable2IndividualVariable(i.object)
				            			else thisModule.ReferencePropertyFunctionTerm2IndividualVariable(i.object)
				            			endif
						}
		)
}

-- Rule 'DataOperation2ObjectProperty'
-- Lazy rule which creates RDM ObjectProperty from R2ML DataOperation.
unique lazy rule DataOperation2ObjectProperty {
	from i : R2ML!DataOperation
	to o : RDM!ObjectProperty (
			name <- i.name
		)
}

-- Rule 'Attribute2ObjectProperty'
-- Lazy rule which creates RDM ObjectProperty from R2ML Attribute.
unique lazy rule Attribute2ObjectProperty {
	from i : R2ML!Attribute
	to o : RDM!ObjectProperty (
			name <- i.name
		)
}

-- Rule 'ReferencePropertyFunctionTerm2IndividualVariable'
-- Lazy rule which creates RDM IndividualVariable from R2ML ReferencePropertyFunctionTerm.
unique lazy rule ReferencePropertyFunctionTerm2IndividualVariable {
	from i : R2ML!ReferencePropertyFunctionTerm
	to o : RDM!IndividualVariable (
			name <- if i.contextArgument.oclIsTypeOf(R2ML!ObjectVariable) then
								i.contextArgument.name + i.referencePropertyRef.name.firstCharToUpper()
								-- In case of ReferencePropertyFunctionTerm as contextArgument
						  else i.contextArgument.getVariableName() + i.attribute.name.firstCharToUpper()
					      endif
		)
}

-- Rule 'DataOperationTerm2IndividualVariable'
-- Lazy rule which creates RDM IndividualVariable from R2ML DataOperationTerm.
unique lazy rule DataOperationTerm2IndividualVariable {
	from i : R2ML!DataOperationTerm
	to o : RDM!IndividualVariable (
			name <- if i.contextArgument.oclIsTypeOf(R2ML!ObjectVariable) then
								i.contextArgument.name + i.dataOperationRef.name.firstCharToUpper()
					      else 'Unknow'
					      endif
		)
}

-- Rule 'AttributeFunctionTerm2IndividualVariable'
-- Lazy rule which creates RDM IndividualVariable from R2ML AttributeFunctionTerm.
unique lazy rule AttributeFunctionTerm2IndividualVariable {
	from i : R2ML!AttributeFunctionTerm
	to o : RDM!IndividualVariable (
			name <- if i.contextArgument.oclIsTypeOf(R2ML!ObjectVariable) then 
								i.contextArgument.name + i.attribute.name.firstCharToUpper()
							   -- In case of ReferencePropertyFunctionTerm
						  else i.contextArgument.getVariableName() + i.attribute.name.firstCharToUpper()
					      endif
	)
}",atlcompil atl transform r ml metamodel rdm metamodel creat part m sc these good old ai laboratori author milan milanov milan milanov org work r ml v integr deriv rule licenc gnu general public licens version modul r ml rdm modul templat creat out rdm in r ml use string helper helper firstchartoupp convert first charact string upper return complet string context string out string helper context string def firstchartoupp string let firstchar string self substr firstchar toupper self substr self size helper toboolean convert string valu boolean valu context string in string out boolean helper context string def toboolean boolean self true true els fals endif helper getterm return object term variabl current element context r ml objectclassificationatom out r ml objectvari helper context r ml objectclassificationatom def getterm r ml objectvari self term helper getterm return object term variabl current element context rdm disjunct out r ml objectvari helper context r ml disjunct def getterm r ml objectvari self formula assequ first getterm helper getterm return object term variabl current element context rdm conjuct out r ml objectvari helper context r ml conjuct def getterm r ml objectvari self formula assequ first getterm helper getterm return object term variabl current element context r ml universallyquantifiedformula out r ml objectvari helper context r ml universallyquantifiedformula def getterm r ml objectvari self formula getterm helper getterm return object term variabl current element context r ml existentiallyquantifiedformula out r ml objectvari helper context r ml existentiallyquantifiedformula def getterm r ml objectvari self formula getterm helper getterm return object term variabl current element context r ml referencepropertyatom out r ml objectvari helper context r ml referencepropertyatom def getterm r ml objectvari self subject helper getterm return object term variabl current element context r ml atmostquantifiedformula out r ml objectvari helper context r ml atmostquantifiedformula def getterm r ml objectvari self formula getterm helper getterm return object term variabl current element context r ml atleastquantifiedformula out r ml objectvari helper context r ml atleastquantifiedformula def getterm r ml objectvari self formula getterm helper getterm return object term variabl current element context r ml atleastandatmostquantifiedformula out r ml objectvari helper context r ml atleastandatmostquantifiedformula def getterm r ml objectvari self formula getterm helper getterm return object term variabl current element context r ml equalityatom out r ml objectvari helper context r ml equalityatom def getterm r ml objectvari self term select e e oclistypeof r ml objectvari first helper getterm return object term variabl current element context r ml datatypepredicateatom out r ml datavari helper context r ml datatypepredicateatom def getterm r ml datavari self dataargu select c c oclistypeof r ml datavari first helper getterm return object term variabl current element context r ml attributionatom out r ml datavari helper context r ml attributionatom def getterm r ml variabl self datavalu oclistypeof r ml datavari todo check self datavalu els self subject endif helper getchildren return children context implic anteced consequ context r ml implic out sequenc r ml logicalformula helper context r ml implic def getchildren sequenc r ml logicalformula self getanteced assequ union self getconsequ assequ helper getanteced return anteced children context implic context r ml implic out sequenc r ml logicalformula helper context r ml implic def getanteced sequenc r ml logicalformula self anteced oclistypeof r ml conjuct self anteced isconjuctionfromintersect sequenc self anteced els self anteced formula endif els sequenc self anteced endif helper getconsequ return consequ children context implic context r ml implic out sequenc r ml logicalformula helper context r ml implic def getconsequ sequenc r ml logicalformula self consequ oclistypeof r ml conjuct self consequ isconjuctionfromintersect sequenc self consequ els self consequ formula endif els sequenc self consequ endif helper getchildrenofalltopmostimpl return children element anteced consequ topmost implic rule out sequenc r ml logicalformula helper def getchildrenofalltopmostimpl sequenc r ml logicalformula let allimp sequenc r ml implic thismodul gettopmostuniversallyquantifiedformula collect c c formula flatten allimp collect c c getchildren flatten helper isconjuctionfromintersect implement algorithm check contextu conjuct come rdm intersect conjuct transform this import implic rdm rule containt anteced consequ conjuct multipl atom intersect context r ml conjuct out boolean helper context r ml conjuct def isconjuctionfromintersect boolean r ml existentiallyquantifiedformula allinstancesfrom in assequ collect c c formula flatten exclud self self formula size self formula assequ first getterm self formula assequ last getterm self formula select c c oclistypeof r ml disjunct collect e e formula flatten foral c c oclistypeof r ml equalityatom self formula select c c oclistypeof r ml universallyquantifiedformula collect e e formula flatten foral c c oclistypeof r ml implic self formula select c c oclistypeof r ml existentiallyquantifiedformula collect e e formula flatten foral c c oclistypeof r ml conjuct self formula select c c oclistypeof r ml atleastquantifiedformula collect e e formula flatten foral c c oclistypeof r ml referencepropertyatom self formula select c c oclistypeof r ml atmostquantifiedformula collect e e formula flatten foral c c oclistypeof r ml referencepropertyatom self formula select c c oclistypeof r ml atleastandatmostquantifiedformula collect e e formula flatten foral c c oclistypeof r ml referencepropertyatom self formula select c c oclistypeof r ml attributionatom size self formula select c c oclistypeof r ml datatypepredicateatom size self formula collect c c oclistypeof r ml referencepropertyatom flatten size true els fals endif helper gettopmostuniversallyquantifiedformula return top universallyquantifiedformula out sequenc r ml universallyquantifiedformula helper def gettopmostuniversallyquantifiedformula sequenc r ml universallyquantifiedformula r ml alethicintegrityrul allinstancesfrom in assequ collect c c constraint flatten helper isrefpropatomforhasvalu implement algorithm check contextu referencepropertyatom candid rdm hasvaluerestrict context r ml referencepropertyatom out boolean helper context r ml referencepropertyatom def isrefpropatomforhasvalu boolean thismodul getchildrenofalltopmostimpl exclud self r ml universallyquantifiedformula allinstancesfrom in assequ exclud thismodul gettopmostuniversallyquantifiedformula select e e formula oclistypeof r ml implic collect c c formula flatten collect c c anteced flatten exclud self r ml existentiallyquantifiedformula allinstancesfrom in assequ select e e formula oclistypeof r ml conjuct collect c c formula formula assequ flatten exclud self r ml atmostquantifiedformula allinstancesfrom in assequ collect c c formula flatten exclud self r ml atleastquantifiedformula allinstancesfrom in assequ collect c c formula flatten exclud self r ml atleastandatmostquantifiedformula allinstancesfrom in assequ collect c c formula flatten exclud self helper transform r ml element transform ocl metamodel helper getdatatypepredicateatomswithsubelem return datatyp predic atom subelem contextu logic formula context r ml logicalformula out sequenc oclani helper context r ml logicalformula def getdatatypepredicateatomswithsubelem sequenc oclani self oclistypeof r ml conjuct self formula select c c oclistypeof r ml datatypepredicateatom assequ collect c c getelementwithsubelem flatten assequ els self oclistypeof r ml datatypepredicateatom self getelementwithsubelem els oclundefin endif endif helper getreferencepropertyatomswithtermswithsubelem return refer properti atom term contextu logic formula context r ml logicalformula out sequenc oclani helper context r ml logicalformula def getreferencepropertyatomswithtermswithsubelem sequenc oclani self oclistypeof r ml conjuct sequenc self formula select c c oclistypeof r ml referencepropertyatom select c c subject oclistypeof r ml objectvari c object oclistypeof r ml objectvari assequ collect c c getelementwithsubelem flatten assequ self formula select c c oclistypeof r ml referencepropertyatom select c c subject oclistypeof r ml objectvari c object oclistypeof r ml objectvari flatten assequ get basic referencepropertyatom els self subject oclistypeof r ml objectvari self object oclistypeof r ml objectvari self getelementwithsubelem flatten assequ els self endif endif helper areallobjectvari return object variabl r ml referencepropertyatom subject object context r ml referencepropertyatom out boolean helper context r ml referencepropertyatom def areallobjectvari boolean self subject oclistypeof r ml objectvari self object oclistypeof r ml objectvari true els fals endif els fals endif helper getelementwithsubelem return contextu referencepropertyatom sub element context r ml referencepropertyatom out sequenc oclani helper context r ml referencepropertyatom def getelementwithsubelem sequenc oclani sequenc self subject oclistypeof r ml objectvari self subject getelementwithsubelem flatten assequ els oclundefin endif self object oclistypeof r ml objectvari self object getelementwithsubelem flatten assequ els oclundefin endif flatten assequ append self helper getelementwithsubelem return contextu datatypepredicateatom sub element context r ml datatypepredicateatom out sequenc oclani helper context r ml datatypepredicateatom def getelementwithsubelem sequenc oclani self dataargu select c c ocliskindof r ml dataliter assequ collect c c getelementwithsubelem flatten assequ append self helper getelementwithsubelem return contextu attributefunctionterm sub element context r ml attributefunctionterm out sequenc oclani helper context r ml attributefunctionterm def getelementwithsubelem sequenc oclani sequenc self contextargu getelementwithsubelem flatten append self helper getelementwithsubelem return contextu referencepropertyfunctionterm sub element context r ml referencepropertyfunctionterm out sequenc oclani helper context r ml referencepropertyfunctionterm def getelementwithsubelem sequenc oclani sequenc self contextargu getelementwithsubelem flatten append self helper getelementwithsubelem return contextu dataoperationterm sub element context r ml dataoperationterm out sequenc oclani helper context r ml dataoperationterm def getelementwithsubelem sequenc oclani sequenc self contextargu getelementwithsubelem flatten append self helper getelementwithsubelem return contextu objectvari sub element context r ml objectvari out sequenc oclani helper context r ml objectvari def getelementwithsubelem sequenc oclani sequenc self helper getvariablenam return referencepropertyfunctionterm contextargu name e variabl referencepropertyref name context r ml referencepropertyfunctionterm out string helper context r ml referencepropertyfunctionterm def getvariablenam string self contextargu name self referencepropertyref name firstchartoupp rule rule implic rule creat rdm rule element r ml implic element rule implic rule r ml implic thismodul gettopmostuniversallyquantifiedformula collect c c formula flatten includ rdm rule hasanteced ant hasconsequ con ant rdm anteced containsatom anteced oclistypeof r ml conjuct anteced isconjuctionfromintersect anteced els sequenc anteced formula select c c oclistypeof r ml datatypepredicateatom c oclistypeof r ml referencepropertyatom assequ anteced getdatatypepredicateatomswithsubelem anteced getreferencepropertyatomswithtermswithsubelem endif els anteced oclistypeof r ml datatypepredicateatom anteced getdatatypepredicateatomswithsubelem els anteced oclistypeof r ml referencepropertyatom anteced getelementwithsubelem check intersect element type term els anteced oclistypeof r ml disjunct anteced getterm oclistypeof r ml objectvari anteced getterm classref oclisundefin creat intersect type thismodul logicalformula intersect anteced els anteced endif els anteced endif els anteced endif endif endif endif con rdm consequ containsatom consequ oclistypeof r ml conjuct consequ isconjuctionfromintersect consequ els sequenc consequ formula select c c oclistypeof r ml datatypeprediacateatom c oclistypeof r ml referencepropertyatom assequ consequ getdatatypepredicateatomswithsubelem consequ getreferencepropertyatomswithtermswithsubelem endif els consequ oclistypeof r ml datatypepredicateatom consequ getdatatypepredicateatomswithsubelem els consequ oclistypeof r ml referencepropertyatom consequ getelementwithsubelem check intersect element type term els consequ oclistypeof r ml disjunct consequ getterm oclistypeof r ml objectvari consequ getterm classref oclisundefin creat intersect type thismodul logicalformula intersect consequ els consequ endif els consequ endif els consequ endif endif endif endif lazi rule logicalformula intersect creat intersectionclass rdm element logicalformula r ml element uniqu lazi rule logicalformula intersect r ml logicalformula rdm atom name classatom haspredicatesymbol intcla term thismodul objectvari individualvari getterm intcla rdm intersectionclass intersectionof sequenc thismodul class class getterm classref individualpropertyatom rule referencepropertyatom individualpropertyatom creat atom rdm element individualpropertyatom referencepropertyatom r ml element rule referencepropertyatom individualpropertyatom r ml referencepropertyatom isrefpropatomforhasvalu areallobjectvari rdm atom name individualpropertyatom haspredicatesymbol thismodul referenceproperti objectproperti referenceproperti term sequenc thismodul objectvari individualvari object thismodul objectvari individualvari subject rule referenceproperti objectproperti transform r ml referenceproperti element rdm objectproperti element uniqu lazi rule referenceproperti objectproperti r ml referenceproperti rdm objectproperti name name rule referenceproperti datatypeproperti transform r ml referenceproperti element rdm datatypeproperti element uniqu lazi rule referenceproperti datatypeproperti r ml referenceproperti rdm datatypeproperti name name rule objectvari individualvari creat rdm individualvari r ml objectvari uniqu lazi rule objectvari individualvari r ml objectvari rdm individualvari name name classref classref oclisundefin thismodul class class classref els oclundefin endif rule datavari individualvari creat rdm individualvari r ml datavari uniqu lazi rule datavari individualvari r ml datavari rdm individualvari name name classatom rule conjuct classatom creat rdm classatom intersect predic symbol r ml conjuct rule conjuct classatom r ml conjuct isconjuctionfromintersect becaus defin type intersect formula assequ first getterm oclistypeof r ml objectvari formula assequ first getterm classref oclisundefin fals els true endif els true endif rdm atom name classatom haspredicatesymbol intcla term thismodul objectvari individualvari formula assequ first getterm intcla rdm intersectionclass intersectionof sequenc formula assequ select c c oclistypeof r ml objectclassificationatom collect e thismodul class class e type formula assequ select c c oclistypeof r ml objectclassificationatom rule disjunctionatom union creat rdm classatom unionclass predic symbol r ml disjunct equalityatom datatypepredicateatom formula children top implic rule disjunctionatom union r ml disjunct r ml conjuct allinstancesfrom in assequ select c c isconjuctionfromintersect collect e e formula flatten exclud r ml disjunct allinstancesfrom in assequ select e e formula assequ first oclistypeof r ml equalityatom e formula assequ first oclistypeof r ml datatypepredicateatom exclud thismodul getchildrenofalltopmostimpl includ formula assequ first getterm oclistypeof r ml objectvari formula assequ first getterm classref oclisundefin fals els true endif els true endif rdm atom name classatom haspredicatesymbol unicla term thismodul objectvari individualvari formula assequ first getterm unicla rdm unionclass unionof sequenc formula assequ select c c oclistypeof r ml objectclassificationatom collect e thismodul class class e type formula assequ select c c oclistypeof r ml objectclassificationatom rule disjunct union creat unionclass predicat ml disjunct equalityatom datatypepredicateatom formula children top implic rule disjunct union r ml disjunct r ml conjuct allinstancesfrom in assequ select c c isconjuctionfromintersect collect e e formula flatten exclud r ml disjunct allinstancesfrom in assequ select e e formula assequ first oclistypeof r ml equalityatom e formula assequ first oclistypeof r ml datatypepredicateatom exclud thismodul getchildrenofalltopmostimpl exclud becaus defin type intersect formula assequ first getterm oclistypeof r ml objectvari formula assequ first getterm classref oclisundefin true els fals endif els true endif unicla rdm unionclass unionof sequenc formula assequ select c c oclistypeof r ml objectclassificationatom collect e thismodul class class e type formula assequ select c c oclistypeof r ml objectclassificationatom rule negationatom complement creat rdm classatom complementclass predic symbol r ml negationasfailur rule negationatom complement r ml strongneg oclistypeof r ml strongneg thismodul getchildrenofalltopmostimpl includ rdm atom name classatom haspredicatesymbol comcla term thismodul objectvari individualvari formula getterm comcla rdm complementclass complementof formula oclistypeof r ml objectclassificationatom thismodul class class formula type els formula endif rule negat complement creat rdm classatom complementclass predic symbol r ml negationasfailur rule negat complement r ml strongneg oclistypeof r ml strongneg thismodul getchildrenofalltopmostimpl exclud comcla rdm complementclass complementof formula oclistypeof r ml objectclassificationatom thismodul class class formula type els formula endif rule disjunct enumeratedclass creat enumeratedclass r ml disjunct rule disjunctionfromintersect enumeratedclass r ml disjunct r ml conjuct allinstancesfrom in assequ select c c isconjuctionfromintersect collect e e formula flatten includ formula select e e oclistypeof r ml equalityatom size enumclass rdm enumeratedclass oneof formula assequ collect c c term flatten select c c oclistypeof r ml objectnam assequ rule disjunctionfromatom enumeratedclass creat rdm classatom enumeratedclass predic symbol r ml disjunct rule disjunctionfromatom enumeratedclass r ml disjunct r ml conjuct allinstancesfrom in assequ select c c isconjuctionfromintersect collect e e formula flatten exclud formula select e e oclistypeof r ml equalityatom size rdm atom name classatom haspredicatesymbol enumclass term thismodul objectvari individualvari formula assequ first getterm enumclass rdm enumeratedclass oneof formula collect e e term flatten select c c oclistypeof r ml objectnam rule objectnam individu creat rdm individu r ml objectnam rule objectnam individu r ml objectnam r ml equalityatom allinstancesfrom in assequ collect c c term flatten select e e oclistypeof r ml objectnam includ rdm individu name name rule objectclassificationatom classatom creat classatom rdm element r ml objectclassificationatom element rule objectclassificationatom classatom r ml objectclassificationatom thismodul getchildrenofalltopmostimpl includ r ml conjuct allinstancesfrom in assequ select e e isconjuctionfromintersect collect e e formula flatten exclud isneg fals rdm atom name classatom haspredicatesymbol thismodul class class type term thismodul objectvari individualvari term rule objectclassificationatom creat classatom rdm element r ml objectclassificationatom element negat rule objectclassificationatomneg complementclassatom r ml objectclassificationatom thismodul getchildrenofalltopmostimpl includ r ml conjuct allinstancesfrom in assequ select e e isconjuctionfromintersect collect e e formula flatten exclud isneg true rdm atom name classatom haspredicatesymbol cla term thismodul objectvari individualvari term cla rdm class subclassof sequenc cs cs rdm complementclass complementof thismodul class class type rule class class creat rdm class r ml class element uniqu lazi rule class class r ml class cla rdm class name name rule existentiallyquantifiedformulaclass somevaluesfromrestrict creat somevaluesfromrestrict rdm element r ml existentiallyquantifiedformula element referencepropertyatom formula rule existentiallyquantifiedformulaclass somevaluesfromrestrict r ml existentiallyquantifiedformula thismodul getchildrenofalltopmostimpl exclud formula formula select c c oclistypeof r ml referencepropertyatom size rdm somevaluesfromrestrict somevaluesfromclass sequenc formula formula select c c oclistypeof r ml objectclassificationatom collect c thismodul class class c type first formula formula select c c oclistypeof r ml referencepropertyatom c oclistypeof r ml objectclassificationatom first select c c oclisundefin assequ first onproperti thismodul referenceproperti objectproperti formula formula select c c oclistypeof r ml referencepropertyatom first referenceproperti rule existentiallyquantifiedformulaclass classatomsomevaluesfromrestrict creat rdm atom somevaluesfromrestrict predic symbol r ml existentiallyquantifiedformula element referencepropertyatom formula rule existentiallyquantifiedformulaclass classatomsomevaluesfromrestrict r ml existentiallyquantifiedformula thismodul getchildrenofalltopmostimpl includ formula formula select c c oclistypeof r ml referencepropertyatom size rdm atom name classatom haspredicatesymbol svf term thismodul objectvari individualvari formula formula select c c oclistypeof r ml referencepropertyatom first getterm svf rdm somevaluesfromrestrict somevaluesfromclass sequenc formula formula select c c oclistypeof r ml objectclassificationatom collect c thismodul class class c type first formula formula select c c oclistypeof r ml referencepropertyatom c oclistypeof r ml objectclassificationatom first select c c oclisundefin assequ first onproperti thismodul referenceproperti objectproperti formula formula select c c oclistypeof r ml referencepropertyatom first referenceproperti rule universallyquantifiedformulaclass allvaluesfromrestrict creat allvaluesfromrestrict rdm element r ml universallyquantifiedformula element implic formula referencepropertyatom anteced rule universallyquantifiedformulaclass allvaluesfromrestrict r ml universallyquantifiedformula thismodul gettopmostuniversallyquantifiedformula exclud formula oclistypeof r ml implic formula anteced oclistypeof r ml referencepropertyatom true els fals endif els fals endif rdm allvaluesfromrestrict allvaluesfromclass formula consequ oclistypeof r ml objectclassificationatom thismodul class class formula consequ els formula consequ endif onproperti thismodul referenceproperti objectproperti formula anteced referenceproperti rule referencepropertyatomclass hasvalu creat hasvaluerestrict rdm element r ml referencepropertyatom referencepropertyatom type restrict use helper isrefpropatomforhasvalu check rule referencepropertyatomclass hasvalu r ml referencepropertyatom isrefpropatomforhasvalu thismodul getchildrenofalltopmostimpl exclud rdm hasvaluerestrict hasvalu thismodul objectvari individu object onproperti thismodul referenceproperti objectproperti referenceproperti rule referencepropertyatomclass classatomhasvalu creat rdm atom hasvaluerestrict predic symbol r ml referencepropertyatom referencepropertyatom type restrict use helper isrefpropatomforhasvalu check rule referencepropertyatomclass classatomhasvalu r ml referencepropertyatom isrefpropatomforhasvalu thismodul getchildrenofalltopmostimpl includ rdm atom name classatom haspredicatesymbol hvr term thismodul objectvari individualvari subject hvr rdm hasvaluerestrict hasvalu thismodul objectvari individu object onproperti thismodul referenceproperti objectproperti referenceproperti rule objectvari individu creat individu rdm element r ml objectvari lazi rule uniqu lazi rule objectvari individu r ml objectvari rdm individu name name rule atleastquantifiedformula mincardinalityrestrict creat mincardinalityrestrict rdm element r ml atleastquantifiedformula work datarangeatom classatom cardin restrict rule atleastquantifiedformula mincardinalityrestrict r ml atleastquantifiedformula oclistypeof r ml atleastquantifiedformula thismodul getchildrenofalltopmostimpl exclud rdm mincardinalityrestrict mincardin card onproperti formula oclistypeof r ml referencepropertyatom thismodul referenceproperti objectproperti formula referenceproperti els thismodul attribut datatypeproperti formula attribut endif card rdm typedliter thetyp int lexicalform mincardin tostr rule atleastquantifiedformulainclassatom mincardinalityrestrict creat rdm atom mincardinalityrestrict predic symbol r ml atleastquantifiedformula work classatom cardin restrict rule atleastquantifiedformulainclassatom mincardinalityrestrict r ml atleastquantifiedformula oclistypeof r ml atleastquantifiedformula formula oclistypeof r ml referencepropertyatom thismodul getchildrenofalltopmostimpl includ rdm atom name classatom haspredicatesymbol mcr term thismodul objectvari individualvari formula subject mcr rdm mincardinalityrestrict mincardin card onproperti thismodul referenceproperti objectproperti formula referenceproperti card rdm typedliter thetyp int lexicalform mincardin tostr rule atleastquantifiedformulaindatarangeatom mincardinalityrestrict creat rdm atom mincardinalityrestrict predic symbol r ml atleastquantifiedformula work datarangeatom cardin restrict rule atleastquantifiedformulaindatarangeatom mincardinalityrestrict r ml atleastquantifiedformula oclistypeof r ml atleastquantifiedformula formula oclistypeof r ml attributionatom thismodul getchildrenofalltopmostimpl includ rdm atom name datarangeatom haspredicatesymbol mcr term thismodul datavari individualvari formula datavalu mcr rdm mincardinalityrestrict mincardin card onproperti thismodul attribut datatypeproperti formula attribut card rdm typedliter thetyp int lexicalform mincardin tostr rule atmostquantifiedformulaclass maxcardinalityrestrict creat maxcardinalityrestrict rdm element r ml atmostquantifiedformula work datarangeatom classatom cardin restrict rule atmostquantifiedformulaclass maxcardinalityrestrict r ml atmostquantifiedformula oclistypeof r ml atmostquantifiedformula thismodul getchildrenofalltopmostimpl exclud rdm maxcardinalityrestrict maxcardin card onproperti formula oclistypeof r ml referencepropertyatom thismodul referenceproperti objectproperti formula referenceproperti els thismodul attribut datatypeproperti formula attribut endif card rdm typedliter thetyp int lexicalform maxcardin tostr rule atmostquantifiedformulainclassatom maxcardinalityrestrict creat rdm atom maxcardinalityrestrict predic symbol r ml atmostquantifiedformula work classatom cardin restrict rule atmostquantifiedformulainclassatom maxcardinalityrestrict r ml atmostquantifiedformula oclistypeof r ml atmostquantifiedformula formula oclistypeof r ml referencepropertyatom thismodul getchildrenofalltopmostimpl includ rdm atom name classatom haspredicatesymbol mcr term thismodul objectvari individualvari formula subject mcr rdm maxcardinalityrestrict maxcardin card onproperti thismodul referenceproperti objectproperti formula referenceproperti card rdm typedliter thetyp int lexicalform maxcardin tostr rule atmostquantifiedformulaindatarangeatom maxcardinalityrestrict creat rdm atom maxcardinalityrestrict predic symbol r ml atmostquantifiedformula work datarangeatom cardin restrict rule atmostquantifiedformulaindatarangeatom maxcardinalityrestrict r ml atmostquantifiedformula oclistypeof r ml atmostquantifiedformula formula oclistypeof r ml attributionatom thismodul getchildrenofalltopmostimpl includ rdm atom name datarangeatom haspredicatesymbol mcr term thismodul datavari individualvari formula datavalu mcr rdm maxcardinalityrestrict maxcardin card onproperti thismodul attribut datatypeproperti formula attribut card rdm typedliter thetyp int lexicalform maxcardin tostr rule atleastandatmostquantifiedformulaclass cardinalityrestrict creat cardinalityrestrict rdm element r ml atleastandatmostquantifiedformula work datarangeatom classatom cardin restrict rule atleastandatmostquantifiedformulaclass cardinalityrestrict r ml atleastandatmostquantifiedformula oclistypeof r ml atleastandatmostquantifiedformula maxcardin mincardin thismodul getchildrenofalltopmostimpl exclud rdm cardinalityrestrict cardin card onproperti formula oclistypeof r ml referencepropertyatom thismodul referenceproperti objectproperti formula referenceproperti els thismodul attribut datatypeproperti formula attribut endif card rdm typedliter thetyp int lexicalform maxcardin tostr rule atleastandatmostquantifiedformulainclassatom cardinalityrestrict creat rdm atom cardinalityrestrict predic symbol r ml atleastandatmostquantifiedformula work classatom cardin restrict rule atleastandatmostquantifiedformulainclassatom cardinalityrestrict r ml atleastandatmostquantifiedformula oclistypeof r ml atleastandatmostquantifiedformula formula oclistypeof r ml referencepropertyatom maxcardin mincardin thismodul getchildrenofalltopmostimpl includ rdm atom name classatom haspredicatesymbol mcr term thismodul objectvari individualvari formula subject mcr rdm cardinalityrestrict cardin card onproperti thismodul referenceproperti objectproperti formula referenceproperti card rdm typedliter thetyp int lexicalform maxcardin tostr rule atleastandatmostquantifiedformulaindatarangeatom cardinalityrestrict creat rdm atom cardinalityrestrict predic symbol r ml atleastandatmostquantifiedformula work datarangeatom cardin restrict rule atleastandatmostquantifiedformulaindatarangeatom cardinalityrestrict r ml atleastandatmostquantifiedformula oclistypeof r ml atleastandatmostquantifiedformula formula oclistypeof r ml attributionatom maxcardin mincardin thismodul getchildrenofalltopmostimpl includ rdm atom name datarangeatom haspredicatesymbol mcr term thismodul datavari individualvari formula datavalu mcr rdm cardinalityrestrict cardin card onproperti thismodul attribut datatypeproperti formula attribut card rdm typedliter thetyp int lexicalform maxcardin tostr rule atleastandatmostquantifiedformulaclass minmaxcardinalityrestrict creat mincardinalityrestrict maxcardinalityrestrict rdm element r ml atleastandatmostquantifiedformula differ max min cardin work datarangeatom classatom cardin restrict rule atleastandatmostquantifiedformulaclass minmaxcardinalityrestrict r ml atleastandatmostquantifiedformula oclistypeof r ml atleastandatmostquantifiedformula maxcardin mincardin thismodul getchildrenofalltopmostimpl exclud rdm mincardinalityrestrict mincardin cardmin onproperti formula oclistypeof r ml referencepropertyatom thismodul referenceproperti objectproperti formula referenceproperti els thismodul attribut datatypeproperti formula attribut endif cardmin rdm typedliter thetyp int lexicalform mincardin tostr u rdm maxcardinalityrestrict maxcardin cardmax onproperti formula oclistypeof r ml referencepropertyatom thismodul referenceproperti objectproperti formula referenceproperti els thismodul attribut datatypeproperti formula attribut endif cardmax rdm typedliter thetyp int lexicalform maxcardin tostr rule atleastandatmostquantifiedformulaclassatom minmaxcardinalityrestrict creat rdm atom mincardinalityrestrict predic symbol maxcardinalityrestrict rdm elementfrom r ml atleastandatmostquantifiedformula differ max min cardin work classatom cardin restrict rule atleastandatmostquantifiedformulaclassatom minmaxcardinalityrestrict r ml atleastandatmostquantifiedformula oclistypeof r ml atleastandatmostquantifiedformula formula oclistypeof r ml referencepropertyatom maxcardin mincardin thismodul getchildrenofalltopmostimpl includ rdm atom name classatom haspredicatesymbol mcr term thismodul objectvari individualvari formula subject mcr rdm mincardinalityrestrict mincardin cardmin onproperti thismodul referenceproperti objectproperti formula referenceproperti cardmin rdm typedliter thetyp int lexicalform mincardin tostr u rdm maxcardinalityrestrict maxcardin cardmax onproperti thismodul referenceproperti objectproperti formula referenceproperti cardmax rdm typedliter thetyp int lexicalform maxcardin tostr rule atleastandatmostquantifiedformuladatarangeatom minmaxcardinalityrestrict creat rdm atom mincardinalityrestrict predic symbol maxcardinalityrestrict rdm elementfrom r ml atleastandatmostquantifiedformula differ max min cardin work datarangeatom cardin restrict rule atleastandatmostquantifiedformuladatarangeatom minmaxcardinalityrestrict r ml atleastandatmostquantifiedformula oclistypeof r ml atleastandatmostquantifiedformula formula oclistypeof r ml attributionatom maxcardin mincardin thismodul getchildrenofalltopmostimpl includ rdm atom name datarangeatom haspredicatesymbol mcr term thismodul datavari individualvari formula datavalu mcr rdm mincardinalityrestrict mincardin cardmin onproperti thismodul attribut datatypeproperti formula attribut cardmin rdm typedliter thetyp int lexicalform mincardin tostr u rdm maxcardinalityrestrict maxcardin cardmax onproperti thismodul attribut datatypeproperti formula attribut cardmax rdm typedliter thetyp int lexicalform maxcardin tostr datarang atom rule dataclassificationatom datarangeatomoneof creat rdm atom r ml dataclassificationatom element children top implic rule dataclassificationatom datarangeatomoneof r ml dataclassificationatom thismodul getchildrenofalltopmostimpl includ rdm atom name datarangeatom haspredicatesymbol dtr term thismodul datavari individualvari term dtr rdm datarang datatyp type rule dataclassificationatom datarang creat rdm datarang r ml dataclassificationatom element children top implic rule dataclassificationatom datarang r ml dataclassificationatom thismodul getchildrenofalltopmostimpl exclud dtr rdm datarang datatyp type rule disjunct datarangeatom creat rdm atom r ml disjunct element children top implic datatypepredicateatom formula rule disjunct datarangeatom r ml disjunct thismodul getchildrenofalltopmostimpl includ formula assequ first oclistypeof r ml datatypepredicateatom rdm atom name datarangeatom haspredicatesymbol dtr term sequenc thismodul datavari individualvari formula assequ first getterm dtr rdm datarang oneof formula rule disjunct datarang creat rdm datarang r ml disjunct element children top implic datatypepredicateatom formula rule disjunct datarang r ml disjunct thismodul getchildrenofalltopmostimpl exclud formula assequ first oclistypeof r ml datatypepredicateatom rdm datarang oneof formula rule datatyp primitivetyp creat rdm primitivetyp r ml datatyp element rule datatyp primitivetyp r ml datatyp oclistypeof r ml datatyp rdm primitivetyp name name rule plainliter plainliter creat rdm plainliter r ml plainliter element valu top attributionatom dataargu datatypepredicateatom rule plainliter plainliter r ml plainliter oclistypeof r ml plainliter thismodul getchildrenofalltopmostimpl select c c oclistypeof r ml attributionatom collect c c valu flatten exclud r ml datatypepredicateatom allinstancesfrom in assequ collect c c dataargu flatten exclud rdm plainliter languag languagetag lexicalform lexicalvalu rule typedliter typedliter creat rdm typedliter r ml typedliter element rule typedliter typedliter r ml typedliter oclistypeof r ml typedliter r ml datatypepredicateatom allinstancesfrom in assequ collect c c dataargu flatten exclud rdm typedliter thetyp type name lexicalform lexicalvalu rule datatypepredicateatom plainliter creat rdm plainliter r ml datatypepredicateatom element atom dataargu plainliter formula disjunct rule datatypepredicateatom plainliter r ml datatypepredicateatom dataargu select c c oclistypeof r ml plainliter size r ml disjunct allinstancesfrom in assequ collect e e formula flatten includ dataargu select c c oclistypeof r ml attributefunctionterm size true els fals endif rdm plainliter languag dataargu select c c ocliskindof r ml dataliter assequ first languagetag lexicalform dataargu select c c ocliskindof r ml dataliter assequ first lexicalvalu rule datatypepredicateatom typedliter creat rdm typedliter r ml datatypepredicateatom element atom dataargu typedliter formula disjunct rule datatypepredicateatom typedliter r ml datatypepredicateatom dataargu select c c oclistypeof r ml typedliter size r ml disjunct allinstancesfrom in assequ collect e e formula flatten includ dataargu select c c oclistypeof r ml attributefunctionterm size true els fals endif rdm typedliter thetyp dataargu select c c oclistypeof r ml typedliter assequ first type name lexicalform dataargu select c c oclistypeof r ml typedliter assequ first lexicalvalu rule universallyquantifiedformuladata allvaluesfromrestrict creat allvaluesfromrestrict rdm element r ml universallyquantifiedformula element implic formula attributionatom anteced rule universallyquantifiedformuladata allvaluesfromrestrict r ml universallyquantifiedformula thismodul gettopmostuniversallyquantifiedformula exclud thismodul getchildrenofalltopmostimpl exclud formula oclistypeof r ml implic formula anteced oclistypeof r ml attributionatom true els fals endif els fals endif rdm allvaluesfromrestrict allvaluesfromrang formula consequ onproperti thismodul attribut datatypeproperti formula anteced attribut rule universallyquantifiedformuladata allvaluesfromrestrict creat rdm atom allvaluesfromrestrict predic symbol r ml universallyquantifiedformula element implic formula attributionatom anteced rule universallyquantifiedformuladata datarangeatomallvaluesfromrestrict r ml universallyquantifiedformula thismodul gettopmostuniversallyquantifiedformula exclud thismodul getchildrenofalltopmostimpl includ formula oclistypeof r ml implic formula anteced oclistypeof r ml attributionatom true els fals endif els fals endif dra rdm atom name datarangeatom haspredicatesymbol alr term thismodul datavari individualvari formula anteced getterm alr rdm allvaluesfromrestrict allvaluesfromrang formula consequ onproperti thismodul attribut datatypeproperti formula anteced attribut rule existentiallyquantifiedformuladata somevaluesfromrestrict creat somevaluesfromrestrict rdm element r ml existentiallyquantifiedformula element attributionatom formula rule existentiallyquantifiedformuladata somevaluesfromrestrict r ml existentiallyquantifiedformula thismodul getchildrenofalltopmostimpl exclud formula oclistypeof r ml conjuct formula formula select e e oclistypeof r ml attributionatom size true els fals endif els fals endif rdm somevaluesfromrestrict somevaluesfromrang formula formula select c c oclistypeof r ml attributionatom first onproperti thismodul attribut datatypeproperti formula formula select c c oclistypeof r ml attributionatom first attribut rule existentiallyquantifiedformuladata datarangeatomsomevaluesfromrestrict creat rdm atom somevaluesfromrestrict predic symbol r ml existentiallyquantifiedformula element attributionatom formula rule existentiallyquantifiedformuladata datarangeatomsomevaluesfromrestrict r ml existentiallyquantifiedformula thismodul getchildrenofalltopmostimpl includ formula oclistypeof r ml conjuct formula formula select e e oclistypeof r ml attributionatom size true els fals endif els fals endif dra rdm atom name datarangeatom haspredicatesymbol smr term thismodul datavari individualvari formula anteced getterm smr rdm somevaluesfromrestrict somevaluesfromrang formula formula select c c oclistypeof r ml attributionatom first onproperti thismodul attribut datatypeproperti formula formula select c c oclistypeof r ml attributionatom first attribut rule attribut datatypeproperti lazi rule creat rdm datatypeproperti r ml attribut uniqu lazi rule attribut datatypeproperti r ml attribut rdm datatypeproperti name name rule typedliter datavalu lazi rule creat rdm datavalu r ml typedliter uniqu lazi rule typedliter datavalu r ml typedliter rdm datavalu valu lexicalvalu type type rule attributeatomdata datavaluedpropertyatom creat rdm atom r ml attributionatom children top implic rule attributeatomdata datavaluedpropertyatom r ml attributionatom thismodul getchildrenofalltopmostimpl includ rdm atom name datavaluedpropertyatom haspredicatesymbol thismodul attribut datatypeproperti attribut term datavalu oclistypeof r ml typedliter sequenc thismodul typedliter datavalu datavalu thismodul objectvari individualvari subject els sequenc thismodul datavari datavari datavalu thismodul objectvari individualvari subject endif rule attributionatomdata hasvaluerestrict creat rdm hasvaluerestrict r ml attributionatom children top implic rule attributionatomdata hasvaluerestrict r ml attributionatom thismodul getchildrenofalltopmostimpl includ rdm hasvaluerestrict hasliteralvalu datavalu onproperti thismodul attribut datatypeproperti attribut rule datavari datavari lazi rule creat rdm datavari r ml datavari uniqu lazi rule datavari datavari r ml datavari rdm datavari name name rule equalityatom sameindividualatom creat rdm atom r ml equalityatom children formula disjunct rule equalityatom sameindividualatom r ml equalityatom r ml disjunct allinstancesfrom in assequ collect e e formula flatten exclud rdm atom name sameindividualatom haspredicatesymbol term term select e e oclistypeof r ml objectvari collect c thismodul objectvari individualvari c rdm samea rule inequalityatom differentindividualatom creat rdm atom r ml inequalityatom rule inequalityatom differentindividualatom r ml inequalityatom oclistypeof r ml inequalityatom rdm atom name differentindividualatom haspredicatesymbol differ term term select e e oclistypeof r ml objectvari collect c thismodul objectvari individualvari c differ rdm differentfrom rule datatypepredicateatom bulitinatom creat rdm atom r ml datatypepredicateatom formula disjunct rule datatypepredicateatom bulitinatom r ml datatypepredicateatom r ml disjunct allinstancesfrom in assequ collect e e formula flatten exclud dataargu select c c oclistypeof r ml attributefunctionterm size dataargu select c c oclistypeof r ml dataoperationterm size rdm atom name bulitinatom haspredicatesymbol thismodul datatypepred builtin predic term sequenc dataargu select e e ocliskindof r ml datavari collect c thismodul datavari datavari c dataargu select e e ocliskindof r ml typedliter collect c thismodul typedliter datavalu c rule datatypepred builtin lazi rule creat rdm builtin r ml datatypepred uniqu lazi rule datatypepred builtin r ml datatypepred rdm builtin buildinid name rule transform r ml element transform ocl metamodel rule objectvari classatom creat rdm classatom r ml objectvari rule objectvari classatom r ml objectvari r ml attributefunctionterm allinstancesfrom in collect c c contextargu flatten includ r ml referencepropertyfunctionterm allinstancesfrom in collect c c contextargu flatten includ r ml dataoperationterm allinstancesfrom in collect c c contextargu flatten includ rdm atom name classatom haspredicatesymbol thismodul class class classref term thismodul objectvari individualvari rule attributefunctionterm individualpropertyatom creat rdm individualpropertyatom r ml attributefunctionterm rule attributefunctionterm individualpropertyatom r ml attributefunctionterm oclistypeof r ml attributefunctionterm rdm atom name individualpropertyatom haspredicatesymbol thismodul attribut objectproperti attribut term sequenc contextargu oclistypeof r ml objectvari thismodul objectvari individualvari contextargu els thismodul referencepropertyfunctionterm individualvari contextargu endif thismodul attributefunctionterm individualvari rule datatypepredicateatomwithattributefuncterm builtinatom creat rdm bulitinatom r ml datatypepredicateatom rule datatypepredicateatomwithattributefuncterm builtinatom r ml datatypepredicateatom dataargu select c c oclistypeof r ml attributefunctionterm size dataargu select c c oclistypeof r ml dataoperationterm size rdm atom name bulitinatom haspredicatesymbol thismodul datatypepred builtin predic term sequenc dataargu select e e ocliskindof r ml attributefunctionterm assequ collect c thismodul attributefunctionterm individualvari c dataargu select e e ocliskindof r ml dataoperationterm assequ collect c thismodul dataoperationterm individualvari c dataargu select e e ocliskindof r ml typedliter collect c thismodul typedliter datavalu c rule referencepropertyfunctionterm individualpropertyatom creat rdm individualpropertyatom r ml referencepropertyfunctionterm rule referencepropertyfunctionterm individualpropertyatom r ml referencepropertyfunctionterm oclistypeof r ml referencepropertyfunctionterm rdm atom name individualpropertyatom haspredicatesymbol thismodul referenceproperti objectproperti referencepropertyref term sequenc contextargu oclistypeof r ml objectvari thismodul objectvari individualvari contextargu els thismodul referencepropertyfunctionterm individualvari contextvari endif thismodul referencepropertyfunctionterm individualvari rule dataoperationterm individualpropertyatom creat rdm individualpropertyatom r ml dataoperationterm rule dataoperationterm individualpropertyatom r ml dataoperationterm oclistypeof r ml dataoperationterm rdm atom name individualpropertyatom haspredicatesymbol thismodul dataoper objectproperti dataoperationref term sequenc thismodul objectvari individualvari contextargu thismodul dataoperationterm individualvari rule referencepropertyatom individualpropertyatom creat rdm individualpropertyatom r ml referencepropertyatom rule referencepropertyatom individualpropertyatom r ml referencepropertyatom isrefpropatomforhasvalu areallobjectvari rdm atom name individualpropertyatom haspredicatesymbol thismodul referenceproperti objectproperti referenceproperti term sequenc subject oclistypeof r ml objectvari thismodul objectvari individualvari subject els thismodul referencepropertyfunctionterm individualvari subject endif object oclistypeof r ml objectvari thismodul objectvari individualvari object els thismodul referencepropertyfunctionterm individualvari object endif rule dataoper objectproperti lazi rule creat rdm objectproperti r ml dataoper uniqu lazi rule dataoper objectproperti r ml dataoper rdm objectproperti name name rule attribut objectproperti lazi rule creat rdm objectproperti r ml attribut uniqu lazi rule attribut objectproperti r ml attribut rdm objectproperti name name rule referencepropertyfunctionterm individualvari lazi rule creat rdm individualvari r ml referencepropertyfunctionterm uniqu lazi rule referencepropertyfunctionterm individualvari r ml referencepropertyfunctionterm rdm individualvari name contextargu oclistypeof r ml objectvari contextargu name referencepropertyref name firstchartoupp in case referencepropertyfunctionterm contextargu els contextargu getvariablenam attribut name firstchartoupp endif rule dataoperationterm individualvari lazi rule creat rdm individualvari r ml dataoperationterm uniqu lazi rule dataoperationterm individualvari r ml dataoperationterm rdm individualvari name contextargu oclistypeof r ml objectvari contextargu name dataoperationref name firstchartoupp els unknow endif rule attributefunctionterm individualvari lazi rule creat rdm individualvari r ml attributefunctionterm uniqu lazi rule attributefunctionterm individualvari r ml attributefunctionterm rdm individualvari name contextargu oclistypeof r ml objectvari contextargu name attribut name firstchartoupp in case referencepropertyfunctionterm els contextargu getvariablenam attribut name firstchartoupp endif,6
130,130,P60-RDM2XML.atl,"--@atlcompiler atl2006

-- ============================================================
-- Transforms an RDM (SWRL/OWL) metamodel to XML metamodel.
-- Created as part of M.Sc. theses at GOOD OLD AI Laboratory
-- Author: Milan Milanovic (milan at milanovic.org)
-- Works for SWRL v0.6 (XML syntax)
-- Licence: GNU General Public License, version 2
-- ============================================================
	
module RDM2XML; -- Module Template
create OUT : XML from IN : RDM;

uses strings;

-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- HELPER: elementsForProperty
-- Returns all Restriction inerhited elements which have restriction on this property.
-- Works for Object and Data properties.
-- CONTEXT:	RDM!Property
-- OUT:		Sequence (RDM!Restriction)
helper context RDM!Property def: elementsForProperty : Sequence (RDM!Restriction) = 
	RDM!Restriction.allInstancesFrom('IN')->asSequence()->select(c | c.onProperty->includes(self))->asSequence();

-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'Ontology'
-- Create XML Root element from the RDM Ontology element 
rule Ontology {
	from i : RDM!Ontology (
			i.oclIsTypeOf(RDM!Ontology)
		)
	to o : XML!Root (
		children <- Sequence { attr, i.elements},
		name <- 'swrlx:Ontology'
		),
	attr : XML!Attribute (
		name <- 'swrlx:name',
		value <- 'Ontology'
		)
}

-- Rule 'RuleOne'
-- Create XML Root element from the RDM Rule element 
rule RuleOne {
	from i : RDM!Rule (
		i.oclIsTypeOf(RDM!Rule) and
		RDM!Ontology.allInstancesFrom('IN')->asSequence()->size() = 0
		)
	to o : XML!Root (
		name <- 'ruleml:imp',
		children <- Sequence {owlxns, swrlxns, rulemlns, i.hasAntecedent, i.hasConsequent }
		),
	owlxns : XML!Attribute (
		name <- 'xmlns:owlx',
		value <- 'http://www.w3.org/2003/05/owl-xml'
		),
	swrlxns : XML!Attribute (
		name <- 'xmlns:swrlx',
		value <- 'http://www.w3.org/2003/11/swrlx'
		),
	rulemlns : XML!Attribute (
		name <- 'xmlns:ruleml',
		value <- 'http://www.w3.org/2003/11/ruleml'
		)
}

-- Rule 'RuleMoreThanOne'
-- Create XML Element (ruleml:imp) element from the RDM Rule element 
rule RuleMoreThanOne {
	from i : RDM!Rule (
		i.oclIsTypeOf(RDM!Rule) and 
		( RDM!Rule.allInstancesFrom('IN')->asSequence()->size() > 1 or
		  RDM!Ontology.allInstancesFrom('IN')->asSequence()->size() > 0 )
		)
	to o : XML!Element (
		name <- 'ruleml:imp',
		children <- Sequence {owlxns, swrlxns, rulemlns, i.hasAntecedent, i.hasConsequent }
		),
	owlxns : XML!Attribute (
		name <- 'xmlns:owlx',
		value <- 'http://www.w3.org/2003/05/owl-xml'
		),
	swrlxns : XML!Attribute (
		name <- 'xmlns:swrlx',
		value <- 'http://www.w3.org/2003/11/swrlx'
		),
	rulemlns : XML!Attribute (
		name <- 'xmlns:ruleml',
		value <- 'http://www.w3.org/2003/11/ruleml'
		)
}

-- Rule 'Consequent'
-- Create XML Element (ruleml:_head) element from the RDM Consequent element 
rule Consequent {
	from i : RDM!Consequent (
			i.oclIsTypeOf(RDM!Consequent)
		)
	to o : XML!Element (
		name <- 'ruleml:_head',
				-- ANNOTATION: This is because we can have same Atom in consequent and antecedent.
				--             E.g. when we have two ClassAtoms from two DatatypePredicateAtom-s.
		children <- let thisRule : RDM!Rule = RDM!Rule.allInstancesFrom('IN')->asSequence()->select(c | c.hasConsequent = i)->first() in
						i.containsAtom->asSequence()->select(c | thisRule.hasAntecedent.containsAtom->excludes(c))->asSequence()
		)
}

-- Rule 'Antecedent'
-- Create XML Element (ruleml:_body) element from the RDM Antecedent element 
rule Antecedent {
	from i : RDM!Antecedent (
			i.oclIsTypeOf(RDM!Antecedent)
		)
	to o : XML!Element (
		name <- 'ruleml:_body',
		children <- i.containsAtom
		)
}

-- Atoms 

-- Rule 'IndividualPropertyAtom'
-- Create XML Element (swrlx:individualPropertyAtom) element from the RDM Atom (IndividualPropertyAtom) element 
rule IndividualPropertyAtom {
	from i : RDM!Atom (
			i.name = 'IndividualPropertyAtom'
		)
	to o : XML!Element (
		name <- 'swrlx:individualPropertyAtom',
		children <- Sequence { prop, i.terms->select(c | c.oclIsTypeOf(RDM!IndividualVariable))->collect(c | thisModule.IndividualVariable(c)),
									 i.terms->select(c | not c.oclIsTypeOf(RDM!IndividualVariable))
							 }
		),
	prop : XML!Attribute (
		name <- 'swrlx:property',
		value <- i.hasPredicateSymbol.name
		)
}

-- Rule 'ClassAtom'
-- Create XML Element (swrlx:classAtom) element from the RDM Atom (ClassAtom) element
rule ClassAtom {
	from i : RDM!Atom (
			i.name = 'ClassAtom'
		)
	to o : XML!Element (
		name <- 'swrlx:classAtom',
		children <- Sequence { if i.hasPredicateSymbol.oclIsTypeOf(RDM!Class) then
									thisModule.Class(i.hasPredicateSymbol)
								else if i.hasPredicateSymbol.oclIsKindOf(RDM!Restriction) then
										i.hasPredicateSymbol.onProperty
	  							     else i.hasPredicateSymbol
							         endif
								endif,
								i.terms->asSequence()->select(c | c.oclIsTypeOf(RDM!IndividualVariable))->collect(e | thisModule.IndividualVariable(e)),
								i.terms->asSequence()->select(c | not c.oclIsTypeOf(RDM!IndividualVariable))
							}
		)
}

-- Rule 'DataRangeAtom'
-- Create XML Element (swrlx:datarangeAtom) element from the RDM Atom (DataRangeAtom) element
rule DataRangeAtom {
	from i : RDM!Atom (
			i.name = 'DataRangeAtom'
		)
	to o : XML!Element (
		name <- 'swrlx:datarangeAtom',
		children <- Sequence { if i.hasPredicateSymbol.oclIsKindOf(RDM!Restriction) then
									i.hasPredicateSymbol.onProperty
							   else i.hasPredicateSymbol
							   endif,
							   i.terms->asSequence()->select(c | c.oclIsTypeOf(RDM!IndividualVariable))->collect(e | thisModule.IndividualVariable(e)),
							   i.terms->asSequence()->select(c | not c.oclIsTypeOf(RDM!IndividualVariable))
							}
		)
}

-- Rule 'DataValuedPropertyAtom'
-- Create XML Element (swrlx:datavaluedPropertyAtom) element from the RDM Atom (DataValuedPropertyAtom) element
rule DataValuedPropertyAtom {
	from i : RDM!Atom (
			i.name = 'DataValuedPropertyAtom'
		)
	to o : XML!Element (
		name <- 'swrlx:datavaluedPropertyAtom',
		children <- Sequence { prop, i.terms->asSequence()->select(c | c.oclIsTypeOf(RDM!IndividualVariable))->collect(e | thisModule.IndividualVariable(e)),
									 i.terms->asSequence()->select(c | c.oclIsTypeOf(RDM!DataVariable))->collect(e | thisModule.DataVariable(e)),
									 i.terms->asSequence()->select(c | not c.oclIsTypeOf(RDM!IndividualVariable) and not c.oclIsTypeOf(RDM!DataVariable))
							}
		),
	prop : XML!Attribute (
		name <- 'swrlx:property',
		value <- i.hasPredicateSymbol.name
		)
}

-- Rule 'SameIndividualAtom'
-- Create XML Element (swrlx:sameIndividualAtom) element from the RDM Atom (SameIndividualAtom) element
rule SameIndividualAtom {
	from i : RDM!Atom (
			i.name = 'SameIndividualAtom'
		)
	to o : XML!Element (
		name <- 'swrlx:sameIndividualAtom',
		children <- Sequence { i.terms->asSequence()->select(c | c.oclIsTypeOf(RDM!IndividualVariable))->collect(e | thisModule.IndividualVariable(e)),
							   i.terms->asSequence()->select(c | not c.oclIsTypeOf(RDM!IndividualVariable))
							 }
		)
}

-- Rule 'DifferentIndividualAtom'
-- Create XML Element (swrlx:differentIndividualsAtom) element from the RDM Atom (DifferentIndividualAtom) element
rule DifferentIndividualsAtom {
	from i : RDM!Atom (
			i.name = 'DifferentIndividualAtom'
		)
	to o : XML!Element (
		name <- 'swrlx:differentIndividualsAtom',
		children <- Sequence { i.terms->asSequence()->select(c | c.oclIsTypeOf(RDM!IndividualVariable))->collect(e | thisModule.IndividualVariable(e)),
							   i.terms->asSequence()->select(c | not c.oclIsTypeOf(RDM!IndividualVariable))
							 }
		)
}

-- Rule 'BuiltinAtom'
-- Create XML Element (swrlx:builtinAtom) element from the RDM Atom (BuiltinAtom) element
rule BuiltinAtom {
	from i : RDM!Atom (
			i.name = 'BulitinAtom'
		)
	to o : XML!Element (
		name <- 'swrlx:builtinAtom',
		children <- Sequence { attr, 
							   i.terms->asSequence()->select(c | c.oclIsTypeOf(RDM!DataVariable))->collect(e | thisModule.DataVariable(e)),
							   i.terms->asSequence()->select(c | c.oclIsTypeOf(RDM!IndividualVariable))->collect(e | thisModule.IndividualVariable(e)),
							   i.terms->asSequence()->select(c | not c.oclIsTypeOf(RDM!DataVariable) and not c.oclIsTypeOf(RDM!IndividualVariable))
							 }
		),
	attr : XML!Attribute (
		name <- 'swrlx:builtin',
		value <- i.hasPredicateSymbol.buildInID
		)
}

-- Lazy Rule 'DataVariable'
-- Create XML Element element (ruleml:var) from the RDM DataVariable element
lazy rule DataVariable {
	from i : RDM!DataVariable
	to o : XML!Element (
		name <- 'ruleml:var',
		children <- Sequence { txt }
		),
	txt : XML!Text (
		name <- '#text',
		value <- i.name
		)
}

-- Lazy Rule 'Individual'
-- Create XML Element element (owlx:Individual) from the RDM Individual element
rule Individual {
	from i : RDM!Individual (
			i.oclIsTypeOf(RDM!Individual)
		)
	to o : XML!Element (
		name <- 'owlx:Individual',
		children <- Sequence { attr }
		),
	attr : XML!Attribute (
		name <- 'owlx:name',
		value <- i.name
		)
}

-- Rule 'DataType'
-- Create XML Element element (owlx:Datatype) from the RDM DataRange element
rule DataType {
	from i : RDM!DataRange (
			not	i.datatype.oclIsUndefined()
		)
	to o : XML!Element (
		name <- 'owlx:Datatype',
		children <- Sequence { attr }
		),
	attr : XML!Attribute (
		name <- 'owlx:name',
		value <- i.datatype.name
		)
}

-- Rule 'DataValue'
-- Create XML Element element (owlx:DataValue) from the RDM DataValue element
rule DataValue {
	from i : RDM!DataValue (
			i.oclIsTypeOf(RDM!DataValue)
		)
	to o : XML!Element (
		name <- 'owlx:DataValue',
		children <- Sequence { attr, txt }
		),
	attr : XML!Attribute (
		name <- 'owlx:datatype',
		value <- i.type.name
		),
	txt : XML!Text (
		name <- '#text',
		value <- i.value
		)
}

-- Rule 'TypedLiteralOfDataRange'
-- Create XML Element element (owlx:DataValue) from the RDM TypedLiteral element
rule TypedLiteralOfDataRange {
	from i : RDM!TypedLiteral (
			RDM!DataRange.allInstancesFrom('IN')->asSequence()->collect(c | c.oneOf)->flatten()->includes(i)
		)
	to o : XML!Element (
		name <- 'owlx:DataValue',
		children <- Sequence { attr, txt }
		),
	attr : XML!Attribute (
		name <- 'owlx:datatype',
		value <- i.theType
		),
	txt : XML!Text (
		name <- '#text',
		value <- i.lexicalForm
		)
}

-- Rule 'IntersectionOf'
-- Create XML Element element (owlx:IntersectionOf) from the RDM IntersectionClass element
rule IntersectionOf {
	from i : RDM!IntersectionClass (
			i.oclIsTypeOf(RDM!IntersectionClass)
		)
	to o : XML!Element (
		name <- 'owlx:IntersectionOf',
 		children <- Sequence { i.intersectionOf->asSequence()->select(c | c.oclIsTypeOf(RDM!Class))->collect(c | thisModule.Class(c)),
							   i.intersectionOf->asSequence()->select(c | not c.oclIsTypeOf(RDM!Class) and c.oclIsKindOf(RDM!Restriction))->collect(e | e.onProperty)->flatten(),
							   i.intersectionOf->asSequence()->select(c | not c.oclIsTypeOf(RDM!Class) and not c.oclIsKindOf(RDM!Restriction))
							}
		)
}

-- Rule 'UnionOf'
-- Create XML Element element (owlx:UnionOf) from the RDM UnionClass element
rule UnionOf {
	from i : RDM!UnionClass (
			i.oclIsTypeOf(RDM!UnionClass)
		)
	to o : XML!Element (
		name <- 'owlx:UnionOf',
 		children <- Sequence { i.unionOf->asSequence()->select(c | c.oclIsTypeOf(RDM!Class))->collect(c | thisModule.Class(c)),
							   i.unionOf->asSequence()->select(c | not c.oclIsTypeOf(RDM!Class) and c.oclIsKindOf(RDM!Restriction))->collect(e | e.onProperty)->flatten(),
							   i.unionOf->asSequence()->select(c | not c.oclIsTypeOf(RDM!Class) and not c.oclIsKindOf(RDM!Restriction))
							}
		)
}

-- Rule 'ComplementOf'
-- Create XML Element element (owlx:ComplementOf) from the RDM ComplementClass element
rule ComplementOf {
	from i : RDM!ComplementClass (
			i.oclIsTypeOf(RDM!ComplementClass)
		)
	to o : XML!Element (
		name <- 'owlx:ComplementOf',
 		children <- Sequence { if i.complementOf.oclIsTypeOf(RDM!Class) then
								thisModule.Class(i.complementOf)
								else
									if i.complementOf.oclIsKindOf(RDM!Restriction) then
										i.complementOf.onProperty
									else
										i.complementOf
									endif
							   endif
 							 }
		)
}

-- Rule 'SomeValuesFromAttrClass'
-- Create XML Element element (owlx:someValuesFrom) from the RDM SomeValuesFromRestriction element
rule SomeValuesFromAttrClass {
	from i : RDM!SomeValuesFromRestriction (
			if not i.someValuesFromClass.oclIsUndefined()
				then i.someValuesFromClass.oclIsTypeOf(RDM!Class)
				else false
			endif
		)
	to	someValuesFrom : XML!Element (
		name <- 'owlx:someValuesFrom',
		children <- Sequence { class }
		),
	class : XML!Attribute (
		name <- 'owlx:class',
		value <- i.someValuesFromClass.name
		)
}

-- Rule 'SomeValuesFromElemClass'
-- Create XML Element element (owlx:someValuesFrom) from the RDM SomeValuesFromRestriction element
rule SomeValuesFromElemClass {
	from i : RDM!SomeValuesFromRestriction (
			if not i.someValuesFromClass.oclIsUndefined()
				then if not i.someValuesFromClass.oclIsTypeOf(RDM!Class) and  not i.someValuesFromClass.oclIsTypeOf(RDM!UnionClass) then
						true
					else false
					endif
				else false
			endif
		)
	to someValuesFrom : XML!Element (
		name <- 'owlx:someValuesFrom',
		children <- i.someValuesFromClass
		)
}


-- Rule 'SomeValuesFromChild'
-- Create XML Element element (owlx:someValuesFrom) from the RDM SomeValuesFromRestriction element
rule SomeValuesFromChild {
	from i : RDM!SomeValuesFromRestriction (
			if not i.someValuesFromClass.oclIsUndefined()
				then i.someValuesFromClass.oclIsTypeOf(RDM!UnionClass)
				else false
			endif
		)
	to someValuesFrom : XML!Element (
		name <- 'owlx:someValuesFrom',
		children <- Sequence { i.someValuesFromClass.unionOf->asSequence()->select(c | c.oclIsTypeOf(RDM!Class))->collect(c | thisModule.Class(c)),
							   i.someValuesFromClass.unionOf->asSequence()->select(c | not c.oclIsTypeOf(RDM!Class))
							 }
		)
}

-- Rule 'SomeValuesFromAttrDatatype'
-- Create XML Element element (owlx:someValuesFrom) from the RDM SomeValuesFromRestriction element
rule SomeValuesFromAttrDatatype {
	from i : RDM!SomeValuesFromRestriction (
			if not i.someValuesFromRange.oclIsUndefined()
				then i.someValuesFromRange.oclIsTypeOf(RDM!DataRange)
				else false
			endif
		)
	to someValuesFrom : XML!Element (
		name <- 'owlx:someValuesFrom',
		children <- Sequence { datatype }
		),
	datatype : XML!Attribute (
		name <- 'owlx:datatype',
		value <- i.someValuesFromRange.datatype.name
		)
}

-- Rule 'AllValuesFromAttrClass'
-- Create XML Element element (owlx:allValuesFrom) from the RDM AllValuesFromRestriction element
rule AllValuesFromAttrClass {
	from i : RDM!AllValuesFromRestriction (
			if not i.allValuesFromClass.oclIsUndefined()
				then i.allValuesFromClass.oclIsTypeOf(RDM!Class)
				else false
			endif
		)
	to allValuesFrom : XML!Element (
		name <- 'owlx:allValuesFrom',
		children <- Sequence { class }
		),
	class : XML!Attribute (
		name <- 'owlx:class',
		value <- i.allValuesFromClass.name
		)
}

-- Rule 'AllValuesFromAttrDatatype'
-- Create XML Element element (owlx:allValuesFrom) from the RDM AllValuesFromRestriction element
rule AllValuesFromAttrDatatype {
	from i : RDM!AllValuesFromRestriction (
			if not i.allValuesFromRange.oclIsUndefined()
				then i.allValuesFromRange.oclIsTypeOf(RDM!DataRange)
				else false
			endif
		)
	to allValuesFrom : XML!Element (
		name <- 'owlx:allValuesFrom',
		children <- Sequence { datatype }
		),
	datatype : XML!Attribute (
		name <- 'owlx:datatype',
		value <- i.allValuesFromRange.datatype.name
		)
}

-- Rule 'AllValuesFromElemClass'
-- Create XML Element element (owlx:allValuesFrom) from the RDM AllValuesFromRestriction element
rule AllValuesFromElemClass {
	from i : RDM!AllValuesFromRestriction (
			if not i.allValuesFromClass.oclIsUndefined()
				then if not i.allValuesFromClass.oclIsTypeOf(RDM!Class) and not i.someValuesFromClass.oclIsTypeOf(RDM!UnionClass) then
						true
					else false
					endif
				else false
			endif
		)
	to allValuesFrom : XML!Element (
		name <- 'owlx:allValuesFrom',
		children <- i.allValuesFromClass
		)
}

-- Rule 'AllValuesFromChild'
-- Create XML Element element (owlx:allValuesFrom) from the RDM AllValuesFromRestriction element
rule AllValuesFromChild {
	from i : RDM!AllValuesFromRestriction (
			if not i.allValuesFromClass.oclIsUndefined()
				then i.allValuesFromClass.oclIsTypeOf(RDM!UnionClass)
				else false
			endif
		)
	to allValuesFrom : XML!Element (
		name <- 'owlx:allValuesFrom',
		children <- Sequence { i.allValuesFromClass.unionOf->asSequence()->select(c | c.oclIsTypeOf(RDM!Class))->collect(c | thisModule.Class(c)),
							   i.allValuesFromClass.unionOf->asSequence()->select(c | not c.oclIsTypeOf(RDM!Class))
							 }
		)
}

-- Rule 'HasValueObject'
-- Create XML Element element (owlx:hasValue) from the RDM HasValueRestriction element
rule HasValueObject {
	from i : RDM!HasValueRestriction (
			if not i.hasValue.oclIsUndefined() then
				i.hasValue.oclIsTypeOf(RDM!Individual)
			else false
			endif
		)
	to hasValue : XML!Element (
		name <- 'owlx:hasValue',
		children <- Sequence { hattr }
		),
	hattr : XML!Attribute (
		name <- 'owlx:name',
		value <- i.hasValue.name
		)
}

-- Rule 'HasValueData'
-- Create XML Element element (owlx:hasValue) from the RDM HasValueRestriction element
rule HasValueData {
	from i : RDM!HasValueRestriction (
			if not i.hasLiteralValue.oclIsUndefined() then
				i.hasLiteralValue.oclIsKindOf(RDM!Literal)
			else false
			endif
		)
	to hasValue : XML!Element (
		name <- 'owlx:hasValue',
		children <- Sequence { hattr }
		),
	hattr : XML!Attribute (
		name <- 'owlx:name',
		value <- i.hasLiteralValue.lexicalForm
		)
}

-- Rule 'CardinalityRestriction'
-- Create XML Element element (owlx:cardinality) from the RDM CardinalityRestriction element
rule CardinalityRestriction {
	from i : RDM!CardinalityRestriction (
			i.oclIsTypeOf(RDM!CardinalityRestriction)
		)
	to o : XML!Element (
		name <- 'owlx:cardinality',
		children <- Sequence { attr } 
		),
	attr : XML!Attribute (
		name <- 'owlx:value',
		value <- i.cardinality.lexicalForm
		)
}

-- Rule 'MinCardinalityRestriction'
-- Create XML Element element (owlx:minCardinality) from the RDM MinCardinalityRestriction element
rule MinCardinalityRestriction {
	from i : RDM!MinCardinalityRestriction (
			i.oclIsTypeOf(RDM!MinCardinalityRestriction)
		)
	to o : XML!Element (
		name <- 'owlx:minCardinality',
		children <- Sequence { attr } 
		),
	attr : XML!Attribute (
		name <- 'owlx:value',
		value <- i.minCardinality.lexicalForm
		)
}

-- Rule 'MaxCardinalityRestriction'
-- Create XML Element element (owlx:maxCardinality) from the RDM MaxCardinalityRestriction element
rule MaxCardinalityRestriction {
	from i : RDM!MaxCardinalityRestriction (
			i.oclIsTypeOf(RDM!MaxCardinalityRestriction)
		)
	to o : XML!Element (
		name <- 'owlx:maxCardinality',
		children <- Sequence { attr } 
		),
	attr : XML!Attribute (
		name <- 'owlx:value',
		value <- i.maxCardinality.lexicalForm
		)
}

-- Rule 'ObjectRestriction'
-- Create XML Element element (owlx:ObjectRestriction) from the RDM ObjectProperty element
rule ObjectRestriction {
	from i : RDM!ObjectProperty (
			i.oclIsTypeOf(RDM!ObjectProperty) and
			RDM!Atom.allInstancesFrom('IN')->asSequence()->collect(c | c.hasPredicateSymbol)->flatten()->excludes(i)
		)
	to o : XML!Element (
		name <- 'owlx:ObjectRestriction',
		children <- Sequence { attr , i.elementsForProperty }
		),
	attr : XML!Attribute (
		name <- 'owlx:property',
		value <- i.name
		)
}
		
-- Rule 'DataRestriction'
-- Create XML Element element (owlx:DataRestriction) from the RDM DatatypeProperty element
rule DataRestriction {
	from i : RDM!DatatypeProperty (
			i.oclIsTypeOf(RDM!DatatypeProperty) and
			RDM!Atom.allInstancesFrom('IN')->asSequence()->collect(c | c.hasPredicateSymbol)->flatten()->excludes(i)
		)
	to o : XML!Element (
		name <- 'owlx:DataRestriction',
		children <- Sequence { attr , i.elementsForProperty }
		),
	attr : XML!Attribute (
		name <- 'owlx:property',
		value <- i.name
		)
}

-- Lazy Rule 'Class'
-- Create XML Element element (owlx:Class) from the RDM Class element
lazy rule Class {
	from i : RDM!Class 
	to o : XML!Element (
		name <- 'owlx:Class',
		children <- Sequence { attr, i.subClassOf->select(c | c.oclIsKindOf(RDM!Restriction))->collect(c | c.onProperty)->flatten(),
									 i.subClassOf->select(c | not c.oclIsKindOf(RDM!Restriction))
					}
		),
	attr : XML!Attribute (
		name <- 'owlx:name', 
		value <- i.name
		)
}

-- Lazy Rule 'IndividualVariable'
-- Create XML Element element (ruleml:var) from the RDM IndividualVariable element
lazy rule IndividualVariable {
	from i : RDM!IndividualVariable
	to o : XML!Element (
		name <- 'ruleml:var',
		children <- Sequence { txt }
		),
	txt : XML!Text (
		name <- '#text',
		value <- i.name
		)
}

-- Rule 'OneOfIndividual'
-- Create XML Element element (owlx:OneOf) from the RDM EnumeratedClass element
rule OneOfIndividual {
	from i : RDM!EnumeratedClass (
			i.oclIsTypeOf(RDM!EnumeratedClass)
		)
	to o : XML!Element (
		name <- 'owlx:OneOf',
		children <- i.oneOf
		)
}

-- Rule 'OneOfDataValue'
-- Create XML Element element (owlx:OneOf) from the RDM DataRange element
rule OneOfDataValue {
	from i : RDM!DataRange (
			i.oneOf->size() > 0
		)
	to o : XML!Element (
		name <- 'owlx:OneOf',
		children <- i.oneOf
		)
}",atlcompil atl transform rdm swrl owl metamodel xml metamodel creat part m sc these good old ai laboratori author milan milanov milan milanov org work swrl v xml syntax licenc gnu general public licens version modul rdm xml modul templat creat out xml in rdm use string helper helper elementsforproperti return restrict inerhit element restrict properti work object data properti context rdm properti out sequenc rdm restrict helper context rdm properti def elementsforproperti sequenc rdm restrict rdm restrict allinstancesfrom in assequ select c c onproperti includ self assequ rule rule ontolog creat xml root element rdm ontolog element rule ontolog rdm ontolog oclistypeof rdm ontolog xml root children sequenc attr element name swrlx ontolog attr xml attribut name swrlx name valu ontolog rule ruleon creat xml root element rdm rule element rule ruleon rdm rule oclistypeof rdm rule rdm ontolog allinstancesfrom in assequ size xml root name ruleml imp children sequenc owlxn swrlxns rulemln hasanteced hasconsequ owlxn xml attribut name xmlns owlx valu http www w org owl xml swrlxns xml attribut name xmlns swrlx valu http www w org swrlx rulemln xml attribut name xmlns ruleml valu http www w org ruleml rule rulemorethanon creat xml element ruleml imp element rdm rule element rule rulemorethanon rdm rule oclistypeof rdm rule rdm rule allinstancesfrom in assequ size rdm ontolog allinstancesfrom in assequ size xml element name ruleml imp children sequenc owlxn swrlxns rulemln hasanteced hasconsequ owlxn xml attribut name xmlns owlx valu http www w org owl xml swrlxns xml attribut name xmlns swrlx valu http www w org swrlx rulemln xml attribut name xmlns ruleml valu http www w org ruleml rule consequ creat xml element ruleml head element rdm consequ element rule consequ rdm consequ oclistypeof rdm consequ xml element name ruleml head annot this atom consequ anteced e g two classatom two datatypepredicateatom children let thisrul rdm rule rdm rule allinstancesfrom in assequ select c c hasconsequ first containsatom assequ select c thisrul hasanteced containsatom exclud c assequ rule anteced creat xml element ruleml bodi element rdm anteced element rule anteced rdm anteced oclistypeof rdm anteced xml element name ruleml bodi children containsatom atom rule individualpropertyatom creat xml element swrlx individualpropertyatom element rdm atom individualpropertyatom element rule individualpropertyatom rdm atom name individualpropertyatom xml element name swrlx individualpropertyatom children sequenc prop term select c c oclistypeof rdm individualvari collect c thismodul individualvari c term select c c oclistypeof rdm individualvari prop xml attribut name swrlx properti valu haspredicatesymbol name rule classatom creat xml element swrlx classatom element rdm atom classatom element rule classatom rdm atom name classatom xml element name swrlx classatom children sequenc haspredicatesymbol oclistypeof rdm class thismodul class haspredicatesymbol els haspredicatesymbol ocliskindof rdm restrict haspredicatesymbol onproperti els haspredicatesymbol endif endif term assequ select c c oclistypeof rdm individualvari collect e thismodul individualvari e term assequ select c c oclistypeof rdm individualvari rule datarangeatom creat xml element swrlx datarangeatom element rdm atom datarangeatom element rule datarangeatom rdm atom name datarangeatom xml element name swrlx datarangeatom children sequenc haspredicatesymbol ocliskindof rdm restrict haspredicatesymbol onproperti els haspredicatesymbol endif term assequ select c c oclistypeof rdm individualvari collect e thismodul individualvari e term assequ select c c oclistypeof rdm individualvari rule datavaluedpropertyatom creat xml element swrlx datavaluedpropertyatom element rdm atom datavaluedpropertyatom element rule datavaluedpropertyatom rdm atom name datavaluedpropertyatom xml element name swrlx datavaluedpropertyatom children sequenc prop term assequ select c c oclistypeof rdm individualvari collect e thismodul individualvari e term assequ select c c oclistypeof rdm datavari collect e thismodul datavari e term assequ select c c oclistypeof rdm individualvari c oclistypeof rdm datavari prop xml attribut name swrlx properti valu haspredicatesymbol name rule sameindividualatom creat xml element swrlx sameindividualatom element rdm atom sameindividualatom element rule sameindividualatom rdm atom name sameindividualatom xml element name swrlx sameindividualatom children sequenc term assequ select c c oclistypeof rdm individualvari collect e thismodul individualvari e term assequ select c c oclistypeof rdm individualvari rule differentindividualatom creat xml element swrlx differentindividualsatom element rdm atom differentindividualatom element rule differentindividualsatom rdm atom name differentindividualatom xml element name swrlx differentindividualsatom children sequenc term assequ select c c oclistypeof rdm individualvari collect e thismodul individualvari e term assequ select c c oclistypeof rdm individualvari rule builtinatom creat xml element swrlx builtinatom element rdm atom builtinatom element rule builtinatom rdm atom name bulitinatom xml element name swrlx builtinatom children sequenc attr term assequ select c c oclistypeof rdm datavari collect e thismodul datavari e term assequ select c c oclistypeof rdm individualvari collect e thismodul individualvari e term assequ select c c oclistypeof rdm datavari c oclistypeof rdm individualvari attr xml attribut name swrlx builtin valu haspredicatesymbol buildinid lazi rule datavari creat xml element element ruleml var rdm datavari element lazi rule datavari rdm datavari xml element name ruleml var children sequenc txt txt xml text name text valu name lazi rule individu creat xml element element owlx individu rdm individu element rule individu rdm individu oclistypeof rdm individu xml element name owlx individu children sequenc attr attr xml attribut name owlx name valu name rule datatyp creat xml element element owlx datatyp rdm datarang element rule datatyp rdm datarang datatyp oclisundefin xml element name owlx datatyp children sequenc attr attr xml attribut name owlx name valu datatyp name rule datavalu creat xml element element owlx datavalu rdm datavalu element rule datavalu rdm datavalu oclistypeof rdm datavalu xml element name owlx datavalu children sequenc attr txt attr xml attribut name owlx datatyp valu type name txt xml text name text valu valu rule typedliteralofdatarang creat xml element element owlx datavalu rdm typedliter element rule typedliteralofdatarang rdm typedliter rdm datarang allinstancesfrom in assequ collect c c oneof flatten includ xml element name owlx datavalu children sequenc attr txt attr xml attribut name owlx datatyp valu thetyp txt xml text name text valu lexicalform rule intersectionof creat xml element element owlx intersectionof rdm intersectionclass element rule intersectionof rdm intersectionclass oclistypeof rdm intersectionclass xml element name owlx intersectionof children sequenc intersectionof assequ select c c oclistypeof rdm class collect c thismodul class c intersectionof assequ select c c oclistypeof rdm class c ocliskindof rdm restrict collect e e onproperti flatten intersectionof assequ select c c oclistypeof rdm class c ocliskindof rdm restrict rule unionof creat xml element element owlx unionof rdm unionclass element rule unionof rdm unionclass oclistypeof rdm unionclass xml element name owlx unionof children sequenc unionof assequ select c c oclistypeof rdm class collect c thismodul class c unionof assequ select c c oclistypeof rdm class c ocliskindof rdm restrict collect e e onproperti flatten unionof assequ select c c oclistypeof rdm class c ocliskindof rdm restrict rule complementof creat xml element element owlx complementof rdm complementclass element rule complementof rdm complementclass oclistypeof rdm complementclass xml element name owlx complementof children sequenc complementof oclistypeof rdm class thismodul class complementof els complementof ocliskindof rdm restrict complementof onproperti els complementof endif endif rule somevaluesfromattrclass creat xml element element owlx somevaluesfrom rdm somevaluesfromrestrict element rule somevaluesfromattrclass rdm somevaluesfromrestrict somevaluesfromclass oclisundefin somevaluesfromclass oclistypeof rdm class els fals endif somevaluesfrom xml element name owlx somevaluesfrom children sequenc class class xml attribut name owlx class valu somevaluesfromclass name rule somevaluesfromelemclass creat xml element element owlx somevaluesfrom rdm somevaluesfromrestrict element rule somevaluesfromelemclass rdm somevaluesfromrestrict somevaluesfromclass oclisundefin somevaluesfromclass oclistypeof rdm class somevaluesfromclass oclistypeof rdm unionclass true els fals endif els fals endif somevaluesfrom xml element name owlx somevaluesfrom children somevaluesfromclass rule somevaluesfromchild creat xml element element owlx somevaluesfrom rdm somevaluesfromrestrict element rule somevaluesfromchild rdm somevaluesfromrestrict somevaluesfromclass oclisundefin somevaluesfromclass oclistypeof rdm unionclass els fals endif somevaluesfrom xml element name owlx somevaluesfrom children sequenc somevaluesfromclass unionof assequ select c c oclistypeof rdm class collect c thismodul class c somevaluesfromclass unionof assequ select c c oclistypeof rdm class rule somevaluesfromattrdatatyp creat xml element element owlx somevaluesfrom rdm somevaluesfromrestrict element rule somevaluesfromattrdatatyp rdm somevaluesfromrestrict somevaluesfromrang oclisundefin somevaluesfromrang oclistypeof rdm datarang els fals endif somevaluesfrom xml element name owlx somevaluesfrom children sequenc datatyp datatyp xml attribut name owlx datatyp valu somevaluesfromrang datatyp name rule allvaluesfromattrclass creat xml element element owlx allvaluesfrom rdm allvaluesfromrestrict element rule allvaluesfromattrclass rdm allvaluesfromrestrict allvaluesfromclass oclisundefin allvaluesfromclass oclistypeof rdm class els fals endif allvaluesfrom xml element name owlx allvaluesfrom children sequenc class class xml attribut name owlx class valu allvaluesfromclass name rule allvaluesfromattrdatatyp creat xml element element owlx allvaluesfrom rdm allvaluesfromrestrict element rule allvaluesfromattrdatatyp rdm allvaluesfromrestrict allvaluesfromrang oclisundefin allvaluesfromrang oclistypeof rdm datarang els fals endif allvaluesfrom xml element name owlx allvaluesfrom children sequenc datatyp datatyp xml attribut name owlx datatyp valu allvaluesfromrang datatyp name rule allvaluesfromelemclass creat xml element element owlx allvaluesfrom rdm allvaluesfromrestrict element rule allvaluesfromelemclass rdm allvaluesfromrestrict allvaluesfromclass oclisundefin allvaluesfromclass oclistypeof rdm class somevaluesfromclass oclistypeof rdm unionclass true els fals endif els fals endif allvaluesfrom xml element name owlx allvaluesfrom children allvaluesfromclass rule allvaluesfromchild creat xml element element owlx allvaluesfrom rdm allvaluesfromrestrict element rule allvaluesfromchild rdm allvaluesfromrestrict allvaluesfromclass oclisundefin allvaluesfromclass oclistypeof rdm unionclass els fals endif allvaluesfrom xml element name owlx allvaluesfrom children sequenc allvaluesfromclass unionof assequ select c c oclistypeof rdm class collect c thismodul class c allvaluesfromclass unionof assequ select c c oclistypeof rdm class rule hasvalueobject creat xml element element owlx hasvalu rdm hasvaluerestrict element rule hasvalueobject rdm hasvaluerestrict hasvalu oclisundefin hasvalu oclistypeof rdm individu els fals endif hasvalu xml element name owlx hasvalu children sequenc hattr hattr xml attribut name owlx name valu hasvalu name rule hasvaluedata creat xml element element owlx hasvalu rdm hasvaluerestrict element rule hasvaluedata rdm hasvaluerestrict hasliteralvalu oclisundefin hasliteralvalu ocliskindof rdm liter els fals endif hasvalu xml element name owlx hasvalu children sequenc hattr hattr xml attribut name owlx name valu hasliteralvalu lexicalform rule cardinalityrestrict creat xml element element owlx cardin rdm cardinalityrestrict element rule cardinalityrestrict rdm cardinalityrestrict oclistypeof rdm cardinalityrestrict xml element name owlx cardin children sequenc attr attr xml attribut name owlx valu valu cardin lexicalform rule mincardinalityrestrict creat xml element element owlx mincardin rdm mincardinalityrestrict element rule mincardinalityrestrict rdm mincardinalityrestrict oclistypeof rdm mincardinalityrestrict xml element name owlx mincardin children sequenc attr attr xml attribut name owlx valu valu mincardin lexicalform rule maxcardinalityrestrict creat xml element element owlx maxcardin rdm maxcardinalityrestrict element rule maxcardinalityrestrict rdm maxcardinalityrestrict oclistypeof rdm maxcardinalityrestrict xml element name owlx maxcardin children sequenc attr attr xml attribut name owlx valu valu maxcardin lexicalform rule objectrestrict creat xml element element owlx objectrestrict rdm objectproperti element rule objectrestrict rdm objectproperti oclistypeof rdm objectproperti rdm atom allinstancesfrom in assequ collect c c haspredicatesymbol flatten exclud xml element name owlx objectrestrict children sequenc attr elementsforproperti attr xml attribut name owlx properti valu name rule datarestrict creat xml element element owlx datarestrict rdm datatypeproperti element rule datarestrict rdm datatypeproperti oclistypeof rdm datatypeproperti rdm atom allinstancesfrom in assequ collect c c haspredicatesymbol flatten exclud xml element name owlx datarestrict children sequenc attr elementsforproperti attr xml attribut name owlx properti valu name lazi rule class creat xml element element owlx class rdm class element lazi rule class rdm class xml element name owlx class children sequenc attr subclassof select c c ocliskindof rdm restrict collect c c onproperti flatten subclassof select c c ocliskindof rdm restrict attr xml attribut name owlx name valu name lazi rule individualvari creat xml element element ruleml var rdm individualvari element lazi rule individualvari rdm individualvari xml element name ruleml var children sequenc txt txt xml text name text valu name rule oneofindividu creat xml element element owlx oneof rdm enumeratedclass element rule oneofindividu rdm enumeratedclass oclistypeof rdm enumeratedclass xml element name owlx oneof children oneof rule oneofdatavalu creat xml element element owlx oneof rdm datarang element rule oneofdatavalu rdm datarang oneof size xml element name owlx oneof children oneof,6
131,131,P61-MDL2GMF.atl,"-- @atlcompiler atl2006
module MDL2GMF; -- Module Template
create OUT : GMF from INMDL : MDL, INUML : UML, INPROP : Property;
uses MDLHelpers;

helper def: quid2Object : Map(String,MDL!Object)=
	MDL!Object.allInstancesFrom('INMDL')->iterate(e; acc : Map(String, MDL!Object) = Map {} |
		acc->including(e.getValue('quid'),e)
	);
helper def: id2Node : Map(String,MDL!Object)=
	MDL!Object.allInstancesFrom('INMDL')->iterate(e; acc : Map(String, MDL!Object) = Map {} |
		let _type : String = e.type in
		if(_type='ClassView')
			then
			acc->including(e.id.toString(),e)
			else
			acc->including(OclUndefined,e)
		endif
	);
	

--UML LIB--
helper def: quid2Element : Map(String,UML!Element)=
	UML!PackageableElement.allInstancesFrom('INUML')->iterate(e; acc : Map(String, UML!Element) = Map {} |
		let _eAnnotation : GMF!""ecore::EAnnotation""=e.eAnnotations->any(a|true)in
		if(not _eAnnotation.oclIsUndefined())
			then
			acc->including(_eAnnotation.source,e)
			else
			acc->including(OclUndefined,e)
		endif
	);
helper def : getElementById(id : String) : UML!Element =
	thisModule.quid2Element->get(id);
helper def: quid2Generalization : Map(String,UML!Element)=
	UML!Generalization.allInstancesFrom('INUML')->iterate(e; acc : Map(String, UML!Element) = Map {} |
		let _eAnnotation : GMF!""ecore::EAnnotation""=e.eAnnotations->any(a|true)in
		if(not _eAnnotation.oclIsUndefined())
			then
			acc->including(_eAnnotation.source,e)
			else
			acc->including(OclUndefined,e)
		endif
	);
helper def : getGeneralizationById(id : String) : UML!Element =
	thisModule.quid2Generalization->get(id);


rule ClassDiagram {
	from
		o : MDL!Object(
			o.type='ClassDiagram'
			and o.getValue('quid')=Property!Property.allInstancesFrom('INPROP')->any(e|true).value
		)
	to
		m : GMF!Diagram (
			element<-thisModule.getElementById(o.getValue('quid')),
			type<-'UMLClass',
			measurementUnit<-#Pixel,
			children<-o.getOwnedNodes('items'),
			edges<-o.getOwnedEdges('items')
			
		)
		
}

helper context MDL!Object def: x : Integer =
	self.getValue('location').x;

helper context MDL!Object def: y : Integer =
	self.getValue('location').y;

helper context MDL!Object def: width : Integer =
	self.getValue('width');

helper context MDL!Object def: height : Integer =
	self.getValue('height');

helper context MDL!Object def: hasSize : Boolean =
	not (self.width.oclIsUndefined() or self.height.oclIsUndefined());

helper context MDL!Object def: location : TupleType(x : Integer, y : Integer) =
	if self.hasSize then
		Tuple {
			x = (self.x - self.width / 2).round(),
			y = (self.y - self.height / 2).round()
		}
	else
		Tuple {
			x = self.x,
			y = self.y
		}
	endif;

abstract rule NodeView {
	from
		o : MDL!Object(
			o.hasOwnerView(Property!Property.allInstancesFrom('INPROP')->any(e|true).value)
		)
	to		
		g : GMF!Node (
			element<-thisModule.getElementById(o.getValue('quidu')),			
			layoutConstraint<- bound,
			eAnnotations<- eAnn,
			styles<- style
		),		
		eAnn : GMF!""ecore::EAnnotation""(
			source<-'Shortcut',
			details<-mapEntry			
		),
		mapEntry : GMF!""ecore::EStringToStringMapEntry""(
			key<-'modelID',
			value<-'UMLClass'
		),
		bound : GMF!Bounds(
			x<-o.location.x,
			y<- o.location.y
		),
		style : GMF!ShapeStyle(
			lineColor<-o.getValue('line_color'),
			fillColor<-o.getValue('fill_color')
		)
		
}
rule ClassView extends NodeView{
	from
		o : MDL!Object(
			o.type='ClassView'
			and not(o.isStereotypeApplied('Interface')or o.isStereotypeApplied('enumeration'))					
		)
	to
		g : GMF!Node (
			type<-'2001',
			children<-Sequence{label,attributes,operations,inners}
		),
		label : GMF!Node(
			type<-'5003'	
		),
		attributes : GMF!Node(
			type<-'7001'	
		),
		operations : GMF!Node(
			type<-'7002'	
		),
		inners : GMF!Node(
			type<-'7003'	
		)
		
}
rule InterfaceView extends NodeView{
	from
		o : MDL!Object(
			o.type='ClassView'
			and(o.isStereotypeApplied('Interface'))
		)
	to
		g : GMF!Node (
			type<-'2010',
			children<-Sequence{label}
		),
		label : GMF!Node(
			type<-'5012',
			layoutConstraint<-location
		),			
		location : GMF!Location(
		)
		
}
rule EnumerationView extends NodeView{
	from
		o : MDL!Object(
			o.type='ClassView'
			and(o.isStereotypeApplied('enumeration'))
		)
	to
		g : GMF!Node (
			type<-'2003',
			children<-Sequence{label,attributes,operations,literals}
		),
		label : GMF!Node(
			type<-'5005'
		),	
		attributes : GMF!Node(
			type<-'7013'
		),
		operations : GMF!Node(
			type<-'7014'
		),
		literals : GMF!Node(
			type<-'7015'
		)
		
		
}
rule PackageView extends NodeView{
	from
		o : MDL!Object(
			o.type='CategoryView'			
		)
	to
		g : GMF!Node (
			type<-'2002',
			children<-Sequence{label,packages,classifiers,others}
		),
		label : GMF!Node(
			type<-'5004'
		),	
		packages : GMF!Node(
			type<-'7010'
		),
		classifiers : GMF!Node(
			type<-'7011'
		),
		others : GMF!Node(
			type<-'7012'
		)
			
}
rule GeneralizationView {
	from
		o : MDL!Object(
			o.type='InheritView'
			and
			o.hasOwnerView(Property!Property.allInstancesFrom('INPROP')->any(e|true).value)
			
		)
	to		
		g : GMF!Edge (
			type<-'4001',
			source<-thisModule.id2Node->get(o.getValue('client')),
			target<-thisModule.id2Node->get(o.getValue('supplier')),		
			styles<- Sequence{connectorStyle,fontStyle},
			element<-thisModule.getGeneralizationById(o.getValue('quidu')),
			bendpoints<-relativeBendPoints
			
		),
		connectorStyle : GMF!ConnectorStyle(
		),
		fontStyle : GMF!FontStyle(
		),
		relativeBendPoints : GMF!RelativeBendpoints(
		)
}
",atlcompil atl modul mdl gmf modul templat creat out gmf inmdl mdl inuml uml inprop properti use mdlhelper helper def quid object map string mdl object mdl object allinstancesfrom inmdl iter e acc map string mdl object map acc includ e getvalu quid e helper def id node map string mdl object mdl object allinstancesfrom inmdl iter e acc map string mdl object map let type string e type type classview acc includ e id tostr e els acc includ oclundefin e endif uml lib helper def quid element map string uml element uml packageableel allinstancesfrom inuml iter e acc map string uml element map let eannot gmf ecor eannot e eannot true eannot oclisundefin acc includ eannot sourc e els acc includ oclundefin e endif helper def getelementbyid id string uml element thismodul quid element get id helper def quid general map string uml element uml general allinstancesfrom inuml iter e acc map string uml element map let eannot gmf ecor eannot e eannot true eannot oclisundefin acc includ eannot sourc e els acc includ oclundefin e endif helper def getgeneralizationbyid id string uml element thismodul quid general get id rule classdiagram mdl object type classdiagram getvalu quid properti properti allinstancesfrom inprop e true valu gmf diagram element thismodul getelementbyid getvalu quid type umlclass measurementunit pixel children getownednod item edg getownededg item helper context mdl object def x integ self getvalu locat x helper context mdl object def integ self getvalu locat helper context mdl object def width integ self getvalu width helper context mdl object def height integ self getvalu height helper context mdl object def hassiz boolean self width oclisundefin self height oclisundefin helper context mdl object def locat tupletyp x integ integ self hassiz tupl x self x self width round self self height round els tupl x self x self endif abstract rule nodeview mdl object hasownerview properti properti allinstancesfrom inprop e true valu g gmf node element thismodul getelementbyid getvalu quidu layoutconstraint bound eannot eann style style eann gmf ecor eannot sourc shortcut detail mapentri mapentri gmf ecor estringtostringmapentri key modelid valu umlclass bound gmf bound x locat x locat style gmf shapestyl linecolor getvalu line color fillcolor getvalu fill color rule classview extend nodeview mdl object type classview isstereotypeappli interfac isstereotypeappli enumer g gmf node type children sequenc label attribut oper inner label gmf node type attribut gmf node type oper gmf node type inner gmf node type rule interfaceview extend nodeview mdl object type classview isstereotypeappli interfac g gmf node type children sequenc label label gmf node type layoutconstraint locat locat gmf locat rule enumerationview extend nodeview mdl object type classview isstereotypeappli enumer g gmf node type children sequenc label attribut oper liter label gmf node type attribut gmf node type oper gmf node type liter gmf node type rule packageview extend nodeview mdl object type categoryview g gmf node type children sequenc label packag classifi other label gmf node type packag gmf node type classifi gmf node type other gmf node type rule generalizationview mdl object type inheritview hasownerview properti properti allinstancesfrom inprop e true valu g gmf edg type sourc thismodul id node get getvalu client target thismodul id node get getvalu supplier style sequenc connectorstyl fontstyl element thismodul getgeneralizationbyid getvalu quidu bendpoint relativebendpoint connectorstyl gmf connectorstyl fontstyl gmf fontstyl relativebendpoint gmf relativebendpoint,0
132,132,P61-MDL2UML21.atl,"-- @atlcompiler atl2006
module MDL2UML21; -- Module Template
create OUT : UML from IN : MDL;
uses MDLHelpers;

helper def: quid2Object : Map(String,MDL!Object)=
	MDL!Object.allInstancesFrom('IN')->iterate(e; acc : Map(String, MDL!Object) = Map {} |
		acc->including(e.getValue('quid'),e)
	);
	
helper def : multiplicity : Map(String,TupleType(lower: String,upper: String))=
	Map{
		('*',Tuple{lower='0', upper='-1'}),
		('1',Tuple{lower='1', upper='1'}),
		('0..1',Tuple{lower='0', upper='1'})		
	};
	
helper def: primitiveType2OutVar : Map(String, String) =
	Map {
		('String', 'str'),
		('Integer', 'int'),
		('Boolean', 'bool'),
		('Byte', 'byte'),
		('Currency', 'currency'),
		('Date', 'date'),
		('Double', 'double'),
		('Long', 'long'),
		('Object', 'object'),
		('Single', 'single'),
		('Variant', 'variant')
	};
	
helper def: root : MDL!MDLFile =
	MDL!MDLFile.allInstancesFrom('IN')->any(e | true);

rule File {
	from
		f : MDL!MDLFile
	to
		m : UML!Model (
			packagedElement <- f.elements->select(e | e.oclIsTypeOf(MDL!Object))->union(Sequence{uml,rose})
		),
		uml : UML!Package(
			name<- 'UMLPrimitiveTypes',
			packagedElement<- Sequence{str,int,bool}
		),
		rose : UML!Package(
			name<-'RoseDataTypes',
			packagedElement<- Sequence{byte,currency,date,double,long,object,single,variant}
		),
		--UMLPrimitiveTypes
		str : UML!PrimitiveType(
			name<- 'String'
		),
		int : UML!PrimitiveType(
			name<- 'Integer'
		),
		bool : UML!PrimitiveType(
			name<- 'Boolean'
		),
		--RoseDataTypes
		byte : UML!PrimitiveType(
			name<- 'Byte'
		),		
		currency : UML!PrimitiveType(
			name<- 'Currency'
		),		
		date : UML!PrimitiveType(
			name<- 'Date'
		),		
		double : UML!PrimitiveType(
			name<- 'Double'
		),		
		long : UML!PrimitiveType(
			name<- 'Long'
		),		
		object : UML!PrimitiveType(
			name<- 'Object'
		),		
		single : UML!PrimitiveType(
			name<- 'Single'
		),		
		variant : UML!PrimitiveType(
			name<- 'Variant'
		)
		
}

rule Model{
	from
		o : MDL!Object(
			o.type='Design'
		)
	to
		mm : UML!Model(
			name<- o.name,
			packagedElement <- o.properties->any(e | e.name='root_category').value.value
		)					
}
rule Package{
	from
		o : MDL!Object(
			o.type='Class_Category'
		)
	to
		mm : UML!Package(
			name<- o.name,
			packagedElement <- o.properties->select(e | e.name='logical_models'or e.name='logical_presentations' ),
--			packagedElement <- o.properties->any(e |
--								e.name='logical_models'
--							).getAllObjects->union(
--								o.properties->select(e | e.name='logical_presentations')
--							),
			eAnnotations<-annotation
		),
		annotation : UML!""ecore::EAnnotation""(
			source<-o.getValue('quid')
		)
}
rule Diagrams{
	from
		o : MDL!Property(
			o.name='logical_models' 
			or
			o.name='logical_presentations'
		)
	to
		mm : UML!Package(
			name<- o.name,
			packagedElement <- o.getAllObjects
		)
}
rule Class{
	from
		o : MDL!Object(
			o.type='Class'	
			and	o.getValue('stereotype')<>'Interface'
			and	o.getValue('stereotype')<>'primitive'
			and	o.getValue('stereotype')<>'enumeration'
		)
		using{
			associationEnds : Sequence(MDL!Object)= o.getAssociationEnds();
		}
	to
		mm : UML!Class(
			name<- o.name,
			ownedAttribute <- o.getOwnedElements('class_attributes')->including(ends),--->union(o.getAssociationEnds()),
			ownedOperation<- o.getOwnedElements('operations'),
			nestedClassifier<- o.getOwnedElements('nestedClasses'),
			generalization<- o.getOwnedElements('superclasses'),
			interfaceRealization<- o.getOwnedElements('realized_interfaces'),
			clientDependency<-o.getOwnedElements('used_nodes'),
			eAnnotations<-annotation
		),
		annotation : UML!""ecore::EAnnotation""(
			source<-o.getValue('quid')
		),
		ends : distinct UML!Property foreach(e in associationEnds)(
				name<- e.name,
				type<-e.getObjectById(e.getValue('quidu')),
				aggregation<- let _aggregation : Boolean =not (e.getValue('is_aggregate').oclIsUndefined()) in
							  let _containment : String = e.getValue('Containment') in
								if(_aggregation and _containment<>'By Value')
								then
									#shared
								else if(_aggregation and _containment='By Value')
								then
									#composite
								else
									#none
								endif endif,	
				upper<-let _value : TupleType(lower: String,upper: String)=
							thisModule.multiplicity.get(e.getValue('client_cardinality')) in
						if(_value.oclIsUndefined())
						then
							OclUndefined
						else
							_value.upper.toInteger()
						endif,		
				lower<-let _value : TupleType(lower: String,upper: String)=
							thisModule.multiplicity.get(e.getValue('client_cardinality')) in
						if(_value.oclIsUndefined())
						then
							OclUndefined
						else
							_value.lower.toInteger()
						endif,	
								
				association<-thisModule.getOwnerObject(e)
			)
		
}
rule Interface{
	from
		o : MDL!Object(
			o.type='Class'
			and	o.getValue('stereotype')='Interface'
			
		)
	to
		mm : UML!Interface(
			name<- o.name,
			ownedAttribute <- o.getOwnedElements('class_attributes'),
			ownedOperation<- o.getOwnedElements('operations'),
			nestedClassifier<- o.getOwnedElements('nestedClasses'),
			generalization<- o.getOwnedElements('superclasses'),
			eAnnotations<-annotation
		),
		annotation : UML!""ecore::EAnnotation""(
			source<-o.getValue('quid')
		)
}
rule Primitive{
	from
		o : MDL!Object(
			o.type='Class'
			and	o.getValue('stereotype')='primitive'
			
		)
	to
		mm : UML!PrimitiveType(
			name<- o.name
		)
}
rule Enumeration{
	from
		o : MDL!Object(
			o.type='Class'
			and	o.getValue('stereotype')='enumeration'
			
		)
	using{
			ownedLiterals : Sequence(MDL!Object) = o.getOwnedElements('class_attributes');
	}
	to
		mm : UML!Enumeration(
			name<- o.name,
			ownedLiteral <- l	,
			eAnnotations<-annotation
		),
		annotation : UML!""ecore::EAnnotation""(
			source<-o.getValue('quid')
		),
		l : distinct UML!EnumerationLiteral foreach(e in ownedLiterals)(
				name<- e.name
		)	
}
rule Attribute{
	from
		o : MDL!Object(
			o.type='ClassAttribute'
			and (let _object : MDL!Object = thisModule.getOwnerObject(o) in
					if(_object.oclIsUndefined())
					then
						false
					else if(_object.getValue('stereotype')<>'enumeration')
					then
						true
					else
						false
					endif endif)
		)
	to
		mm : UML!Property(
			name<- o.name,
			type<- o.getTypeValueByName('type'),
			default<- o.getValue('initV'),		
			visibility<-	let _value: String =o.getValue('exportControl') in
							if(_value='Public')
							then
								#public
							else if(_value='Protected')
							then
								#protected							
							else if (_value='Implementation')
							then
								#package
							else
								OclUndefined
							endif endif endif,
			isStatic<- if(o.getValue('static')='TRUE')
						then
							true
						else
							false
						endif	,
			isDerived<-if(o.getValue('derived')='TRUE')
						then
							true
						else
							false
						endif
							
		)
}
rule Operation {
	from
		o : MDL!Object(
			o.type='Operation'			
		)
	to
		mm : UML!Operation(
			name<-o.name,
			type<- o.getTypeValueByName('result'),			
			ownedParameter<- o.getOwnedElements('parameters'),
			visibility<-let _value: String =o.getValue('opExportControl') in
							if(_value='Public')
							then
								#public
							else if(_value='Protected')
							then
								#protected							
							else if (_value='Implementation')
							then
								#package
							else
								OclUndefined
							endif endif endif,
			concurrency<- let _value: String =o.getValue('concurrency') in
							if(_value='Sequential')
							then
								#sequential
							else if(_value='Guarded')
							then
								#guarded							
							else if (_value='synchronous')
							then
								#synchronous
							else
								OclUndefined
							endif endif endif,
			isStatic<- if(o.getValue('static')='TRUE')
						then
							true
						else
							false
						endif
			
		)
}
rule Parameter {
	from
		o : MDL!Object(
			o.type='Parameter'			
		)
	to
		mm : UML!Parameter(
			name<-o.name,
			type<-o.getTypeValueByName('type')
		)
}
rule Generalization {
	from 
		o: MDL!Object(
			o.type='Inheritance_Relationship'
		)
	to
		mm : UML!Generalization(
			general<- o.getObjectById(o.getValue('quidu')),
			eAnnotations<-annotation
		),
		annotation : UML!""ecore::EAnnotation""(
			source<-o.getValue('quid')
		)
		
}
rule InterfaceRealization {
	from 
		o: MDL!Object(
			o.type='Realize_Relationship'
		)
	to
		mm : UML!InterfaceRealization(			
			supplier<- o.getObjectById(o.getValue('quidu'))
		)
}
rule Role {
	from
		o : MDL!Object(
			o.type='Role'
			and not o.isNavigable()
		)
	to
		mm : UML!Property(
			name<-o.name,
			type<-o.getObjectById(o.getValue('quidu')),
			aggregation<-let _aggregation : Boolean = not (o.getValue('is_aggregate').oclIsUndefined()) in
							  let _containment : String = o.getValue('Containment') in
								if(_aggregation and _containment<>'By Value')
								then
									#shared
								else if(_aggregation and _containment='By Value')
								then
									#composite
								else
									#none
								endif endif,	
			upper<-let _value : TupleType(lower: String,upper: String)=
							thisModule.multiplicity.get(o.getValue('client_cardinality')) in
						if(_value.oclIsUndefined())
						then
							OclUndefined
						else
							_value.upper.toInteger()
						endif,		
				lower<-let _value : TupleType(lower: String,upper: String)=
							thisModule.multiplicity.get(o.getValue('client_cardinality')) in
						if(_value.oclIsUndefined())
						then
							OclUndefined
						else
							_value.lower.toInteger()
						endif,	
			association<-thisModule.getOwnerObject(o)
			
			
		)
}
rule Association{
	from
		o : MDL!Object(
			o.type='Association'
			and o.getValue('AssociationClass').oclIsUndefined()
		)
	to
		mm : UML!Association(
			name<-o.name,
			ownedEnd<-o.getOwnedElements('roles')->select(e|not e.isNavigable())->asSequence(),
			eAnnotations<-annotation
		),
		annotation : UML!""ecore::EAnnotation""(
			source<-o.getValue('quid')
		)
}
rule AssociationClass{
	from
		o : MDL!Object(
			o.type='Association'
			and not o.getValue('AssociationClass').oclIsUndefined()
		)
	to
		mm : UML!AssociationClass(
			name<-o.name,
			ownedEnd<-o.getOwnedElements('roles')->select(e|not e.isNavigable())->asSequence()
		)
}
rule Dependency{
	from
		o: MDL!Object(
			o.type='Uses_Relationship'
		)
	to
		mm : UML!Dependency(
			supplier<- o.getObjectById(o.getValue('quidu'))
		)
}
rule Diagram {
	from
		o : MDL!Object(
			o.type='ClassDiagram'		
		)
	to
		m : UML!Package (
			name<-o.name,
			eAnnotations<-annotation
		),
		annotation : UML!""ecore::EAnnotation""(
			source<-o.getValue('quid')
		)
		
}
",atlcompil atl modul mdl uml modul templat creat out uml in mdl use mdlhelper helper def quid object map string mdl object mdl object allinstancesfrom in iter e acc map string mdl object map acc includ e getvalu quid e helper def multipl map string tupletyp lower string upper string map tupl lower upper tupl lower upper tupl lower upper helper def primitivetyp outvar map string string map string str integ int boolean bool byte byte currenc currenc date date doubl doubl long long object object singl singl variant variant helper def root mdl mdlfile mdl mdlfile allinstancesfrom in e true rule file f mdl mdlfile uml model packagedel f element select e e oclistypeof mdl object union sequenc uml rose uml uml packag name umlprimitivetyp packagedel sequenc str int bool rose uml packag name rosedatatyp packagedel sequenc byte currenc date doubl long object singl variant umlprimitivetyp str uml primitivetyp name string int uml primitivetyp name integ bool uml primitivetyp name boolean rosedatatyp byte uml primitivetyp name byte currenc uml primitivetyp name currenc date uml primitivetyp name date doubl uml primitivetyp name doubl long uml primitivetyp name long object uml primitivetyp name object singl uml primitivetyp name singl variant uml primitivetyp name variant rule model mdl object type design mm uml model name name packagedel properti e e name root categori valu valu rule packag mdl object type class categori mm uml packag name name packagedel properti select e e name logic model e name logic present packagedel properti e e name logic model getallobject union properti select e e name logic present eannot annot annot uml ecor eannot sourc getvalu quid rule diagram mdl properti name logic model name logic present mm uml packag name name packagedel getallobject rule class mdl object type class getvalu stereotyp interfac getvalu stereotyp primit getvalu stereotyp enumer use associationend sequenc mdl object getassociationend mm uml class name name ownedattribut getownedel class attribut includ end union getassociationend ownedoper getownedel oper nestedclassifi getownedel nestedclass general getownedel superclass interfacer getownedel realiz interfac clientdepend getownedel use node eannot annot annot uml ecor eannot sourc getvalu quid end distinct uml properti foreach e associationend name e name type e getobjectbyid e getvalu quidu aggreg let aggreg boolean e getvalu aggreg oclisundefin let contain string e getvalu contain aggreg contain by valu share els aggreg contain by valu composit els none endif endif upper let valu tupletyp lower string upper string thismodul multipl get e getvalu client cardin valu oclisundefin oclundefin els valu upper tointeg endif lower let valu tupletyp lower string upper string thismodul multipl get e getvalu client cardin valu oclisundefin oclundefin els valu lower tointeg endif associ thismodul getownerobject e rule interfac mdl object type class getvalu stereotyp interfac mm uml interfac name name ownedattribut getownedel class attribut ownedoper getownedel oper nestedclassifi getownedel nestedclass general getownedel superclass eannot annot annot uml ecor eannot sourc getvalu quid rule primit mdl object type class getvalu stereotyp primit mm uml primitivetyp name name rule enumer mdl object type class getvalu stereotyp enumer use ownedliter sequenc mdl object getownedel class attribut mm uml enumer name name ownedliter l eannot annot annot uml ecor eannot sourc getvalu quid l distinct uml enumerationliter foreach e ownedliter name e name rule attribut mdl object type classattribut let object mdl object thismodul getownerobject object oclisundefin fals els object getvalu stereotyp enumer true els fals endif endif mm uml properti name name type gettypevaluebynam type default getvalu initv visibl let valu string getvalu exportcontrol valu public public els valu protect protect els valu implement packag els oclundefin endif endif endif isstat getvalu static true true els fals endif isderiv getvalu deriv true true els fals endif rule oper mdl object type oper mm uml oper name name type gettypevaluebynam result ownedparamet getownedel paramet visibl let valu string getvalu opexportcontrol valu public public els valu protect protect els valu implement packag els oclundefin endif endif endif concurr let valu string getvalu concurr valu sequenti sequenti els valu guard guard els valu synchron synchron els oclundefin endif endif endif isstat getvalu static true true els fals endif rule paramet mdl object type paramet mm uml paramet name name type gettypevaluebynam type rule general mdl object type inherit relationship mm uml general general getobjectbyid getvalu quidu eannot annot annot uml ecor eannot sourc getvalu quid rule interfacer mdl object type realiz relationship mm uml interfacer supplier getobjectbyid getvalu quidu rule role mdl object type role isnavig mm uml properti name name type getobjectbyid getvalu quidu aggreg let aggreg boolean getvalu aggreg oclisundefin let contain string getvalu contain aggreg contain by valu share els aggreg contain by valu composit els none endif endif upper let valu tupletyp lower string upper string thismodul multipl get getvalu client cardin valu oclisundefin oclundefin els valu upper tointeg endif lower let valu tupletyp lower string upper string thismodul multipl get getvalu client cardin valu oclisundefin oclundefin els valu lower tointeg endif associ thismodul getownerobject rule associ mdl object type associ getvalu associationclass oclisundefin mm uml associ name name ownedend getownedel role select e e isnavig assequ eannot annot annot uml ecor eannot sourc getvalu quid rule associationclass mdl object type associ getvalu associationclass oclisundefin mm uml associationclass name name ownedend getownedel role select e e isnavig assequ rule depend mdl object type use relationship mm uml depend supplier getobjectbyid getvalu quidu rule diagram mdl object type classdiagram uml packag name name eannot annot annot uml ecor eannot sourc getvalu quid,18
133,133,P62-PathExp2PetriNet.atl,"module PathExp2PetriNet;
create OUT : PetriNet from IN : PathExp;


-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------


-- This helper computes the Set containing all the Transitions of the input
-- PathExp model.
-- CONTEXT: thisModule
-- RETURN:	Set(PathExp!Transition)
helper def: allTransitions : Set(PathExp!Transition) = 
	PathExp!Transition.allInstances();


-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------


-- Rule 'Main'
-- This rule generates a PetriNet element from the input PathExp element.
-- The name of the generated PetriNet is copied from the input PathExp element.
-- Its set of places and its set of transitions respectively correspond to the
-- elements generated for states and the transitions of the input PathExp.
-- Its set of arcs correspond to the 'pn_ia' and 'pn_oa' elements generated for
-- the input Transition elements.
rule Main {
	from
        pe : PathExp!PathExp
	to 
		pn : PetriNet!PetriNet (
			name <- pe.name,
			places <- pe.states,
			transitions <- pe.transitions,
			arcs <- thisModule.allTransitions
						->collect(e | thisModule.resolveTemp(e, 'pn_ia'))
						->union(
							thisModule.allTransitions
							->collect(e | thisModule.resolveTemp(e, 'pn_oa'))
						)
		)
}


-- Rule 'State'
-- This rule generates a Place element from an input State element.
-- Generated Place accepts an empty string as name.
-- Its set of incoming arcs correspond to 'pn_oa' elements that are generated
-- for the incoming Transitions of the input State.
-- Its set of outgoing arcs correspond to 'pn_ia' elements that are generated
-- for the outgoing Transitions of the input State.
rule State {
	from
       pe_s : PathExp!State
	to 
		pn_p : PetriNet!Place (
			name <- '',
			incoming <-	pe_s.incoming
							->collect(e | thisModule.resolveTemp(e, 'pn_oa')),
			outgoing <- pe_s.outgoing
							->collect(e | thisModule.resolveTemp(e, 'pn_ia'))
		)
}


-- Rule 'Transition'
-- From an input PathExp Transition, this rule generates:
--  * a PetriNet Transition
--  * a PlaceToTransArc
--  * a TransToPlaceArc
-- The generated Transition accepts an empty string as name, the generated
-- 'pn_ia' PlaceToTransArc as incoming arc, and the generated 'pn_oa'
-- TransToPlaceArc as outgoing arc.
-- The generated PlaceToTransArc accepts the element generated for the source
-- of the input PathExpTransition as source, and the generated PetriNet
-- Transition as target.
-- The generated TransToPlaceArc accepts the generated PetriNet Transition as
-- source, and the element generated for the target of the input
-- PathExpTransition as target.
rule Transition {
	from
       pe_t : PathExp!Transition
	to 
		pn_t : PetriNet!Transition (
			name <- '',
			incoming <- pn_ia,
			outgoing <- pn_oa
		),
		
		pn_ia : PetriNet!PlaceToTransArc (
			source <- pe_t.source,
			target <- pn_t,
			weight <- 1
		),
		
		pn_oa : PetriNet!TransToPlaceArc (
			source <- pn_t,
			target <- pe_t.target,
			weight <- 1			
		)
}

",modul pathexp petrinet creat out petrinet in pathexp helper this helper comput set contain transit input pathexp model context thismodul return set pathexp transit helper def alltransit set pathexp transit pathexp transit allinst rule rule main this rule generat petrinet element input pathexp element the name generat petrinet copi input pathexp element it set place set transit respect correspond element generat state transit input pathexp it set arc correspond pn ia pn oa element generat input transit element rule main pe pathexp pathexp pn petrinet petrinet name pe name place pe state transit pe transit arc thismodul alltransit collect e thismodul resolvetemp e pn ia union thismodul alltransit collect e thismodul resolvetemp e pn oa rule state this rule generat place element input state element generat place accept empti string name it set incom arc correspond pn oa element generat incom transit input state it set outgo arc correspond pn ia element generat outgo transit input state rule state pe pathexp state pn p petrinet place name incom pe incom collect e thismodul resolvetemp e pn oa outgo pe outgo collect e thismodul resolvetemp e pn ia rule transit from input pathexp transit rule generat petrinet transit placetotransarc transtoplacearc the generat transit accept empti string name generat pn ia placetotransarc incom arc generat pn oa transtoplacearc outgo arc the generat placetotransarc accept element generat sourc input pathexptransit sourc generat petrinet transit target the generat transtoplacearc accept generat petrinet transit sourc element generat target input pathexptransit target rule transit pe pathexp transit pn petrinet transit name incom pn ia outgo pn oa pn ia petrinet placetotransarc sourc pe sourc target pn weight pn oa petrinet transtoplacearc sourc pn target pe target weight,3
134,134,P62-PathExp2TextualPathExp.atl,"module PathExp2TextualPathExp;
create OUT : TextualPathExp from IN : PathExp;


-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- This helper computes the root State of the input PathExp model.
-- To this end, it selects among all State instances the one that has no
-- incoming transition.
-- CONTEXT: thisModule
-- RETURN:	PathExp!State
helper def: rootState : PathExp!State =
	PathExp!State.allInstances()
		->select(s | s.incoming->isEmpty())
		->asSequence()
		->first();


-- This helper computes a boolean value stating whether a loop transition is
-- defined for the contextual State.
-- For this purpose, the helper checks if there exists an incoming transition
-- whose source is the contextual State.
-- CONTEXT: PathExp!State
-- RETURN:	Boolean
helper context PathExp!State def: existLoop() : Boolean =
	self.incoming
		->select(e | e.source = self)
		->notEmpty();


-- This helper returns the loop Transition defined for the contextual State.
-- To this end, it returns the first incoming transition that has the
-- contextual State as source.
-- PRECOND:	a loop transition must be defined for the contextual State.
-- CONTEXT: PathExp!State
-- RETURN:	PathExp!Transition
helper context PathExp!State def: getLoop() : PathExp!Transition =
	self.incoming
		->select(e | e.source = self)
		->asSequence()
		->first();


-- This helper computes the set of non-loop incoming transitions of the
-- contextual State.
-- To this end, it selects among incoming transitions the ones that do not
-- target the contextual State.
-- CONTEXT: PathExp!State
-- RETURN:	Sequence(PathExp!Transition)
helper context PathExp!State def: getInT() : Sequence(PathExp!Transition) =
	self.incoming
		->select(e | e.source <> self)
		->asSequence();


-- This helper computes the set of non-loop outgoing transitions of the
-- contextual State.
-- To this end, it selects among outgoing transitions the ones that do not
-- target the contextual State.
-- CONTEXT: PathExp!State
-- RETURN:	Sequence(PathExp!Transition)
helper context PathExp!State def: getOutT() : Sequence(PathExp!Transition) =
	self.outgoing
		->select(e | e.target <> self)
		->asSequence();

	
-- This helper computes the set of States whose transitions lead to the
-- contextual State (except the contextual State if it is reachable from itself
-- by means of a loop transitions).
-- For this purpose, the helper simply collects the source of the transitions
-- returned by the call of the 'getInT' helper onto the contextual State.
-- CONTEXT: PathExp!State
-- RETURN:	Sequence(PathExp!State)
helper context PathExp!State def: getPrevStates() : Sequence(PathExp!State) =
	self.getInT()->collect(e | e.source);


-- This helper computes the set of States that can be reached by means of
-- outgoing transitions of the contextual State (except the contextual State
-- if it is reachable from itself through a loop transitions).
-- For this purpose, the helper simply collects the target of the transitions
-- returned by the call of the 'getOutT' helper onto the contextual State.
-- CONTEXT: PathExp!State
-- RETURN:	Sequence(PathExp!State)
helper context PathExp!State def: getNextStates() : Sequence(PathExp!State) =
	self.getOutT()->collect(e | e.target);


-- This helper computes the sequence of both Path!State and Path!Transition
-- input elements that correspond to the transitions of the Path initiated by
-- the contextual State.
-- The helper accepts a Boolean parameter that encodes the fact that what
-- cooresponds to a nested alternative transition has just been parsed. The
-- helper is initially called with false as parameter.
--  * A contextual State with several non-loop incoming transitions along with
--    a false nested parameter, identifies the end of the current Path. The
--    helper therefore returns an empty sequence.
--  * If the contextual State has several non-loop outgoing transitions with a
--    true along with a nested parameter, this identifies the beginning of a
--    new nested alternative transition within the current Path. The helper
--    then returns a sequence made of 1) the loop transition of the contextual
--    State, if it is defined, 2) the contextual State itself, and 3) the
--    sequence returned by a recursive call of 'getTransitionsFromState' on the
--    state that closes the new alternative transition (it is computed by the
--    'findNextState' helper), with the nested parameter set to true.
--  * If the contextual State has a single non-loop outgoing transition, the
--    helper returns a sequence made of 1) the loop transition of the
--    contextual State, if it is defined, 2) the outgoing transition of the
--    contextual State, and 3) the sequence returned by a recursive call of
--    'getTransitionsFromState' onto the the next state of the contextual
--    State, with the nested parameter set to false.
--  * Finally, a contextual State with no outgoing Transitions indicates the
--    end of the input PathExp and (also) of the current Path. The  helper
--    therefore returns an empty sequence.
--
-- NOTE: the result type of the helper is currently encoded as a sequence of
-- strings since 1) the oclAny type is not implemented yet 2) and no type
-- verifications are performed by the current atl version.
--
-- CONTEXT: PathExp!State
-- IN:		Boolean
-- RETURN:	Sequence(oclAny)
helper context PathExp!State
	def: getTransitionsFromState(nested : Boolean) : Sequence(String) =
	let nextStates : Sequence(PathExp!State) = self.getNextStates()
	in let prevStates : Sequence(PathExp!State) = self.getPrevStates()
	in let loop : Sequence(PathExp!Transition) =
		if self.existLoop() then
			self.getLoop()
		else
			Sequence{}
		endif
	in

	if prevStates->size() > 1 and not nested then
		Sequence{}
	else
		if nextStates->size() > 1 then
			let state : PathExp!State = nextStates->first().findNextState(0)
			in Sequence{
					loop,
					self,
					state.getTransitionsFromState(true)
				}->flatten()
		else
			if nextStates->size() = 1 then
				Sequence{
					loop,
					self.getOutT()->first(),
					nextStates->first().getTransitionsFromState(false)
				}->flatten()
			else
				Sequence{}
			endif
		endif
	endif;
			
		
-- This helper computes the sequence of both Path!State and Path!Transition
-- input elements that correspond to the transitions of the Path initiated by
-- the contextual Transition.
-- The returned sequence is composed of the contextual transition followed by
-- the result of the call of the 'getTransitionsFromState' helper onto the
-- target of this contextual transition.
--
-- NOTE: the result type of the helper is currently encoded as a sequence of
-- strings since 1) the oclAny type is not implemented yet 2) and no type
-- verifications are performed by the current atl version.
--
-- CONTEXT: PathExp!State
-- RETURN:	Sequence(oclAny)
helper context PathExp!Transition
	def: getTransitionsFromTrans() : Sequence(String) =
	Sequence{self, self.target.getTransitionsFromState(false)}->flatten();


-- This helper aims to compute the State that closes the alternative transition
-- that is started at the contextual State of the initial call.
-- It accepts an Integer as parameter which indicates the number of opened
-- nested alternative transitions. It is initially called with n = 0.
-- In order to compute its closing State, the helper recursively parses the
-- Path:
--  * if the contextual State has more than one incoming transition and no
--    nested alternative trans. are opened (n=0), the helper returns the
--    contextualState.
--  * if the contextual State has more than one incoming transition and more
--    than one outgoing transition, the helper returns the value provided by
--    the recursive call of 'findNextState(n)' onto one of the next states of
--    the contextual state.
--  * if the contextual State has more than one incoming transition but a
--    single outgoing transition, the helper returns the value provided by the
--    recursive call of 'findNextState(n-1)' onto the next state of the
--    contextual state.
--  * if the contextual State has a single incoming transition and more than
--    one outgoing transition, the helper returns the value provided by the
--    'findNextState(n+1)' onto one of the next states of the contextual state.
--  * finally, if the contextual State has a single incoming transition and a
--    single outgoing transition, the helper returns the value provided by the
--    recursive call of 'findNextState(n+)' onto the next state of the
--    contextual state.
-- CONTEXT: PathExp!State
-- IN:		Integer
-- RETURN:	PathExp!State
helper context PathExp!State def: findNextState(n : Integer) : PathExp!State =
	let prevStates : Sequence(PathExp!State) = self.getPrevStates() in
	let nextStates : Sequence(PathExp!State) = self.getNextStates() in
	if prevStates->size() > 1 and n = 0 then
		self
	else
		if prevStates->size() > 1 then
			if nextStates->size() > 1 then
				nextStates->first().findNextState(n)
			else
				nextStates->first().findNextState(n-1)
			endif
		else
			if nextStates->size() > 1 then
				nextStates->first().findNextState(n+1)
			else
				nextStates->first().findNextState(n)
			endif
		endif
	endif;

		
-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'Main'
-- This rule generates both a TextualPathExp and its main Path from the root
-- PathExp input element.
-- The generated TextualPathExp accepts the Path generated by the rule as path.
-- The sequence of transitions contained by the generated Path is returned by
-- the call of the 'getTransitionsFromState' helper onto the root State element
-- of the input model.
rule Main {
	from
        pe : PathExp!PathExp
	to 
		tpe : TextualPathExp!TextualPathExp (
			path <- p
		),
		
		p : TextualPathExp!Path (
			transitions <- thisModule.rootState.getTransitionsFromState(false)
		)
}


-- Rule 'Loop'
-- This rule generates a multiple PrimitiveTrans from a loop Transition.
-- The generated PrimitiveTrans accepts an empty string as name. Its
-- 'isMultiple' attribute is set to 'true'.
rule Loop {
	from
       t : PathExp!Transition (
        	t.source = t.target
       )
	to 
		pt : TextualPathExp!PrimitiveTrans (
			name <- '',
			isMultiple <- true
		)
}


-- Rule 'STransition'
-- This rule generates a simple PrimitiveTrans from a non-loop transition
-- which is the only outgoing transition of its source State.
-- The generated PrimitiveTrans accepts an empty string as name. Its
-- 'isMultiple' attribute is set to 'false'.
rule STransition {
	from
       t : PathExp!Transition (
        	t.source <> t.target and 
        	t.source.getOutT()->size() = 1
       )
	to 
		pt : TextualPathExp!PrimitiveTrans (
			name <- '',
			isMultiple <- false
		)
}


-- Rule 'MTransition'
-- This rule generates a simple PrimitiveTrans from a non-loop transition
-- which is NOT the only outgoing transition of its source State.
-- The generated PrimitiveTrans accepts an empty string as name. Its
-- 'isMultiple' attribute is set to 'false'.
rule MTransition {
	from
       t : PathExp!Transition (
        	t.source <> t.target and 
        	t.source.getOutT()->size() > 1
       )
	to 
		pt : TextualPathExp!PrimitiveTrans (
			name <- '',
			isMultiple <- false
		)
}


-- Rule 'State'
-- This rule generates both an AlternativeTransition and the different Paths
-- that compose that compose this alternative transition from an input State
-- that has multiple non-loop outgoing Transitions.
-- Paths of the generated AlternativeTransition are those that are generated
-- by the rule. Its 'isMultiple' attribute is set to 'false'.
-- A distinct Path is generated for each non-loop outgoing Transition of the
-- input State. The sequence of transitions that is assigned to a generated
-- Path is the corresponding (ie. at same rank) sequence of model elements in
-- the 'transitions2' sequence (calculated in the using clause).
rule State {
	from
        s : PathExp!State (
        	s.getOutT()->size() > 1
        )
	using {
    	transitions2 : Sequence(String) =
    		s.getOutT()->collect(e | e.getTransitionsFromTrans());    	
	}
	to 
		at : TextualPathExp!AlternativeTrans (
			altPaths <- paths,
			isMultiple <- false
		),
		
		paths : distinct TextualPathExp!Path foreach(e in transitions2) (
			transitions <- transitions2
		)
}
",modul pathexp textualpathexp creat out textualpathexp in pathexp helper this helper comput root state input pathexp model to end select among state instanc one incom transit context thismodul return pathexp state helper def rootstat pathexp state pathexp state allinst select incom isempti assequ first this helper comput boolean valu state whether loop transit defin contextu state for purpos helper check exist incom transit whose sourc contextu state context pathexp state return boolean helper context pathexp state def existloop boolean self incom select e e sourc self notempti this helper return loop transit defin contextu state to end return first incom transit contextu state sourc precond loop transit must defin contextu state context pathexp state return pathexp transit helper context pathexp state def getloop pathexp transit self incom select e e sourc self assequ first this helper comput set non loop incom transit contextu state to end select among incom transit one target contextu state context pathexp state return sequenc pathexp transit helper context pathexp state def getint sequenc pathexp transit self incom select e e sourc self assequ this helper comput set non loop outgo transit contextu state to end select among outgo transit one target contextu state context pathexp state return sequenc pathexp transit helper context pathexp state def getoutt sequenc pathexp transit self outgo select e e target self assequ this helper comput set state whose transit lead contextu state except contextu state reachabl mean loop transit for purpos helper simpli collect sourc transit return call getint helper onto contextu state context pathexp state return sequenc pathexp state helper context pathexp state def getprevst sequenc pathexp state self getint collect e e sourc this helper comput set state reach mean outgo transit contextu state except contextu state reachabl loop transit for purpos helper simpli collect target transit return call getoutt helper onto contextu state context pathexp state return sequenc pathexp state helper context pathexp state def getnextst sequenc pathexp state self getoutt collect e e target this helper comput sequenc path state path transit input element correspond transit path initi contextu state the helper accept boolean paramet encod fact coorespond nest altern transit pars the helper initi call fals paramet a contextu state sever non loop incom transit along fals nest paramet identifi end current path the helper therefor return empti sequenc if contextu state sever non loop outgo transit true along nest paramet identifi begin new nest altern transit within current path the helper return sequenc made loop transit contextu state defin contextu state sequenc return recurs call gettransitionsfromst state close new altern transit comput findnextst helper nest paramet set true if contextu state singl non loop outgo transit helper return sequenc made loop transit contextu state defin outgo transit contextu state sequenc return recurs call gettransitionsfromst onto next state contextu state nest paramet set fals final contextu state outgo transit indic end input pathexp also current path the helper therefor return empti sequenc note result type helper current encod sequenc string sinc oclani type implement yet type verif perform current atl version context pathexp state in boolean return sequenc oclani helper context pathexp state def gettransitionsfromst nest boolean sequenc string let nextstat sequenc pathexp state self getnextst let prevstat sequenc pathexp state self getprevst let loop sequenc pathexp transit self existloop self getloop els sequenc endif prevstat size nest sequenc els nextstat size let state pathexp state nextstat first findnextst sequenc loop self state gettransitionsfromst true flatten els nextstat size sequenc loop self getoutt first nextstat first gettransitionsfromst fals flatten els sequenc endif endif endif this helper comput sequenc path state path transit input element correspond transit path initi contextu transit the return sequenc compos contextu transit follow result call gettransitionsfromst helper onto target contextu transit note result type helper current encod sequenc string sinc oclani type implement yet type verif perform current atl version context pathexp state return sequenc oclani helper context pathexp transit def gettransitionsfromtran sequenc string sequenc self self target gettransitionsfromst fals flatten this helper aim comput state close altern transit start contextu state initi call it accept integ paramet indic number open nest altern transit it initi call n in order comput close state helper recurs pars path contextu state one incom transit nest altern tran open n helper return contextualst contextu state one incom transit one outgo transit helper return valu provid recurs call findnextst n onto one next state contextu state contextu state one incom transit singl outgo transit helper return valu provid recurs call findnextst n onto next state contextu state contextu state singl incom transit one outgo transit helper return valu provid findnextst n onto one next state contextu state final contextu state singl incom transit singl outgo transit helper return valu provid recurs call findnextst n onto next state contextu state context pathexp state in integ return pathexp state helper context pathexp state def findnextst n integ pathexp state let prevstat sequenc pathexp state self getprevst let nextstat sequenc pathexp state self getnextst prevstat size n self els prevstat size nextstat size nextstat first findnextst n els nextstat first findnextst n endif els nextstat size nextstat first findnextst n els nextstat first findnextst n endif endif endif rule rule main this rule generat textualpathexp main path root pathexp input element the generat textualpathexp accept path generat rule path the sequenc transit contain generat path return call gettransitionsfromst helper onto root state element input model rule main pe pathexp pathexp tpe textualpathexp textualpathexp path p p textualpathexp path transit thismodul rootstat gettransitionsfromst fals rule loop this rule generat multipl primitivetran loop transit the generat primitivetran accept empti string name it ismultipl attribut set true rule loop pathexp transit sourc target pt textualpathexp primitivetran name ismultipl true rule stransit this rule generat simpl primitivetran non loop transit outgo transit sourc state the generat primitivetran accept empti string name it ismultipl attribut set fals rule stransit pathexp transit sourc target sourc getoutt size pt textualpathexp primitivetran name ismultipl fals rule mtransit this rule generat simpl primitivetran non loop transit not outgo transit sourc state the generat primitivetran accept empti string name it ismultipl attribut set fals rule mtransit pathexp transit sourc target sourc getoutt size pt textualpathexp primitivetran name ismultipl fals rule state this rule generat alternativetransit differ path compos compos altern transit input state multipl non loop outgo transit path generat alternativetransit generat rule it ismultipl attribut set fals a distinct path generat non loop outgo transit input state the sequenc transit assign generat path correspond ie rank sequenc model element transit sequenc calcul use claus rule state pathexp state getoutt size use transit sequenc string getoutt collect e e gettransitionsfromtran textualpathexp alternativetran altpath path ismultipl fals path distinct textualpathexp path foreach e transit transit transit,0
135,135,P62-PetriNet2PathExp.atl,"module PetriNet2PathExp;
create OUT : PathExp from IN : PetriNet;


-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'Main'
-- This rule generates a PathExp from the input PetriNet element.
-- Name of the generated PathExp is copied from the PetriNet one.
-- Its set of states and transitions respectively correspond to the elements
-- that are generated for the input Places and Transitions.
rule Main {
	from
        pn : PetriNet!PetriNet
	to 
		pe : PathExp!PathExp (
			name <- pn.name,
			states <- pn.places,
			transitions <- pn.transitions
		)
}


-- Rule 'Place'
-- This rule generates State for each input Place element.
-- The set of incoming transitions of the generated Place corresponds to the
-- elements generated for Transitions that are source of the incoming
-- PetriNet!Arc.
-- The set of outgoing transitions of the generated Place corresponds to the
-- elements generated for Transitions that are tagret of the outgoing
-- PetriNet!Arc.
rule Place {
	from
        pn_p : PetriNet!Place
	to 
		pe_s : PathExp!State (
			incoming <- pn_p.incoming
							->collect(e | e.source)
							->flatten(),
			outgoing <- pn_p.outgoing
							->collect(e | e.target)
							->flatten()
		)
}


-- Rule 'Transition'
-- This rule generates a PathExp!Transition for each PetriNet!Transition.
-- Source of the generated Transition corresponds to the element generated for
-- the Place that is the source of the incoming PetriNet!Arc.
-- Target of the generated Transition corresponds to the element generated for
-- the Place that is the target of the outgoing PetriNet!Arc.
rule Transition {
	from
        pn_t : PetriNet!Transition
	to 
		pe_t : PathExp!Transition (
			name <- '',
			source <- pn_t.incoming
						->collect(e | e.source)
						->flatten()
						->first(),
			target <- pn_t.outgoing
						->collect(e | e.target)
						->flatten()
						->first()
		)
}

",modul petrinet pathexp creat out pathexp in petrinet rule rule main this rule generat pathexp input petrinet element name generat pathexp copi petrinet one it set state transit respect correspond element generat input place transit rule main pn petrinet petrinet pe pathexp pathexp name pn name state pn place transit pn transit rule place this rule generat state input place element the set incom transit generat place correspond element generat transit sourc incom petrinet arc the set outgo transit generat place correspond element generat transit tagret outgo petrinet arc rule place pn p petrinet place pe pathexp state incom pn p incom collect e e sourc flatten outgo pn p outgo collect e e target flatten rule transit this rule generat pathexp transit petrinet transit sourc generat transit correspond element generat place sourc incom petrinet arc target generat transit correspond element generat place target outgo petrinet arc rule transit pn petrinet transit pe pathexp transit name sourc pn incom collect e e sourc flatten first target pn outgo collect e e target flatten first,3
136,136,P62-PetriNet2XML.atl,"module PetriNet2XML;
create OUT : XML from IN : PetriNet;


-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------


-- This helper computes a Sequence that contains all the Places of the input
-- PetriNet model.
-- CONTEXT: thisModule
-- RETURN:	Sequence(PetriNet!Place)
helper def: allPlaces : Sequence(PetriNet!Place) = 
	PetriNet!Place.allInstances()->asSequence();


-- This helper computes a Sequence that contains all the Transitions of the
-- input PetriNet model.
-- CONTEXT: thisModule
-- RETURN:	Sequence(PetriNet!Transition)
helper def: allTransitions : Sequence(PetriNet!Transition) = 
	PetriNet!Transition.allInstances()->asSequence();


-- This helper computes a Sequence that contains all the Arcs of the input
-- PetriNet model.
-- CONTEXT: thisModule
-- RETURN:	Sequence(PetriNet!Arc)
helper def: allArcs : Sequence(PetriNet!Arc) = 
	PetriNet!Arc.allInstances()->asSequence();


-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------


-- Rule 'Main'
-- This rule generates the ""pnml"" root tag from the input PetriNet element.
-- This tag has an ""xmlns"" attribute and a ""net"" element as child element.
-- The ""net"" tag has an ""id"", a ""type"" and a ""name"" attributes, and the
-- following children elements:
--  * a ""place"" element for each Place of the input PetriNet model
--  * a ""transition"" element for each Transition of the input PetriNet model
--  * an ""arc"" element for each Arc of the input PetriNet model.
rule Main {
	from
        pn : PetriNet!PetriNet
	to 
		root : XML!Root (
			name <- 'pnml',
			children <- Sequence{xmlns, net}
		),
		xmlns: XML!Attribute (
			name <- 'xmlns',
			value <- 'http://www.example.org/pnpl'
		),
		
		net : XML!Element (
			name <- 'net',
			children <- Sequence{
							id,
							type,
							name,
							thisModule.allPlaces,
							thisModule.allTransitions,
							thisModule.allArcs
						}
		),
		id : XML!Attribute (
			name <- 'id',
			value <- 'n1'
		),
		type : XML!Attribute (
			name <- 'type',
			value <- 'http://www.example.org/pnpl/PTNet'
		),
		
		name : XML!Element (
			name <- 'name',
			children <- Sequence{text}
		),
		text : XML!Element (
			name <- 'text',
			children <- Sequence{val}
		),
		val : XML!Text (
			value <- pn.name
		)
}


-- Rule 'Place'
-- This rule generates a ""place"" tag from an input Place element.
-- This tag has an ""id"" attribute which value corresponds to the Place rank
-- within the allPlaces sequence.
-- The ""place"" tag also has a ""name"" child element, which has itself a ""text""
-- child element that contains the name of the place (copied from the input
-- Place element).
rule Place {
	from
        pn_s : PetriNet!Place
	to 
		xml_place : XML!Element (
			name <- 'place',
			children <- Sequence{id, name}
		),
		id : XML!Attribute (
			name <- 'id',
			value <- thisModule.allPlaces->indexOf(pn_s).toString()
		),
		
		name : XML!Element (
			name <- 'name',
			children <- Sequence{text}
		),
		text : XML!Element (
			name <- 'text',
			children <- Sequence{val}
		),
		val : XML!Text (
			value <- pn_s.name
		)
}


-- Rule 'Transition'
-- This rule generates a ""transition"" tag from an input Transition element.
-- This tag has an ""id"" attribute which value corresponds to (the size of the
-- allPlaces sequence + the Transition rank within the allTransitions
-- sequence).
rule Transition {
	from
       pn_t : PetriNet!Transition
	to 
		xml_trans : XML!Element (
			name <- 'transition',
			children <- Sequence{trans_id}
		),
		trans_id : XML!Attribute (
			name <- 'id',
			value <- (thisModule.allPlaces->size() +
					  thisModule.allTransitions->indexOf(pn_t)).toString()
		)
}


-- Rule 'PlaceToTransArc'
-- This rule generates an ""arc"" tag from an input PlaceToTransArc element.
-- This tag has an ""id"", a ""source"" and a ""target"" attributes.
-- Value of the ""id"" attribute corresponds to (the size of the allPlaces
-- sequence + the size of the allTransitions sequence + the Arc rank within
-- the allArcs sequence).
-- Value of the ""source"" attribute corresponds to the source Place rank
-- within the allPlaces sequence.
-- Value of the ""target"" attribute corresponds to (the size of the allPlaces
-- sequence + the target Transition rank within the allTransitions sequence).
rule PlaceToTransArc {
	from
		pn_a : PetriNet!PlaceToTransArc
	to 
		xml_arc : XML!Element (
			name <- 'arc',
			children <- Sequence{id, source, target}
		),
		id : XML!Attribute (
			name <- 'id',
			value <- (thisModule.allPlaces->size() +
					  thisModule.allTransitions->size() +
					  thisModule.allArcs->indexOf(pn_a)).toString()
		),
		source : XML!Attribute (
			name <- 'source',
			value <- thisModule.allPlaces
						->indexOf(pn_a.source).toString()
		),
		target : XML!Attribute (
			name <- 'target',
			value <- (thisModule.allPlaces->size() + 
					  thisModule.allTransitions
						->indexOf(pn_a.target)).toString()
		)
}


-- Rule 'TransToPlaceArc'
-- This rule generates an ""arc"" tag from an input TransToPlaceArc element.
-- This tag has an ""id"", a ""source"" and a ""target"" attributes.
-- Value of the ""id"" attribute corresponds to (the size of the allPlaces
-- sequence + the size of the allTransitions sequence + the Arc rank within
-- the allArcs sequence).
-- Value of the ""source"" attribute corresponds to (the size of the allPlaces
-- sequence + the source Transition rank within the allTransitions sequence).
-- Value of the ""target"" attribute corresponds to the target Place rank
-- within the allPlaces sequence.
rule TransToPlaceArc {
	from
		pn_a : PetriNet!TransToPlaceArc
	to 
		xml_arc : XML!Element (
			name <- 'arc',
			children <- Sequence{id, source, target}
		),
		id : XML!Attribute (
			name <- 'id',
			value <- (thisModule.allPlaces->size() +
					  thisModule.allTransitions->size() +
					  thisModule.allArcs->indexOf(pn_a)).toString()
		),
		source : XML!Attribute (
			name <- 'source',
			value <- (thisModule.allPlaces->size() + 
					  thisModule.allTransitions
						->indexOf(pn_a.source)).toString()
		),
		target : XML!Attribute (
			name <- 'target',
			value <- thisModule.allPlaces
						->indexOf(pn_a.target).toString()
		)
}
",modul petrinet xml creat out xml in petrinet helper this helper comput sequenc contain place input petrinet model context thismodul return sequenc petrinet place helper def allplac sequenc petrinet place petrinet place allinst assequ this helper comput sequenc contain transit input petrinet model context thismodul return sequenc petrinet transit helper def alltransit sequenc petrinet transit petrinet transit allinst assequ this helper comput sequenc contain arc input petrinet model context thismodul return sequenc petrinet arc helper def allarc sequenc petrinet arc petrinet arc allinst assequ rule rule main this rule generat pnml root tag input petrinet element this tag xmlns attribut net element child element the net tag id type name attribut follow children element place element place input petrinet model transit element transit input petrinet model arc element arc input petrinet model rule main pn petrinet petrinet root xml root name pnml children sequenc xmlns net xmlns xml attribut name xmlns valu http www exampl org pnpl net xml element name net children sequenc id type name thismodul allplac thismodul alltransit thismodul allarc id xml attribut name id valu n type xml attribut name type valu http www exampl org pnpl ptnet name xml element name name children sequenc text text xml element name text children sequenc val val xml text valu pn name rule place this rule generat place tag input place element this tag id attribut valu correspond place rank within allplac sequenc the place tag also name child element text child element contain name place copi input place element rule place pn petrinet place xml place xml element name place children sequenc id name id xml attribut name id valu thismodul allplac indexof pn tostr name xml element name name children sequenc text text xml element name text children sequenc val val xml text valu pn name rule transit this rule generat transit tag input transit element this tag id attribut valu correspond size allplac sequenc transit rank within alltransit sequenc rule transit pn petrinet transit xml tran xml element name transit children sequenc tran id tran id xml attribut name id valu thismodul allplac size thismodul alltransit indexof pn tostr rule placetotransarc this rule generat arc tag input placetotransarc element this tag id sourc target attribut valu id attribut correspond size allplac sequenc size alltransit sequenc arc rank within allarc sequenc valu sourc attribut correspond sourc place rank within allplac sequenc valu target attribut correspond size allplac sequenc target transit rank within alltransit sequenc rule placetotransarc pn petrinet placetotransarc xml arc xml element name arc children sequenc id sourc target id xml attribut name id valu thismodul allplac size thismodul alltransit size thismodul allarc indexof pn tostr sourc xml attribut name sourc valu thismodul allplac indexof pn sourc tostr target xml attribut name target valu thismodul allplac size thismodul alltransit indexof pn target tostr rule transtoplacearc this rule generat arc tag input transtoplacearc element this tag id sourc target attribut valu id attribut correspond size allplac sequenc size alltransit sequenc arc rank within allarc sequenc valu sourc attribut correspond size allplac sequenc sourc transit rank within alltransit sequenc valu target attribut correspond target place rank within allplac sequenc rule transtoplacearc pn petrinet transtoplacearc xml arc xml element name arc children sequenc id sourc target id xml attribut name id valu thismodul allplac size thismodul alltransit size thismodul allarc indexof pn tostr sourc xml attribut name sourc valu thismodul allplac size thismodul alltransit indexof pn sourc tostr target xml attribut name target valu thismodul allplac indexof pn target tostr,11
137,137,P62-R2ML2XML.atl,"--@atlcompiler atl2006

-- ============================================================
-- Transforms an R2ML metamodel to XML metamodel.
-- Created as part of M.Sc. theses at GOOD OLD AI Laboratory
-- Author: Milan Milanovic (milan at milanovic.org)
-- Works for R2ML v0.4
-- Licence: GNU General Public License, version 2
-- ============================================================

module R2ML2XML; -- Module Template
create OUT : XML from IN : R2ML;

uses strings;

-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- HELPER: isNegated
-- Checks if Atom is negated. If property is not defined then it is false.
-- CONTEXT:	R2ML!Atom
-- OUT:		Boolean
helper context R2ML!Atom def: isNegated() : Boolean = 
	if self.isNegated.oclIsUndefined() then
		false
	else self.isNegated
	endif;

-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'RuleBase'
-- Create XML Root element (r2ml:RuleBase) from the R2ML RuleBase element 
rule RuleBase {
	from i : R2ML!RuleBase (
		i.oclIsTypeOf(R2ML!RuleBase)
		)
	to o : XML!Root (
			name <- 'r2ml:RuleBase',
			children <- Sequence { dc, schema, r2ml, xsi, i.rules }
		),
	dc : XML!Attribute (
			name <- 'xmlns:dc',
			value <- 'http://purl.org/dc/elements/1.1/'
		),
	schema : XML!Attribute (
			name <- 'xsi:schemaLocation',
			value <- 'http://www.rewerse.net/I1/2006/R2ML http://oxygen.informatik.tu-cottbus.de/R2ML/0.4/R2ML.xsd'
		),
	r2ml : XML!Attribute (
			name <- 'xmlns:r2ml',
			value <- 'http://www.rewerse.net/I1/2006/R2ML'
		),
	xsi : XML!Attribute (
			name <- 'xmlns:xsi',
			value <- 'http://www.w3.org/2001/XMLSchema-instance'
		)
}

-- Rule 'DerivationRuleSet'
-- Create XML element (r2ml:DerivationRuleSet) from the R2ML DerivationRuleSet element 
rule DerivationRuleSet {
	from i : R2ML!DerivationRuleSet (
			i.oclIsTypeOf(R2ML!DerivationRuleSet)
		)
	to o : XML!Element (
			name <- 'r2ml:DerivationRuleSet',
			children <- i.rules
		)
}

-- Rule 'IntegrityRuleSet'
-- Create XML element (r2ml:IntegrityRuleSet) from the R2ML IntegrityRuleSet element 
rule IntegrityRuleSet {
	from i : R2ML!IntegrityRuleSet (
			i.oclIsTypeOf(R2ML!IntegrityRuleSet)
		)
	to o : XML!Element (
			name <- 'r2ml:IntegrityRuleSet',
			children <- i.rules
		)
}

-- Rule 'ReactionRuleSet'
-- Create XML element (r2ml:ReactionRuleSet) from the R2ML ReactionRuleSet element 
rule ReactionRuleSet {
	from i : R2ML!ReactionRuleSet (
			i.oclIsTypeOf(R2ML!ReactionRuleSet)
		)
	to o : XML!Element (
			name <- 'r2ml:ReactionRuleSet',
			children <- i.rules
		)
}

-- Rule 'ProductionRuleSet'
-- Create XML element (r2ml:ProductionRuleSet) from the R2ML ProductionRuleSet element 
rule ProductionRuleSet {
	from i : R2ML!ProductionRuleSet (
			i.oclIsTypeOf(R2ML!ProductionRuleSet)
		)
	to o : XML!Element (
			name <- 'r2ml:ProductionRuleSet',
			children <- i.rules
		)
}

-- Rule 'AlethicIntegrityRule'
-- Create XML element (r2ml:AlethicIntegrityRule) from the R2ML AlethicIntegrityRule element 
rule AlethicIntegrityRule { 
	from i : R2ML!AlethicIntegrityRule (
			i.oclIsTypeOf(R2ML!AlethicIntegrityRule)
		)
	to o : XML!Element (
			name <- 'r2ml:AlethicIntegrityRule',
			children <- Sequence { if not i.ruleID.oclIsUndefined() then
									thisModule.RuleId(i)
									else OclUndefined
									endif,
									constraint
								}
		),
	constraint : XML!Element (
			name <- 'r2ml:constraint',
			children <- Sequence { i.constraint }
		)
}

-- Rule 'RuleId'
-- Create XML attribute (r2ml:ruleID) from the R2ML Rule element 
lazy rule RuleId {
	from i : R2ML!Rule
	to o : XML!Attribute (
			name <- 'r2ml:ruleID',
			value <- i.ruleID
		)
}

-- Rule 'DeonticIntegrityRule'
-- Create XML element (r2ml:DeonticIntegrityRule) from the R2ML DeonticIntegrityRule element 
rule DeonticIntegrityRule { 
	from i : R2ML!DeonticIntegrityRule (
			i.oclIsTypeOf(R2ML!DeonticIntegrityRule)
		)
	to o : XML!Element (
			name <- 'r2ml:DeonticIntegrityRule',
			children <- Sequence { if not i.ruleID.oclIsUndefined() then
									thisModule.RuleId(i)
									else OclUndefined
									endif,
									constraint 
								 }
		),
	constraint : XML!Element (
			name <- 'r2ml:constraint',
			children <- Sequence { i.constraint }
		)
}

-- Rule 'UniversallyQuantifiedFormula'
-- Create XML element (r2ml:UniversallyQuantifiedFormula) from the R2ML UniversallyQuantifiedFormula element 
rule UniversallyQuantifiedFormula {
	from i : R2ML!UniversallyQuantifiedFormula (
			i.oclIsTypeOf(R2ML!UniversallyQuantifiedFormula)
		)
	to o : XML!Element (
			name <- 'r2ml:UniversallyQuantifiedFormula',
			children <- Sequence {
							i.variables->asSequence()->select(c | c.oclIsTypeOf(R2ML!ObjectVariable))->collect(e | thisModule.ObjectVariable(e)),
							i.variables->asSequence()->select(c | c.oclIsTypeOf(R2ML!DataVariable))->collect(e | thisModule.DataVariable(e)),
							i.formula
						}
		)
}

-- Rule 'ExistentiallyQuantifiedFormula'
-- Create XML element (r2ml:ExistentiallyQuantifiedFormula) from the R2ML ExistentiallyQuantifiedFormula element 
rule ExistentiallyQuantifiedFormula {
	from i : R2ML!ExistentiallyQuantifiedFormula (
			i.oclIsTypeOf(R2ML!ExistentiallyQuantifiedFormula)
		)
	to o : XML!Element (
			name <- 'r2ml:ExistentiallyQuantifiedFormula',
			children <- Sequence {
							i.variables->asSequence()->select(c | c.oclIsTypeOf(R2ML!ObjectVariable))->collect(e | thisModule.ObjectVariable(e)),
							i.variables->asSequence()->select(c | c.oclIsTypeOf(R2ML!DataVariable))->collect(e | thisModule.DataVariable(e)),
							i.formula
						}
		)
}

-- Lazy rule 'ClassRule'
-- Create XML attribute (r2ml:classID) from the R2ML Class element 
lazy rule ClassRule {
	from i : R2ML!Class 
	to o : XML!Attribute (
			name <- 'r2ml:classID',
			value <- i.name
		)
}

-- Lazy rule 'ObjectVariable'
-- Create XML element (r2ml:ObjectVariable) from the R2ML ObjectVariable element 
lazy rule ObjectVariable {
	from i : R2ML!ObjectVariable
	to o : XML!Element (
		name <- 'r2ml:ObjectVariable',
		children <- Sequence { attrName, if not i.classRef.oclIsUndefined() then
											thisModule.ClassRule(i.classRef)
										 else OclUndefined
										 endif
							 }
		),
	attrName : XML!Attribute (
			name <- 'r2ml:name',
			value <- i.name
		)
}

-- Lazy rule 'DataVariable'
-- Create XML element (r2ml:DataVariable) from the R2ML DataVariable element 
lazy rule DataVariable {
	from i : R2ML!DataVariable
	to o : XML!Element (
		name <- 'r2ml:DataVariable',
		children <- Sequence { attrName, if not i.datatypeRef.oclIsUndefined() then
											thisModule.Datatype(i.datatypeRef)
										 else OclUndefined
										 endif,
										 if not i.typeCategory.oclIsUndefined() then
										 	thisModule.TypeCategory(i)
										 else OclUndefined
										 endif
							 }
		),
	attrName : XML!Attribute (
			name <- 'r2ml:name',
			value <- i.name
		)
}

-- Lazy rule 'GenericVariable'
-- Create XML element (r2ml:GenericVariable) from the R2ML GenericVariable element 
lazy rule GenericVariable {
	from i : R2ML!GenericVariable
	to o : XML!Element (
			name <- 'r2ml:GenericVariable',
			children <- Sequence { attrName, if not i.typeRef.oclIsUndefined() then
												thisModule.Datatype(i.typeRef)
										 	 else OclUndefined
										 	 endif 
								 }
		),
	attrName : XML!Attribute (
			name <- 'r2ml:name',
			value <- i.name
		)
}

-- Lazy rule 'Datatype'
-- Create XML attribute (r2ml:datatypeID) from the R2ML Datatype element 
lazy rule Datatype {
	from i : R2ML!Datatype
	to o : XML!Attribute (
			name <- 'r2ml:datatypeID',
			value <- i.name
		)
}

-- Rule 'Implication'
-- Create XML element (r2ml:Implication) from the R2ML Implication element 
rule Implication {
	from i : R2ML!Implication (
			i.oclIsTypeOf(R2ML!Implication)
		)
	to o : XML!Element (
			name <- 'r2ml:Implication',
			children <- Sequence { ant, con }
		),
		ant : XML!Element (
			name <- 'r2ml:antecedent',
			children <- i.antecedent
		),
		con : XML!Element (
			name <- 'r2ml:consequent',
			children <- i.consequent
		)
}

-- Rule 'Conjuction'
-- Create XML element (r2ml:Conjuction) from the R2ML Conjuction element 
rule Conjuction {
	from i : R2ML!Conjuction (
			i.oclIsTypeOf(R2ML!Conjuction)
		)
	to o : XML!Element (
			name <- 'r2ml:Conjunction',
			children <- i.formulas
		)
}

-- Rule 'Disjunction'
-- Create XML element (r2ml:Disjunction) from the R2ML Disjunction element 
rule Disjunction {
	from i : R2ML!Disjunction (
			i.oclIsTypeOf(R2ML!Disjunction)
		)
	to o : XML!Element (
			name <- 'r2ml:Disjunction',
			children <- i.formulas
		)
}

-- Rule 'NegationAsFailure'
-- Create XML element (r2ml:NegationAsFailure) from the R2ML NegationAsFailure element 
rule NegationAsFailure {
	from i : R2ML!NegationAsFailure (
			i.oclIsTypeOf(R2ML!NegationAsFailure)
		)
	to o : XML!Element (
			name <- 'r2ml:NegationAsFailure',
			children <- Sequence { i.formula }
		)
}

-- Rule 'StrongNegation'
-- Create XML element (r2ml:StrongNegation) from the R2ML StrongNegation element 
rule StrongNegation {
	from i : R2ML!StrongNegation (
			i.oclIsTypeOf(R2ML!StrongNegation)
		)
	to o : XML!Element (
			name <- 'r2ml:StrongNegation',
			children <- Sequence { i.formula }
		)
}

-- Rule 'EqualityAtom'
-- Create XML element (r2ml:EqualityAtom) from the R2ML EqualityAtom element 
rule EqualityAtom {
	from i : R2ML!EqualityAtom (
			i.oclIsTypeOf(R2ML!EqualityAtom)
		)
	to o : XML!Element (
			name <- 'r2ml:EqualityAtom',
			children <- Sequence { i.terms->select(c | c.oclIsTypeOf(R2ML!ObjectVariable))->collect(e | thisModule.ObjectVariable(e)),
								   i.terms->select(c | not c.oclIsTypeOf(R2ML!ObjectVariable))
								 }
		)
}

-- Rule 'InequalityAtom'
-- Create XML element (r2ml:InequalityAtom) from the R2ML InequalityAtom element 
rule InequalityAtom {
	from i : R2ML!InequalityAtom (
			i.oclIsTypeOf(R2ML!InequalityAtom)
		)
	to o : XML!Element (
			name <- 'r2ml:InequalityAtom',
			children <- Sequence { i.terms->select(c | c.oclIsTypeOf(R2ML!ObjectVariable))->collect(e | thisModule.ObjectVariable(e)),
								   i.terms->select(c | not c.oclIsTypeOf(R2ML!ObjectVariable))
								 }
		)
}

-- Rule 'DerivationRule'
-- Create XML element (r2ml:DerivationRule) from the R2ML DerivationRule element 
rule DerivationRule { 
	from i : R2ML!DerivationRule (
			i.oclIsTypeOf(R2ML!DerivationRule)
		)
	to o : XML!Element (
			name <- 'r2ml:DerivationRule',
			children <- Sequence { if not i.ruleID.oclIsUndefined() then
									thisModule.RuleId(i)
									else OclUndefined
									endif,
									conditions, 
									conclusions 
								 }
		),
		conditions : XML!Element (
				name <- 'r2ml:conditions',
				children <- i.conditions
			),
		conclusions : XML!Element (
				name <- 'r2ml:conclusion',
				children <- i.conclusions->asSequence()->collect(c | c.atoms)->flatten()->asSequence() -- collect LiteralConjuctions
			)
}

-- Rule 'ObjectClassificationAtom'
-- Create XML element (r2ml:ObjectClassificationAtom) from the R2ML ObjectClassificationAtom element 
rule ObjectClassificationAtom {
	from i : R2ML!ObjectClassificationAtom (
			i.oclIsTypeOf(R2ML!ObjectClassificationAtom)
		)
	to o : XML!Element (
			name <- 'r2ml:ObjectClassificationAtom',
			children <- Sequence { if i.isNegated() then    	  -- for isNegated attribute
									 thisModule.AtomIsNegated(i)
								   else OclUndefined
								   endif,
								   thisModule.ClassRule(i.type),      -- for classID attribute
								   thisModule.ObjectVariable(i.term)  -- for term 
								}
		)
}

-- Rule 'AtomIsNegated'
-- Create XML attribute (r2ml:isNegated) from the R2ML Atom element 
lazy rule AtomIsNegated {
	from i : R2ML!Atom
	to o : XML!Attribute ( 
			name <- 'r2ml:isNegated',
			value <- 'true'
		)
}

-- Rule 'DataClassificationAtom'
-- Create XML element (r2ml:DataClassificationAtom) from the R2ML DataClassificationAtom element 
rule DataClassificationAtom {
	from i : R2ML!DataClassificationAtom (
			i.oclIsTypeOf(R2ML!DataClassificationAtom)
		)
	to o : XML!Element (
			name <- 'r2ml:DataClassificationAtom',
			children <- Sequence { if i.isNegated() then    	  -- for isNegated attribute
									 thisModule.AtomIsNegated(i)
								   else OclUndefined
								   endif,
								   thisModule.Datatype(i.type),      -- for classID attribute
								   thisModule.DataVariable(i.term)  -- for term 
								}
		)
}

-- Rule 'QFConjunction'
-- Create XML element (r2ml:qf.Conjuction) from the R2ML QFConjunction element 
rule QFConjunction {
	from i : R2ML!QFConjunction (
			i.oclIsTypeOf(R2ML!QFConjunction)
		)
	to o : XML!Element (
			name <- 'r2ml:qf.Conjuction',
			children <- i.formulas
		)
}

-- Rule 'QFDisjunction'
-- Create XML element (r2ml:qf.Disjunction) from the R2ML QFDisjunction element 
rule QFDisjunction {
	from i : R2ML!QFDisjunction (
			i.oclIsTypeOf(R2ML!QFDisjunction)
		)
	to o : XML!Element (
			name <- 'r2ml:qf.Disjunction',
			children <- i.formulas
		)
}

-- Rule 'QFNegationAsFailure'
-- Create XML element (r2ml:qf.NegationAsFailure) from the R2ML QFNegationAsFailure element 
rule QFNegationAsFailure {
	from i : R2ML!QFNegationAsFailure (
			i.oclIsTypeOf(R2ML!QFNegationAsFailure)
		)
	to o : XML!Element (
			name <- 'r2ml:qf.NegationAsFailure',
			children <- Sequence { i.formula }
		)
}

-- Rule 'QFStrongNegation'
-- Create XML element (r2ml:qf.StrongNegation) from the R2ML QFStrongNegation element 
rule QFStrongNegation {
	from i : R2ML!QFStrongNegation (
			i.oclIsTypeOf(R2ML!QFStrongNegation)
		)
	to o : XML!Element (
			name <- 'r2ml:qf.StrongNegation',
			children <- Sequence { i.formula }
		)
}

-- Rule 'DatatypePredicateAtom'
-- Create XML element (r2ml:DatatypePredicateAtom) from the R2ML DatatypePredicateAtom element 
rule DatatypePredicateAtom {
	from i : R2ML!DatatypePredicateAtom (
			i.oclIsTypeOf(R2ML!DatatypePredicateAtom)
		)
	to o : XML!Element (
			name <- 'r2ml:DatatypePredicateAtom',
			children <- Sequence { if i.isNegated() then    	  -- for isNegated attribute
									 thisModule.AtomIsNegated(i)
								   else OclUndefined
								   endif,
								   attr, 
								   dataArgs }
		),
		attr : XML!Attribute (
				name <- 'r2ml:datatypePredicateID',
				value <- i.predicate.name
			),
		dataArgs : XML!Element (
				name <- 'r2ml:dataArguments',
				children <- Sequence { i.dataArguments->asSequence()->select(c | c.oclIsTypeOf(R2ML!DataVariable))->collect(c | thisModule.DataVariable(c)),
									   i.dataArguments->asSequence()->select(c | not c.oclIsTypeOf(R2ML!DataVariable))
									 }
			)
}

-- Rule 'TypeCategory'
-- Create XML attribute (r2ml:typeCategory) for R2ML Term element 
lazy rule TypeCategory {
	from i : R2ML!Term
	to o : XML!Attribute (
		name <- 'r2ml:typeCategory',
		value <- if i.typeCategory = #individual then
					 'individual'
				 else if i.typeCategory = #set then
						  'set'
					  else if i.typeCategory = #orderedSet then
								 'order'
						   else if i.typeCategory = #bag then
									'bag'
							    else if i.typeCategory = #sequence then
										  'sequence'
									 else OclUndefined
								     endif
								endif
						   endif
					  endif
				 endif			
		)
}
			
-- Rule 'DataOperationTermArgs'
-- Create XML element (r2ml:arguments) for R2ML DataOperationTerm element 
lazy rule DataOperationTermArgs {
	from i : R2ML!DataOperationTerm
	to o : XML!Element (
			name <- 'r2ml:arguments',
			children <- Sequence { i.arguments->asSequence()->select(c | c.oclIsTypeOf(R2ML!ObjectVariable))->collect(c | thisModule.ObjectVariable(c)),
								   i.arguments->asSequence()->select(c | c.oclIsTypeOf(R2ML!DataVariable))->collect(c | thisModule.DataVariable(c)),
								   i.arguments->asSequence()->select(c | not c.oclIsTypeOf(R2ML!ObjectVariable) and not c.oclIsTypeOf(R2ML!DataVariable))
								 }
		)
}

-- Rule 'TypedLiteral'
-- Create XML element (r2ml:TypedLiteral) from the R2ML TypedLiteral element 
rule TypedLiteral {
	from i : R2ML!TypedLiteral (
			i.oclIsTypeOf(R2ML!TypedLiteral)
		)
	to o : XML!Element (
			name <- 'r2ml:TypedLiteral',
			children <- Sequence { type, value }
		),
	type : XML!Attribute (
			name <- 'r2ml:datatypeID',
			value <- i.type.name
		),
	value : XML!Attribute (
			name <- 'r2ml:lexicalValue',
			value <- i.lexicalValue
		)
}

-- Rule 'PlainLiteral'
-- Create XML element (r2ml:PlainLiteral) from the R2ML PlainLiteral element
rule PlainLiteral {
	from i : R2ML!PlainLiteral (
			i.oclIsTypeOf(R2ML!PlainLiteral)
		)
	to o : XML!Element (
			name <- Sequence { if not i.languageTag.oclIsUndefined() then 
								thisModule.PlainLiteralLanguageTag(i)
							   else OclUndefined
							   endif, 
							   value
							}
		),
	value : XML!Attribute (
			name <- 'r2ml:lexicalValue',
			value <- i.lexicalValue
		)
}
		
-- Rule 'PlainLiteralLanguageTag'
-- Create XML attribute (r2ml:languageTag) for R2ML PlainLiteral element
lazy rule PlainLiteralLanguageTag {
	from i : R2ML!PlainLiteral
	to o : XML!Attribute (
			name <- 'r2ml:languageTag',
			value <- i.languageTag
		)
}

-- Rule 'AttributeFunctionTerm'
-- Create XML element (r2ml:AttributeFunctionTerm) from the R2ML AttributeFunctionTerm element
rule AttributeFunctionTerm {
	from i : R2ML!AttributeFunctionTerm (
			i.oclIsTypeOf(R2ML!AttributeFunctionTerm)
		)
	to o : XML!Element (
			name <- 'r2ml:AttributeFunctionTerm',
			children <- Sequence { attr,  contextArg, 
								   if not i.typeCategory.oclIsUndefined() then
										thisModule.TypeCategory(i)
								   else OclUndefined
								   endif 
								  }
		),
	attr : XML!Attribute (
			name <- 'r2ml:attributeID',
			value <- i.attribute.name
		),
	contextArg : XML!Element (
			name <- 'r2ml:contextArgument',
			children <- Sequence { if i.contextArgument.oclIsTypeOf(R2ML!ObjectVariable) then 
									thisModule.ObjectVariable(i.contextArgument)
								   else i.contextArgument
								   endif
								 }
		)
}

-- Rule 'AssociationAtom'
-- Create XML element (r2ml:AssociationAtom) from the R2ML AssociationAtom element
rule AssociationAtom {
	from i : R2ML!AssociationAtom (
			i.oclIsTypeOf(R2ML!AssociationAtom)
		)
	to o : XML!Element (
			name <- 'r2ml:AssociationAtom',
			children <- Sequence { if i.isNegated() then    	  -- for isNegated attribute
										thisModule.AtomIsNegated(i)
								   else OclUndefined
								   endif,
								   assocPred,
								   objArgs,
								   if i.dataArguments->size() > 0 then
								   		thisModule.AssociationAtomDataArgs(i)
								   else OclUndefined
								   endif
								   }
		),
	assocPred : XML!Attribute (
			name <- 'r2ml:associationPredicateID',
			value <- i.associationPredicate.name
		),
	objArgs : XML!Element (
			name <- 'r2ml:objectArguments',
			children <- Sequence { i.objectArguments->asSequence()->select(c | c.oclIsTypeOf(R2ML!ObjectVariable))->collect(c | thisModule.ObjectVariable(c)),
								   i.objectArguments->asSequence()->select(c | not c.oclIsTypeOf(R2ML!ObjectVariable))
								 }
		)
}

-- Rule 'AssociationAtomDataArgs'
-- Create XML element (r2ml:dataArguments) for R2ML AssociationAtom element
lazy rule AssociationAtomDataArgs {
	from i : R2ML!AssociationAtom
	to o : XML!Element (
			name <- 'r2ml:dataArguments',
			children <- Sequence { i.dataArguments->asSequence()->select(c | c.oclIsTypeOf(R2ML!DataVariable))->collect(c | thisModule.DataVariable(c)),
								   i.dataArguments->asSequence()->select(c | not c.oclIsTypeOf(R2ML!DataVariable))
								 }
		)
}

-- Rule 'ReferencePropertyFunctionTerm'
-- Create XML element (r2ml:ReferencePropertyFunctionTerm) from the R2ML ReferencePropertyFunctionTerm element
rule ReferencePropertyFunctionTerm {
	from i : R2ML!ReferencePropertyFunctionTerm (
			i.oclIsTypeOf(R2ML!ReferencePropertyFunctionTerm)
		)
	to o : XML!Element (
			name <- 'r2ml:ReferencePropertyFunctionTerm',
			children <- Sequence { refProp, contextArg, 
								   if not i.typeCategory.oclIsUndefined() then
									thisModule.TypeCategory(i)
								   else OclUndefined
								   endif 
								  }
		),
	refProp : XML!Attribute (
			name <- 'r2ml:referencePropertyID',
			value <- i.referencePropertyRef.name
		),
	contextArg : XML!Element (
			name <- 'r2ml:contextArgument',
			children <- Sequence { if i.contextArgument.oclIsTypeOf(R2ML!ObjectVariable) then
									thisModule.ObjectVariable(i.contextArgument)
								   else i.contextArgument
								   endif
								 }
		)
}

-- Rule 'AttributionAtom'
-- Create XML element (r2ml:AttributionAtom) from the R2ML AttributionAtom element
rule AttributionAtom {
	from i : R2ML!AttributionAtom (
			i.oclIsTypeOf(R2ML!AttributionAtom)
		)
	to o : XML!Element (
			name <- 'r2ml:AttributionAtom',
			children <- Sequence { attr, if i.isNegated() then    	  -- for isNegated attribute
									       thisModule.AtomIsNegated(i)
								   		 else OclUndefined
								         endif,
								   subject,
								   dataValue
								 }
		),
	attr : XML!Attribute (
			name <- 'r2ml:attributeID',
			value <- i.attribute.name
		),
	subject : XML!Element (
			name <- 'r2ml:subject',
			children <- Sequence { if i.subject.oclIsTypeOf(R2ML!ObjectVariable) then
										thisModule.ObjectVariable(i.subject)
								   else i.subject
								   endif
								 }
		),
	dataValue : XML!Element (
			name <- 'r2ml:dataValue',
			children <- Sequence { if i.dataValue.oclIsTypeOf(R2ML!DataVariable) then
										thisModule.DataVariable(i.dataValue)
								   else i.dataValue
					 			   endif
								 }
		)
}

-- Rule 'ReferencePropertyAtom'
-- Create XML element (r2ml:ReferencePropertyAtom) from the R2ML ReferencePropertyAtom element
rule ReferencePropertyAtom {
	from i : R2ML!ReferencePropertyAtom (
			i.oclIsTypeOf(R2ML!ReferencePropertyAtom)
		)
	to o : XML!Element (
			name <- 'r2ml:ReferencePropertyAtom',
			children <- Sequence { if i.isNegated() then    	  -- for isNegated attribute
								   	thisModule.AtomIsNegated(i)
								   else OclUndefined
								   endif,
								   refProp,
								   subject,
								   object
								  }
		),
	refProp : XML!Attribute (
			name <- 'r2ml:referencePropertyID',
			value <- i.referenceProperty.name
		),
	subject : XML!Element (
			name <- 'r2ml:subject',
			children <- Sequence { if i.subject.oclIsTypeOf(R2ML!ObjectVariable) then
									thisModule.ObjectVariable(i.subject)
								   else i.subject
								   endif
								}
		),
	object : XML!Element (
			name <- 'r2ml:object',
			children <- Sequence { if i.object.oclIsTypeOf(R2ML!ObjectVariable) then
									thisModule.ObjectVariable(i.object)
								   else i.object
								   endif
								}
		)
}

-- Rule 'GenericAtom'
-- Create XML element (r2ml:GenericAtom) from the R2ML GenericAtom element
rule GenericAtom {
	from i : R2ML!GenericAtom (
			i.oclIsTypeOf(R2ML!GenericAtom)
		)
	to o : XML!Element (
			name <- 'r2ml:GenericAtom',
			children <- Sequence { predicate, args }
		),
	predicate : XML!Attribute (
			name <- 'r2ml:predicateID',
			value <- i.predicate.name
		),
	args : XML!Element (
			name <- 'r2ml:arguments',
			children <- Sequence { i.arguments->asSequence()->select(c | c.oclIsTypeOf(R2ML!GenericVariable))->collect(c | thisModule.GenericVariable(c)),
								   i.arguments->asSequence()->select(c | c.oclIsTypeOf(R2ML!ObjectVariable))->collect(c | thisModule.ObjectVariable(c)),
								   i.arguments->asSequence()->select(c | c.oclIsTypeOf(R2ML!DataVariable))->collect(c | thisModule.DataVariable(c)),
								   i.arguments->asSequence()->select(c | not c.oclIsKindOf(R2ML!Variable))
								 }
		)
}

-- Rule 'PredicateType'
-- Create XML attribute (r2ml:predicateType) for R2ML GenericAtom element
lazy rule PredicateType {
	from i : R2ML!GenericPredicate
	to o : XML!Attribute (
			name <- 'r2ml:predicateType',
			value <- if i.predicateTypeID = #ObjectClassificationPredicate then
						'ObjectClassificationPredicate'
						else if i.predicateTypeID = #AttributionPredicate then
							  'AttributionPredicate'
							 else if i.predicateTypeID = #AssociationPredicate then
								   'AssociationPredicate'
								  else if i.predicateTypeID = #ReferencePropertyPredicate then
									    'ReferencePropertyPredicate'
									   else if i.predicateTypeID = #EqualityPredicate then
										     'EqualityPredicate'
										    else if i.predicateTypeID = #InequalityPredicate then
											      'InequalityPredicate'
											     else if i.predicateTypeID = #DatatypePredicate then
												       'DatatypePredicate'
												      else if i.predicateTypeID = #DataClassificationPredicate then
														    'DataClassificationPredicate'
													       else OclUndefined
													       endif
												      endif
												 endif
											endif 
										endif
								   endif
							 endif 
						endif
		)
}

-- Rule 'GenericFunctionTerm'
-- Create XML element (r2ml:GenericFunctionTerm) from the R2ML GenericFunctionTerm element
rule GenericFunctionTerm {
	from i : R2ML!GenericFunctionTerm (
			i.oclIsTypeOf(R2ML!GenericFunctionTerm)
		)
	to o : XML!Element (
			name <- 'r2ml:GenericFunctionTerm',
			children <- Sequence { attr, args }
		),
	attr : XML!Attribute (
			name <- 'r2ml:genericFunctionID',
			value <- i.functor.name
		),
	args : XML!Element ( 
			name <- 'r2ml:arguments',
			children <- Sequence { i.arguments->asSequence()->select(c | c.oclIsTypeOf(R2ML!GenericVariable))->collect(c | thisModule.GenericVariable(c)),
								   i.arguments->asSequence()->select(c | not c.oclIsTypeOf(R2ML!GenericVariable)),
								   if not i.typeCategory.oclIsUndefined() then
									thisModule.TypeCategory(i)
								   else OclUndefined
								   endif 
								 }
		)
}

-- Rule 'DatatypeFunctionTerm'
-- Create XML element (r2ml:DatatypeFunctionTerm) from the R2ML DatatypeFunctionTerm element
rule DatatypeFunctionTerm {
	from i : R2ML!DatatypeFunctionTerm (
			i.oclIsTypeOf(R2ML!DatatypeFunctionTerm)
		)
	to o : XML!Element (
			name <- 'r2ml:DatatypeFunctionTerm',
			children <- Sequence { attr, args }
		),
	attr : XML!Attribute (
			name <- 'datatypeFunctionID',
			value <- i.function.name
		),
	args : XML!Element (
			name <- 'r2ml:dataArguments',
			children <- Sequence { i.dataArguments->asSequence()->select(c | c.oclIsTypeOf(R2ML!DataVariable))->collect(c | thisModule.DataVariable(c)),
								   i.dataArguments->asSequence()->select(c | not c.oclIsTypeOf(R2ML!DataVariable)),
								   if not i.typeCategory.oclIsUndefined() then
									thisModule.TypeCategory(i)
								   else OclUndefined
								   endif 
								 }						
		)
}

-- Rule 'ObjectName'
-- Create XML element (r2ml:ObjectName) from the R2ML ObjectName element
rule ObjectName {
	from i : R2ML!ObjectName (
			i.oclIsTypeOf(R2ML!ObjectName)
		)
	to o : XML!Element (
			name <- 'r2ml:ObjectName',
			children <- Sequence { attr, if not i.classRef.oclIsUndefined() then 
											thisModule.ClassRule(i.classRef)
										 else OclUndefined
										 endif,
										 if not i.typeCategory.oclIsUndefined() then
											thisModule.TypeCategory(i)
								  		 else OclUndefined
								   		 endif
								 }
		),
	attr : XML!Attribute (
			name <- 'r2ml:objectID',
			value <- i.name
		)
}

-- Rule 'ObjectDescriptionAtom'
-- Create XML element (r2ml:ObjectDescriptionAtom) from the R2ML ObjectDescriptionAtom element
rule ObjectDescriptionAtom {
	from i : R2ML!ObjectDescriptionAtom (
			i.oclIsTypeOf(R2ML!ObjectDescriptionAtom)
		)
	to o : XML!Element (
			name <- 'r2ml:ObjectDescriptionAtom',
			children <- Sequence { class, if not i.baseType.oclIsUndefined then 
											thisModule.ClassRule(i.baseType)
										  else OclUndefined 
										  endif,
								   subject,
								   i.slots,
								   objects
			}
		),
	class : XML!Attribute (
			name <- 'r2ml:classID',
			value <- i.type.name
		),
	subject : XML!Element (
			name <- 'r2ml:subject',
			children <- Sequence { if i.subject.oclIsTypeOf(R2ML!ObjectVariable) then 
									thisModule.ObjectVariable(i.subject)
								   else i.subject
								   endif
								 }
		),
	objects : XML!Element (
			name <- 'r2ml:objects',
			children <- i.objects
		)
}

-- Rule 'ObjectSlot'
-- Create XML element (r2ml:ObjectSlot) from the R2ML ObjectSlot element
rule ObjectSlot {
	from i : R2ML!ObjectSlot (
			i.oclIsTypeOf(R2ML!ObjectSlot)
		)
	to o : XML!Element (
			name <- 'r2ml:ObjectSlot',
			children <- Sequence { attr, object }
		),
	attr : XML!Attribute (
			name <- 'r2ml:referencePropertyID',
			value <- i.referenceProperty.name
		),
	object : XML!Element (
			name <- 'r2ml:object',
			children <- Sequence { if i.object.oclIsTypeOf(R2ML!ObjectVariable) then 
									thisModule.ObjectVariable(i.object)
								   else i.object
								   endif
								 }
		)
}

-- Rule 'DataSlot'
-- Create XML element (r2ml:DataSlot) from the R2ML DataSlot element
rule DataSlot {
	from i : R2ML!DataSlot (
			i.oclIsTypeOf(R2ML!DataSlot)
		)
	to o : XML!Element (
			name <- 'r2ml:DataSlot',
			children <- Sequence { attr, value }
		),
	attr : XML!Attribute (
			name <- 'r2ml:attributeID',
			value <- i.attribute.name
		),
	value : XML!Element (
			name <- 'r2ml:value',
			children <- Sequence { if i.value.oclIsTypeOf(R2ML!DataVariable) then 
									thisModule.DataVariable(i.value)
								   else i.value
								   endif
								 }
		)
}

-- Rule 'AtLeastQuantifiedFormula'
-- Create XML element (r2ml:AtLeastQuantifiedFormula) from the R2ML AtLeastQuantifiedFormula element 
rule AtLeastQuantifiedFormula {
	from i : R2ML!AtLeastQuantifiedFormula (
			i.oclIsTypeOf(R2ML!AtLeastQuantifiedFormula)
		)
	to o : XML!Element (
			name <- 'r2ml:AtLeastQuantifiedFormula',
			children <- Sequence {
							attr,
							i.variables->asSequence()->select(c | c.oclIsTypeOf(R2ML!ObjectVariable))->collect(e | thisModule.ObjectVariable(e)),
							i.variables->asSequence()->select(c | c.oclIsTypeOf(R2ML!DataVariable))->collect(e | thisModule.DataVariable(e)),
							i.formula
						}
  		  ),
		attr : XML!Attribute (
			name <- 'r2ml:minCardinality',
			value <- i.minCardinality.toString()
		)
}

-- Rule 'AtMostQuantifiedFormula'
-- Create XML element (r2ml:AtMostQuantifiedFormula) from the R2ML AtMostQuantifiedFormula element 
rule AtMostQuantifiedFormula {
	from i : R2ML!AtMostQuantifiedFormula (
			i.oclIsTypeOf(R2ML!AtMostQuantifiedFormula)
		)
	to o : XML!Element (
			name <- 'r2ml:AtMostQuantifiedFormula',
			children <- Sequence {
							attr,
							i.variables->asSequence()->select(c | c.oclIsTypeOf(R2ML!ObjectVariable))->collect(e | thisModule.ObjectVariable(e)),
							i.variables->asSequence()->select(c | c.oclIsTypeOf(R2ML!DataVariable))->collect(e | thisModule.DataVariable(e)),
							i.formula
						}
  		  ),
		attr : XML!Attribute (
			name <- 'r2ml:maxCardinality',
			value <- i.maxCardinality.toString()
		)
}

-- Rule 'AtLeastAndAtMostQuantifiedFormula'
-- Create XML element (r2ml:AtLeastAndAtMostQuantifiedFormula) from the R2ML AtLeastAndAtMostQuantifiedFormula element.
rule AtLeastAndAtMostQuantifiedFormula {
	from i : R2ML!AtLeastAndAtMostQuantifiedFormula (
			i.oclIsTypeOf(R2ML!AtLeastAndAtMostQuantifiedFormula)
		)
	to o : XML!Element (
			name <- 'r2ml:AtLeastAndAtMostQuantifiedFormula',
			children <- Sequence {
							attrMax, attrMin,
							i.variables->asSequence()->select(c | c.oclIsTypeOf(R2ML!ObjectVariable))->collect(e | thisModule.ObjectVariable(e)),
							i.variables->asSequence()->select(c | c.oclIsTypeOf(R2ML!DataVariable))->collect(e | thisModule.DataVariable(e)),
							i.formula
						}
  		  ),
		attrMax : XML!Attribute (
			name <- 'r2ml:maxCardinality',
			value <- i.maxCardinality.toString()
		),
		attrMin : XML!Attribute (
			name <- 'r2ml:minCardinality',
			value <- i.minCardinality.toString()
		)
}

-- Rule 'ObjectOperationTerm'
-- Create XML element (r2ml:ObjectOperationTerm) from the R2ML ObjectOperationTerm element.
rule ObjectOperationTerm {
	from i : R2ML!ObjectOperationTerm (
			i.oclIsTypeOf(R2ML!ObjectOperationTerm)
		)
	to o : XML!Element (
			name <- 'r2ml:ObjectOperationTerm',
			children <- Sequence { operation, contextArg, 
													if i.arguments->size() > 0 then
															i.arguments
														  else OclUndefined
														  endif
								  }
		),
	operation : XML!Attribute (
			name <- 'r2ml:operationID',
			value <- i.operation.name
		),
	contextArg : XML!Element (
			name <- 'r2ml:contextArgument',
			children <- Sequence { if i.contextArgument.oclIsTypeOf(R2ML!ObjectVariable) then
									thisModule.ObjectVariable(i.contextArgument)
								   else i.contextArgument
								   endif
								 }
		)
}


-- Rule 'DataOperationTerm'
-- Create XML element (r2ml:DataOperationTerm) from the R2ML DataOperationTerm element 
rule DataOperationTerm {
	from i : R2ML!DataOperationTerm (
			i.oclIsTypeOf(R2ML!DataOperationTerm)
		)
	to o : XML!Element (
			name <- 'r2ml:DataOperationTerm',
			children <- Sequence { attr, if i.arguments->size() > 0 then
											thisModule.DataOperationTermArgs(i)
											else OclUndefined
											endif, 
											contArg,
										 if not i.typeCategory.oclIsUndefined() then
										 	thisModule.TypeCategory(i)
										 else OclUndefined
										 endif
								 }
		),
	attr : XML!Attribute (
			name <- 'r2ml:operationID',
			value <- i.dataOperationRef.name
		),
	contArg : XML!Element (
			name <- 'r2ml:contextArgument',
			children <- Sequence { if i.contextArgument.oclIsTypeOf(R2ML!ObjectVariable) then
									thisModule.ObjectVariable(i.contextArgument)
								   else i.contextArgument	
								   endif
								 }
		)
}
",atlcompil atl transform r ml metamodel xml metamodel creat part m sc these good old ai laboratori author milan milanov milan milanov org work r ml v licenc gnu general public licens version modul r ml xml modul templat creat out xml in r ml use string helper helper isneg check atom negat if properti defin fals context r ml atom out boolean helper context r ml atom def isneg boolean self isneg oclisundefin fals els self isneg endif rule rule rulebas creat xml root element r ml rulebas r ml rulebas element rule rulebas r ml rulebas oclistypeof r ml rulebas xml root name r ml rulebas children sequenc dc schema r ml xsi rule dc xml attribut name xmlns dc valu http purl org dc element schema xml attribut name xsi schemaloc valu http www rewers net i r ml http oxygen informatik tu cottbus de r ml r ml xsd r ml xml attribut name xmlns r ml valu http www rewers net i r ml xsi xml attribut name xmlns xsi valu http www w org xmlschema instanc rule derivationruleset creat xml element r ml derivationruleset r ml derivationruleset element rule derivationruleset r ml derivationruleset oclistypeof r ml derivationruleset xml element name r ml derivationruleset children rule rule integrityruleset creat xml element r ml integrityruleset r ml integrityruleset element rule integrityruleset r ml integrityruleset oclistypeof r ml integrityruleset xml element name r ml integrityruleset children rule rule reactionruleset creat xml element r ml reactionruleset r ml reactionruleset element rule reactionruleset r ml reactionruleset oclistypeof r ml reactionruleset xml element name r ml reactionruleset children rule rule productionruleset creat xml element r ml productionruleset r ml productionruleset element rule productionruleset r ml productionruleset oclistypeof r ml productionruleset xml element name r ml productionruleset children rule rule alethicintegrityrul creat xml element r ml alethicintegrityrul r ml alethicintegrityrul element rule alethicintegrityrul r ml alethicintegrityrul oclistypeof r ml alethicintegrityrul xml element name r ml alethicintegrityrul children sequenc ruleid oclisundefin thismodul ruleid els oclundefin endif constraint constraint xml element name r ml constraint children sequenc constraint rule ruleid creat xml attribut r ml ruleid r ml rule element lazi rule ruleid r ml rule xml attribut name r ml ruleid valu ruleid rule deonticintegrityrul creat xml element r ml deonticintegrityrul r ml deonticintegrityrul element rule deonticintegrityrul r ml deonticintegrityrul oclistypeof r ml deonticintegrityrul xml element name r ml deonticintegrityrul children sequenc ruleid oclisundefin thismodul ruleid els oclundefin endif constraint constraint xml element name r ml constraint children sequenc constraint rule universallyquantifiedformula creat xml element r ml universallyquantifiedformula r ml universallyquantifiedformula element rule universallyquantifiedformula r ml universallyquantifiedformula oclistypeof r ml universallyquantifiedformula xml element name r ml universallyquantifiedformula children sequenc variabl assequ select c c oclistypeof r ml objectvari collect e thismodul objectvari e variabl assequ select c c oclistypeof r ml datavari collect e thismodul datavari e formula rule existentiallyquantifiedformula creat xml element r ml existentiallyquantifiedformula r ml existentiallyquantifiedformula element rule existentiallyquantifiedformula r ml existentiallyquantifiedformula oclistypeof r ml existentiallyquantifiedformula xml element name r ml existentiallyquantifiedformula children sequenc variabl assequ select c c oclistypeof r ml objectvari collect e thismodul objectvari e variabl assequ select c c oclistypeof r ml datavari collect e thismodul datavari e formula lazi rule classrul creat xml attribut r ml classid r ml class element lazi rule classrul r ml class xml attribut name r ml classid valu name lazi rule objectvari creat xml element r ml objectvari r ml objectvari element lazi rule objectvari r ml objectvari xml element name r ml objectvari children sequenc attrnam classref oclisundefin thismodul classrul classref els oclundefin endif attrnam xml attribut name r ml name valu name lazi rule datavari creat xml element r ml datavari r ml datavari element lazi rule datavari r ml datavari xml element name r ml datavari children sequenc attrnam datatyperef oclisundefin thismodul datatyp datatyperef els oclundefin endif typecategori oclisundefin thismodul typecategori els oclundefin endif attrnam xml attribut name r ml name valu name lazi rule genericvari creat xml element r ml genericvari r ml genericvari element lazi rule genericvari r ml genericvari xml element name r ml genericvari children sequenc attrnam typeref oclisundefin thismodul datatyp typeref els oclundefin endif attrnam xml attribut name r ml name valu name lazi rule datatyp creat xml attribut r ml datatypeid r ml datatyp element lazi rule datatyp r ml datatyp xml attribut name r ml datatypeid valu name rule implic creat xml element r ml implic r ml implic element rule implic r ml implic oclistypeof r ml implic xml element name r ml implic children sequenc ant con ant xml element name r ml anteced children anteced con xml element name r ml consequ children consequ rule conjuct creat xml element r ml conjuct r ml conjuct element rule conjuct r ml conjuct oclistypeof r ml conjuct xml element name r ml conjunct children formula rule disjunct creat xml element r ml disjunct r ml disjunct element rule disjunct r ml disjunct oclistypeof r ml disjunct xml element name r ml disjunct children formula rule negationasfailur creat xml element r ml negationasfailur r ml negationasfailur element rule negationasfailur r ml negationasfailur oclistypeof r ml negationasfailur xml element name r ml negationasfailur children sequenc formula rule strongneg creat xml element r ml strongneg r ml strongneg element rule strongneg r ml strongneg oclistypeof r ml strongneg xml element name r ml strongneg children sequenc formula rule equalityatom creat xml element r ml equalityatom r ml equalityatom element rule equalityatom r ml equalityatom oclistypeof r ml equalityatom xml element name r ml equalityatom children sequenc term select c c oclistypeof r ml objectvari collect e thismodul objectvari e term select c c oclistypeof r ml objectvari rule inequalityatom creat xml element r ml inequalityatom r ml inequalityatom element rule inequalityatom r ml inequalityatom oclistypeof r ml inequalityatom xml element name r ml inequalityatom children sequenc term select c c oclistypeof r ml objectvari collect e thismodul objectvari e term select c c oclistypeof r ml objectvari rule derivationrul creat xml element r ml derivationrul r ml derivationrul element rule derivationrul r ml derivationrul oclistypeof r ml derivationrul xml element name r ml derivationrul children sequenc ruleid oclisundefin thismodul ruleid els oclundefin endif condit conclus condit xml element name r ml condit children condit conclus xml element name r ml conclus children conclus assequ collect c c atom flatten assequ collect literalconjuct rule objectclassificationatom creat xml element r ml objectclassificationatom r ml objectclassificationatom element rule objectclassificationatom r ml objectclassificationatom oclistypeof r ml objectclassificationatom xml element name r ml objectclassificationatom children sequenc isneg isneg attribut thismodul atomisneg els oclundefin endif thismodul classrul type classid attribut thismodul objectvari term term rule atomisneg creat xml attribut r ml isneg r ml atom element lazi rule atomisneg r ml atom xml attribut name r ml isneg valu true rule dataclassificationatom creat xml element r ml dataclassificationatom r ml dataclassificationatom element rule dataclassificationatom r ml dataclassificationatom oclistypeof r ml dataclassificationatom xml element name r ml dataclassificationatom children sequenc isneg isneg attribut thismodul atomisneg els oclundefin endif thismodul datatyp type classid attribut thismodul datavari term term rule qfconjunct creat xml element r ml qf conjuct r ml qfconjunct element rule qfconjunct r ml qfconjunct oclistypeof r ml qfconjunct xml element name r ml qf conjuct children formula rule qfdisjunct creat xml element r ml qf disjunct r ml qfdisjunct element rule qfdisjunct r ml qfdisjunct oclistypeof r ml qfdisjunct xml element name r ml qf disjunct children formula rule qfnegationasfailur creat xml element r ml qf negationasfailur r ml qfnegationasfailur element rule qfnegationasfailur r ml qfnegationasfailur oclistypeof r ml qfnegationasfailur xml element name r ml qf negationasfailur children sequenc formula rule qfstrongneg creat xml element r ml qf strongneg r ml qfstrongneg element rule qfstrongneg r ml qfstrongneg oclistypeof r ml qfstrongneg xml element name r ml qf strongneg children sequenc formula rule datatypepredicateatom creat xml element r ml datatypepredicateatom r ml datatypepredicateatom element rule datatypepredicateatom r ml datatypepredicateatom oclistypeof r ml datatypepredicateatom xml element name r ml datatypepredicateatom children sequenc isneg isneg attribut thismodul atomisneg els oclundefin endif attr dataarg attr xml attribut name r ml datatypepredicateid valu predic name dataarg xml element name r ml dataargu children sequenc dataargu assequ select c c oclistypeof r ml datavari collect c thismodul datavari c dataargu assequ select c c oclistypeof r ml datavari rule typecategori creat xml attribut r ml typecategori r ml term element lazi rule typecategori r ml term xml attribut name r ml typecategori valu typecategori individu individu els typecategori set set els typecategori orderedset order els typecategori bag bag els typecategori sequenc sequenc els oclundefin endif endif endif endif endif rule dataoperationtermarg creat xml element r ml argument r ml dataoperationterm element lazi rule dataoperationtermarg r ml dataoperationterm xml element name r ml argument children sequenc argument assequ select c c oclistypeof r ml objectvari collect c thismodul objectvari c argument assequ select c c oclistypeof r ml datavari collect c thismodul datavari c argument assequ select c c oclistypeof r ml objectvari c oclistypeof r ml datavari rule typedliter creat xml element r ml typedliter r ml typedliter element rule typedliter r ml typedliter oclistypeof r ml typedliter xml element name r ml typedliter children sequenc type valu type xml attribut name r ml datatypeid valu type name valu xml attribut name r ml lexicalvalu valu lexicalvalu rule plainliter creat xml element r ml plainliter r ml plainliter element rule plainliter r ml plainliter oclistypeof r ml plainliter xml element name sequenc languagetag oclisundefin thismodul plainliterallanguagetag els oclundefin endif valu valu xml attribut name r ml lexicalvalu valu lexicalvalu rule plainliterallanguagetag creat xml attribut r ml languagetag r ml plainliter element lazi rule plainliterallanguagetag r ml plainliter xml attribut name r ml languagetag valu languagetag rule attributefunctionterm creat xml element r ml attributefunctionterm r ml attributefunctionterm element rule attributefunctionterm r ml attributefunctionterm oclistypeof r ml attributefunctionterm xml element name r ml attributefunctionterm children sequenc attr contextarg typecategori oclisundefin thismodul typecategori els oclundefin endif attr xml attribut name r ml attributeid valu attribut name contextarg xml element name r ml contextargu children sequenc contextargu oclistypeof r ml objectvari thismodul objectvari contextargu els contextargu endif rule associationatom creat xml element r ml associationatom r ml associationatom element rule associationatom r ml associationatom oclistypeof r ml associationatom xml element name r ml associationatom children sequenc isneg isneg attribut thismodul atomisneg els oclundefin endif assocpr objarg dataargu size thismodul associationatomdataarg els oclundefin endif assocpr xml attribut name r ml associationpredicateid valu associationpred name objarg xml element name r ml objectargu children sequenc objectargu assequ select c c oclistypeof r ml objectvari collect c thismodul objectvari c objectargu assequ select c c oclistypeof r ml objectvari rule associationatomdataarg creat xml element r ml dataargu r ml associationatom element lazi rule associationatomdataarg r ml associationatom xml element name r ml dataargu children sequenc dataargu assequ select c c oclistypeof r ml datavari collect c thismodul datavari c dataargu assequ select c c oclistypeof r ml datavari rule referencepropertyfunctionterm creat xml element r ml referencepropertyfunctionterm r ml referencepropertyfunctionterm element rule referencepropertyfunctionterm r ml referencepropertyfunctionterm oclistypeof r ml referencepropertyfunctionterm xml element name r ml referencepropertyfunctionterm children sequenc refprop contextarg typecategori oclisundefin thismodul typecategori els oclundefin endif refprop xml attribut name r ml referencepropertyid valu referencepropertyref name contextarg xml element name r ml contextargu children sequenc contextargu oclistypeof r ml objectvari thismodul objectvari contextargu els contextargu endif rule attributionatom creat xml element r ml attributionatom r ml attributionatom element rule attributionatom r ml attributionatom oclistypeof r ml attributionatom xml element name r ml attributionatom children sequenc attr isneg isneg attribut thismodul atomisneg els oclundefin endif subject datavalu attr xml attribut name r ml attributeid valu attribut name subject xml element name r ml subject children sequenc subject oclistypeof r ml objectvari thismodul objectvari subject els subject endif datavalu xml element name r ml datavalu children sequenc datavalu oclistypeof r ml datavari thismodul datavari datavalu els datavalu endif rule referencepropertyatom creat xml element r ml referencepropertyatom r ml referencepropertyatom element rule referencepropertyatom r ml referencepropertyatom oclistypeof r ml referencepropertyatom xml element name r ml referencepropertyatom children sequenc isneg isneg attribut thismodul atomisneg els oclundefin endif refprop subject object refprop xml attribut name r ml referencepropertyid valu referenceproperti name subject xml element name r ml subject children sequenc subject oclistypeof r ml objectvari thismodul objectvari subject els subject endif object xml element name r ml object children sequenc object oclistypeof r ml objectvari thismodul objectvari object els object endif rule genericatom creat xml element r ml genericatom r ml genericatom element rule genericatom r ml genericatom oclistypeof r ml genericatom xml element name r ml genericatom children sequenc predic arg predic xml attribut name r ml predicateid valu predic name arg xml element name r ml argument children sequenc argument assequ select c c oclistypeof r ml genericvari collect c thismodul genericvari c argument assequ select c c oclistypeof r ml objectvari collect c thismodul objectvari c argument assequ select c c oclistypeof r ml datavari collect c thismodul datavari c argument assequ select c c ocliskindof r ml variabl rule predicatetyp creat xml attribut r ml predicatetyp r ml genericatom element lazi rule predicatetyp r ml genericpred xml attribut name r ml predicatetyp valu predicatetypeid objectclassificationpred objectclassificationpred els predicatetypeid attributionpred attributionpred els predicatetypeid associationpred associationpred els predicatetypeid referencepropertypred referencepropertypred els predicatetypeid equalitypred equalitypred els predicatetypeid inequalitypred inequalitypred els predicatetypeid datatypepred datatypepred els predicatetypeid dataclassificationpred dataclassificationpred els oclundefin endif endif endif endif endif endif endif endif rule genericfunctionterm creat xml element r ml genericfunctionterm r ml genericfunctionterm element rule genericfunctionterm r ml genericfunctionterm oclistypeof r ml genericfunctionterm xml element name r ml genericfunctionterm children sequenc attr arg attr xml attribut name r ml genericfunctionid valu functor name arg xml element name r ml argument children sequenc argument assequ select c c oclistypeof r ml genericvari collect c thismodul genericvari c argument assequ select c c oclistypeof r ml genericvari typecategori oclisundefin thismodul typecategori els oclundefin endif rule datatypefunctionterm creat xml element r ml datatypefunctionterm r ml datatypefunctionterm element rule datatypefunctionterm r ml datatypefunctionterm oclistypeof r ml datatypefunctionterm xml element name r ml datatypefunctionterm children sequenc attr arg attr xml attribut name datatypefunctionid valu function name arg xml element name r ml dataargu children sequenc dataargu assequ select c c oclistypeof r ml datavari collect c thismodul datavari c dataargu assequ select c c oclistypeof r ml datavari typecategori oclisundefin thismodul typecategori els oclundefin endif rule objectnam creat xml element r ml objectnam r ml objectnam element rule objectnam r ml objectnam oclistypeof r ml objectnam xml element name r ml objectnam children sequenc attr classref oclisundefin thismodul classrul classref els oclundefin endif typecategori oclisundefin thismodul typecategori els oclundefin endif attr xml attribut name r ml objectid valu name rule objectdescriptionatom creat xml element r ml objectdescriptionatom r ml objectdescriptionatom element rule objectdescriptionatom r ml objectdescriptionatom oclistypeof r ml objectdescriptionatom xml element name r ml objectdescriptionatom children sequenc class basetyp oclisundefin thismodul classrul basetyp els oclundefin endif subject slot object class xml attribut name r ml classid valu type name subject xml element name r ml subject children sequenc subject oclistypeof r ml objectvari thismodul objectvari subject els subject endif object xml element name r ml object children object rule objectslot creat xml element r ml objectslot r ml objectslot element rule objectslot r ml objectslot oclistypeof r ml objectslot xml element name r ml objectslot children sequenc attr object attr xml attribut name r ml referencepropertyid valu referenceproperti name object xml element name r ml object children sequenc object oclistypeof r ml objectvari thismodul objectvari object els object endif rule dataslot creat xml element r ml dataslot r ml dataslot element rule dataslot r ml dataslot oclistypeof r ml dataslot xml element name r ml dataslot children sequenc attr valu attr xml attribut name r ml attributeid valu attribut name valu xml element name r ml valu children sequenc valu oclistypeof r ml datavari thismodul datavari valu els valu endif rule atleastquantifiedformula creat xml element r ml atleastquantifiedformula r ml atleastquantifiedformula element rule atleastquantifiedformula r ml atleastquantifiedformula oclistypeof r ml atleastquantifiedformula xml element name r ml atleastquantifiedformula children sequenc attr variabl assequ select c c oclistypeof r ml objectvari collect e thismodul objectvari e variabl assequ select c c oclistypeof r ml datavari collect e thismodul datavari e formula attr xml attribut name r ml mincardin valu mincardin tostr rule atmostquantifiedformula creat xml element r ml atmostquantifiedformula r ml atmostquantifiedformula element rule atmostquantifiedformula r ml atmostquantifiedformula oclistypeof r ml atmostquantifiedformula xml element name r ml atmostquantifiedformula children sequenc attr variabl assequ select c c oclistypeof r ml objectvari collect e thismodul objectvari e variabl assequ select c c oclistypeof r ml datavari collect e thismodul datavari e formula attr xml attribut name r ml maxcardin valu maxcardin tostr rule atleastandatmostquantifiedformula creat xml element r ml atleastandatmostquantifiedformula r ml atleastandatmostquantifiedformula element rule atleastandatmostquantifiedformula r ml atleastandatmostquantifiedformula oclistypeof r ml atleastandatmostquantifiedformula xml element name r ml atleastandatmostquantifiedformula children sequenc attrmax attrmin variabl assequ select c c oclistypeof r ml objectvari collect e thismodul objectvari e variabl assequ select c c oclistypeof r ml datavari collect e thismodul datavari e formula attrmax xml attribut name r ml maxcardin valu maxcardin tostr attrmin xml attribut name r ml mincardin valu mincardin tostr rule objectoperationterm creat xml element r ml objectoperationterm r ml objectoperationterm element rule objectoperationterm r ml objectoperationterm oclistypeof r ml objectoperationterm xml element name r ml objectoperationterm children sequenc oper contextarg argument size argument els oclundefin endif oper xml attribut name r ml operationid valu oper name contextarg xml element name r ml contextargu children sequenc contextargu oclistypeof r ml objectvari thismodul objectvari contextargu els contextargu endif rule dataoperationterm creat xml element r ml dataoperationterm r ml dataoperationterm element rule dataoperationterm r ml dataoperationterm oclistypeof r ml dataoperationterm xml element name r ml dataoperationterm children sequenc attr argument size thismodul dataoperationtermarg els oclundefin endif contarg typecategori oclisundefin thismodul typecategori els oclundefin endif attr xml attribut name r ml operationid valu dataoperationref name contarg xml element name r ml contextargu children sequenc contextargu oclistypeof r ml objectvari thismodul objectvari contextargu els contextargu endif,6
138,138,P62-TextualPathExp2PathExp.atl,"module TextualPathExp2PathExp;
create OUT : PathExp from IN : TextualPathExp;


-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- This helper returns the root TextualPathExp element of the input
-- TextualPathExp model.
-- CONTEXT: thisModule
-- RETURN:	TextualPathExp!TextualPathExp
helper def: root : TextualPathExp!TextualPathExp = 
	TextualPathExp!TextualPathExp.allInstances()
		->asSequence()->first();


-- This helper returns the 1st Transition element contained by the root
-- TextualPathExp model.
-- CONTEXT: thisModule
-- RETURN:	TextualPathExp!Transition
helper def: rootTrans : TextualPathExp!Transition = 
	thisModule.root.path.transitions->first();


-- This helper returns the last Transition element contained by the root
-- TextualPathExp model.
-- CONTEXT: thisModule
-- RETURN:	TextualPathExp!Transition
helper def: leafTrans : TextualPathExp!Transition = 
	thisModule.root.path.transitions->last();


-- This helper computes the Set containing all the Path elements of the input
-- TextualPathExp model.
-- CONTEXT: thisModule
-- RETURN:	Set(TextualPathExp!Path)
helper def: allPaths : Set(TextualPathExp!Path) = 
	TextualPathExp!Path.allInstances();


-- This helper computes the Set of Path elements that are contained by
-- AlternativeTransition elements.
-- CONTEXT: thisModule
-- RETURN:	Set(TextualPathExp!PrimitiveTrans)
helper def: altPaths : Set(TextualPathExp!Path) = 
	thisModule.allPaths
		->select(a |
			TextualPathExp!AlternativeTrans.allInstances()
				->collect(b | b.altPaths)
				->flatten()
				->includes(a)
		);


-- This helper computes the Set of PrimitiveTrans that are not contained
-- by any AlternativeTransition.
-- To this end, it selects, among all Paths, those that are not contained
-- by any AlternativeTransition element. It then gets, for the selected Paths,
-- the transitions of type PrimitiveTrans.
-- CONTEXT: thisModule
-- RETURN:	Set(TextualPathExp!PrimitiveTrans)
helper def: primTransitions : Set(TextualPathExp!PrimitiveTrans) = 
	TextualPathExp!Path.allInstances()
		->select(a |
			not TextualPathExp!AlternativeTrans.allInstances()
				->collect(b | b.altPaths)
				->flatten()
				->includes(a)
		)
		->collect(p | p.transitions)
		->flatten()
		->select(c | c.oclIsTypeOf(TextualPathExp!PrimitiveTrans));


-- This helper computes the Set of 'single' primitive transitions.
-- For this purpose, it selects in the primTransitions set, the transitions
-- whose 'isMultiple' attribute is set to false.
-- CONTEXT: thisModule
-- RETURN:	Set(TextualPathExp!PrimitiveTrans)
helper def: singlePrimTransitions : Set(TextualPathExp!PrimitiveTrans) = 
	thisModule.primTransitions->select(c | c.isMultiple = false);


-- This helper computes the Set of 'multiple' primitive transitions.
-- For this purpose, it selects in the primTransitions set, the transitions
-- whose 'isMultiple' attribute is set to true.
-- CONTEXT: thisModule
-- RETURN:	Set(TextualPathExp!PrimitiveTrans)
helper def: multiplePrimTransitions : Set(TextualPathExp!PrimitiveTrans) = 
	thisModule.primTransitions->select(c | c.isMultiple = true);


-- This helper computes the Set of PrimitiveTrans that are contained by an
-- AlternativeTransition, except those that are the last transition of their
-- Path.
-- To this end, the helper first collects the transitions contained by each
-- alternative path. For each collected sequence of transitions of size S, it
-- gets the (S-1 ) first transition. Finally, it selects in the built sequence
-- the transitions of type PrimitiveTrans.
-- CONTEXT: thisModule
-- RETURN:	Set(TextualPathExp!PrimitiveTrans)
helper def: altTransitions1 : Set(TextualPathExp!PrimitiveTrans) = 
	thisModule.altPaths
		->collect(p | p.transitions)
		->iterate(e;
				  res : Sequence(Sequence(TextualPathExp!Transition)) = Set{} |
			res->including(e->subSequence(1, e->size()-1))
		)
		->asSequence()
		->flatten()
		->select(c | c.oclIsTypeOf(TextualPathExp!PrimitiveTrans));


-- This helper computes the Set of 'single' alternative transitions.
-- For this purpose, it selects in the altTransitions1 set, the transitions
-- whose 'isMultiple' attribute is set to false.
-- CONTEXT: thisModule
-- RETURN:	Set(TextualPathExp!PrimitiveTrans)
helper def: singleAltTransitions1 : Set(TextualPathExp!PrimitiveTrans) = 
	thisModule.altTransitions1->select(c | c.isMultiple = false);


-- This helper computes the Set of 'multiple' alternative transitions.
-- For this purpose, it selects in the altTransitions1 set, the transitions
-- whose 'isMultiple' attribute is set to true.
-- CONTEXT: thisModule
-- RETURN:	Set(TextualPathExp!PrimitiveTrans)
helper def: multipleAltTransitions1 : Set(TextualPathExp!PrimitiveTrans) = 
	thisModule.altTransitions1->select(c | c.isMultiple = true);


-- This helper computes the Set of PrimitiveTrans that are contained by an
-- AlternativeTransition and that are the last transition of their Path (which
-- may also be the first transition if the path contains a singel transition).
-- To this end, the helper first collects the transitions contained by each
-- alternative path. For each collected sequence of transitions of size S, it
-- gets the transition number S. Finally, it selects in the built sequence
-- the transitions of type PrimitiveTrans.
-- CONTEXT: thisModule
-- RETURN:	Set(TextualPathExp!PrimitiveTrans)
helper def: altTransitions2 : Set(TextualPathExp!PrimitiveTrans) = 
	thisModule.altPaths
		->collect(p | p.transitions)
		->iterate(e;
				  res : Sequence(Sequence(TextualPathExp!Transition)) = Set{} |
			res->including(e->last())
		)
		->asSequence()
		->flatten()
		->select(c | c.oclIsTypeOf(TextualPathExp!PrimitiveTrans));


-- This helper computes the containing Path of the contextual Transition
-- element.
-- For this purpose, it selects ammong all Paths, the one that contains the
-- contextual Transition elements.
-- CONTEXT: TextualPathExp!Transition
-- RETURN:	TextualPathExp!Path
helper context TextualPathExp!Transition
	def: getPath() :  TextualPathExp!Path = 
	thisModule.allPaths
		->select(a | a.transitions->includes(self))
		->first();


-- This helper computes a boolean value assessing whether or not the contextual
-- PrimitiveTrans is the last transition of its Path.
-- To this end, the helper first gets the path of the contextual transition (by
-- means of the 'getPath' helper) and then compares the contextual transition
-- to the last transition of the path.
-- CONTEXT: TextualPathExp!PrimitiveTrans
-- RETURN:	TextualPathExp!Transition
helper context TextualPathExp!PrimitiveTrans
	def: isLastOfPath() : Boolean = 
	let p : TextualPathExp!Path = self.getPath()
	in self = p.transitions->last();
	

-- This helper computes a boolean value assessing whether or not the contextual
-- PrimitiveTrans is the first transition of its Path.
-- To this end, the helper first gets the path of the contextual transition (by
-- means of the 'getPath' helper) and then compares the contextual transition
-- to the first transition of the path.
-- CONTEXT: TextualPathExp!PrimitiveTrans
-- RETURN:	TextualPathExp!Transition
helper context TextualPathExp!PrimitiveTrans
	def: isFirstOfPath() : Boolean = 
	let p : TextualPathExp!Path = self.getPath()
	in self = p.transitions->first();

		
-- This helper computes the Transition for which is generated the target state
-- of the loop defined by the contextual PrimitiveTrans. A multiple primitive
-- transition only leads to the generation of a loop transition. As a
-- consequence, the computed Transition is the one preceding the contextual 
-- primitive transition in their path. The contextual primitrive transition
-- should therefore not be the first of its path.
-- CONTEXT: TextualPathExp!PrimitiveTrans
-- RETURN:	TextualPathExp!Transition
helper context TextualPathExp!PrimitiveTrans
	def: getLoopTarget() : TextualPathExp!Transition = 
	let p : TextualPathExp!Path = self.getPath()
	in let i : Integer = p.transitions->indexOf(self)
	in p.transitions->at(i-1);


-- This helper computes a boolean value assessing whether or not the contextual
-- PrimitiveTrans is preceding a multiple transition in its Path.
-- If the contextual PrimitiveTrans is the last transition of its Path, the
-- helper returns false. Otherwise, it returns the value of the 'isMultiple'
-- attribute of the next transition in the path.
-- CONTEXT: TextualPathExp!PrimitiveTrans
-- RETURN:	Boolean
helper context TextualPathExp!PrimitiveTrans
	def: loopIncoming() : Boolean = 
	let p : TextualPathExp!Path = self.getPath()
	in let i : Integer = p.transitions->indexOf(self)
	in if self = p.transitions->last() then
			false
	   else
			p.transitions->at(i+1).isMultiple
	   endif;


-- This helper computes the incoming/outgoing loop Transition of the contextual
-- multiple PrimitiveTrans.
-- For this purpose, it returns the next transition in the path.
-- PRECOND:	this helper should only be called from a PrimTransition that
-- precedes a multiple PrimitiveTrans.
-- CONTEXT: TextualPathExp!PrimitiveTrans
-- RETURN:	TextualPathExp!Transition
helper context TextualPathExp!PrimitiveTrans
	def: getLoopIncoming() : TextualPathExp!Transition = 
	let p : TextualPathExp!Path = self.getPath()
	in let i : Integer = p.transitions->indexOf(self)
	in p.transitions->at(i + 1);


-- This helper computes the set of primitive transitions (except loop
-- transitions) that follow the contextual transition.
-- For this purpose, the helper first gets the transition next to the
-- contextual transition in the same path.
-- If this following transition is a PrimitiveTrans and is not multiple, the
-- helper returns the transition. If the following transition is a multiple
-- PrimitiveTrans, then the helper looks for the transitions that follow this
-- next transition by means of a recursive call onto this ""next transition"".
-- If the following transition is an AlternativeTrans, the helper collects the
-- first transition of each alternative path of the AlternativeTrans, and
-- returns the calculated set.
-- CONTEXT: TextualPathExp!Transition
-- IN:		Integer
-- RETURN:	Set(TextualPathExp!PrimitiveTrans)
helper context TextualPathExp!Transition
	def: getOutgoing() : Set(TextualPathExp!PrimitiveTrans) = 
	let p : TextualPathExp!Path = self.getPath()
	in let i : Integer = p.transitions->indexOf(self)
	in let t : TextualPathExp!Transition = p.transitions->at(i + 1)
	in if t.oclIsTypeOf(TextualPathExp!PrimitiveTrans) then
			if not t.isMultiple then 
				Set{t}
			else
				t.getOutgoing()
			endif
	   else
		t.altPaths
			->iterate(e; res : Set(TextualPathExp!PrimitiveTrans) = Set{} |
				res->including(e.transitions->first()) 
			)
	   endif;


-- This helper computes the Transition (primitive or alternative) that precedes
-- the contextual PrimitiveTrans in the input TextualPathExp model.
-- To this end, the helper first checks whether or not the contextual
-- PrimitiveTrans is the first transition of its Path.
-- If the contextual transition is the first of its path, the helper first gets
-- the AtlernativeTrans the contextual transition belongs to. It then gets the
-- Path in which this AlternativeTrans is defined, and the rank of the
-- AlternativeTrans within this Path. From then, it gets the transition that
-- precedes the computed AlternativeTrans. The helper returns this preceding
-- transition if it is not multiple. If the preceding transition is multiple,
-- the helper returns the transition that precedes this preceding transition
-- by means of a recursive call of the helper onto the transition that precedes
-- the AlternativeTrans.
-- If the contextual transition is not the first of its path, the helper
-- returns its preceding transition if this last is not multiple. If the
-- preceding transition is multiple, the helper returns the preceding
-- transition of the preceding transition by means of a recursive call of the
-- helper onto the transition preceding the contextual transition.
-- PRECOND: this helper should not be called on the root Transition of the
-- input model.
-- CONTEXT: TextualPathExp!PrimitiveTrans
-- RETURN:	TextualPathExp!Transition
helper context TextualPathExp!PrimitiveTrans
	def: getPreviousTransition() : TextualPathExp!Transition = 
	let p : TextualPathExp!Path = self.getPath() in
	if self.isFirstOfPath() then
		let alt : TextualPathExp!AlternativeTrans =
			TextualPathExp!AlternativeTrans.allInstances()
				->select(a | a.altPaths->includes(p))
				->first()
		in let p2 : TextualPathExp!Path =
			thisModule.allPaths
				->select(a | a.transitions->includes(alt))
				->first()
		in let i : Integer = p2.transitions->indexOf(alt)
		in let t : TextualPathExp!Transition = 
			p2.transitions->at(i-1) in
		if t.isMultiple then
			t.getPreviousTransition()
		else
			t
		endif
	else
		let i : Integer = p.transitions->indexOf(self)
		in let t : TextualPathExp!Transition = 
			p.transitions->at(i-1) in
		if t.isMultiple then
			t.getPreviousTransition()
		else
			t
		endif
	endif;
		

-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'Main'
-- This rule generates both a PathExp element and its initial State element
-- from the input root TextualPathExp element.
-- The generated PathExp element accepts an empty string as name. Its set of
-- states corresponds to the 'pe_s' elements generated for the input elements
-- of the singlePrimTransitions, singleAltTransitions sets, plus the 'pe_s'
-- elements generated for AlternativeTransition, plus the initial State
-- generated by the current rule. Its set of transitions corresponds to the
-- 'pe_t' elements generated for the input elements in the primTransitions,
-- altTransitions1, and altTransitions2 sets.
-- The generated initial State has an empty set of incoming transitions. Its
-- set of outgoing transitions corresponds to the 'pe_t' elements that are
-- generated for the outgoing transitions computed by the getOutgoing(0) call.
rule Main {
	from
        tpe : TextualPathExp!TextualPathExp
	to 
		pe : PathExp!PathExp (
			name <- '',
			states <- Set{
						thisModule.singlePrimTransitions
							->collect(e | thisModule.resolveTemp(e, 'pe_s')),
						thisModule.singleAltTransitions1
							->collect(e | thisModule.resolveTemp(e, 'pe_s')),
						TextualPathExp!AlternativeTrans.allInstances()
							->collect(e | thisModule.resolveTemp(e, 'pe_s')),
						pe_s
						},
			transitions <- Set{
						thisModule.primTransitions
							->collect(e | thisModule.resolveTemp(e, 'pe_t')),
						thisModule.altTransitions1
							->collect(e | thisModule.resolveTemp(e, 'pe_t')),
						thisModule.altTransitions2
							->collect(e | thisModule.resolveTemp(e, 'pe_t'))
							}
		),
		
		pe_s : PathExp!State (
			incoming <- Set{},
			outgoing <- Set{thisModule.rootTrans}
							->collect(e | thisModule.resolveTemp(e, 'pe_t'))
		)
}


-- Rule 'AlternativeTrans'
-- This rule generates the State element that closes an input
-- AlternativeTransition element. The generated State is the one at which the
-- different alternative paths of the AlternativeTransition join.
-- Incoming transitions of the generated state correspond to the elements
-- generated for the last alternative transitions of the input
-- AlternativeTransition element.
-- Outgoing transitions of the generated state correspond to the 'pe_t'
-- elements generated for the set of transitions returned by the call of
-- getOutgoing(1).
rule AlternativeTrans {
	from
		tpe_at : TextualPathExp!AlternativeTrans (
--			tpe_at.isMultiple = false
			true
		)
	to 
		pe_s : PathExp!State (
			incoming <- thisModule.altTransitions2
							->select(a | tpe_at.altPaths
								->collect(b | b.transitions)
								->flatten()
								->includes(a)
							),
			outgoing <- tpe_at.getOutgoing()
							->collect(e | thisModule.resolveTemp(e, 'pe_t'))
		)
}


-- Rule ''
-- This rule generates ...
--rule MultipleAlternativeTrans {
--	from
--		tpe_at : TextualPathExp!AlternativeTrans (
--			tpe_at.isMultiple = true
--		)
--	to 
--		pe_s : PathExp!State (
--			outgoing <- Set{
--						tpe_at.getOutgoing()
--							->collect(e | thisModule.resolveTemp(e, 'pe_t')),
--						pe_t}
--		),
--		
--		pe_t : PathExp!Transition (
--			name <- ''--,
--			target <- pe_s
--		)
--}


-- Rule 'SinglePrimitiveTrans'
-- This rule generates both a Transition and a State for each PrimitiveTrans
-- element that belongs to the 'singlePrimTransitions' set.
-- The generated transition accepts as name the name of the input
-- PrimitiveTrans. If the input PrimitiveTrans is the root transition of the
-- input model, its source corresponds to the 'pe_s' initial state generated
-- for the input TextualPathExp element by rule 'Main'. Otherwise, the source
-- element corresponds to the 'pe_s' element generated for the transition that
-- precedes the input PrimitiveTrans in the current Path. Its target is the
-- State generated by the rule.
-- Incoming transitions for the generated State include the Transition
-- generated by the rule and, when the input Transition precedes a multiple
-- transition, the 'pe_t' element generated for this next transition.
-- If the input PrimitiveTrans is the leaf transition of the input model, the
-- generated State has no outgoing transitions. Otherwise, its outgoing
-- transition corresponds to the 'pe_t' element generated for the input
-- transition returned by the call of getOugoing(). Moreover, if the input
-- Transition precedes a multiple transition, the 'pe_t' element generated for
-- this next transition is added to the set ougoing transitions of the
-- generated State.
rule SinglePrimitiveTrans {
	from
       tpe_pt : TextualPathExp!PrimitiveTrans (
			thisModule.singlePrimTransitions->includes(tpe_pt)
       	)
	to 
		pe_t : PathExp!Transition (
			name <- tpe_pt.name,
			source <- 
					if tpe_pt = thisModule.rootTrans then
						thisModule.resolveTemp(thisModule.root, 'pe_s')
					else
						let p : TextualPathExp!Path = tpe_pt.getPath()
						in let i : Integer = p.transitions->indexOf(tpe_pt)
						in let t : TextualPathExp!Transition = 
							p.transitions->at(i-1)
						in thisModule.resolveTemp(t, 'pe_s')
					endif,
			target <- pe_s
		),
		
		pe_s : PathExp!State (
			incoming <- Set{pe_t}->union(
							if tpe_pt.loopIncoming() then
								Set{thisModule.resolveTemp(tpe_pt.getLoopIncoming(), 'pe_t')}
							else
								Set{}
							endif
						),
			outgoing <- if tpe_pt = thisModule.leafTrans then
							Set{}
						else
							tpe_pt.getOutgoing()
								->collect(e | thisModule.resolveTemp(e, 'pe_t'))
								->union(
								if tpe_pt.loopIncoming() then
									Set{thisModule.resolveTemp(tpe_pt.getLoopIncoming(), 'pe_t')}
								else
									Set{}
								endif
								)
						endif
		)
}


-- Rule 'MultiplePrimitiveTrans'
-- This rule generates a loop transition for each transition that belongs
-- to the 'multiplePrimTransitions' set. The generated transition is a
-- transition from and to the state generated for the previous input
-- transition.
-- The generated loop transition accepts the name of the input Transition as
-- name.
-- If the input PrimitiveTrans is the root transition of the input model, its
-- source is the initial State generated by the 'Main' rule. Otherwise, the
-- source is computed by the getLoopTarget() helper.
-- If the input PrimitiveTrans is the root transition of the input model, its
-- target is the initial State generated by the 'Main' rule. Otherwise, the
-- target is computed by the getLoopTarget() helper.
rule MultiplePrimitiveTrans {
	from
       tpe_pt : TextualPathExp!PrimitiveTrans (
			thisModule.multiplePrimTransitions->includes(tpe_pt)
       	)
	to 
		pe_t : PathExp!Transition (
			name <- tpe_pt.name,
			source <- 
					if tpe_pt = thisModule.rootTrans then
						thisModule.resolveTemp(thisModule.root, 'pe_s')
					else
						tpe_pt.getLoopTarget()
					endif,
			target <-
					if tpe_pt = thisModule.rootTrans then
						thisModule.resolveTemp(thisModule.root, 'pe_s')
					else
						tpe_pt.getLoopTarget()
					endif
		)
}


-- Rule 'SingleAltTrans1'
-- This rule generates both a Transition and a State for each PrimitiveTrans
-- element that belongs to the 'singleAltTransitions1' set.
-- The generated transition accepts as name the name of the input
-- PrimitiveTrans. Its source element corresponds to the 'pe_s' element
-- generated for the transition returned by the call of the
-- 'getPrevioustransition' helper. Its target is the State generated by the
-- rule.
-- Incoming transitions for the generated State include the Transition
-- generated by the rule and, when the input Transition precedes a multiple
-- transition, the 'pe_t' element generated for this next transition.
-- Outgoing transitions for the generated State include to the 'pe_t' element
-- generated for the input transition returned by the call of getOugoing(1).
-- Moreover, if the input Transition precedes a multiple transition, the 'pe_t'
-- element generated for this next transition is added to the set ougoing
-- transitions of the generated State.
rule SingleAltTrans1 {
	from
       tpe_pt : TextualPathExp!PrimitiveTrans (
			thisModule.singleAltTransitions1->includes(tpe_pt)
       	)
	to 
		pe_t : PathExp!Transition (
			name <- tpe_pt.name,
			source <-
					thisModule.resolveTemp(
						tpe_pt.getPreviousTransition(),
						'pe_s'
					),
			target <- pe_s
		),
		
		pe_s : PathExp!State (
			incoming <- Set{pe_t}->union(
							if tpe_pt.loopIncoming() then
								Set{thisModule.resolveTemp(tpe_pt.getLoopIncoming(), 'pe_t')}
							else
								Set{}
							endif
						),
			outgoing <- tpe_pt.getOutgoing()
							->collect(e | thisModule.resolveTemp(e, 'pe_t'))
							->union(
							if tpe_pt.loopIncoming() then
								Set{thisModule.resolveTemp(tpe_pt.getLoopIncoming(), 'pe_t')}
							else
								Set{}
							endif
							)
		)
}


-- Rule 'MultipleAltTrans1'
-- This rule generates a loop transition for each transition that belongs
-- to the 'multipleAltTransitions1' set. The generated transition is a
-- transition from and to the state generated for the previous input
-- transition.
-- The generated loop transition accepts the name of the input Transition as
-- name.
-- Its source corresponds to the 'pe_s' element generated for the input State
-- returned by the call to the getLoopTarget() helper.
-- Its target corresponds to the 'pe_s' element generated for the input State
-- returned by the call to the getLoopTarget() helper.
rule MultipleAltTrans1 {
	from
       tpe_pt : TextualPathExp!PrimitiveTrans (
			thisModule.multipleAltTransitions1->includes(tpe_pt)
       	)
	to 
		pe_t : PathExp!Transition (
			name <- tpe_pt.name,
			source <- thisModule.resolveTemp(tpe_pt.getLoopTarget(), 'pe_s'),
			target <- thisModule.resolveTemp(tpe_pt.getLoopTarget(), 'pe_s')
		)
}


-- Rule 'AltTrans2'
-- This rule generates a Transition from the last Transition of a Path
-- contained by an AlternativeTransition. The generated transition goes from
-- the state generated for the previous transition to the final state generated
-- for the current AlternativeTransition by the 'AlternativeTrans' helper.
-- The generated loop transition accepts the name of the input Transition as
-- name.
-- Its source corresponds to the 'pe_s' element generated for the input element
-- returned by the call of the 'getPreviousTransition()' helper.
-- Its target corresponds to the 'pe_s' element generated for the
-- AlternativeTransition element that contains the rule input PrimitiveTrans
-- element in one of its alternative pathes.
rule AltTrans2 {
	from
       tpe_pt : TextualPathExp!PrimitiveTrans (
			thisModule.altTransitions2->includes(tpe_pt)
       	)
	to 
		pe_t : PathExp!Transition (
			name <- tpe_pt.name,
			source <- thisModule.resolveTemp(
						tpe_pt.getPreviousTransition(),
						'pe_s'),
			target <- thisModule.resolveTemp(
						TextualPathExp!AlternativeTrans.allInstances()
							->select(a | a.altPaths
								->collect(b | b.transitions)
								->flatten()
								->includes(tpe_pt)
							)->asSequence()
							->first(),
						'pe_s')
		)
}
",modul textualpathexp pathexp creat out pathexp in textualpathexp helper this helper return root textualpathexp element input textualpathexp model context thismodul return textualpathexp textualpathexp helper def root textualpathexp textualpathexp textualpathexp textualpathexp allinst assequ first this helper return st transit element contain root textualpathexp model context thismodul return textualpathexp transit helper def roottran textualpathexp transit thismodul root path transit first this helper return last transit element contain root textualpathexp model context thismodul return textualpathexp transit helper def leaftran textualpathexp transit thismodul root path transit last this helper comput set contain path element input textualpathexp model context thismodul return set textualpathexp path helper def allpath set textualpathexp path textualpathexp path allinst this helper comput set path element contain alternativetransit element context thismodul return set textualpathexp primitivetran helper def altpath set textualpathexp path thismodul allpath select textualpathexp alternativetran allinst collect b b altpath flatten includ this helper comput set primitivetran contain alternativetransit to end select among path contain alternativetransit element it get select path transit type primitivetran context thismodul return set textualpathexp primitivetran helper def primtransit set textualpathexp primitivetran textualpathexp path allinst select textualpathexp alternativetran allinst collect b b altpath flatten includ collect p p transit flatten select c c oclistypeof textualpathexp primitivetran this helper comput set singl primit transit for purpos select primtransit set transit whose ismultipl attribut set fals context thismodul return set textualpathexp primitivetran helper def singleprimtransit set textualpathexp primitivetran thismodul primtransit select c c ismultipl fals this helper comput set multipl primit transit for purpos select primtransit set transit whose ismultipl attribut set true context thismodul return set textualpathexp primitivetran helper def multipleprimtransit set textualpathexp primitivetran thismodul primtransit select c c ismultipl true this helper comput set primitivetran contain alternativetransit except last transit path to end helper first collect transit contain altern path for collect sequenc transit size s get s first transit final select built sequenc transit type primitivetran context thismodul return set textualpathexp primitivetran helper def alttransit set textualpathexp primitivetran thismodul altpath collect p p transit iter e res sequenc sequenc textualpathexp transit set res includ e subsequ e size assequ flatten select c c oclistypeof textualpathexp primitivetran this helper comput set singl altern transit for purpos select alttransit set transit whose ismultipl attribut set fals context thismodul return set textualpathexp primitivetran helper def singlealttransit set textualpathexp primitivetran thismodul alttransit select c c ismultipl fals this helper comput set multipl altern transit for purpos select alttransit set transit whose ismultipl attribut set true context thismodul return set textualpathexp primitivetran helper def multiplealttransit set textualpathexp primitivetran thismodul alttransit select c c ismultipl true this helper comput set primitivetran contain alternativetransit last transit path may also first transit path contain singel transit to end helper first collect transit contain altern path for collect sequenc transit size s get transit number s final select built sequenc transit type primitivetran context thismodul return set textualpathexp primitivetran helper def alttransit set textualpathexp primitivetran thismodul altpath collect p p transit iter e res sequenc sequenc textualpathexp transit set res includ e last assequ flatten select c c oclistypeof textualpathexp primitivetran this helper comput contain path contextu transit element for purpos select ammong path one contain contextu transit element context textualpathexp transit return textualpathexp path helper context textualpathexp transit def getpath textualpathexp path thismodul allpath select transit includ self first this helper comput boolean valu assess whether contextu primitivetran last transit path to end helper first get path contextu transit mean getpath helper compar contextu transit last transit path context textualpathexp primitivetran return textualpathexp transit helper context textualpathexp primitivetran def islastofpath boolean let p textualpathexp path self getpath self p transit last this helper comput boolean valu assess whether contextu primitivetran first transit path to end helper first get path contextu transit mean getpath helper compar contextu transit first transit path context textualpathexp primitivetran return textualpathexp transit helper context textualpathexp primitivetran def isfirstofpath boolean let p textualpathexp path self getpath self p transit first this helper comput transit generat target state loop defin contextu primitivetran a multipl primit transit lead generat loop transit as consequ comput transit one preced contextu primit transit path the contextu primitr transit therefor first path context textualpathexp primitivetran return textualpathexp transit helper context textualpathexp primitivetran def getlooptarget textualpathexp transit let p textualpathexp path self getpath let integ p transit indexof self p transit this helper comput boolean valu assess whether contextu primitivetran preced multipl transit path if contextu primitivetran last transit path helper return fals otherwis return valu ismultipl attribut next transit path context textualpathexp primitivetran return boolean helper context textualpathexp primitivetran def loopincom boolean let p textualpathexp path self getpath let integ p transit indexof self self p transit last fals els p transit ismultipl endif this helper comput incom outgo loop transit contextu multipl primitivetran for purpos return next transit path precond helper call primtransit preced multipl primitivetran context textualpathexp primitivetran return textualpathexp transit helper context textualpathexp primitivetran def getloopincom textualpathexp transit let p textualpathexp path self getpath let integ p transit indexof self p transit this helper comput set primit transit except loop transit follow contextu transit for purpos helper first get transit next contextu transit path if follow transit primitivetran multipl helper return transit if follow transit multipl primitivetran helper look transit follow next transit mean recurs call onto next transit if follow transit alternativetran helper collect first transit altern path alternativetran return calcul set context textualpathexp transit in integ return set textualpathexp primitivetran helper context textualpathexp transit def getoutgo set textualpathexp primitivetran let p textualpathexp path self getpath let integ p transit indexof self let textualpathexp transit p transit oclistypeof textualpathexp primitivetran ismultipl set els getoutgo endif els altpath iter e res set textualpathexp primitivetran set res includ e transit first endif this helper comput transit primit altern preced contextu primitivetran input textualpathexp model to end helper first check whether contextu primitivetran first transit path if contextu transit first path helper first get atlernativetran contextu transit belong it get path alternativetran defin rank alternativetran within path from get transit preced comput alternativetran the helper return preced transit multipl if preced transit multipl helper return transit preced preced transit mean recurs call helper onto transit preced alternativetran if contextu transit first path helper return preced transit last multipl if preced transit multipl helper return preced transit preced transit mean recurs call helper onto transit preced contextu transit precond helper call root transit input model context textualpathexp primitivetran return textualpathexp transit helper context textualpathexp primitivetran def getprevioustransit textualpathexp transit let p textualpathexp path self getpath self isfirstofpath let alt textualpathexp alternativetran textualpathexp alternativetran allinst select altpath includ p first let p textualpathexp path thismodul allpath select transit includ alt first let integ p transit indexof alt let textualpathexp transit p transit ismultipl getprevioustransit els endif els let integ p transit indexof self let textualpathexp transit p transit ismultipl getprevioustransit els endif endif rule rule main this rule generat pathexp element initi state element input root textualpathexp element the generat pathexp element accept empti string name it set state correspond pe element generat input element singleprimtransit singlealttransit set plus pe element generat alternativetransit plus initi state generat current rule it set transit correspond pe element generat input element primtransit alttransit alttransit set the generat initi state empti set incom transit it set outgo transit correspond pe element generat outgo transit comput getoutgo call rule main tpe textualpathexp textualpathexp pe pathexp pathexp name state set thismodul singleprimtransit collect e thismodul resolvetemp e pe thismodul singlealttransit collect e thismodul resolvetemp e pe textualpathexp alternativetran allinst collect e thismodul resolvetemp e pe pe transit set thismodul primtransit collect e thismodul resolvetemp e pe thismodul alttransit collect e thismodul resolvetemp e pe thismodul alttransit collect e thismodul resolvetemp e pe pe pathexp state incom set outgo set thismodul roottran collect e thismodul resolvetemp e pe rule alternativetran this rule generat state element close input alternativetransit element the generat state one differ altern path alternativetransit join incom transit generat state correspond element generat last altern transit input alternativetransit element outgo transit generat state correspond pe element generat set transit return call getoutgo rule alternativetran tpe textualpathexp alternativetran tpe ismultipl fals true pe pathexp state incom thismodul alttransit select tpe altpath collect b b transit flatten includ outgo tpe getoutgo collect e thismodul resolvetemp e pe rule this rule generat rule multiplealternativetran tpe textualpathexp alternativetran tpe ismultipl true pe pathexp state outgo set tpe getoutgo collect e thismodul resolvetemp e pe pe pe pathexp transit name target pe rule singleprimitivetran this rule generat transit state primitivetran element belong singleprimtransit set the generat transit accept name name input primitivetran if input primitivetran root transit input model sourc correspond pe initi state generat input textualpathexp element rule main otherwis sourc element correspond pe element generat transit preced input primitivetran current path it target state generat rule incom transit generat state includ transit generat rule input transit preced multipl transit pe element generat next transit if input primitivetran leaf transit input model generat state outgo transit otherwis outgo transit correspond pe element generat input transit return call getougo moreov input transit preced multipl transit pe element generat next transit ad set ougo transit generat state rule singleprimitivetran tpe pt textualpathexp primitivetran thismodul singleprimtransit includ tpe pt pe pathexp transit name tpe pt name sourc tpe pt thismodul roottran thismodul resolvetemp thismodul root pe els let p textualpathexp path tpe pt getpath let integ p transit indexof tpe pt let textualpathexp transit p transit thismodul resolvetemp pe endif target pe pe pathexp state incom set pe union tpe pt loopincom set thismodul resolvetemp tpe pt getloopincom pe els set endif outgo tpe pt thismodul leaftran set els tpe pt getoutgo collect e thismodul resolvetemp e pe union tpe pt loopincom set thismodul resolvetemp tpe pt getloopincom pe els set endif endif rule multipleprimitivetran this rule generat loop transit transit belong multipleprimtransit set the generat transit transit state generat previous input transit the generat loop transit accept name input transit name if input primitivetran root transit input model sourc initi state generat main rule otherwis sourc comput getlooptarget helper if input primitivetran root transit input model target initi state generat main rule otherwis target comput getlooptarget helper rule multipleprimitivetran tpe pt textualpathexp primitivetran thismodul multipleprimtransit includ tpe pt pe pathexp transit name tpe pt name sourc tpe pt thismodul roottran thismodul resolvetemp thismodul root pe els tpe pt getlooptarget endif target tpe pt thismodul roottran thismodul resolvetemp thismodul root pe els tpe pt getlooptarget endif rule singlealttran this rule generat transit state primitivetran element belong singlealttransit set the generat transit accept name name input primitivetran it sourc element correspond pe element generat transit return call getprevioustransit helper it target state generat rule incom transit generat state includ transit generat rule input transit preced multipl transit pe element generat next transit outgo transit generat state includ pe element generat input transit return call getougo moreov input transit preced multipl transit pe element generat next transit ad set ougo transit generat state rule singlealttran tpe pt textualpathexp primitivetran thismodul singlealttransit includ tpe pt pe pathexp transit name tpe pt name sourc thismodul resolvetemp tpe pt getprevioustransit pe target pe pe pathexp state incom set pe union tpe pt loopincom set thismodul resolvetemp tpe pt getloopincom pe els set endif outgo tpe pt getoutgo collect e thismodul resolvetemp e pe union tpe pt loopincom set thismodul resolvetemp tpe pt getloopincom pe els set endif rule multiplealttran this rule generat loop transit transit belong multiplealttransit set the generat transit transit state generat previous input transit the generat loop transit accept name input transit name it sourc correspond pe element generat input state return call getlooptarget helper it target correspond pe element generat input state return call getlooptarget helper rule multiplealttran tpe pt textualpathexp primitivetran thismodul multiplealttransit includ tpe pt pe pathexp transit name tpe pt name sourc thismodul resolvetemp tpe pt getlooptarget pe target thismodul resolvetemp tpe pt getlooptarget pe rule alttran this rule generat transit last transit path contain alternativetransit the generat transit goe state generat previous transit final state generat current alternativetransit alternativetran helper the generat loop transit accept name input transit name it sourc correspond pe element generat input element return call getprevioustransit helper it target correspond pe element generat alternativetransit element contain rule input primitivetran element one altern path rule alttran tpe pt textualpathexp primitivetran thismodul alttransit includ tpe pt pe pathexp transit name tpe pt name sourc thismodul resolvetemp tpe pt getprevioustransit pe target thismodul resolvetemp textualpathexp alternativetran allinst select altpath collect b b transit flatten includ tpe pt assequ first pe,0
139,139,P62-XML2PetriNet.atl,"module XML2PetriNet;
create OUT : PetriNet from IN : XML;


-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------


-- This helper computes the Set containing all the XML!Element of the input
-- XML model that are named 'place'.
-- CONTEXT: thisModule
-- RETURN:	Set(XML!Element)
helper def: allPlaces : Set(XML!Element) = 
	XML!Element.allInstances()
		->select(e | e.name = 'place');


-- This helper computes the Set containing all the XML!Element of the input
-- XML model that are named 'transition'.
-- CONTEXT: thisModule
-- RETURN:	Set(XML!Element)
helper def: allTransitions : Set(XML!Element) = 
	XML!Element.allInstances()
		->select(e | e.name = 'transition');


-- This helper computes the Set containing all the XML!Element of the input
-- XML model that are named 'arc'.
-- CONTEXT: thisModule
-- RETURN:	Set(XML!Element)
helper def: allArcs : Set(XML!Element) = 
	XML!Element.allInstances()
		->select(e | e.name = 'arc');


-- This helper computes the name value of an input XML!Element.
-- For this purpose, it first selects among its elements children the one
-- named 'name'. It then selects, among children of this new element, the one
-- named 'text'. It then selects the XML!Text child of this last element and
-- returns its value.
-- CONTEXT: XML!Element
-- RETURN:	String
helper context XML!Element def : getName() : String =
	self.children
		->select(c | c.oclIsTypeOf(XML!Element) and c.name = 'name')
		->first().children
		->select(c | c.oclIsTypeOf(XML!Element) and c.name = 'text')
		->first().children
		->first().value;


-- This helper calculates the value of a given attribute (identified by the
-- name provided as a parameter) of the contextual XML!Element.
-- To this end, it selects among its attribute children the one which has the
-- name provided in parameter, and returns its value.
-- CONTEXT: XML!Element
-- IN:		String
-- RETURN:	String
helper context XML!Element def : getAttributeValue(name : String) : String = 
	self.children
		->select(c | c.oclIsTypeOf(XML!Attribute) and c.name = name)
		->first().value;


-- This helper calculates the value of the 'id' attribute of the contextual
-- XML!Element. For this purpose, it calls the 'getAttributeValue' with 'id'
-- as parameter.
-- CONTEXT: XML!Element
-- RETURN:	String
helper context XML!Element def : getId() : String =
	self.getAttributeValue('id');


-- This helper calculates the value of the 'target' attribute of the contextual
-- XML!Element. For this purpose, it calls the 'getAttributeValue' with
-- 'target' as parameter.
-- CONTEXT: XML!Element
-- RETURN:	String
helper context XML!Element def : getTarget() : String =
	self.getAttributeValue('target');


-- This helper calculates the value of the 'source' attribute of the contextual
-- XML!Element. For this purpose, it calls the 'getAttributeValue' with
-- 'source' as parameter.
-- CONTEXT: XML!Element
-- RETURN:	String
helper context XML!Element def : getSource() : String =
	self.getAttributeValue('source');


-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------


-- Rule 'Main'
-- This rule generates a PetriNet element from the XML!Element called 'net'.
-- Name of the generated PetriNet is computed by the 'getName' helper.
-- Its places, transitions and arcs respectively correspond to the elements
-- generated for the XML!Elements named 'place', 'transition', and 'arc'.
rule Main {
	from
        xml_net : XML!Element (
        	xml_net.name = 'net'
        )
	to 
		pn : PetriNet!PetriNet (
			name <- xml_net.getName(),
			places <- thisModule.allPlaces,
			transitions <- thisModule.allTransitions,
			arcs <- thisModule.allArcs
		)
}


-- Rule 'State'
-- This rule generates a Place element for each XML!Element called 'place'.
-- Name of the generated Place is computed by the 'getName' helper.
-- Its incoming arcs correspond to the elements generated for the XML!Element
-- named 'arc' whose target is the input 'place' XML!Element.
-- Its outgoing arcs correspond to the elements generated for the XML!Element
-- named 'arc' whose source is the input 'place' XML!Element.
rule Place {
	from
        xml_place :  XML!Element (
        	xml_place.name = 'place'
        )
	to 
		pn_p : PetriNet!Place (
			name <- xml_place.getName(),
			incoming <- thisModule.allArcs
							->select(a | a.getTarget() = xml_place.getId()),
			outgoing <- thisModule.allArcs
							->select(a | a.getSource() = xml_place.getId())
		)
}


-- Rule 'Transition'
-- This rule generates a Transition element for each XML!Element called
-- 'transition'.
-- Generated Place accepts an empty string as name.
-- Its incoming arcs correspond to the elements generated for the XML!Element
-- named 'arc' whose target is the input 'transition' XML!Element.
-- Its outgoing arcs correspond to the elements generated for the XML!Element
-- named 'arc' whose source is the input 'transition' XML!Element.
rule Transition {
	from
        xml_trans :  XML!Element (
        	xml_trans.name = 'transition'
        )
	to
		pn_t : PetriNet!Transition (
			name <- '',
			incoming <- thisModule.allArcs
							->select(a | a.getTarget() = xml_trans.getId()),
			outgoing <- thisModule.allArcs
							->select(a | a.getSource() = xml_trans.getId())
		)
}


-- Rule 'PlaceToTransArc'
-- This rule generates a PlaceToTransArc element for each XML!Element called
-- 'arc' whose source is a 'place' XML!Element.
-- The source of the generated PlaceToTransArc corresponds to the element
-- generated for the 'place' XML!Element whose 'id' is equal to the source of
-- the input 'arc' XML!Element.
-- The target of the generated PlaceToTransArc corresponds to the element
-- generated for the 'transition' XML!Element whose 'id' is equal to the target
-- of the input 'arc' XML!Element.
rule PlaceToTransArc {
	from
        xml_arc :  XML!Element (
        	if xml_arc.name = 'arc' then
				thisModule.allPlaces
					->collect(p | p.getId())
					->includes(xml_arc.getSource())
			else
				false
			endif
        )
	to
		pn_a : PetriNet!PlaceToTransArc (
			weight <- 1,
			source <- thisModule.allPlaces
						->select(b | b.getId() = xml_arc.getSource())
						->first(),
			target <- thisModule.allTransitions
						->select(b | b.getId() = xml_arc.getTarget())
						->first()
		)
}


-- Rule 'TransToPlaceArc'
-- This rule generates a TransToPlaceArc element for each XML!Element called
-- 'arc' whose source is an 'transition' XML!Element.
-- The source of the generated TransToPlaceArc corresponds to the element
-- generated for the 'transition' XML!Element whose 'id' is equal to the source
-- of the input 'arc' XML!Element.
-- The target of the generated TransToPlaceArc corresponds to the element
-- generated for the 'place' XML!Element whose 'id' is equal to the target of
-- the input 'arc' XML!Element.
rule TransToPlaceArc {
	from
        xml_arc :  XML!Element (
        	if xml_arc.name = 'arc' then
				thisModule.allTransitions
					->collect(p | p.getId())
					->includes(xml_arc.getSource())
			else
				false
			endif
        )
	to
		pn_a : PetriNet!TransToPlaceArc (
			weight <- 1,
			source <- thisModule.allTransitions
						->select(b | b.getId() = xml_arc.getSource())
						->first(),
			target <- thisModule.allPlaces
						->select(b | b.getId() = xml_arc.getTarget())
						->first()
		)
}
",modul xml petrinet creat out petrinet in xml helper this helper comput set contain xml element input xml model name place context thismodul return set xml element helper def allplac set xml element xml element allinst select e e name place this helper comput set contain xml element input xml model name transit context thismodul return set xml element helper def alltransit set xml element xml element allinst select e e name transit this helper comput set contain xml element input xml model name arc context thismodul return set xml element helper def allarc set xml element xml element allinst select e e name arc this helper comput name valu input xml element for purpos first select among element children one name name it select among children new element one name text it select xml text child last element return valu context xml element return string helper context xml element def getnam string self children select c c oclistypeof xml element c name name first children select c c oclistypeof xml element c name text first children first valu this helper calcul valu given attribut identifi name provid paramet contextu xml element to end select among attribut children one name provid paramet return valu context xml element in string return string helper context xml element def getattributevalu name string string self children select c c oclistypeof xml attribut c name name first valu this helper calcul valu id attribut contextu xml element for purpos call getattributevalu id paramet context xml element return string helper context xml element def getid string self getattributevalu id this helper calcul valu target attribut contextu xml element for purpos call getattributevalu target paramet context xml element return string helper context xml element def gettarget string self getattributevalu target this helper calcul valu sourc attribut contextu xml element for purpos call getattributevalu sourc paramet context xml element return string helper context xml element def getsourc string self getattributevalu sourc rule rule main this rule generat petrinet element xml element call net name generat petrinet comput getnam helper it place transit arc respect correspond element generat xml element name place transit arc rule main xml net xml element xml net name net pn petrinet petrinet name xml net getnam place thismodul allplac transit thismodul alltransit arc thismodul allarc rule state this rule generat place element xml element call place name generat place comput getnam helper it incom arc correspond element generat xml element name arc whose target input place xml element it outgo arc correspond element generat xml element name arc whose sourc input place xml element rule place xml place xml element xml place name place pn p petrinet place name xml place getnam incom thismodul allarc select gettarget xml place getid outgo thismodul allarc select getsourc xml place getid rule transit this rule generat transit element xml element call transit generat place accept empti string name it incom arc correspond element generat xml element name arc whose target input transit xml element it outgo arc correspond element generat xml element name arc whose sourc input transit xml element rule transit xml tran xml element xml tran name transit pn petrinet transit name incom thismodul allarc select gettarget xml tran getid outgo thismodul allarc select getsourc xml tran getid rule placetotransarc this rule generat placetotransarc element xml element call arc whose sourc place xml element the sourc generat placetotransarc correspond element generat place xml element whose id equal sourc input arc xml element the target generat placetotransarc correspond element generat transit xml element whose id equal target input arc xml element rule placetotransarc xml arc xml element xml arc name arc thismodul allplac collect p p getid includ xml arc getsourc els fals endif pn petrinet placetotransarc weight sourc thismodul allplac select b b getid xml arc getsourc first target thismodul alltransit select b b getid xml arc gettarget first rule transtoplacearc this rule generat transtoplacearc element xml element call arc whose sourc transit xml element the sourc generat transtoplacearc correspond element generat transit xml element whose id equal sourc input arc xml element the target generat transtoplacearc correspond element generat place xml element whose id equal target input arc xml element rule transtoplacearc xml arc xml element xml arc name arc thismodul alltransit collect p p getid includ xml arc getsourc els fals endif pn petrinet transtoplacearc weight sourc thismodul alltransit select b b getid xml arc getsourc first target thismodul allplac select b b getid xml arc gettarget first,0
140,140,P63-TypeA2TypeB_v1.atl,"-- @path TypeA=/Port/Metamodel/TypeA.ecore
-- @path TypeB=/Port/Metamodel/TypeB.ecore

module TypeA2TypeB;
create inB : TypeB from inA : TypeA;

rule BlkA2BlkB {
	from
		blkA : TypeA!BlockA
	to
		blkB : TypeB!BlockB (
			inputPorts <- inPts,
			outputPorts <- outPts
		),
		inPts : distinct TypeB!InPortB foreach(ptA in blkA.inputPorts)(
				name <- ptA.name),
		outPts : distinct TypeB!OutPortB foreach(ptA in blkA.outputPorts)(
				name <- ptA.name)				
}",path typea port metamodel typea ecor path typeb port metamodel typeb ecor modul typea typeb creat inb typeb ina typea rule blka blkb blka typea blocka blkb typeb blockb inputport inpt outputport outpt inpt distinct typeb inportb foreach pta blka inputport name pta name outpt distinct typeb outportb foreach pta blka outputport name pta name,4
141,141,P63-TypeA2TypeB_v2.atl,"-- @path TypeA=/Port/Metamodel/TypeA.ecore
-- @path TypeB=/Port/Metamodel/TypeB.ecore

module TypeA2TypeB;
create inB : TypeB from inA : TypeA;

rule BlkA2BlkB {
	from
		blkA : TypeA!BlockA
	to
		blkB : TypeB!BlockB (
			inputPorts <- blkA.inputPorts->collect(e | thisModule.PortA2InPortB(e)),
			outputPorts <- blkA.outputPorts->collect(e | thisModule.PortA2OutPortB(e))
		)
}

lazy rule PortA2InPortB {
	from
		s : TypeA!PortA
	to
		t : TypeB!InPortB (
			name <- s.name
		)
}

lazy rule PortA2OutPortB {
	from
		s : TypeA!PortA
	to
		t : TypeB!OutPortB (
			name <- s.name
		)
}",path typea port metamodel typea ecor path typeb port metamodel typeb ecor modul typea typeb creat inb typeb ina typea rule blka blkb blka typea blocka blkb typeb blockb inputport blka inputport collect e thismodul porta inportb e outputport blka outputport collect e thismodul porta outportb e lazi rule porta inportb typea porta typeb inportb name name lazi rule porta outportb typea porta typeb outportb name name,4
142,142,P63-TypeA2TypeB_v3.atl,"-- @path TypeA=/Port/Metamodel/TypeA.ecore
-- @path TypeB=/Port/Metamodel/TypeB.ecore

module TypeA2TypeB;
create inB : TypeB from inA : TypeA;

rule BlkA2BlkB {
	from
		blkA : TypeA!BlockA
	to
		blkB : TypeB!BlockB (
			inputPorts <- blkA.inputPorts,
			outputPorts <- blkA.outputPorts
		)
}

rule PortA2InPortB {
	from
		s : TypeA!PortA (TypeA!BlockA.allInstances()->select(e | e.inputPorts->includes(s))->notEmpty())
	to
		t : TypeB!InPortB (
			name <- s.name
		)
}

rule PortA2OutPortB {
	from
		s : TypeA!PortA (TypeA!BlockA.allInstances()->select(e | e.outputPorts->includes(s))->notEmpty())
	to
		t : TypeB!OutPortB (
			name <- s.name
		)
}",path typea port metamodel typea ecor path typeb port metamodel typeb ecor modul typea typeb creat inb typeb ina typea rule blka blkb blka typea blocka blkb typeb blockb inputport blka inputport outputport blka outputport rule porta inportb typea porta typea blocka allinst select e e inputport includ notempti typeb inportb name name rule porta outportb typea porta typea blocka allinst select e e outputport includ notempti typeb outportb name name,4
143,143,P63-TypeA2TypeB_v4.atl,"-- @path TypeA=/Port/Metamodel/TypeA.ecore
-- @path TypeB=/Port/Metamodel/TypeB.ecore

module TypeA2TypeB;
create inB : TypeB from inA : TypeA;

rule BlkA2BlkB {
	from
		blkA : TypeA!BlockA
	to
		blkB : TypeB!BlockB (
			inputPorts <- blkA.inputPorts,
			outputPorts <- blkA.outputPorts
		)
}

rule PortA2InPortB {
	from
		s : TypeA!PortA (s.refImmediateComposite().inputPorts->includes(s))
	to
		t : TypeB!InPortB (
			name <- s.name
		)
}

rule PortA2OutPortB {
	from
		s : TypeA!PortA (s.refImmediateComposite().outputPorts->includes(s))
	to
		t : TypeB!OutPortB (
			name <- s.name
		)
}",path typea port metamodel typea ecor path typeb port metamodel typeb ecor modul typea typeb creat inb typeb ina typea rule blka blkb blka typea blocka blkb typeb blockb inputport blka inputport outputport blka outputport rule porta inportb typea porta refimmediatecomposit inputport includ typeb inportb name name rule porta outportb typea porta refimmediatecomposit outputport includ typeb outportb name name,4
144,144,P64-Public2Private.atl,"module Public2Private;
create OUT : UML refining IN : UML;

helper context String def: firstToUpper() : String =
	self.substring(1, 1).toUpper() + self.substring(2, self.size());

rule ReadOnlyPublicAttribute {
	from
		s : UML!Attribute (
			(s.visibility = #vk_public) and
			(s.changeability = #ck_frozen)
		)
	to
		t : UML!Attribute (
			name <- s.name,
			owner <- s.owner,
			type <- s.type,
			ownerScope <- s.ownerScope,
			visibility <- #vk_private,
			changeability <- s.changeability
		),

		-- getter
		tg : UML!Operation (
			name <- 'get' + s.name.firstToUpper(),
			owner <- s.owner,
			visibility <- #vk_public,
			ownerScope <- s.ownerScope,
			isQuery <- true,
			parameter <- tgr
		),
		tgr : UML!Parameter (
			name <- 'return',
			kind <- #pdk_return,
			type <- s.type
		)
}

rule ReadWritePublicAttribute {
	from
		s : UML!Attribute (
			(s.visibility = #vk_public) and
			(s.changeability <> #ck_frozen)
		)
	to
		t : UML!Attribute (
			name <- s.name,
			owner <- s.owner,
			type <- s.type,
			ownerScope <- s.ownerScope,
			visibility <- #vk_private,
			changeability <- s.changeability
		),

		-- getter
		tg : UML!Operation (
			name <- 'get' + s.name.firstToUpper(),
			owner <- s.owner,
			visibility <- #vk_public,
			ownerScope <- s.ownerScope,
			isQuery <- true,
			parameter <- tgr
		),
		tgr : UML!Parameter (
			name <- 'return',
			kind <- #pdk_return,
			type <- s.type
		),

		-- setter
		ts : UML!Operation (
			name <- 'set' + s.name.firstToUpper(),
			owner <- s.owner,
			visibility <- #vk_public,
			ownerScope <- s.ownerScope,
			parameter <- tsp
		),
		tsp : UML!Parameter (
			name <- 'newValue',
			kind <- #pdk_in,
			type <- s.type
		)
}

",modul public privat creat out uml refin in uml helper context string def firsttoupp string self substr toupper self substr self size rule readonlypublicattribut uml attribut visibl vk public changeabl ck frozen uml attribut name name owner owner type type ownerscop ownerscop visibl vk privat changeabl changeabl getter tg uml oper name get name firsttoupp owner owner visibl vk public ownerscop ownerscop isqueri true paramet tgr tgr uml paramet name return kind pdk return type type rule readwritepublicattribut uml attribut visibl vk public changeabl ck frozen uml attribut name name owner owner type type ownerscop ownerscop visibl vk privat changeabl changeabl getter tg uml oper name get name firsttoupp owner owner visibl vk public ownerscop ownerscop isqueri true paramet tgr tgr uml paramet name return kind pdk return type type setter ts uml oper name set name firsttoupp owner owner visibl vk public ownerscop ownerscop paramet tsp tsp uml paramet name newvalu kind pdk type type,16
145,145,P65-R2ML2OCL.atl,"-- ============================================================
-- Transforms an R2ML metamodel into OCL metamodel (without general support for iterator expressions).
-- Created as part of M.Sc. theses at GOOD OLD AI Laboratory
-- Author: Milan Milanovic (milan at milanovic.org)
-- Works for R2ML v0.4 (Integrity  rules)
-- Licence: GNU General Public License, version 2
-- ============================================================

module R2ML2OCL; -- Module Template
create OUT : OCL from IN : R2ML;

uses strings;

-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- HELPER:	firstCharToUpper
-- Converts first character of String to upper and return complete string.
-- CONTEXT:	String
-- OUT:		String
helper context String def: firstCharToUpper() : String =
	let firstChar : String = self.substring(1, 1) in
		firstChar.toUpper() + self.substring(2, self.size());

-- HELPER:	toBoolean
-- Converts String value to Boolean value
-- CONTEXT:	String
-- IN:		String
-- OUT:		Boolean
helper context String def: toBoolean() : Boolean =
	if self = 'true'
	then true
	else false
	endif;

-- HELPER: getChildren
-- Returns all children for context Implication (for both, antecedent and consequent).
-- CONTEXT:	R2ML!Implication
-- OUT:		Sequence(R2ML!LogicalFormula)
helper context R2ML!Implication def: getChildren : Sequence(R2ML!LogicalFormula) =
	self.getAntecedent->asSequence()->union(self.getConsequent->asSequence());
	
-- HELPER: getAntecedent
-- Returns antecedent children for context Implication.
-- CONTEXT:	R2ML!Implication
-- OUT:		Sequence(R2ML!LogicalFormula)
helper context R2ML!Implication def: getAntecedent : Sequence(R2ML!LogicalFormula) 	=
	 if self.antecedent.oclIsTypeOf(R2ML!Conjuction) then
		self.antecedent.formulas
	 else Sequence{self.antecedent}
	 endif;
	
-- HELPER: getConsequent
-- Returns consequent children for context Implication.
-- CONTEXT:	R2ML!Implication
-- OUT:		Sequence(R2ML!LogicalFormula)
helper context R2ML!Implication def: getConsequent : Sequence(R2ML!LogicalFormula) 	=
	if self.consequent.oclIsTypeOf(R2ML!Conjuction) then
		self.consequent.formulas
	 else Sequence{self.consequent}
	 endif;

-- HELPER: getChildrenOfAllTopMostImplications
-- Returns all children elements (both, antecedents and consequents) for all topmost Implications (Rules).
-- OUT:		Sequence(R2ML!LogicalFormula)
helper def: getChildrenOfAllTopMostImplications() : Sequence(R2ML!LogicalFormula) =
	 let allImps : Sequence(R2ML!Implication) = thisModule.getTopMostUniversallyQuantifiedFormulas()->collect(c | c.formula)->flatten() in
  	 	allImps->collect(c | c.getChildren)->flatten();
	 
-- HELPER: getTopMostUniversallyQuantifiedFormulas
-- Returns all top-most UniversallyQuantifiedFormulas.
-- OUT:		 Sequence(R2ML!UniversallyQuantifiedFormula)
helper def: getTopMostUniversallyQuantifiedFormulas() : Sequence(R2ML!UniversallyQuantifiedFormula) =
	R2ML!AlethicIntegrityRule.allInstancesFrom('IN')->asSequence()->collect(c | c.constraint)->flatten();	

-- HELPER: getFirstObjectVariablesOfTopMostUniversallyQuantifiedFormulas
-- Returns all top-most UniversallyQuantifiedFormulas first variables. It is needed because
-- first variable is actually context in OCL.
-- OUT:		 Sequence(R2ML!ObjectVariable)
helper def: getFirstObjectVariablesOfTopMostUniversallyQuantifiedFormulas() : Sequence(R2ML!ObjectVariable) = 
	thisModule.getTopMostUniversallyQuantifiedFormulas()->collect(c | c.variables->asSequence()->first())->flatten()->select(c | c.oclIsTypeOf(R2ML!ObjectVariable))->asSequence();

-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'RuleBase2OclModule'
-- Create OclModule from RuleBase element 
rule RuleBase2OclModule {
	from i : R2ML!RuleBase (
			i.oclIsTypeOf(R2ML!RuleBase)
		)
	to o : OCL!OclModule (
			ownedElements <- i.rules->asSequence()->first().rules
		)
	
}

-- Rule 'AlethicIntegrityRule2Invariant'
-- Create OCL Invariant from R2ML AlethicIntegrityRule element 
rule AlethicIntegrityRule2Invariant {
	from i : R2ML!AlethicIntegrityRule (
			i.oclIsTypeOf(R2ML!AlethicIntegrityRule)
		)
	to o : OCL!Invariant (
			name <- if not i.ruleID.oclIsUndefined() then
						i.ruleID
					else OclUndefined
					endif,
			contextDefinition <- contextDef,
			specification <- if i.constraint.formula.oclIsTypeOf(R2ML!Implication) then
								-- In case of implication for forAll
								if i.constraint.formula.getChildren->forAll(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom)) then
									-- Specific case when we have Implication with three ReferencePropertyAtom-s or UniversallyQuantifiedFormula-s,
									-- then it is forAll
									thisModule.UniversallyQuantifiedFormulaImplication2ForAllIteratorExp(i.constraint)
								else i.constraint.formula
								endif
							else i.constraint.formula
							endif
		),
	  contextDef : OCL!OclContextDefinition (
	  		contextElement <- if not i.constraint.variables->asSequence()->first().classRef.oclIsUndefined() then
								thisModule.Class2Class(i.constraint.variables->asSequence()->first().classRef)
							  else thisModule.ObjectVariable2Class(i.constraint.variables->asSequence()->first())
							  endif
	  	)
}

-- Rule 'UniversallyQuantifiedFormulaImplication2ForAllIteratorExp'
-- Create OCL forAll IteratorExp from R2ML UniversallyQuantifiedFormula element
-- ANNOTATION: case when we have Implication with three ReferencePropertyAtom-s.
unique lazy rule UniversallyQuantifiedFormulaImplication2ForAllIteratorExp {
	from i : R2ML!UniversallyQuantifiedFormula
	to o : OCL!IteratorExp (
			name <- 'forAll',
			source <- opCallExp,
			body <- i.formula,
			iterator <- i.variables->asSequence()->excluding(i.variables->asSequence()->first())->collect(c | thisModule.ObjectVariable2Iterator(c))
		),
	   opCallExp : OCL!OperationCallExp (
	   		name <- 'allInstances',
			source <- varExp
	   	),
	   varExp : OCL!VariableExp (
	   		referredVariable <- var
	   	),
	   var : OCL!Variable (
	   		name <- i.variables->asSequence()->first().classRef.name
	   	)
}

-- Rule 'Disjunction2OperatorCallExp'
-- Create OCL 'or' OperatorCallExp from R2ML Disjunction element.
rule Disjunction2OperatorCallExp {
	from i : R2ML!Disjunction (
			i.oclIsTypeOf(R2ML!Disjunction)
		)
	to o : OCL!OperatorCallExp (
			name <- 'or',
			source <- i.formulas->asSequence()->first(),
			argument <- i.formulas->asSequence()->last()
		)
}

-- Rule 'Conjuction2OperatorCallExp'
-- Create OCL 'and' OperatorCallExp from R2ML Conjuction element.
rule Conjuction2OperatorCallExp {
	from i : R2ML!Conjuction (
			i.oclIsTypeOf(R2ML!Conjuction) and
			-- Checking because in rules with select, we have Conjuctions which doesn't
			-- need to be transformed.
			i.formulas->select(c | c.oclIsTypeOf(R2ML!ExistentiallyQuantifiedFormula))->size() = 0 and
			i.formulas->select(c | c.oclIsTypeOf(R2ML!UniversallyQuantifiedFormula))->size() = 0 and
			i.formulas->select(c | c.oclIsTypeOf(R2ML!GenericAtom))->size() = 0
		)
	to o : OCL!OperatorCallExp (
			name <- 'and',
			source <- i.formulas->asSequence()->first(),
			argument <- i.formulas->asSequence()->last()
		)
}

-- Rule 'Conjuction2IteratorExpSelect'
-- Create OCL 'select' IteratorExp from R2ML Conjuction element.
-- ANNOTATION: Used with select(...)->notEmpty() specific case.
rule Conjuction2IteratorExpSelect {
	from i : R2ML!Conjuction (
			i.oclIsTypeOf(R2ML!Conjuction) and
			i.formulas->select(c | c.oclIsTypeOf(R2ML!ExistentiallyQuantifiedFormula))->size() = 1
			)
	to o : OCL!CollectionOperationCallExp (
			name <- 'notEmpty',
			source <- itExp
		),
	   itExp : OCL!IteratorExp (
	   		name <- 'select',
			source <- i.formulas->select(c | not c.oclIsTypeOf(R2ML!ExistentiallyQuantifiedFormula))->first(),
			-- Get formula from Conjuction in ExistentiallyQuantifiedFormula for body,
			-- which is not GenericAtom.
			body <- i.formulas->select(c | c.oclIsTypeOf(R2ML!ExistentiallyQuantifiedFormula))->first().formula.formulas->select(c | not c.oclIsTypeOf(R2ML!GenericAtom))->first(),
			iterator <- i.formulas->select(c | c.oclIsTypeOf(R2ML!ExistentiallyQuantifiedFormula))->first().variables->collect(c | thisModule.ObjectVariable2Iterator(c))
	   	)
}

-- Rule 'Conjuction2IteratorExpForAll'
-- Create OCL 'forAll' IteratorExp from R2ML Conjuction element.
rule Conjuction2IteratorExpForAll {
	from i : R2ML!Conjuction (
			i.oclIsTypeOf(R2ML!Conjuction) and
			i.formulas->select(c | c.oclIsTypeOf(R2ML!UniversallyQuantifiedFormula))->size() = 1
			)
	to o : OCL!IteratorExp (
			name <- 'forAll',
			source <- i.formulas->select(c | not c.oclIsTypeOf(R2ML!UniversallyQuantifiedFormula))->first(),
			body <- i.formulas->select(c | c.oclIsTypeOf(R2ML!UniversallyQuantifiedFormula))->first().formula
		)
}

-- Rule 'EqualityAtom2OperatorCallExp'
-- Create OCL '<>' or '=' OperatorCallExp from R2ML EqualityAtom element, which
-- have exactly 2 members.
rule EqualityAtom2OperatorCallExp {
	from i : R2ML!EqualityAtom (
			i.oclIsTypeOf(R2ML!EqualityAtom) and
			i.terms->select(c | c.oclIsTypeOf(R2ML!ObjectVariable))->size() = 2
		)
	to o : OCL!OperatorCallExp (
			name <- if i.isNegated then
						'<>'
					else '='
					endif,
			source <- if thisModule.getFirstObjectVariablesOfTopMostUniversallyQuantifiedFormulas()->includes(i.terms->asSequence()->first()) then
						thisModule.ObjectVariable2VariableExp(i.terms->asSequence()->first())
					  else thisModule.ObjectVariable2VariableIteratorExp(i.terms->asSequence()->first())
					  endif,
			argument <- if thisModule.getFirstObjectVariablesOfTopMostUniversallyQuantifiedFormulas()->includes(i.terms->asSequence()->last()) then
							thisModule.ObjectVariable2VariableExp(i.terms->asSequence()->last())
						else thisModule.ObjectVariable2VariableIteratorExp(i.terms->asSequence()->last())
						endif
		)
}

-- Rule 'ReferencePropertyAtom2OperatorCallExp'
-- Create OCL '=' OperatorCallExp from R2ML ReferencePropertyAtom element.
rule ReferencePropertyAtom2OperatorCallExp {
	from i : R2ML!ReferencePropertyAtom	(
			i.oclIsTypeOf(R2ML!ReferencePropertyAtom)
		)
	to o : OCL!OperatorCallExp (
			name <- '=',
			source <- prop,
			argument <- if i.object.oclIsTypeOf(R2ML!ObjectVariable) then
							-- Checking is iterator variable or regular variable
							if thisModule.getFirstObjectVariablesOfTopMostUniversallyQuantifiedFormulas()->includes(i.object) then
								thisModule.ObjectVariable2VariableExp(i.object)
							else thisModule.ObjectVariable2VariableIteratorExp(i.object)
							endif
						else i.object
						endif
		),
	   prop : OCL!PropertyCallExp (
	   		name <- i.referenceProperty.name,
			source <- if i.subject.oclIsTypeOf(R2ML!ObjectVariable) then
							-- Checking is iterator variable or regular variable
							if thisModule.getFirstObjectVariablesOfTopMostUniversallyQuantifiedFormulas()->includes(i.subject) then
								thisModule.ObjectVariable2VariableExp(i.subject)
							else thisModule.ObjectVariable2VariableIteratorExp(i.subject)
							endif
						else i.subject
						endif
	   	)
}

-- Rule 'ReferencePropertyFunctionTerm2VariableExp'
-- Create OCL VariableExp from R2ML referenceProperty of ReferencePropertyFunctionTerm element.
rule ReferencePropertyFunctionTerm2VariableExp {
	from i : R2ML!ReferencePropertyFunctionTerm (
			i.oclIsTypeOf(R2ML!ReferencePropertyFunctionTerm) and
			i.contextArgument.oclIsTypeOf(R2ML!ObjectVariable)
		)
	to o : OCL!VariableExp (
			referredVariable <- thisModule.ReferenceProperty2Variable(i.referencePropertyRef)
		)
}

-- Rule 'ReferencePropertyFunctionTerm2PropertyCallExp'
-- Create OCL PropertyCallExp from R2ML ReferencePropertyFunctionTerm element, if
-- it is object variable as context argument.
rule ReferencePropertyFunctionTerm2PropertyCallExp {
	from i : R2ML!ReferencePropertyFunctionTerm (
			i.oclIsTypeOf(R2ML!ReferencePropertyFunctionTerm) and
			not i.contextArgument.oclIsTypeOf(R2ML!ObjectVariable)
		)
	to o : OCL!PropertyCallExp (
			name <- i.referencePropertyRef.name,
			source <- i.contextArgument
		)
}

-- Rule 'Implication2OperatorCallExp'
-- Create OCL OperatorCallExp from R2ML Implication element, if
-- doesn't have GenericAtom in antecedent (if have see rule below).
rule Implication2OperatorCallExp {
	from i : R2ML!Implication (
			i.oclIsTypeOf(R2ML!Implication) and
			not i.antecedent.oclIsTypeOf(R2ML!GenericAtom)
		)
	to o : OCL!OperatorCallExp (
			name <- 'implies',
			source <- i.antecedent,
			argument <- i.consequent
		)
}

-- Rule 'Implication2CollectionOperationCallExpIncludesAll'
-- Create OCL CollectionOperationCallExp ""includesAll"" from R2ML Implication element, 
-- if have GenericAtom in antecedent.
rule Implication2CollectionOperationCallExpIncludesAll {
	from i : R2ML!Implication (
			i.oclIsTypeOf(R2ML!Implication) and
			i.antecedent.oclIsTypeOf(R2ML!GenericAtom)
		)
	to o : OCL!CollectionOperationCallExp (
			name <- 'includesAll',
			source <- i.antecedent.arguments->select(c | not c.oclIsTypeOf(R2ML!GenericVariable))->first(),
			argument <- i.consequent.arguments->select(c | not c.oclIsTypeOf(R2ML!GenericVariable))->first()
		)
}

-- Rule 'ObjectClassificationAtom2OperationCallExp'
-- Create OCL OperationCallExp ""isKindOf"" from R2ML ObjectClassificationAtom element.
rule ObjectClassificationAtom2OperationCallExp {
	from i : R2ML!ObjectClassificationAtom (
			i.oclIsTypeOf(R2ML!ObjectClassificationAtom)
		)
	to o : OCL!OperationCallExp (
			name <- 'isKindOf',
			source <- if i.term.oclIsTypeOf(R2ML!ObjectVariable) then
					 	if thisModule.getFirstObjectVariablesOfTopMostUniversallyQuantifiedFormulas()->includes(i.term) then
							thisModule.ObjectVariable2VariableExp(i.term)
						else thisModule.ObjectVariable2VariableIteratorExp(i.term)
						endif
			          else i.term
					  endif,
			argument <- varExpArg
		),
	  varExpArg : OCL!VariableExp (
	  		referredVariable <- thisModule.Class2Variable(i.type)
	  	)
}

-- Rule 'AttributionAtom2OperatorCallExp'
-- Create OCL OperatorCallExp ""="" from R2ML AttributionAtom element.
rule AttributionAtom2OperatorCallExp {
	from i : R2ML!AttributionAtom (
			i.oclIsTypeOf(R2ML!AttributionAtom) and
			i.subject.oclIsTypeOf(R2ML!ObjectVariable) and
			i.dataValue.oclIsTypeOf(R2ML!TypedLiteral)
		)	
	to o : OCL!OperatorCallExp (
			name <- '=',
			source <- var,
			argument <- i.dataValue
		),
	   var : OCL!VariableExp (
	   		referredVariable <- thisModule.Attribute2Variable(i.attribute)
	   	)
}

-- Rule 'AttributionAtom2PropertyCallExp'
-- Create OCL PropertyCallExp from R2ML AttributionAtom element.
-- ANNOTATION: for before of select expression.
rule AttributionAtom2PropertyCallExp {
	from i : R2ML!AttributionAtom (
			i.oclIsTypeOf(R2ML!AttributionAtom) and
			i.subject.oclIsTypeOf(R2ML!ObjectVariable) and
			i.dataValue.oclIsTypeOf(R2ML!DataVariable)
			)	
	to o : OCL!PropertyCallExp (
			name <- i.attribute.name,
			source <- if thisModule.getFirstObjectVariablesOfTopMostUniversallyQuantifiedFormulas()->includes(i.subject) then
							thisModule.ObjectVariable2VariableExp(i.subject)
				      else thisModule.ObjectVariable2VariableIteratorExp(i.subject)
					  endif
		)
}

-- Unique lazy rule 'ObjectVariable2Iterator'
-- Create OCL Iterator variable from R2ML ObjectVariable element.
unique lazy rule ObjectVariable2Iterator {
	from i : R2ML!ObjectVariable
	to o : OCL!Iterator (
			name <- i.name
		)
}

-- Lazy rule 'ObjectVariable2VariableIteratorExp'
-- Create OCL VariableExp from R2ML ObjectVariable element.
lazy rule ObjectVariable2VariableIteratorExp {
	from i : R2ML!ObjectVariable
	to o : OCL!VariableExp (
			referredVariable <- thisModule.ObjectVariable2Iterator(i)
		)
}

-- Unique lazy rule 'ReferenceProperty2Variable'
-- Create OCL Variable from R2ML ReferenceProperty element.
unique lazy rule ReferenceProperty2Variable {
	from i : R2ML!ReferenceProperty
	to o : OCL!Variable(
			name <- i.name
		)
}

-- Unique lazy rule 'Attribute2Variable'
-- Create OCL Variable from R2ML Attribute element.
unique lazy rule Attribute2Variable {
	from i : R2ML!Attribute
	to o : OCL!Variable (
			name <- i.name
		)
}

-- Lazy rule 'ObjectVariable2VariableExp'
-- Create OCL VariableExp from R2ML ObjectVariable element.
lazy rule ObjectVariable2VariableExp {
	from i : R2ML!ObjectVariable
	to o : OCL!VariableExp (
			referredVariable <- thisModule.ObjectVariable2Variable(i)
		)
}

-- Unique lazy rule 'ObjectVariable2Variable'
-- Create OCL Variable from R2ML ObjectVariable element.
unique lazy rule ObjectVariable2Variable {
	from i : R2ML!ObjectVariable
	to o : OCL!Variable (
			-- If this source ObjectVariable is first in top-most UniversallyQuantifiedFormula,
			-- then it is self variable.
			name <- if thisModule.getFirstObjectVariablesOfTopMostUniversallyQuantifiedFormulas()->includes(i) then
						'self'
					else i.name
					endif
		)
}

-- Unique lazy rule 'ObjectVariable2Class'
-- Create OCL Class from R2ML ObjectVariable element (for OCL context).
unique lazy rule ObjectVariable2Class {
	from i : R2ML!ObjectVariable
	to o : OCL!Class (			
			name <- i.name.firstCharToUpper(),
			isAbstract <- false
		)
}

-- Unique lazy rule 'Class2Class'
-- Create OCL Class from R2ML Class element.
unique lazy rule Class2Class {
	from i : R2ML!Class
	to o : OCL!Class (			
			name <- i.name,
			isAbstract <- false
		)
}

-- Unique lazy rule 'Class2Variable'
-- Create OCL Variable from R2ML Class element.
unique lazy rule Class2Variable {
	from i : R2ML!Class
	to o : OCL!Variable (
			name <- i.name
		)
}

-- Rule 'DatatypePredicateAtom2OperatorCallExp'
-- Create OCL OperatorCallExp from R2ML DatatypePredicateAtom element.
rule DatatypePredicateAtom2OperatorCallExp {
	from i : R2ML!DatatypePredicateAtom (
			i.oclIsTypeOf(R2ML!DatatypePredicateAtom) and
			i.dataArguments->select(c | c.oclIsTypeOf(R2ML!AttributeFunctionTerm))->select(c | not c.typeCategory.oclIsUndefined())->size() = 0 or
			i.dataArguments->select(c | c.oclIsTypeOf(R2ML!DataOperationTerm) or c.oclIsTypeOf(R2ML!ObjectOperationTerm))->size() > 0			
		)
	to o : OCL!OperatorCallExp(
			name <- if i.predicate.name = 'swrlb:greaterThanOrEqual' then
						'>='
					else if i.predicate.name = 'swrlb:greaterThan' then
							'>'
						 else if i.predicate.name = 'swrlb:equal' then
								if i.isNegated then
									'<>'
								else '='
								endif
	  						  else if i.predicate.name = 'swrlb:lessThan' then
										'<'
			  					   else if i.predicate.name = 'swrlb:lessThanOrEqual' then
										'<='
				  					    else OclUndefined
									    endif
								   endif
						      endif
						 endif
					endif,
			source <- i.dataArguments->asSequence()->first(),
			argument <- i.dataArguments->asSequence()->last()
		)
}

-- Rule 'DatatypePredicateAtomNotNegated2CollectionOperationCallExp'
-- Create OCL CollectionOperationCallExp from R2ML DatatypePredicateAtom element.
rule DatatypePredicateAtomNotNegated2CollectionOperationCallExp {
	from i : R2ML!DatatypePredicateAtom (
			i.oclIsTypeOf(R2ML!DatatypePredicateAtom) and
			i.dataArguments->select(c | c.oclIsTypeOf(R2ML!AttributeFunctionTerm))->select(c | not c.typeCategory.oclIsUndefined())->size() > 0 and
			i.dataArguments->size() = 1 
			and i.isNegated = false
		)
	to o : OCL!CollectionOperationCallExp (
			name <- if i.predicate.name = 'swrlb:empty' then
						'isEmpty'
					else OclUndefined
					endif,
			source <- i.dataArguments->asSequence()->first()
		)
}

-- Rule 'DatatypePredicateAtomNegated2OperatorCallExp'
-- Create OCL OperatorCallExp 'not' from R2ML negated DatatypePredicateAtom element.
rule DatatypePredicateAtomNegated2OperatorCallExp {
	from i : R2ML!DatatypePredicateAtom (
			i.oclIsTypeOf(R2ML!DatatypePredicateAtom) and
			i.dataArguments->select(c | c.oclIsTypeOf(R2ML!AttributeFunctionTerm))->select(c | not c.typeCategory.oclIsUndefined())->size() > 0 and
			i.dataArguments->size() = 1 
			and i.isNegated = true
		)
	to o : OCL!OperatorCallExp (
			name <- 'not',
			source <- collOpExp
		),
	  collOpExp : OCL!CollectionOperationCallExp (
			name <- if i.predicate.name = 'swrlb:empty' then
						'isEmpty'
					else OclUndefined
					endif,
			source <- i.dataArguments->asSequence()->first()
		)
}

-- Rule 'DatatypePredicateAtom2SizeOperatorCallExp'
-- Create OCL OperatorCallExp '=' from R2ML DatatypePredicateAtom ('swrlb:length') element.
rule DatatypePredicateAtom2SizeOperatorCallExp {
	from i : R2ML!DatatypePredicateAtom (
			i.oclIsTypeOf(R2ML!DatatypePredicateAtom) and
			i.dataArguments->select(c | c.oclIsTypeOf(R2ML!AttributeFunctionTerm))->select(c | not c.typeCategory.oclIsUndefined())->size() > 0 and
			i.dataArguments->size() = 2 and
			i.predicate.name = 'swrlb:length'
			)
	to o : OCL!OperatorCallExp (
			name <- '=',
			source <- if i.dataArguments->asSequence()->first().oclIsKindOf(R2ML!DataFunctionTerm) then			
						if i.dataArguments->asSequence()->first().typeCategory.oclIsUndefined() then
							i.dataArguments->asSequence()->first()
					  	else if i.dataArguments->asSequence()->first().typeCategory = #bag then
					  			collCallExp
						   	 else OclUndefined
						     endif
					    endif
					  else i.dataArguments->asSequence()->first()
					  endif,
			argument <- if i.dataArguments->asSequence()->last().oclIsKindOf(R2ML!DataFunctionTerm) then			
							if i.dataArguments->asSequence()->last().typeCategory.oclIsUndefined() then
								i.dataArguments->asSequence()->last()
						  	else if i.dataArguments->asSequence()->last().typeCategory = #bag then
						  			collCallExp
							   	 else OclUndefined
							     endif
						    endif
					    else i.dataArguments->asSequence()->last()
					    endif 
		),
		collCallExp : OCL!CollectionOperationCallExp (
				name <- if i.predicate.name = 'swrlb:length' then
							'size'
						else OclUndefined
						endif,
				source <- if i.dataArguments->asSequence()->first().oclIsKindOf(R2ML!DataFunctionTerm) then			
							if not i.dataArguments->asSequence()->first().typeCategory.oclIsUndefined() then
								 if i.dataArguments->asSequence()->first().typeCategory = #bag then
						  			 i.dataArguments->asSequence()->first()
							   	 else i.dataArguments->asSequence()->last()
							     endif
							   else i.dataArguments->asSequence()->last()
						    endif
					     else i.dataArguments->asSequence()->last()
					     endif 
			)
}

-- Rule 'DatatypeFunctionTerm2CollectionOperationCallExp'
-- Create OCL CollectionOperationCallExp 'size' from R2ML DatatypeFunctionTerm element.
rule DatatypeFunctionTerm2CollectionOperationCallExp {
	from i : R2ML!DatatypeFunctionTerm (
			i.oclIsTypeOf(R2ML!DatatypeFunctionTerm) and
			i.dataArguments->size() = 1
		)
	to o : OCL!CollectionOperationCallExp (
			name <- if i.function.name = 'fn:count' then
						'size'
					else OclUndefined
					endif,
			source <- i.dataArguments->asSequence()->first()
		)
}

-- Rule 'ObjectOperationTerm2CollectionOperationCallExp'
-- Create OCL CollectionOperationCallExp from R2ML ObjectOperationTerm element.
rule ObjectOperationTerm2CollectionOperationCallExp {
	from i : R2ML!ObjectOperationTerm (
			i.oclIsTypeOf(R2ML!ObjectOperationTerm)
		)
	to o : OCL!CollectionOperationCallExp (
			name <- i.operation.name,
			source <- i.contextArgument
		)
}

-- Rule 'DataOperationTerm2OperationCallExp'
-- Create OCL OperationCallExp from R2ML DataOperationTerm element.
rule DataOperationTerm2OperationCallExp {
	from i : R2ML!DataOperationTerm (
			i.oclIsTypeOf(R2ML!DataOperationTerm) and
			i.contextArgument.oclIsTypeOf(R2ML!ObjectVariable)
		)
	to o : OCL!OperationCallExp (
			name <- i.dataOperationRef.name,
			source <- if thisModule.getFirstObjectVariablesOfTopMostUniversallyQuantifiedFormulas()->includes(i.contextArgument) then
							thisModule.ObjectVariable2VariableExp(i.contextArgument)
					  else thisModule.ObjectVariable2VariableIteratorExp(i.contextArgument)
					  endif
		)
}

-- Rule 'AttributeFunctionTerm2PropertyCallExp'
-- Create OCL PropertyCallExp from R2ML AttributeFunctionTerm element.
rule AttributeFunctionTerm2PropertyCallExp {
	from i : R2ML!AttributeFunctionTerm (
			i.oclIsTypeOf(R2ML!AttributeFunctionTerm) and
			( not i.contextArgument.oclIsTypeOf(R2ML!ObjectVariable) or
			  R2ML!GenericAtom.allInstancesFrom('IN')->asSequence()->select(c | c.predicate.name = 'swrlb:member')->collect(c | c.arguments)->flatten()->includes(i.contextArgument) or
			  R2ML!UniversallyQuantifiedFormula.allInstancesFrom('IN')->asSequence()->collect(c | c.variables)->flatten()->includes(i.contextArgument)
			 )
		)
	to o : OCL!PropertyCallExp (
			name <- i.attribute.name,
			source <- 	if R2ML!GenericAtom.allInstancesFrom('IN')->asSequence()->select(c | c.predicate.name = 'swrlb:member')->collect(c | c.arguments)->flatten()->includes(i.contextArgument) 
 						   or 
						   R2ML!UniversallyQuantifiedFormula.allInstancesFrom('IN')->asSequence()->collect(c | c.variables)->flatten()->includes(i.contextArgument) then
							
						   if thisModule.getFirstObjectVariablesOfTopMostUniversallyQuantifiedFormulas()->includes(i.contextArgument) then
								thisModule.ObjectVariable2VariableExp(i.contextArgument)
		 				   else thisModule.ObjectVariable2VariableIteratorExp(i.contextArgument)
					       endif
						else i.contextArgument
						endif
		)
}

-- Rule 'AttributeFunctionTerm2VariableExp'
-- Create OCL VariableExp from R2ML AttributeFunctionTerm element.
rule AttributeFunctionTerm2VariableExp {
	from i : R2ML!AttributeFunctionTerm (
			i.oclIsTypeOf(R2ML!AttributeFunctionTerm) and
			i.contextArgument.oclIsTypeOf(R2ML!ObjectVariable) and
			-- Because of iterator variable in select expression.
			R2ML!GenericAtom.allInstancesFrom('IN')->asSequence()->select(c | c.predicate.name = 'swrlb:member')->collect(c | c.arguments)->flatten()->excludes(i.contextArgument) and
			R2ML!UniversallyQuantifiedFormula.allInstancesFrom('IN')->asSequence()->collect(c | c.variables)->flatten()->excludes(i.contextArgument)
		)
	to o : OCL!VariableExp (
			referredVariable <- thisModule.Attribute2Variable(i.attribute)
		)
}

-- Rule 'TypedLiteralString2StringLiteralExp'
-- Create OCL StringLiteralExp from R2ML TypedLiteral ('xs:string') element.
rule TypedLiteralString2StringLiteralExp {
	from i : R2ML!TypedLiteral(
			i.oclIsTypeOf(R2ML!TypedLiteral) and
			i.type.name = 'xs:string'
		)
	to o : OCL!StringLiteralExp (
			stringSymbol <- i.lexicalValue
		)
}

-- Rule 'TypedLiteralInteger2IntegerLiteralExp'
-- Create OCL IntegerLiteralExp from R2ML TypedLiteral ('xs:positiveInteger') element.
rule TypedLiteralInteger2IntegerLiteralExp {
	from i : R2ML!TypedLiteral(
			i.oclIsTypeOf(R2ML!TypedLiteral) and
			i.type.name = 'xs:positiveInteger'
		)
	to o : OCL!IntegerLiteralExp (
			integerSymbol <- i.lexicalValue.toInteger()
		)
} 

-- Rule 'TypedLiteralBoolean2BooleanLiteralExp'
-- Create OCL BooleanLiteralExp from R2ML TypedLiteral ('xs:boolean') element.
rule TypedLiteralBoolean2BooleanLiteralExp {
	from i : R2ML!TypedLiteral(
			i.oclIsTypeOf(R2ML!TypedLiteral) and
			i.type.name = 'xs:boolean'
		)
	to o : OCL!BooleanLiteralExp (
			booleanSymbol <- i.lexicalValue.toBoolean()
		)
}",transform r ml metamodel ocl metamodel without general support iter express creat part m sc these good old ai laboratori author milan milanov milan milanov org work r ml v integr rule licenc gnu general public licens version modul r ml ocl modul templat creat out ocl in r ml use string helper helper firstchartoupp convert first charact string upper return complet string context string out string helper context string def firstchartoupp string let firstchar string self substr firstchar toupper self substr self size helper toboolean convert string valu boolean valu context string in string out boolean helper context string def toboolean boolean self true true els fals endif helper getchildren return children context implic anteced consequ context r ml implic out sequenc r ml logicalformula helper context r ml implic def getchildren sequenc r ml logicalformula self getanteced assequ union self getconsequ assequ helper getanteced return anteced children context implic context r ml implic out sequenc r ml logicalformula helper context r ml implic def getanteced sequenc r ml logicalformula self anteced oclistypeof r ml conjuct self anteced formula els sequenc self anteced endif helper getconsequ return consequ children context implic context r ml implic out sequenc r ml logicalformula helper context r ml implic def getconsequ sequenc r ml logicalformula self consequ oclistypeof r ml conjuct self consequ formula els sequenc self consequ endif helper getchildrenofalltopmostimpl return children element anteced consequ topmost implic rule out sequenc r ml logicalformula helper def getchildrenofalltopmostimpl sequenc r ml logicalformula let allimp sequenc r ml implic thismodul gettopmostuniversallyquantifiedformula collect c c formula flatten allimp collect c c getchildren flatten helper gettopmostuniversallyquantifiedformula return top universallyquantifiedformula out sequenc r ml universallyquantifiedformula helper def gettopmostuniversallyquantifiedformula sequenc r ml universallyquantifiedformula r ml alethicintegrityrul allinstancesfrom in assequ collect c c constraint flatten helper getfirstobjectvariablesoftopmostuniversallyquantifiedformula return top universallyquantifiedformula first variabl it need first variabl actual context ocl out sequenc r ml objectvari helper def getfirstobjectvariablesoftopmostuniversallyquantifiedformula sequenc r ml objectvari thismodul gettopmostuniversallyquantifiedformula collect c c variabl assequ first flatten select c c oclistypeof r ml objectvari assequ rule rule rulebas oclmodul creat oclmodul rulebas element rule rulebas oclmodul r ml rulebas oclistypeof r ml rulebas ocl oclmodul ownedel rule assequ first rule rule alethicintegrityrul invari creat ocl invari r ml alethicintegrityrul element rule alethicintegrityrul invari r ml alethicintegrityrul oclistypeof r ml alethicintegrityrul ocl invari name ruleid oclisundefin ruleid els oclundefin endif contextdefinit contextdef specif constraint formula oclistypeof r ml implic in case implic foral constraint formula getchildren foral c c oclistypeof r ml referencepropertyatom specif case implic three referencepropertyatom universallyquantifiedformula foral thismodul universallyquantifiedformulaimpl foralliteratorexp constraint els constraint formula endif els constraint formula endif contextdef ocl oclcontextdefinit contextel constraint variabl assequ first classref oclisundefin thismodul class class constraint variabl assequ first classref els thismodul objectvari class constraint variabl assequ first endif rule universallyquantifiedformulaimpl foralliteratorexp creat ocl foral iteratorexp r ml universallyquantifiedformula element annot case implic three referencepropertyatom uniqu lazi rule universallyquantifiedformulaimpl foralliteratorexp r ml universallyquantifiedformula ocl iteratorexp name foral sourc opcallexp bodi formula iter variabl assequ exclud variabl assequ first collect c thismodul objectvari iter c opcallexp ocl operationcallexp name allinst sourc varexp varexp ocl variableexp referredvari var var ocl variabl name variabl assequ first classref name rule disjunct operatorcallexp creat ocl operatorcallexp r ml disjunct element rule disjunct operatorcallexp r ml disjunct oclistypeof r ml disjunct ocl operatorcallexp name sourc formula assequ first argument formula assequ last rule conjuct operatorcallexp creat ocl operatorcallexp r ml conjuct element rule conjuct operatorcallexp r ml conjuct oclistypeof r ml conjuct check rule select conjuct need transform formula select c c oclistypeof r ml existentiallyquantifiedformula size formula select c c oclistypeof r ml universallyquantifiedformula size formula select c c oclistypeof r ml genericatom size ocl operatorcallexp name sourc formula assequ first argument formula assequ last rule conjuct iteratorexpselect creat ocl select iteratorexp r ml conjuct element annot use select notempti specif case rule conjuct iteratorexpselect r ml conjuct oclistypeof r ml conjuct formula select c c oclistypeof r ml existentiallyquantifiedformula size ocl collectionoperationcallexp name notempti sourc itexp itexp ocl iteratorexp name select sourc formula select c c oclistypeof r ml existentiallyquantifiedformula first get formula conjuct existentiallyquantifiedformula bodi genericatom bodi formula select c c oclistypeof r ml existentiallyquantifiedformula first formula formula select c c oclistypeof r ml genericatom first iter formula select c c oclistypeof r ml existentiallyquantifiedformula first variabl collect c thismodul objectvari iter c rule conjuct iteratorexpforal creat ocl foral iteratorexp r ml conjuct element rule conjuct iteratorexpforal r ml conjuct oclistypeof r ml conjuct formula select c c oclistypeof r ml universallyquantifiedformula size ocl iteratorexp name foral sourc formula select c c oclistypeof r ml universallyquantifiedformula first bodi formula select c c oclistypeof r ml universallyquantifiedformula first formula rule equalityatom operatorcallexp creat ocl operatorcallexp r ml equalityatom element exact member rule equalityatom operatorcallexp r ml equalityatom oclistypeof r ml equalityatom term select c c oclistypeof r ml objectvari size ocl operatorcallexp name isneg els endif sourc thismodul getfirstobjectvariablesoftopmostuniversallyquantifiedformula includ term assequ first thismodul objectvari variableexp term assequ first els thismodul objectvari variableiteratorexp term assequ first endif argument thismodul getfirstobjectvariablesoftopmostuniversallyquantifiedformula includ term assequ last thismodul objectvari variableexp term assequ last els thismodul objectvari variableiteratorexp term assequ last endif rule referencepropertyatom operatorcallexp creat ocl operatorcallexp r ml referencepropertyatom element rule referencepropertyatom operatorcallexp r ml referencepropertyatom oclistypeof r ml referencepropertyatom ocl operatorcallexp name sourc prop argument object oclistypeof r ml objectvari check iter variabl regular variabl thismodul getfirstobjectvariablesoftopmostuniversallyquantifiedformula includ object thismodul objectvari variableexp object els thismodul objectvari variableiteratorexp object endif els object endif prop ocl propertycallexp name referenceproperti name sourc subject oclistypeof r ml objectvari check iter variabl regular variabl thismodul getfirstobjectvariablesoftopmostuniversallyquantifiedformula includ subject thismodul objectvari variableexp subject els thismodul objectvari variableiteratorexp subject endif els subject endif rule referencepropertyfunctionterm variableexp creat ocl variableexp r ml referenceproperti referencepropertyfunctionterm element rule referencepropertyfunctionterm variableexp r ml referencepropertyfunctionterm oclistypeof r ml referencepropertyfunctionterm contextargu oclistypeof r ml objectvari ocl variableexp referredvari thismodul referenceproperti variabl referencepropertyref rule referencepropertyfunctionterm propertycallexp creat ocl propertycallexp r ml referencepropertyfunctionterm element object variabl context argument rule referencepropertyfunctionterm propertycallexp r ml referencepropertyfunctionterm oclistypeof r ml referencepropertyfunctionterm contextargu oclistypeof r ml objectvari ocl propertycallexp name referencepropertyref name sourc contextargu rule implic operatorcallexp creat ocl operatorcallexp r ml implic element genericatom anteced see rule rule implic operatorcallexp r ml implic oclistypeof r ml implic anteced oclistypeof r ml genericatom ocl operatorcallexp name impli sourc anteced argument consequ rule implic collectionoperationcallexpincludesal creat ocl collectionoperationcallexp includesal r ml implic element genericatom anteced rule implic collectionoperationcallexpincludesal r ml implic oclistypeof r ml implic anteced oclistypeof r ml genericatom ocl collectionoperationcallexp name includesal sourc anteced argument select c c oclistypeof r ml genericvari first argument consequ argument select c c oclistypeof r ml genericvari first rule objectclassificationatom operationcallexp creat ocl operationcallexp iskindof r ml objectclassificationatom element rule objectclassificationatom operationcallexp r ml objectclassificationatom oclistypeof r ml objectclassificationatom ocl operationcallexp name iskindof sourc term oclistypeof r ml objectvari thismodul getfirstobjectvariablesoftopmostuniversallyquantifiedformula includ term thismodul objectvari variableexp term els thismodul objectvari variableiteratorexp term endif els term endif argument varexparg varexparg ocl variableexp referredvari thismodul class variabl type rule attributionatom operatorcallexp creat ocl operatorcallexp r ml attributionatom element rule attributionatom operatorcallexp r ml attributionatom oclistypeof r ml attributionatom subject oclistypeof r ml objectvari datavalu oclistypeof r ml typedliter ocl operatorcallexp name sourc var argument datavalu var ocl variableexp referredvari thismodul attribut variabl attribut rule attributionatom propertycallexp creat ocl propertycallexp r ml attributionatom element annot select express rule attributionatom propertycallexp r ml attributionatom oclistypeof r ml attributionatom subject oclistypeof r ml objectvari datavalu oclistypeof r ml datavari ocl propertycallexp name attribut name sourc thismodul getfirstobjectvariablesoftopmostuniversallyquantifiedformula includ subject thismodul objectvari variableexp subject els thismodul objectvari variableiteratorexp subject endif uniqu lazi rule objectvari iter creat ocl iter variabl r ml objectvari element uniqu lazi rule objectvari iter r ml objectvari ocl iter name name lazi rule objectvari variableiteratorexp creat ocl variableexp r ml objectvari element lazi rule objectvari variableiteratorexp r ml objectvari ocl variableexp referredvari thismodul objectvari iter uniqu lazi rule referenceproperti variabl creat ocl variabl r ml referenceproperti element uniqu lazi rule referenceproperti variabl r ml referenceproperti ocl variabl name name uniqu lazi rule attribut variabl creat ocl variabl r ml attribut element uniqu lazi rule attribut variabl r ml attribut ocl variabl name name lazi rule objectvari variableexp creat ocl variableexp r ml objectvari element lazi rule objectvari variableexp r ml objectvari ocl variableexp referredvari thismodul objectvari variabl uniqu lazi rule objectvari variabl creat ocl variabl r ml objectvari element uniqu lazi rule objectvari variabl r ml objectvari ocl variabl if sourc objectvari first top universallyquantifiedformula self variabl name thismodul getfirstobjectvariablesoftopmostuniversallyquantifiedformula includ self els name endif uniqu lazi rule objectvari class creat ocl class r ml objectvari element ocl context uniqu lazi rule objectvari class r ml objectvari ocl class name name firstchartoupp isabstract fals uniqu lazi rule class class creat ocl class r ml class element uniqu lazi rule class class r ml class ocl class name name isabstract fals uniqu lazi rule class variabl creat ocl variabl r ml class element uniqu lazi rule class variabl r ml class ocl variabl name name rule datatypepredicateatom operatorcallexp creat ocl operatorcallexp r ml datatypepredicateatom element rule datatypepredicateatom operatorcallexp r ml datatypepredicateatom oclistypeof r ml datatypepredicateatom dataargu select c c oclistypeof r ml attributefunctionterm select c c typecategori oclisundefin size dataargu select c c oclistypeof r ml dataoperationterm c oclistypeof r ml objectoperationterm size ocl operatorcallexp name predic name swrlb greaterthanorequ els predic name swrlb greaterthan els predic name swrlb equal isneg els endif els predic name swrlb lessthan els predic name swrlb lessthanorequ els oclundefin endif endif endif endif endif sourc dataargu assequ first argument dataargu assequ last rule datatypepredicateatomnotneg collectionoperationcallexp creat ocl collectionoperationcallexp r ml datatypepredicateatom element rule datatypepredicateatomnotneg collectionoperationcallexp r ml datatypepredicateatom oclistypeof r ml datatypepredicateatom dataargu select c c oclistypeof r ml attributefunctionterm select c c typecategori oclisundefin size dataargu size isneg fals ocl collectionoperationcallexp name predic name swrlb empti isempti els oclundefin endif sourc dataargu assequ first rule datatypepredicateatomneg operatorcallexp creat ocl operatorcallexp r ml negat datatypepredicateatom element rule datatypepredicateatomneg operatorcallexp r ml datatypepredicateatom oclistypeof r ml datatypepredicateatom dataargu select c c oclistypeof r ml attributefunctionterm select c c typecategori oclisundefin size dataargu size isneg true ocl operatorcallexp name sourc collopexp collopexp ocl collectionoperationcallexp name predic name swrlb empti isempti els oclundefin endif sourc dataargu assequ first rule datatypepredicateatom sizeoperatorcallexp creat ocl operatorcallexp r ml datatypepredicateatom swrlb length element rule datatypepredicateatom sizeoperatorcallexp r ml datatypepredicateatom oclistypeof r ml datatypepredicateatom dataargu select c c oclistypeof r ml attributefunctionterm select c c typecategori oclisundefin size dataargu size predic name swrlb length ocl operatorcallexp name sourc dataargu assequ first ocliskindof r ml datafunctionterm dataargu assequ first typecategori oclisundefin dataargu assequ first els dataargu assequ first typecategori bag collcallexp els oclundefin endif endif els dataargu assequ first endif argument dataargu assequ last ocliskindof r ml datafunctionterm dataargu assequ last typecategori oclisundefin dataargu assequ last els dataargu assequ last typecategori bag collcallexp els oclundefin endif endif els dataargu assequ last endif collcallexp ocl collectionoperationcallexp name predic name swrlb length size els oclundefin endif sourc dataargu assequ first ocliskindof r ml datafunctionterm dataargu assequ first typecategori oclisundefin dataargu assequ first typecategori bag dataargu assequ first els dataargu assequ last endif els dataargu assequ last endif els dataargu assequ last endif rule datatypefunctionterm collectionoperationcallexp creat ocl collectionoperationcallexp size r ml datatypefunctionterm element rule datatypefunctionterm collectionoperationcallexp r ml datatypefunctionterm oclistypeof r ml datatypefunctionterm dataargu size ocl collectionoperationcallexp name function name fn count size els oclundefin endif sourc dataargu assequ first rule objectoperationterm collectionoperationcallexp creat ocl collectionoperationcallexp r ml objectoperationterm element rule objectoperationterm collectionoperationcallexp r ml objectoperationterm oclistypeof r ml objectoperationterm ocl collectionoperationcallexp name oper name sourc contextargu rule dataoperationterm operationcallexp creat ocl operationcallexp r ml dataoperationterm element rule dataoperationterm operationcallexp r ml dataoperationterm oclistypeof r ml dataoperationterm contextargu oclistypeof r ml objectvari ocl operationcallexp name dataoperationref name sourc thismodul getfirstobjectvariablesoftopmostuniversallyquantifiedformula includ contextargu thismodul objectvari variableexp contextargu els thismodul objectvari variableiteratorexp contextargu endif rule attributefunctionterm propertycallexp creat ocl propertycallexp r ml attributefunctionterm element rule attributefunctionterm propertycallexp r ml attributefunctionterm oclistypeof r ml attributefunctionterm contextargu oclistypeof r ml objectvari r ml genericatom allinstancesfrom in assequ select c c predic name swrlb member collect c c argument flatten includ contextargu r ml universallyquantifiedformula allinstancesfrom in assequ collect c c variabl flatten includ contextargu ocl propertycallexp name attribut name sourc r ml genericatom allinstancesfrom in assequ select c c predic name swrlb member collect c c argument flatten includ contextargu r ml universallyquantifiedformula allinstancesfrom in assequ collect c c variabl flatten includ contextargu thismodul getfirstobjectvariablesoftopmostuniversallyquantifiedformula includ contextargu thismodul objectvari variableexp contextargu els thismodul objectvari variableiteratorexp contextargu endif els contextargu endif rule attributefunctionterm variableexp creat ocl variableexp r ml attributefunctionterm element rule attributefunctionterm variableexp r ml attributefunctionterm oclistypeof r ml attributefunctionterm contextargu oclistypeof r ml objectvari becaus iter variabl select express r ml genericatom allinstancesfrom in assequ select c c predic name swrlb member collect c c argument flatten exclud contextargu r ml universallyquantifiedformula allinstancesfrom in assequ collect c c variabl flatten exclud contextargu ocl variableexp referredvari thismodul attribut variabl attribut rule typedliteralstr stringliteralexp creat ocl stringliteralexp r ml typedliter xs string element rule typedliteralstr stringliteralexp r ml typedliter oclistypeof r ml typedliter type name xs string ocl stringliteralexp stringsymbol lexicalvalu rule typedliteralinteg integerliteralexp creat ocl integerliteralexp r ml typedliter xs positiveinteg element rule typedliteralinteg integerliteralexp r ml typedliter oclistypeof r ml typedliter type name xs positiveinteg ocl integerliteralexp integersymbol lexicalvalu tointeg rule typedliteralboolean booleanliteralexp creat ocl booleanliteralexp r ml typedliter xs boolean element rule typedliteralboolean booleanliteralexp r ml typedliter oclistypeof r ml typedliter type name xs boolean ocl booleanliteralexp booleansymbol lexicalvalu toboolean,6
146,146,P65-XML2R2ML.atl,"-- ============================================================
-- Transforms an XML metamodel into a R2ML metamodel.
-- Created as part of M.Sc. theses at GOOD OLD AI Laboratory
-- Author: Milan Milanovic (milan at milanovic.org)
-- Works for R2ML XML Schema and Metamodel v0.4
-- Licence: GNU General Public License, version 2
-- ============================================================

module XML2R2ML;
create OUT : R2ML from IN : XML;

uses strings;
uses XMLHelpers; -- General XML metamodel helpers

-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- XML2R2ML Transformation specific XML helpers

-- HELPER:	isNegated()
-- Returns a boolean that statement is XML!Element attribute XML!Attribute with name 'r2ml:isNegated' is true or false
-- contextual XML!Element.
-- CONTEXT:	XML!Element
-- OUT:		Boolean
helper context XML!Element def: isNegated() : Boolean =
	let collection : Sequence(XML!Attribute) = self.children->select(c | c.oclIsKindOf(XML!Attribute) and c.name = 'r2ml:isNegated') in
	if collection->isEmpty()
	then
		false
	else -- not empty
		let val : String = collection->first().value in
		if val = 'true'
		then
			true
		else 
			false
		endif
	endif;

-- HELPER:	getAllRules()
-- Returns a sequence of all XML elements which name is IntegrityRule of DerivationRule
-- CONTEXT:	thisModule
-- OUT:		Sequence of XML elements
-- TODO: Add other type of rules
helper def: getAllRules() : Sequence(XML!Element) = 
	XML!Element.allInstances()->select(e | e.name = 'r2ml:AlethicIntegrityRule' or e.name = 'r2ml:DeonticIntegrityRule' or e.name = 'r2ml:DerivationRule')->asSequence();

-- HELPER: allSubElements
-- Returns a sequence of all XML sub elements for XML element, recursivelly
-- from this element to last element (children)
-- ANNOTATION: Based on ""Transforming Models with ATL"", Frederic Jouault, Ivan Kurtev.
-- CONTEXT:	XML!Element
-- OUT:		Sequence of XML elements
helper context XML!Element def : allSubElements : Sequence(XML!Element) = 
	let subElems : Sequence(XML!Element) = 
		XML!Element.allInstances()->select(c |      			-- 1. get all elements with this parent
			c.parent = self
		)->collect(elems | elems.allSubElements)->flatten()  in -- 2. for every element get subelements
		subElems->union( 										-- 3. when all subelements are apprehended 
																--    for every element, add topmost elements (child of this parent).
			self.children->select(ch | ch.oclIsTypeOf(XML!Element)
	    ))->flatten();

-- HELPER: allSubAttributes
-- Returns a sequence of all XML sub attributes for XML element, recursivelly
-- from this attribute to last attribute (children)
-- CONTEXT:	XML!Element
-- OUT:		Sequence of XML attributes
helper context XML!Element def : allSubAttributes : Sequence(XML!Attribute) = 
	let subAttrs : Sequence(XML!Attribute) = 
    	XML!Element.allInstances()->select(c | 
        	c.parent = self
		)->collect(attrs | attrs.allSubAttributes)->flatten()  in
		subAttrs->union(
			self.children->select(at | at.oclIsTypeOf(XML!Attribute)
		))->flatten();

-- HELPER: getRuleForElement()
-- Returns XML element (Rule, Integrity of Derivation) which contains context-ual XML element
-- CONTEXT:	XML!Element
-- OUT:		XML element
helper context XML!Element def: getRuleForElement() : XML!Element = 
	thisModule.getAllRules()->select(c | c.allSubElements->includes(self))->asSequence()->first();

-- HELPER: getRuleForAttribute()
-- Returns XML element (Rule, Integrity of Derivation) which contains context-ual XML attribute
-- CONTEXT:	XML!Attribute
-- OUT:		XML element
helper context XML!Attribute def: getRuleForAttribute() : XML!Element = 
	thisModule.getAllRules()->select(c | c.allSubAttributes->includes(self))->asSequence()->first();

-- HELPER:	getDefaultObjectVariable()
-- Return always first ObjectVariable with value
-- This is necessary for unique lazy rule that creates just one 
-- output ObjectVariable for multiple input (with same value)
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		XML!Element
helper def: getDefaultObjectVariable(elem : XML!Element, value: String) : XML!Element = 
	let objVar : Sequence(XML!Element) = elem.getRuleForElement().allSubElements->select(e | e.name = 'r2ml:ObjectVariable')->select(e | e.getAttrVal('r2ml:name') = value and e.hasAttr('r2ml:classID'))->asSequence() in 
	if objVar->isEmpty() then
		elem.getRuleForElement().allSubElements->select(e | e.name = 'r2ml:ObjectVariable')->select(e | e.getAttrVal('r2ml:name') = value)->asSequence()->first()
	else objVar->first()
	endif;

-- HELPER:	getDefaultDataVariable()
-- Same as previous but for Data variable
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		XML!Element
helper def: getDefaultDataVariable(elem: XML!Element, value: String) : XML!Element = 
	elem.getRuleForElement().allSubElements->select(e | e.name = 'r2ml:DataVariable')->select(e | e.getAttrVal('r2ml:name') = value)->asSequence()->first();

-- HELPER:	getDefaultGenericVariable()
-- Same as previous but for Variable
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		XML!Element
helper def: getDefaultGenericVariable(elem : XML!Element, value: String) : XML!Element = 
	elem.getRuleForElement().allSubElements->select(e | e.name = 'r2ml:Variable' or e.name = 'r2ml:GenericVariable')->select(e | e.getAttrVal('r2ml:name') = value)->asSequence()->first();
	
-- HELPER:	getDefaultGenericPredicate()
-- Always returns first predicate associated with GenericAtom
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		XML!Attribute
helper def: getDefaultGenericPredicate(attr : XML!Attribute, value: String) : XML!Attribute = 
	attr.getRuleForAttribute().allSubAttributes->select(e | e.name = 'r2ml:predicateID')->select(e | e.value = value)->asSequence()->first();

-- HELPER:	getDefaultAttribute()
-- Always returns first attribute associated with term
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		XML!Attribute
helper def: getDefaultAttribute(attr : XML!Attribute, value: String) : XML!Attribute = 
	attr.getRuleForAttribute().allSubAttributes->select(e | e.name = 'r2ml:attributeID')->select(e | e.value = value)->asSequence()->first();

-- HELPER:	getDefaultDataType()
-- Always returns first data type
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		XML!Attribute
helper def: getDefaultDataType(attr : XML!Attribute, value: String) : XML!Attribute = 
	attr.getRuleForAttribute().allSubAttributes->select(e | e.name = 'r2ml:datatypeID' or e.name = 'r2ml:type')->select(e | e.value = value)->asSequence()->first();

-- HELPER:	getAllObjectVariables()
-- Return all Object variables from input file
-- CONTEXT:	thisModule
-- OUT:		Sequence of XML Elements
helper def: getAllObjectVariables() : Sequence(XML!Element) = 
	XML!Element.allInstances()->select(e | e.name = 'r2ml:ObjectVariable');

-- HELPER:	getAllDataVariables()
-- Return all Data variables from input file
-- CONTEXT:	thisModule
-- OUT:		Sequence of XML Elements
helper def: getAllDataVariables() : Sequence(XML!Element) = 
	XML!Element.allInstances()->select(e | e.name = 'r2ml:DataVariable');

-- HELPER:	getAllVariables()
-- Return all Variables from input file
-- CONTEXT:	thisModule
-- OUT:		Sequence of XML Elements
helper def: getAllVariables() : Sequence(XML!Element) = 
	XML!Element.allInstances()->select(e | e.name = 'r2ml:Variable' or e.name = 'r2ml:GenericVariable');

-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'RuleBase'
-- Creates RuleBase from the Root element.
rule RuleBase {
	from
		i : XML!Element (
				i.name = 'r2ml:RuleBase'
			)		
	to
		o : R2ML!RuleBase (                 
				ruleBaseID <- i.getAttrVal('xmlns:r2ml'),
				rules <- i.children->select(c | c.oclIsKindOf(XML!Element))->asSequence()
		)
}

-- Rule 'DerivationRuleSet'
-- Creates DerivationRuleSet from an XML!Element named 'r2ml:DerivationRuleSet'.
rule DerivationRuleSet {
	from
		i : XML!Element(
				i.name = 'r2ml:DerivationRuleSet'
			)
		to
		o : R2ML!DerivationRuleSet (
				rules <- i.children->select(c | c.oclIsKindOf(XML!Element))->asSequence()
		)
}

-- Rule 'IntegrityRuleSet'
-- Creates IntegrityRuleSet from an XML!Element named 'r2ml:IntegrityRuleSet'.
rule IntegrityRuleSet {
	from
		i : XML!Element(
				i.name = 'r2ml:IntegrityRuleSet'
			)
		to
		o : R2ML!IntegrityRuleSet (
				rules <- i.children->select(c | c.oclIsKindOf(XML!Element))->asSequence()
			)		
}

-- Rule 'ReactionRuleSet'
-- Creates ReactionRuleSet from an XML!Element named 'r2ml:ReactionRuleSet'.
rule ReactionRuleSet {
	from
		i : XML!Element(
				i.name = 'r2ml:ReactionRuleSet'
			)
		to
		o : R2ML!ReactionRuleSet (
				rules <- i.children->select(c | c.oclIsKindOf(XML!Element))->asSequence()
			)		
}

-- Rule 'ProductionRuleSet'
-- Creates ProductionRuleSet from an XML!Element named 'r2ml:ProductionRuleSet'.
rule ProductionRuleSet {
	from
		i : XML!Element(
				i.name = 'r2ml:ProductionRuleSet'
			)
		to
		o : R2ML!ProductionRuleSet (
				rules <-  i.children->select(c | c.oclIsKindOf(XML!Element))->asSequence()
			)
}

-- Rule 'AlethicIntegrityRule'
-- Creates AlethicIntegrityRule from an XML!Element named 'r2ml:AlethicIntegrityRule'.
rule AlethicIntegrityRule { 
	from
		i : XML!Element (
				i.name = 'r2ml:AlethicIntegrityRule'
			)
  to
		o : R2ML!AlethicIntegrityRule (
				constraint <- i.getElementsByName('r2ml:constraint')->first().children->select(c | c.oclIsKindOf(XML!Element))->first(),
				ruleID <- if i.hasAttr('r2ml:ruleID') = true then
							i.getAttrVal('r2ml:ruleID')
						  else OclUndefined
						  endif
			)
}

-- Rule 'DeonticIntegrityRule'
-- Creates DeonticIntegrityRule from an XML!Element named 'r2ml:DeonticIntegrityRule'.
rule DeonticIntegrityRule { 
	from
		i : XML!Element (
				i.name = 'r2ml:DeonticIntegrityRule'
			)
  to
		o : R2ML!DeonticIntegrityRule (
				constraint <- i.getElementsByName('r2ml:constraint')->first().children->select(c | c.oclIsKindOf(XML!Element))->first(),
				ruleID <- if i.hasAttr('r2ml:ruleID') = true then
							i.getAttrVal('r2ml:ruleID')
						  else OclUndefined
						  endif
			)
}

-- Rule 'UniversallyQuantifiedFormula'
-- Creates UniversallyQuantifiedFormula from an XML!Element named 'r2ml:UniversallyQuantifiedFormula'.
rule UniversallyQuantifiedFormula {
	from i : XML!Element (
				i.name = 'r2ml:UniversallyQuantifiedFormula'
			)
  to
		o : R2ML!UniversallyQuantifiedFormula (
				-- ANNOTATION: Remark on this first time generating variable, we get ObjectVariable elements (children), then with helper getDefaultObjectVariable we get
				--             always same input element (Variable) with that name, and then call unique lazy rule ObjectVariable() to generate variable.
				variables <- Sequence { i.getElementsByName('r2ml:ObjectVariable')->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
									    i.getElementsByName('r2ml:DataVariable')->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e)) },
				formula <- i.children->select(e | thisModule.getAllDataVariables()->excludes(e) and thisModule.getAllObjectVariables()->excludes(e) and e.oclIsTypeOf(XML!Element))->first()
			)
}

-- Rule 'ExistentiallyQuantifiedFormula'
-- Creates ExistentiallyQuantifiedFormula from an XML!Element named 'r2ml:ExistentiallyQuantifiedFormula'.
rule ExistentiallyQuantifiedFormula {
	from i : XML!Element (
				i.name = 'r2ml:ExistentiallyQuantifiedFormula'
			)
  to
		o : R2ML!ExistentiallyQuantifiedFormula (
				variables <- Sequence { i.getElementsByName('r2ml:ObjectVariable')->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
										i.getElementsByName('r2ml:DataVariable')->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e)) },
				formula <- i.children->select(e | thisModule.getAllDataVariables()->excludes(e) and thisModule.getAllObjectVariables()->excludes(e) and e.oclIsTypeOf(XML!Element))->first()
			)
}

-- Rule 'Implication'
-- Creates Implication from an XML!Element named 'r2ml:Implication'.
rule Implication {
	from i : XML!Element (
				i.name = 'r2ml:Implication'
			)
    to
		o : R2ML!Implication (
				antecedent <- i.getElementsByName('r2ml:antecedent')->first().children->select(c | c.oclIsTypeOf(XML!Element))->asSequence()->first(),
				consequent <- i.getElementsByName('r2ml:consequent')->first().children->select(c | c.oclIsTypeOf(XML!Element))->asSequence()->first()
			)
}

-- Rule 'Conjuction'
-- Creates Conjuction from an XML!Element named 'r2ml:Conjuction'.
rule Conjuction {
	from i : XML!Element (
				i.name = 'r2ml:Conjunction'
			)
    to
		o : R2ML!Conjuction (
				formulas <- i.children->select(c | c.oclIsKindOf(XML!Element))->asSet()
			)
}

-- Rule 'Disjunction'
-- Creates Disjunction from an XML!Element named 'r2ml:Disjunction'.
rule Disjunction {
	from i : XML!Element (
				i.name = 'r2ml:Disjunction'
			)
    to
		o : R2ML!Disjunction (
				formulas <- i.children->select(c | c.oclIsKindOf(XML!Element))->asSet()
			)
}

-- Rule 'NegationAsFailure'
-- Creates NegationAsFailure from an XML!Element named 'r2ml:NegationAsFailure'.
rule NegationAsFailure {
	from i : XML!Element (
				i.name = 'r2ml:NegationAsFailure'
			)
    to
		o : R2ML!NegationAsFailure (
				formula <- i.children->select(c | c.oclIsKindOf(XML!Element))->first()
		)
}

-- Rule 'StrongNegation'
-- Creates StrongNegation from an XML!Element named 'r2ml:StrongNegation'.
rule StrongNegation {
	from i : XML!Element (
				i.name = 'r2ml:StrongNegation'
			)
    to
		o : R2ML!StrongNegation (
				formula <- i.children->select(c | c.oclIsKindOf(XML!Element))->first()
		)
}

-- Rule 'EqualityAtom'
-- Creates EqualityAtom from an XML!Element named 'r2ml:EqualityAtom'.
rule EqualityAtom {
	from i : XML!Element (
				i.name = 'r2ml:EqualityAtom'
			)
    to
		o : R2ML!EqualityAtom (
				terms <- Sequence { i.children->select(c | c.oclIsKindOf(XML!Element) and c.name = 'r2ml:ObjectVariable')->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
									i.children->select(c | c.oclIsKindOf(XML!Element) and c.name <> 'r2ml:ObjectVariable')				
								  }
			)
}

-- Rule 'InequalityAtom'
-- Creates InequalityAtom from an XML!Element named 'r2ml:InequalityAtom'.
rule InequalityAtom {
	from i : XML!Element (
				i.name = 'r2ml:InequalityAtom'
			)
    to
		o : R2ML!InequalityAtom (
				terms <- Sequence { i.children->select(c | c.oclIsKindOf(XML!Element) and c.name = 'r2ml:ObjectVariable')->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
									i.children->select(c | c.oclIsKindOf(XML!Element) and c.name <> 'r2ml:ObjectVariable')				
								  }
			)
}

-- Rule 'DerivationRule'
-- Creates DerivationRule from an XML!Element named 'r2ml:DerivationRule'.
rule DerivationRule { 
	from
		i : XML!Element (
				i.name = 'r2ml:DerivationRule'
			)
  to
		o : R2ML!DerivationRule (
				conditions <- i.getElementsByName('r2ml:conditions')->first().children->select(c | c.oclIsKindOf(XML!Element))->asSequence(),
				conclusions <- i.getElementsByName('r2ml:conclusion')->first(),
				ruleID <- if i.hasAttr('r2ml:ruleID') = true then
							i.getAttrVal('r2ml:ruleID')
						  else OclUndefined
						  endif
	)
}

-- Rule 'LiteralConjuction'
-- Creates atoms from an XML!Element named r2ml:DerivationRule conclusions'.
rule LiteralConjuction {
	from
		i : XML!Element (
				i.name = 'r2ml:conclusion'
			)
	to
		o : R2ML!LiteralConjunction (	     
				atoms <- i.children->select(c | c.oclIsKindOf(XML!Element))->asSet()
			)
}

-- Rule 'ClassRule'
-- Create Class from XML!Attribute 
-- This is lazy rule which is called from other rules
unique lazy rule ClassRule {
	from
		i : XML!Attribute 
	to
		cla : R2ML!Class (
			name <- i.value,
			predicateCategory <- #closed
		)
}

-- Rule 'ObjectClassificationAtom'
-- Creates ObjectClassificationAtom  from an XML!Element named 'r2ml:ObjectClassificationAtom'.
rule ObjectClassificationAtom {
	from i : XML!Element (
			i.name = 'r2ml:ObjectClassificationAtom'
		)
	to 
		obj : R2ML!ObjectClassificationAtom (
			isNegated <- i.isNegated(),
			type <- i.children->select(c | c.oclIsKindOf(XML!Attribute) and c.name = 'r2ml:classID')->collect(e | thisModule.ClassRule(e))->first(),
			term <- i.children->select(c | c.oclIsKindOf(XML!Element) and c.name = 'r2ml:ObjectVariable')->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first()			
		)
}

-- Rule 'DataClassificationAtom'
-- Creates DataClassificationAtom  from an XML!Element named 'r2ml:DataClassificationAtom'.
rule DataClassificationAtom {
	from i : XML!Element (
			i.name = 'r2ml:DataClassificationAtom'
		)
	to 
		obj : R2ML!DataClassificationAtom (
			isNegated <- i.isNegated(),
			type <- thisModule.Datatype(thisModule.getDefaultDataType(i.getAttr('r2ml:datatypeID'), i.getAttrVal('r2ml:datatypeID'))),
			term <- i.children->select(c | c.oclIsKindOf(XML!Element) and c.name = 'r2ml:DataVariable')->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e))->first()			
		)
}

-- Rule 'ObjectVariable'
-- Creates ObjectVariable from an XML!Element named 'r2ml:ObjectVariable'.
-- This rule is unique lazy rule, which means that is called from other rules
unique lazy rule ObjectVariable {
	from i : XML!Element (
			i.name = 'r2ml:ObjectVariable'
		)
	to 
		ov : R2ML!ObjectVariable (
			classRef <- i.children->select(c | c.oclIsKindOf(XML!Attribute) and c.name = 'r2ml:classID')->collect(e | thisModule.ClassRule(e))->first(),
  	        name <- i.getAttrVal('r2ml:name'),
			typeCategory <- #individual
		)		
}

-- Rule 'DataVariable'
-- Creates DataVariable from an XML!Element named 'r2ml:DataVariable'.
-- This rule is unique lazy rule, which means that is called from other rules
unique lazy rule DataVariable {
	from i : XML!Element (
			i.name = 'r2ml:DataVariable'
		)
	to 
		odv : R2ML!DataVariable (	
			datatypeRef <- if(i.hasAttr('r2ml:dataTypeID')) then
							thisModule.Datatype(thisModule.getDefaultDataType(i.getAttr('r2ml:dataTypeID'), i.getAttrVal('r2ml:dataTypeID')))
						   else OclUndefined
						   endif,
			name <- i.getAttrVal('r2ml:name'),
			typeCategory <- if i.hasAttr('r2ml:typeCategory') = true then
								if i.getAttrVal('r2ml:typeCategory') = 'individual' then
									#individual
								else if i.getAttrVal('r2ml:typeCategory') = 'set' then
										#set
									 else if i.getAttrVal('r2ml:typeCategory') = 'order' then
									 		#orderedSet
										  else if i.getAttrVal('r2ml:typeCategory') = 'bag' then
										  		#bag
											   else if i.getAttrVal('r2ml:typeCategory') = 'sequence' then
											   		 #sequence
													else #individual
													endif
											   endif
										  endif
									 endif
								endif								
							else OclUndefined
							endif
		)		
}

-- Rule 'Datatype'
-- Creates Datatype from an XML!Attribute
-- This rule is unique lazy rule, which means that is called from other rules
unique lazy rule Datatype {
	from i : XML!Attribute 
	to o : R2ML!Datatype (
			predicateCategory <- #closed,
			name <- i.value
		)
}

-- Rule 'QFDisjunction'
-- Creates QFDisjunction from an XML!Element named 'r2ml:qf.Disjunction'.
rule QFDisjunction {
	from  i : XML!Element (
			i.name = 'r2ml:qf.Disjunction'
		)
	to
		o : R2ML!QFDisjunction (
				formulas <- i.children->select(c | c.oclIsKindOf(XML!Element))->asSequence()
			)
}

-- Rule 'QFConjunction'
-- Creates QFConjunction from an XML!Element named 'r2ml:qf.Conjunction'.
rule QFConjunction {
	from  i : XML!Element (
			i.name = 'r2ml:qf.Conjuction'
		)
	to
		o : R2ML!QFConjunction (
			formulas <- i.children->select(c | c.oclIsKindOf(XML!Element))->asSequence()
			)
}

-- Rule 'QFNegationAsFailure'
-- Creates QFNegationAsFailure from an XML!Element named 'r2ml:qf.NegationAsFailure'.
rule QFNegationAsFailure {
	from i : XML!Element (
				i.name = 'r2ml:qf.NegationAsFailure'
			)
    to
		o : R2ML!QFNegationAsFailure (
				formula <- i.children->select(c | c.oclIsKindOf(XML!Element))->first()
		)
}

-- Rule 'QFStrongNegation'
-- Creates QFStrongNegation from an XML!Element named 'r2ml:qf.StrongNegation'.
rule QFStrongNegation {
	from i : XML!Element (
				i.name = 'r2ml:qf.StrongNegation'
			)
    to
		o : R2ML!QFStrongNegation (
				formula <- i.children->select(c | c.oclIsKindOf(XML!Element))->first()
		)
}

-- Rule 'DatatypePredicateAtom'
-- Creates DatatypePredicateAtom from an XML!Element named 'r2ml:DatatypePredicateAtom' or 'r2ml:DataPredicateAtom'.
rule DatatypePredicateAtom {
	from i : XML!Element (
		-- r2ml v0.1
		i.name = 'r2ml:DataPredicateAtom' or 
		-- r2ml v0.2
		i.name = 'r2ml:DatatypePredicateAtom'
		)
	to 
		o : R2ML!DatatypePredicateAtom (
			dataArguments <- Sequence{ i.getElementsByName('r2ml:dataArguments')->first().children->select(e | thisModule.getAllDataVariables()->includes(e))->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e)), 
				                       i.getElementsByName('r2ml:dataArguments')->first().children->select(e | not thisModule.getAllDataVariables()->includes(e))->asSequence()},
			predicate <- i.children->select(c | c.oclIsKindOf(XML!Attribute) and c.name = 'r2ml:dataPredicateID' or c.name = 'r2ml:datatypePredicateID')->collect(e | thisModule.DatatypePredicateRule(e))->first()
		)
}

-- Rule 'DatatypePredicateRule'
-- Creates DatatypePredicateRule from an XML!Attribute
-- This rule is unique lazy rule, which means that is called from other rules
unique lazy rule DatatypePredicateRule {
	from i : XML!Attribute
	to  
		dtp : R2ML!DatatypePredicate (
			predicateCategory <- #closed,
			name <- i.value
		)		
}

-- Rule 'DataOperationTerm'
-- Creates DataOperationTerm from an XML!Element named 'r2ml:DataOperationTerm'.
rule DataOperationTerm {
	from i : XML!Element (
			i.name = 'r2ml:DataOperationTerm'
		)
	to 
		o : R2ML!DataOperationTerm (
			dataOperationRef <- opr,
			arguments <- let args : Set(XML!Element) = i.getElementsByName('r2ml:arguments') in
							if args->isEmpty() then
							   Sequence {}
							-- ANNOTATION: First we get ObjectVariables, then DataVariables, and all elements which are not ObjectVariables or DataVariables
						    else Sequence { args->first().children->select(e | thisModule.getAllDataVariables()->includes(e))->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e)),
						    	            args->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
											args->first().children->select(e | not thisModule.getAllDataVariables()->includes(e) and not thisModule.getAllObjectVariables()->includes(e))->asSequence()
						         }
							endif,
			contextArgument <- let conArg : Set(XML!Element) = i.getElementsByName('r2ml:contextArgument') in
							       if conArg->isEmpty() then
							           OclUndefined	            
							       else Sequence { conArg->first().children->asSequence()->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first(),
							       				   conArg->first().children->asSequence()->select(e | thisModule.getAllObjectVariables()->excludes(e))
							       				 }->select(c | not c.oclIsUndefined())->asSequence()->first()
								   endif,
			typeCategory <- if i.hasAttr('r2ml:typeCategory') = true then
								if i.getAttrVal('r2ml:typeCategory') = 'individual' then
									#individual
								else if i.getAttrVal('r2ml:typeCategory') = 'set' then
										#set
									 else if i.getAttrVal('r2ml:typeCategory') = 'order' then
									 		#orderedSet
										  else if i.getAttrVal('r2ml:typeCategory') = 'bag' then
										  		#bag
											   else if i.getAttrVal('r2ml:typeCategory') = 'sequence' then
											   		 #sequence
													else OclUndefined
													endif
											   endif
										  endif
									 endif
								endif								
							else OclUndefined
							endif
			),
		opr : R2ML!DataOperation (
			name <- i.getAttrVal('r2ml:operationID')
			)
}

-- Rule 'TypedLiteral'
-- Creates TypedLiteral from an XML!Element named 'r2ml:TypedLiteral'.
rule TypedLiteral {
	from i : XML!Element (
			i.name = 'r2ml:TypedLiteral'
		)
	to 
		o : R2ML!TypedLiteral (
				lexicalValue <- i.getAttrVal('r2ml:lexicalValue'),
				type <- thisModule.Datatype(thisModule.getDefaultDataType(i.getAttr('r2ml:datatypeID'), i.getAttrVal('r2ml:datatypeID'))),
				typeCategory <- if i.hasAttr('r2ml:typeCategory') = true then
									if i.getAttrVal('r2ml:typeCategory') = 'individual' then
										#individual
									else if i.getAttrVal('r2ml:typeCategory') = 'set' then
											#set
										 else if i.getAttrVal('r2ml:typeCategory') = 'order' then
										 		#orderedSet
											  else if i.getAttrVal('r2ml:typeCategory') = 'bag' then
											  		#bag
												   else if i.getAttrVal('r2ml:typeCategory') = 'sequence' then
												   		 #sequence
														else OclUndefined
														endif
												   endif
											  endif
										 endif
									endif								
								else OclUndefined
								endif
			)
}

-- Rule 'PlainLiteral'
-- Creates PlainLiteral from an XML!Element named 'r2ml:PlainLiteral'.
rule PlainLiteral {
	from i : XML!Element (
			i.name = 'r2ml:PlainLiteral'
		)
	to 
		o : R2ML!PlainLiteral (
				lexicalValue <- i.getAttrVal('r2ml:lexicalValue'),
				languageTag <- i.getAttrVal('r2ml:languageTag'),
				typeCategory <- if i.hasAttr('r2ml:typeCategory') = true then
									if i.getAttrVal('r2ml:typeCategory') = 'individual' then
										#individual
									else if i.getAttrVal('r2ml:typeCategory') = 'set' then
											#set
										 else if i.getAttrVal('r2ml:typeCategory') = 'order' then
										 		#orderedSet
											  else if i.getAttrVal('r2ml:typeCategory') = 'bag' then
											  		#bag
												   else if i.getAttrVal('r2ml:typeCategory') = 'sequence' then
												   		 #sequence
														else OclUndefined
														endif
												   endif
											  endif
										 endif
									endif								
								else OclUndefined
								endif
			)
}

-- Rule 'AttributeFunctionTerm'
-- Creates AttributeFunctionTerm from an XML!Element named 'r2ml:AttributeFunctionTerm'.
rule AttributeFunctionTerm {
	from i : XML!Element (
			i.name = 'r2ml:AttributeFunctionTerm'
		)
	to 
		o : R2ML!AttributeFunctionTerm (
				contextArgument <- Sequence { i.getElementsByName('r2ml:contextArgument')->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first(),
						  					  i.getElementsByName('r2ml:contextArgument')->first().children->select(e | thisModule.getAllObjectVariables()->excludes(e))->asSequence()->first() -- other (non ObjectVariable) object terms
											}->select(c | not c.oclIsUndefined())->asSequence()->first(),
				attribute <- thisModule.Attribute(thisModule.getDefaultAttribute(i.getAttr('r2ml:attributeID'), i.getAttrVal('r2ml:attributeID'))),
				typeCategory <- if i.hasAttr('r2ml:typeCategory') = true then
									if i.getAttrVal('r2ml:typeCategory') = 'individual' then
										#individual
									else if i.getAttrVal('r2ml:typeCategory') = 'set' then
											#set
										 else if i.getAttrVal('r2ml:typeCategory') = 'order' then
										 		#orderedSet
											  else if i.getAttrVal('r2ml:typeCategory') = 'bag' then
											  		#bag
												   else if i.getAttrVal('r2ml:typeCategory') = 'sequence' then
												   		 #sequence
														else OclUndefined
														endif
												   endif
											  endif
										 endif
									endif								
								else OclUndefined
								endif
			)
}

-- Rule 'Attribute'
-- Creates Attribute from an XML!Attribute named 'r2ml:attributeID'.
unique lazy rule Attribute {
	from i : XML!Attribute 
	to o : R2ML!Attribute (	
			predicateCategory <- #closed,
			name <- i.value
		)
}

-- Rule 'AssociationAtom'
-- Creates AssociationAtom from an XML!Element named 'r2ml:AssociationAtom'
-- This rule is some complicated, because it is possible that object or data
-- arguments does not exists in input file, so this must be checked first (with let expression).
rule AssociationAtom {
	from i : XML!Element (
		i.name = 'r2ml:AssociationAtom'
		)
	to 
		o : R2ML!AssociationAtom (
			isNegated <- i.isNegated(),
			objectArguments <- let objArgs : Set(XML!Element) = i.getElementsByName('r2ml:objectArguments') in
							       if objArgs->isEmpty() then
								   	  Sequence{}
  						           else Sequence{ objArgs->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)), 
				                                  objArgs->first().children->select(e | thisModule.getAllObjectVariables()->excludes(e))->asSequence()}
								   endif,
			dataArguments <- let dataArgs : Set(XML!Element) = i.getElementsByName('r2ml:dataArguments') in
							     if dataArgs->isEmpty() then
							 	    Sequence{}
						         else Sequence { dataArgs->first().children->asSequence()->select(c | thisModule.getAllDataVariables()->includes(c))->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e)), 
						         				 dataArgs->first().children->asSequence()->select(c | thisModule.getAllDataVariables()->excludes(c))->asSequence()
										       }
						         endif,
			associationPredicate <- asp
			),
		asp : R2ML!AssociationPredicate (
				name <- i.getAttrVal('r2ml:associationPredicateID')
			)
}

-- Rule 'ReferencePropertyFunctionTerm'
-- Creates ReferencePropertyFunctionTerm from an XML!Element named 'r2ml:ReferencePropertyFunctionTerm'.
rule ReferencePropertyFunctionTerm {
	from i : XML!Element (
			i.name = 'r2ml:RoleFunctionTerm' -- v0.3
			or i.name = 'r2ml:ReferencePropertyFunctionTerm' -- v0.4
		)
	to 
		o : R2ML!ReferencePropertyFunctionTerm (
				referencePropertyRef <- thisModule.ReferenceProperty(i.getAttr('r2ml:referencePropertyID')),
				contextArgument <- Sequence { i.getElementsByName('r2ml:contextArgument')->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first(),
											  i.getElementsByName('r2ml:contextArgument')->first().children->select(e | thisModule.getAllObjectVariables()->excludes(e))->first()
											 }->select(c | not c.oclIsUndefined())->asSequence()->first(),
				typeCategory <- if i.hasAttr('r2ml:typeCategory') = true then
									if i.getAttrVal('r2ml:typeCategory') = 'individual' then
										#individual
									else if i.getAttrVal('r2ml:typeCategory') = 'set' then
											#set
										 else if i.getAttrVal('r2ml:typeCategory') = 'order' then
										 		#orderedSet
											  else if i.getAttrVal('r2ml:typeCategory') = 'bag' then
											  		#bag
												   else if i.getAttrVal('r2ml:typeCategory') = 'sequence' then
												   		 #sequence
														else OclUndefined
														endif
												   endif
											  endif
										 endif
									endif								
								else OclUndefined
								endif
			)
}

-- Rule 'AttributionAtom'
-- Creates AttributionAtom from an XML!Element named 'r2ml:AttributionAtom'.
rule AttributionAtom {
	from i : XML!Element (
			i.name = 'r2ml:AttributionAtom'
		)
	to 
		o : R2ML!AttributionAtom (
			isNegated <- i.isNegated(),
			dataValue <- let val : XML!Element = i.getElementsByName('r2ml:dataValue')->first().children->first() in
							if val.name = 'r2ml:DataVariable'			
								then i.getElementsByName('r2ml:dataValue')->first().children->select(e | thisModule.getAllDataVariables()->includes(e))->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e))->first()
								else i.getElementsByName('r2ml:dataValue')->first().children->select(e | not thisModule.getAllDataVariables()->includes(e))->first()
							endif,
			subject <- Sequence { i.getElementsByName('r2ml:subject')->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first(),
								  i.getElementsByName('r2ml:subject')->first().children->select(e | thisModule.getAllObjectVariables()->excludes(e))
							}->select(c | not c.oclIsUndefined())->asSequence()->first(),
			attribute <- thisModule.Attribute(thisModule.getDefaultAttribute(i.getAttr('r2ml:attributeID'), i.getAttrVal('r2ml:attributeID')))
			)
}

-- Rule 'ReferencePropertyAtom'
-- Creates ReferencePropertyAtom from an XML!Element named 'r2ml:ReferencePropertyAtom'.
rule ReferencePropertyAtom {
	from i : XML!Element (
			i.name = 'r2ml:ReferencePropertyAtom'
		)
	to 
		o : R2ML!ReferencePropertyAtom (
				isNegated <- i.isNegated(),
				referenceProperty <- thisModule.ReferenceProperty(i.getAttr('r2ml:referencePropertyID')),
				subject <- Sequence { i.getElementsByName('r2ml:subject')->first().children->select(c | thisModule.getAllObjectVariables()->includes(c))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first(),
							 		  i.getElementsByName('r2ml:subject')->first().children->select(c | thisModule.getAllObjectVariables()->excludes(c))
							 		}->select(c | not c.oclIsUndefined())->asSequence()->first(),
				object <- Sequence { i.getElementsByName('r2ml:object')->first().children->select(c | thisModule.getAllObjectVariables()->includes(c))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first(),
							 		 i.getElementsByName('r2ml:object')->first().children->select(c | thisModule.getAllObjectVariables()->excludes(c))
								   }->select(c | not c.oclIsUndefined())->asSequence()->first()
			)
}

-- Rule 'ReferenceProperty'
-- Creates ReferenceProperty element from an XML!Attribute
-- This rule is unique lazy rule, which means that is called from other rules
unique lazy rule ReferenceProperty {
	from i : XML!Attribute 
	to rfp: R2ML!ReferenceProperty (
				predicateCategory <- #closed,
	    		name <- i.value
	    	)
}

-- Rule 'GenericAtom'
-- Creates GenericAtom element from an XML!Element named 'r2ml:GenericAtom'
rule GenericAtom {
	from i : XML!Element (
			i.name = 'r2ml:GenericAtom'
		)
	to 
		o : R2ML!GenericAtom (
				arguments <- Sequence{ i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllVariables()->includes(e))->collect(e | thisModule.getDefaultGenericVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.GenericVariable(e)), 
					 				   i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllDataVariables()->includes(e))->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e)),
					 				   i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
					                   i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllVariables()->excludes(e) and thisModule.getAllDataVariables()->excludes(e) and thisModule.getAllObjectVariables()->excludes(e))->asSequence()},
				predicate <- thisModule.GenericPredicate(thisModule.getDefaultGenericPredicate(i.getAttr('r2ml:predicateID'), i.getAttrVal('r2ml:predicateID')))
		)
}

-- Rule 'GenericPredicate'
-- Creates Predicate element from an XML!Element named 'r2ml:GenericPredicate'
-- This rule is unique lazy rule, which means that is called from other rules
unique lazy rule GenericPredicate {
	from i : XML!Attribute
	to  
		pre : R2ML!GenericPredicate (
				name <- i.value,
				predicateTypeID <- let pt : String = i.parent.getAttrVal('r2ml:predicateType') in
										if pt <> OclUndefined then
											if pt = 'ObjectClassificationPredicate' then
												#ObjectClassificationPredicate
											else if pt = 'AttributionPredicate' then
													#AttributionPredicate
												 else if pt = 'AssociationPredicate' then
												 	  	#AssociationPredicate
													  else if pt = 'ReferencePropertyPredicate' then
													  	   #ReferencePropertyPredicate
														   else if pt = 'EqualityPredicate' then
														   		#EqualityPredicate
																else if pt = 'InequalityPredicate' then
																		#InequalityPredicate
																	 else if pt = 'DatatypePredicate' then
																	 		#DatatypePredicate
																		  else if pt = 'DataClassificationPredicate' then
																		  		#DataClassificationPredicate
																			   else OclUndefined
																			   endif
																		  endif
																	 endif
																endif 
														   endif
													  endif
												 endif 
											endif
										else OclUndefined
										endif
		)		
}

-- Rule 'GenericVariable'
-- Creates GenericVariable element from an XML!Element named 'r2ml:Variable' or 'r2ml:GenericVariable'
-- This rule is unique lazy rule, which means that it's called from other rules
unique lazy rule GenericVariable {
	from i : XML!Element 
	to 
		o : R2ML!GenericVariable (
				name <- i.getAttrVal('r2ml:name'),
				typeRef <- if i.hasAttr('r2ml:dataTypeID') then 
								thisModule.Datatype(thisModule.getDefaultDataType(i.getAttr('r2ml:dataTypeID'), i.getAttrVal('r2ml:dataTypeID')))
						   else OclUndefined
						   endif
			)
}

-- Rule 'GenericFunctionTerm'
-- Creates GenericFunctionTerm element from an XML!Element named 'r2ml:FunctionTerm' or 'r2ml:GenericFunctionTerm'
rule GenericFunctionTerm {
	from i : XML!Element (
			i.name = 'r2ml:FunctionTerm' -- v0.3
			or i.name = 'r2ml:GenericFunctionTerm' -- v0.4
		)
	to 
		o : R2ML!GenericFunctionTerm (
				arguments <- Sequence{ i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllVariables()->includes(e))->collect(e | thisModule.getDefaultGenericVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.GenericVariable(e)), 
				   		               i.getElementsByName('r2ml:arguments')->first().children->select(e | not thisModule.getAllVariables()->includes(e))->asSequence()},
				functor <- fun,
				typeCategory <- if i.hasAttr('r2ml:typeCategory') = true then
									if i.getAttrVal('r2ml:typeCategory') = 'individual' then
										#individual
									else if i.getAttrVal('r2ml:typeCategory') = 'set' then
											#set
										 else if i.getAttrVal('r2ml:typeCategory') = 'order' then
										 		#orderedSet
											  else if i.getAttrVal('r2ml:typeCategory') = 'bag' then
											  		#bag
												   else if i.getAttrVal('r2ml:typeCategory') = 'sequence' then
												   		 #sequence
														else OclUndefined
														endif
												   endif
											  endif
										 endif
									endif								
								else OclUndefined
								endif
		),
		fun : R2ML!GenericFunction (
				name <- i.getAttrVal('r2ml:genericFunctionID')
			)
}

-- Rule 'DatatypeFunctionTerm'
-- Creates DatatypeFunctionTerm element from an XML!Element named 'r2ml:DatatypeFunctionTerm'
rule DatatypeFunctionTerm {
	from i : XML!Element (
			i.name = 'r2ml:DatatypeFunctionTerm'
		)
	to o : R2ML!DatatypeFunctionTerm (
			dataArguments <- Sequence{ i.getElementsByName('r2ml:dataArguments')->first().children->select(e | thisModule.getAllDataVariables()->includes(e))->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e))->first(), 
				                       i.getElementsByName('r2ml:dataArguments')->first().children->select(e | not thisModule.getAllDataVariables()->includes(e))->asSequence()},
			function <- dtf,
			typeCategory <- if i.hasAttr('r2ml:typeCategory') = true then
								if i.getAttrVal('r2ml:typeCategory') = 'individual' then
									#individual
								else if i.getAttrVal('r2ml:typeCategory') = 'set' then
										#set
									 else if i.getAttrVal('r2ml:typeCategory') = 'order' then
									 		#orderedSet
										  else if i.getAttrVal('r2ml:typeCategory') = 'bag' then
										  		#bag
											   else if i.getAttrVal('r2ml:typeCategory') = 'sequence' then
											   		 #sequence
													else OclUndefined
													endif
											   endif
										  endif
									 endif
								endif								
							else OclUndefined
							endif
		),
	dtf : R2ML!DatatypeFunction (
			name <- i.getAttrVal('r2ml:datatypeFunctionID')
		)
}

-- Rule 'ObjectName'
-- Creates ObjectName element from an XML!Element named 'r2ml:ObjectName'
rule ObjectName {
	from i : XML!Element (
			i.name = 'r2ml:ObjectName'
		)
	to o : R2ML!ObjectName (
			name <- i.getAttrVal('r2ml:objectID'),
			classRef <- let classID : String = i.getAttrVal('r2ml:classID') in
							if not classID.oclIsUndefined() then
								thisModule.ClassRule(i.getAttr('r2ml:classID'))
							else OclUndefined
							endif,
			typeCategory <- if i.hasAttr('r2ml:typeCategory') = true then
								if i.getAttrVal('r2ml:typeCategory') = 'individual' then
									#individual
								else if i.getAttrVal('r2ml:typeCategory') = 'set' then
										#set
									 else if i.getAttrVal('r2ml:typeCategory') = 'order' then
									 		#orderedSet
										  else if i.getAttrVal('r2ml:typeCategory') = 'bag' then
										  		#bag
											   else if i.getAttrVal('r2ml:typeCategory') = 'sequence' then
											   		 #sequence
													else OclUndefined
													endif
											   endif
										  endif
									 endif
								endif								
							else OclUndefined
							endif
		)
}

-- Rule 'ObjectDescriptionAtom'
-- Creates ObjectDescriptionAtom element from an XML!Element named 'r2ml:ObjectDescriptionAtom'
rule ObjectDescriptionAtom {
	from i : XML!Element (
			i.name = 'r2ml:ObjectDescriptionAtom'
		)
	to o : R2ML!ObjectDescriptionAtom (
				isNegated <- i.isNegated(),
				type <- Sequence { thisModule.ClassRule(i.getAttr('r2ml:classID')) },
				slots <- Sequence{ i.getElementsByName('r2ml:DataSlot')->first().children->asSequence(),
								   i.getElementsByName('r2ml:ObjectSlot')->first().children->asSequence() },
				subject <- Sequence { i.getElementsByName('r2ml:subject')->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first(),
								      i.getElementsByName('r2ml:subject')->first().children->select(e | thisModule.getAllObjectVariables()->excludes(e))
							        }->select(c | not c.oclIsUndefined())->asSequence()->first(),
				objects <- i.getElementsByName('r2ml:objects')->first().children->asSequence(),
				baseType <- if i.hasAttr('r2ml:baseType') then
								thisModule.ClassRule(i.getAttr('r2ml:baseType'))
							else OclUndefined
							endif
			)
}

-- Rule 'ObjectSlot'
-- Creates ObjectSlot element from an XML!Element named 'r2ml:ObjectSlot'
rule ObjectSlot {
	from i : XML!Element (
			i.name = 'r2ml:ObjectSlot'
		)
	to 
		o : R2ML!ObjectSlot (
				object <- Sequence { i.getElementsByName('r2ml:object')->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first(),
								     i.getElementsByName('r2ml:object')->first().children->select(e | thisModule.getAllObjectVariables()->excludes(e))
							       }->select(c | not c.oclIsUndefined())->asSequence()->first(),
				referenceProperty <- thisModule.ReferenceProperty(i.getAttr('r2ml:referencePropertyID'))
			) 
}

-- Rule 'DataSlot'
-- Creates DataSlot element from an XML!Element named 'r2ml:DataSlot'
rule DataSlot {
	from i : XML!Element (
			i.name = 'r2ml:DataSlot'
		)
	to 
		o : R2ML!DataSlot (
				value <- Sequence { i.getElementsByName('r2ml:value')->first().children->select(e | thisModule.getAllDataVariables()->includes(e))->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e))->first(),
									i.getElementsByName('r2ml:value')->first().children->select(e | thisModule.getAllDataVariables()->excludes(e))->first()
								  }->select(c | not c.oclIsUndefined())->asSequence()->first(),
				attribute <- thisModule.Attribute(thisModule.getDefaultAttribute(i.getAttr('r2ml:attributeID'), i.getAttrVal('r2ml:attributeID')))
			) 
}

-- Rule 'AtLeastQuantifiedFormula'
-- Creates AtLeastQuantifiedFormula from an XML!Element named 'r2ml:AtLeastQuantifiedFormula'.
rule AtLeastQuantifiedFormula {
	from i : XML!Element (
				i.name = 'r2ml:AtLeastQuantifiedFormula'
			)
  to
		o : R2ML!AtLeastQuantifiedFormula (
				variables <- Sequence { i.getElementsByName('r2ml:ObjectVariable')->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
									    i.getElementsByName('r2ml:DataVariable')->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e)) },
				formula <- i.children->select(e | thisModule.getAllDataVariables()->excludes(e) and thisModule.getAllObjectVariables()->excludes(e) and e.oclIsTypeOf(XML!Element))->first(),
				minCardinality <- i.getAttrVal('r2ml:minCardinality').toInteger()
			)
}

-- Rule 'AtMostQuantifiedFormula'
-- Creates AtMostQuantifiedFormula from an XML!Element named 'r2ml:AtMostQuantifiedFormula'.
rule AtMostQuantifiedFormula {
	from i : XML!Element (
				i.name = 'r2ml:AtMostQuantifiedFormula'
			)
  to
		o : R2ML!AtMostQuantifiedFormula (
				variables <- Sequence { i.getElementsByName('r2ml:ObjectVariable')->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
									    i.getElementsByName('r2ml:DataVariable')->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e)) },
				formula <- i.children->select(e | thisModule.getAllDataVariables()->excludes(e) and thisModule.getAllObjectVariables()->excludes(e) and e.oclIsTypeOf(XML!Element))->first(),
				maxCardinality <- i.getAttrVal('r2ml:maxCardinality').toInteger()
			)
}

-- Rule 'AtLeastAndAtMostQuantifiedFormula'
-- Creates AtLeastAndAtMostQuantifiedFormula from an XML!Element named 'r2ml:AtLeastAndAtMostQuantifiedFormula'.
rule AtLeastAndAtMostQuantifiedFormula {
	from i : XML!Element (
				i.name = 'r2ml:AtLeastAndAtMostQuantifiedFormula'
			)
  to
		o : R2ML!AtLeastAndAtMostQuantifiedFormula (
				variables <- Sequence { i.getElementsByName('r2ml:ObjectVariable')->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
									    i.getElementsByName('r2ml:DataVariable')->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e)) },
				formula <- i.children->select(e | thisModule.getAllDataVariables()->excludes(e) and thisModule.getAllObjectVariables()->excludes(e) and e.oclIsTypeOf(XML!Element))->first(),
				maxCardinality <- i.getAttrVal('r2ml:maxCardinality').toInteger(),
				minCardinality <- i.getAttrVal('r2ml:minCardinality').toInteger()
			)
}

-- Rule 'ObjectOperationTerm'
-- Creates ObjectOperationTerm from an XML!Element named 'r2ml:ObjectOperationTerm'.
rule ObjectOperationTerm {
	from i : XML!Element (
			i.name = 'r2ml:ObjectOperationTerm'
		)
	to o : R2ML!ObjectOperationTerm (
			operation <- thisModule.ObjectOperation(i.getAttr('r2ml:operationID')),
			arguments <- Sequence { i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
									i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllDataVariables()->includes(e))->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e)),
								    i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllObjectVariables()->excludes(e) and thisModule.getAllDataVariables()->excludes(e))
 							      },
			contextArgument <- Sequence { i.getElementsByName('r2ml:contextArgument')->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first(),
										  i.getElementsByName('r2ml:contextArgument')->first().children->select(e | thisModule.getAllObjectVariables()->excludes(e))->first()
									    }->select(c | not c.oclIsUndefined())->asSequence()->first()
		)
}

-- Lazy Rule 'ObjectOperation'
-- Creates ObjectOperation from an XML!Element named attribute of 'r2ml:ObjectOperationTerm'.
unique lazy rule ObjectOperation {
	from i : XML!Attribute
	to o : R2ML!ObjectOperation (
			name <- i.value
		)
}

-- Rule 'DataOperationTerm'
-- Creates DataOperationTerm from an XML!Element named 'r2ml:DataOperationTerm'.
rule DataOperationTerm {
	from i : XML!Element (
			i.name = 'r2ml:DataOperationTerm'
		)
	to o : R2ML!DataOperationTerm (
			dataOperationRef <- thisModule.DataOperation(i.getAttr('r2ml:operationID')),
			arguments <- Sequence { i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
									i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllDataVariables()->includes(e))->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e)),
								    i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllObjectVariables()->excludes(e) and thisModule.getAllDataVariables()->excludes(e))
 							      },
			contextArgument <- Sequence { i.getElementsByName('r2ml:contextArgument')->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first(),
										  i.getElementsByName('r2ml:contextArgument')->first().children->select(e | thisModule.getAllObjectVariables()->excludes(e))->first()
									    }->select(c | not c.oclIsUndefined())->asSequence()->first()
		)
}

-- Lazy Rule 'DataOperation'
-- Creates DataOperation from an XML!Element named attribute of 'r2ml:DataOperationTerm'.
unique lazy rule DataOperation {
	from i : XML!Attribute
	to o : R2ML!DataOperation (
			name <- i.value
		)
}",transform xml metamodel r ml metamodel creat part m sc these good old ai laboratori author milan milanov milan milanov org work r ml xml schema metamodel v licenc gnu general public licens version modul xml r ml creat out r ml in xml use string use xmlhelper general xml metamodel helper helper xml r ml transform specif xml helper helper isneg return boolean statement xml element attribut xml attribut name r ml isneg true fals contextu xml element context xml element out boolean helper context xml element def isneg boolean let collect sequenc xml attribut self children select c c ocliskindof xml attribut c name r ml isneg collect isempti fals els empti let val string collect first valu val true true els fals endif endif helper getallrul return sequenc xml element name integrityrul derivationrul context thismodul out sequenc xml element todo add type rule helper def getallrul sequenc xml element xml element allinst select e e name r ml alethicintegrityrul e name r ml deonticintegrityrul e name r ml derivationrul assequ helper allsubel return sequenc xml sub element xml element recursivelli element last element children annot base transform model atl freder jouault ivan kurtev context xml element out sequenc xml element helper context xml element def allsubel sequenc xml element let subelem sequenc xml element xml element allinst select c get element parent c parent self collect elem elem allsubel flatten everi element get subel subelem union subel apprehend everi element add topmost element child parent self children select ch ch oclistypeof xml element flatten helper allsubattribut return sequenc xml sub attribut xml element recursivelli attribut last attribut children context xml element out sequenc xml attribut helper context xml element def allsubattribut sequenc xml attribut let subattr sequenc xml attribut xml element allinst select c c parent self collect attr attr allsubattribut flatten subattr union self children select oclistypeof xml attribut flatten helper getruleforel return xml element rule integr deriv contain context ual xml element context xml element out xml element helper context xml element def getruleforel xml element thismodul getallrul select c c allsubel includ self assequ first helper getruleforattribut return xml element rule integr deriv contain context ual xml attribut context xml attribut out xml element helper context xml attribut def getruleforattribut xml element thismodul getallrul select c c allsubattribut includ self assequ first helper getdefaultobjectvari return alway first objectvari valu this necessari uniqu lazi rule creat one output objectvari multipl input valu context thismodul in string out xml element helper def getdefaultobjectvari elem xml element valu string xml element let objvar sequenc xml element elem getruleforel allsubel select e e name r ml objectvari select e e getattrv r ml name valu e hasattr r ml classid assequ objvar isempti elem getruleforel allsubel select e e name r ml objectvari select e e getattrv r ml name valu assequ first els objvar first endif helper getdefaultdatavari same previous data variabl context thismodul in string out xml element helper def getdefaultdatavari elem xml element valu string xml element elem getruleforel allsubel select e e name r ml datavari select e e getattrv r ml name valu assequ first helper getdefaultgenericvari same previous variabl context thismodul in string out xml element helper def getdefaultgenericvari elem xml element valu string xml element elem getruleforel allsubel select e e name r ml variabl e name r ml genericvari select e e getattrv r ml name valu assequ first helper getdefaultgenericpred alway return first predic associ genericatom context thismodul in string out xml attribut helper def getdefaultgenericpred attr xml attribut valu string xml attribut attr getruleforattribut allsubattribut select e e name r ml predicateid select e e valu valu assequ first helper getdefaultattribut alway return first attribut associ term context thismodul in string out xml attribut helper def getdefaultattribut attr xml attribut valu string xml attribut attr getruleforattribut allsubattribut select e e name r ml attributeid select e e valu valu assequ first helper getdefaultdatatyp alway return first data type context thismodul in string out xml attribut helper def getdefaultdatatyp attr xml attribut valu string xml attribut attr getruleforattribut allsubattribut select e e name r ml datatypeid e name r ml type select e e valu valu assequ first helper getallobjectvari return object variabl input file context thismodul out sequenc xml element helper def getallobjectvari sequenc xml element xml element allinst select e e name r ml objectvari helper getalldatavari return data variabl input file context thismodul out sequenc xml element helper def getalldatavari sequenc xml element xml element allinst select e e name r ml datavari helper getallvari return variabl input file context thismodul out sequenc xml element helper def getallvari sequenc xml element xml element allinst select e e name r ml variabl e name r ml genericvari rule rule rulebas creat rulebas root element rule rulebas xml element name r ml rulebas r ml rulebas rulebaseid getattrv xmlns r ml rule children select c c ocliskindof xml element assequ rule derivationruleset creat derivationruleset xml element name r ml derivationruleset rule derivationruleset xml element name r ml derivationruleset r ml derivationruleset rule children select c c ocliskindof xml element assequ rule integrityruleset creat integrityruleset xml element name r ml integrityruleset rule integrityruleset xml element name r ml integrityruleset r ml integrityruleset rule children select c c ocliskindof xml element assequ rule reactionruleset creat reactionruleset xml element name r ml reactionruleset rule reactionruleset xml element name r ml reactionruleset r ml reactionruleset rule children select c c ocliskindof xml element assequ rule productionruleset creat productionruleset xml element name r ml productionruleset rule productionruleset xml element name r ml productionruleset r ml productionruleset rule children select c c ocliskindof xml element assequ rule alethicintegrityrul creat alethicintegrityrul xml element name r ml alethicintegrityrul rule alethicintegrityrul xml element name r ml alethicintegrityrul r ml alethicintegrityrul constraint getelementsbynam r ml constraint first children select c c ocliskindof xml element first ruleid hasattr r ml ruleid true getattrv r ml ruleid els oclundefin endif rule deonticintegrityrul creat deonticintegrityrul xml element name r ml deonticintegrityrul rule deonticintegrityrul xml element name r ml deonticintegrityrul r ml deonticintegrityrul constraint getelementsbynam r ml constraint first children select c c ocliskindof xml element first ruleid hasattr r ml ruleid true getattrv r ml ruleid els oclundefin endif rule universallyquantifiedformula creat universallyquantifiedformula xml element name r ml universallyquantifiedformula rule universallyquantifiedformula xml element name r ml universallyquantifiedformula r ml universallyquantifiedformula annot remark first time generat variabl get objectvari element children helper getdefaultobjectvari get alway input element variabl name call uniqu lazi rule objectvari generat variabl variabl sequenc getelementsbynam r ml objectvari collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e getelementsbynam r ml datavari collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e formula children select e thismodul getalldatavari exclud e thismodul getallobjectvari exclud e e oclistypeof xml element first rule existentiallyquantifiedformula creat existentiallyquantifiedformula xml element name r ml existentiallyquantifiedformula rule existentiallyquantifiedformula xml element name r ml existentiallyquantifiedformula r ml existentiallyquantifiedformula variabl sequenc getelementsbynam r ml objectvari collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e getelementsbynam r ml datavari collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e formula children select e thismodul getalldatavari exclud e thismodul getallobjectvari exclud e e oclistypeof xml element first rule implic creat implic xml element name r ml implic rule implic xml element name r ml implic r ml implic anteced getelementsbynam r ml anteced first children select c c oclistypeof xml element assequ first consequ getelementsbynam r ml consequ first children select c c oclistypeof xml element assequ first rule conjuct creat conjuct xml element name r ml conjuct rule conjuct xml element name r ml conjunct r ml conjuct formula children select c c ocliskindof xml element asset rule disjunct creat disjunct xml element name r ml disjunct rule disjunct xml element name r ml disjunct r ml disjunct formula children select c c ocliskindof xml element asset rule negationasfailur creat negationasfailur xml element name r ml negationasfailur rule negationasfailur xml element name r ml negationasfailur r ml negationasfailur formula children select c c ocliskindof xml element first rule strongneg creat strongneg xml element name r ml strongneg rule strongneg xml element name r ml strongneg r ml strongneg formula children select c c ocliskindof xml element first rule equalityatom creat equalityatom xml element name r ml equalityatom rule equalityatom xml element name r ml equalityatom r ml equalityatom term sequenc children select c c ocliskindof xml element c name r ml objectvari collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e children select c c ocliskindof xml element c name r ml objectvari rule inequalityatom creat inequalityatom xml element name r ml inequalityatom rule inequalityatom xml element name r ml inequalityatom r ml inequalityatom term sequenc children select c c ocliskindof xml element c name r ml objectvari collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e children select c c ocliskindof xml element c name r ml objectvari rule derivationrul creat derivationrul xml element name r ml derivationrul rule derivationrul xml element name r ml derivationrul r ml derivationrul condit getelementsbynam r ml condit first children select c c ocliskindof xml element assequ conclus getelementsbynam r ml conclus first ruleid hasattr r ml ruleid true getattrv r ml ruleid els oclundefin endif rule literalconjuct creat atom xml element name r ml derivationrul conclus rule literalconjuct xml element name r ml conclus r ml literalconjunct atom children select c c ocliskindof xml element asset rule classrul creat class xml attribut this lazi rule call rule uniqu lazi rule classrul xml attribut cla r ml class name valu predicatecategori close rule objectclassificationatom creat objectclassificationatom xml element name r ml objectclassificationatom rule objectclassificationatom xml element name r ml objectclassificationatom obj r ml objectclassificationatom isneg isneg type children select c c ocliskindof xml attribut c name r ml classid collect e thismodul classrul e first term children select c c ocliskindof xml element c name r ml objectvari collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first rule dataclassificationatom creat dataclassificationatom xml element name r ml dataclassificationatom rule dataclassificationatom xml element name r ml dataclassificationatom obj r ml dataclassificationatom isneg isneg type thismodul datatyp thismodul getdefaultdatatyp getattr r ml datatypeid getattrv r ml datatypeid term children select c c ocliskindof xml element c name r ml datavari collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e first rule objectvari creat objectvari xml element name r ml objectvari this rule uniqu lazi rule mean call rule uniqu lazi rule objectvari xml element name r ml objectvari ov r ml objectvari classref children select c c ocliskindof xml attribut c name r ml classid collect e thismodul classrul e first name getattrv r ml name typecategori individu rule datavari creat datavari xml element name r ml datavari this rule uniqu lazi rule mean call rule uniqu lazi rule datavari xml element name r ml datavari odv r ml datavari datatyperef hasattr r ml datatypeid thismodul datatyp thismodul getdefaultdatatyp getattr r ml datatypeid getattrv r ml datatypeid els oclundefin endif name getattrv r ml name typecategori hasattr r ml typecategori true getattrv r ml typecategori individu individu els getattrv r ml typecategori set set els getattrv r ml typecategori order orderedset els getattrv r ml typecategori bag bag els getattrv r ml typecategori sequenc sequenc els individu endif endif endif endif endif els oclundefin endif rule datatyp creat datatyp xml attribut this rule uniqu lazi rule mean call rule uniqu lazi rule datatyp xml attribut r ml datatyp predicatecategori close name valu rule qfdisjunct creat qfdisjunct xml element name r ml qf disjunct rule qfdisjunct xml element name r ml qf disjunct r ml qfdisjunct formula children select c c ocliskindof xml element assequ rule qfconjunct creat qfconjunct xml element name r ml qf conjunct rule qfconjunct xml element name r ml qf conjuct r ml qfconjunct formula children select c c ocliskindof xml element assequ rule qfnegationasfailur creat qfnegationasfailur xml element name r ml qf negationasfailur rule qfnegationasfailur xml element name r ml qf negationasfailur r ml qfnegationasfailur formula children select c c ocliskindof xml element first rule qfstrongneg creat qfstrongneg xml element name r ml qf strongneg rule qfstrongneg xml element name r ml qf strongneg r ml qfstrongneg formula children select c c ocliskindof xml element first rule datatypepredicateatom creat datatypepredicateatom xml element name r ml datatypepredicateatom r ml datapredicateatom rule datatypepredicateatom xml element r ml v name r ml datapredicateatom r ml v name r ml datatypepredicateatom r ml datatypepredicateatom dataargu sequenc getelementsbynam r ml dataargu first children select e thismodul getalldatavari includ e collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e getelementsbynam r ml dataargu first children select e thismodul getalldatavari includ e assequ predic children select c c ocliskindof xml attribut c name r ml datapredicateid c name r ml datatypepredicateid collect e thismodul datatypepredicaterul e first rule datatypepredicaterul creat datatypepredicaterul xml attribut this rule uniqu lazi rule mean call rule uniqu lazi rule datatypepredicaterul xml attribut dtp r ml datatypepred predicatecategori close name valu rule dataoperationterm creat dataoperationterm xml element name r ml dataoperationterm rule dataoperationterm xml element name r ml dataoperationterm r ml dataoperationterm dataoperationref opr argument let arg set xml element getelementsbynam r ml argument arg isempti sequenc annot first get objectvari datavari element objectvari datavari els sequenc arg first children select e thismodul getalldatavari includ e collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e arg first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e arg first children select e thismodul getalldatavari includ e thismodul getallobjectvari includ e assequ endif contextargu let conarg set xml element getelementsbynam r ml contextargu conarg isempti oclundefin els sequenc conarg first children assequ select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first conarg first children assequ select e thismodul getallobjectvari exclud e select c c oclisundefin assequ first endif typecategori hasattr r ml typecategori true getattrv r ml typecategori individu individu els getattrv r ml typecategori set set els getattrv r ml typecategori order orderedset els getattrv r ml typecategori bag bag els getattrv r ml typecategori sequenc sequenc els oclundefin endif endif endif endif endif els oclundefin endif opr r ml dataoper name getattrv r ml operationid rule typedliter creat typedliter xml element name r ml typedliter rule typedliter xml element name r ml typedliter r ml typedliter lexicalvalu getattrv r ml lexicalvalu type thismodul datatyp thismodul getdefaultdatatyp getattr r ml datatypeid getattrv r ml datatypeid typecategori hasattr r ml typecategori true getattrv r ml typecategori individu individu els getattrv r ml typecategori set set els getattrv r ml typecategori order orderedset els getattrv r ml typecategori bag bag els getattrv r ml typecategori sequenc sequenc els oclundefin endif endif endif endif endif els oclundefin endif rule plainliter creat plainliter xml element name r ml plainliter rule plainliter xml element name r ml plainliter r ml plainliter lexicalvalu getattrv r ml lexicalvalu languagetag getattrv r ml languagetag typecategori hasattr r ml typecategori true getattrv r ml typecategori individu individu els getattrv r ml typecategori set set els getattrv r ml typecategori order orderedset els getattrv r ml typecategori bag bag els getattrv r ml typecategori sequenc sequenc els oclundefin endif endif endif endif endif els oclundefin endif rule attributefunctionterm creat attributefunctionterm xml element name r ml attributefunctionterm rule attributefunctionterm xml element name r ml attributefunctionterm r ml attributefunctionterm contextargu sequenc getelementsbynam r ml contextargu first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first getelementsbynam r ml contextargu first children select e thismodul getallobjectvari exclud e assequ first non objectvari object term select c c oclisundefin assequ first attribut thismodul attribut thismodul getdefaultattribut getattr r ml attributeid getattrv r ml attributeid typecategori hasattr r ml typecategori true getattrv r ml typecategori individu individu els getattrv r ml typecategori set set els getattrv r ml typecategori order orderedset els getattrv r ml typecategori bag bag els getattrv r ml typecategori sequenc sequenc els oclundefin endif endif endif endif endif els oclundefin endif rule attribut creat attribut xml attribut name r ml attributeid uniqu lazi rule attribut xml attribut r ml attribut predicatecategori close name valu rule associationatom creat associationatom xml element name r ml associationatom this rule complic possibl object data argument exist input file must check first let express rule associationatom xml element name r ml associationatom r ml associationatom isneg isneg objectargu let objarg set xml element getelementsbynam r ml objectargu objarg isempti sequenc els sequenc objarg first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e objarg first children select e thismodul getallobjectvari exclud e assequ endif dataargu let dataarg set xml element getelementsbynam r ml dataargu dataarg isempti sequenc els sequenc dataarg first children assequ select c thismodul getalldatavari includ c collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e dataarg first children assequ select c thismodul getalldatavari exclud c assequ endif associationpred asp asp r ml associationpred name getattrv r ml associationpredicateid rule referencepropertyfunctionterm creat referencepropertyfunctionterm xml element name r ml referencepropertyfunctionterm rule referencepropertyfunctionterm xml element name r ml rolefunctionterm v name r ml referencepropertyfunctionterm v r ml referencepropertyfunctionterm referencepropertyref thismodul referenceproperti getattr r ml referencepropertyid contextargu sequenc getelementsbynam r ml contextargu first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first getelementsbynam r ml contextargu first children select e thismodul getallobjectvari exclud e first select c c oclisundefin assequ first typecategori hasattr r ml typecategori true getattrv r ml typecategori individu individu els getattrv r ml typecategori set set els getattrv r ml typecategori order orderedset els getattrv r ml typecategori bag bag els getattrv r ml typecategori sequenc sequenc els oclundefin endif endif endif endif endif els oclundefin endif rule attributionatom creat attributionatom xml element name r ml attributionatom rule attributionatom xml element name r ml attributionatom r ml attributionatom isneg isneg datavalu let val xml element getelementsbynam r ml datavalu first children first val name r ml datavari getelementsbynam r ml datavalu first children select e thismodul getalldatavari includ e collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e first els getelementsbynam r ml datavalu first children select e thismodul getalldatavari includ e first endif subject sequenc getelementsbynam r ml subject first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first getelementsbynam r ml subject first children select e thismodul getallobjectvari exclud e select c c oclisundefin assequ first attribut thismodul attribut thismodul getdefaultattribut getattr r ml attributeid getattrv r ml attributeid rule referencepropertyatom creat referencepropertyatom xml element name r ml referencepropertyatom rule referencepropertyatom xml element name r ml referencepropertyatom r ml referencepropertyatom isneg isneg referenceproperti thismodul referenceproperti getattr r ml referencepropertyid subject sequenc getelementsbynam r ml subject first children select c thismodul getallobjectvari includ c collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first getelementsbynam r ml subject first children select c thismodul getallobjectvari exclud c select c c oclisundefin assequ first object sequenc getelementsbynam r ml object first children select c thismodul getallobjectvari includ c collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first getelementsbynam r ml object first children select c thismodul getallobjectvari exclud c select c c oclisundefin assequ first rule referenceproperti creat referenceproperti element xml attribut this rule uniqu lazi rule mean call rule uniqu lazi rule referenceproperti xml attribut rfp r ml referenceproperti predicatecategori close name valu rule genericatom creat genericatom element xml element name r ml genericatom rule genericatom xml element name r ml genericatom r ml genericatom argument sequenc getelementsbynam r ml argument first children select e thismodul getallvari includ e collect e thismodul getdefaultgenericvari e getattrv r ml name collect e thismodul genericvari e getelementsbynam r ml argument first children select e thismodul getalldatavari includ e collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e getelementsbynam r ml argument first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e getelementsbynam r ml argument first children select e thismodul getallvari exclud e thismodul getalldatavari exclud e thismodul getallobjectvari exclud e assequ predic thismodul genericpred thismodul getdefaultgenericpred getattr r ml predicateid getattrv r ml predicateid rule genericpred creat predic element xml element name r ml genericpred this rule uniqu lazi rule mean call rule uniqu lazi rule genericpred xml attribut pre r ml genericpred name valu predicatetypeid let pt string parent getattrv r ml predicatetyp pt oclundefin pt objectclassificationpred objectclassificationpred els pt attributionpred attributionpred els pt associationpred associationpred els pt referencepropertypred referencepropertypred els pt equalitypred equalitypred els pt inequalitypred inequalitypred els pt datatypepred datatypepred els pt dataclassificationpred dataclassificationpred els oclundefin endif endif endif endif endif endif endif endif els oclundefin endif rule genericvari creat genericvari element xml element name r ml variabl r ml genericvari this rule uniqu lazi rule mean call rule uniqu lazi rule genericvari xml element r ml genericvari name getattrv r ml name typeref hasattr r ml datatypeid thismodul datatyp thismodul getdefaultdatatyp getattr r ml datatypeid getattrv r ml datatypeid els oclundefin endif rule genericfunctionterm creat genericfunctionterm element xml element name r ml functionterm r ml genericfunctionterm rule genericfunctionterm xml element name r ml functionterm v name r ml genericfunctionterm v r ml genericfunctionterm argument sequenc getelementsbynam r ml argument first children select e thismodul getallvari includ e collect e thismodul getdefaultgenericvari e getattrv r ml name collect e thismodul genericvari e getelementsbynam r ml argument first children select e thismodul getallvari includ e assequ functor fun typecategori hasattr r ml typecategori true getattrv r ml typecategori individu individu els getattrv r ml typecategori set set els getattrv r ml typecategori order orderedset els getattrv r ml typecategori bag bag els getattrv r ml typecategori sequenc sequenc els oclundefin endif endif endif endif endif els oclundefin endif fun r ml genericfunct name getattrv r ml genericfunctionid rule datatypefunctionterm creat datatypefunctionterm element xml element name r ml datatypefunctionterm rule datatypefunctionterm xml element name r ml datatypefunctionterm r ml datatypefunctionterm dataargu sequenc getelementsbynam r ml dataargu first children select e thismodul getalldatavari includ e collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e first getelementsbynam r ml dataargu first children select e thismodul getalldatavari includ e assequ function dtf typecategori hasattr r ml typecategori true getattrv r ml typecategori individu individu els getattrv r ml typecategori set set els getattrv r ml typecategori order orderedset els getattrv r ml typecategori bag bag els getattrv r ml typecategori sequenc sequenc els oclundefin endif endif endif endif endif els oclundefin endif dtf r ml datatypefunct name getattrv r ml datatypefunctionid rule objectnam creat objectnam element xml element name r ml objectnam rule objectnam xml element name r ml objectnam r ml objectnam name getattrv r ml objectid classref let classid string getattrv r ml classid classid oclisundefin thismodul classrul getattr r ml classid els oclundefin endif typecategori hasattr r ml typecategori true getattrv r ml typecategori individu individu els getattrv r ml typecategori set set els getattrv r ml typecategori order orderedset els getattrv r ml typecategori bag bag els getattrv r ml typecategori sequenc sequenc els oclundefin endif endif endif endif endif els oclundefin endif rule objectdescriptionatom creat objectdescriptionatom element xml element name r ml objectdescriptionatom rule objectdescriptionatom xml element name r ml objectdescriptionatom r ml objectdescriptionatom isneg isneg type sequenc thismodul classrul getattr r ml classid slot sequenc getelementsbynam r ml dataslot first children assequ getelementsbynam r ml objectslot first children assequ subject sequenc getelementsbynam r ml subject first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first getelementsbynam r ml subject first children select e thismodul getallobjectvari exclud e select c c oclisundefin assequ first object getelementsbynam r ml object first children assequ basetyp hasattr r ml basetyp thismodul classrul getattr r ml basetyp els oclundefin endif rule objectslot creat objectslot element xml element name r ml objectslot rule objectslot xml element name r ml objectslot r ml objectslot object sequenc getelementsbynam r ml object first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first getelementsbynam r ml object first children select e thismodul getallobjectvari exclud e select c c oclisundefin assequ first referenceproperti thismodul referenceproperti getattr r ml referencepropertyid rule dataslot creat dataslot element xml element name r ml dataslot rule dataslot xml element name r ml dataslot r ml dataslot valu sequenc getelementsbynam r ml valu first children select e thismodul getalldatavari includ e collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e first getelementsbynam r ml valu first children select e thismodul getalldatavari exclud e first select c c oclisundefin assequ first attribut thismodul attribut thismodul getdefaultattribut getattr r ml attributeid getattrv r ml attributeid rule atleastquantifiedformula creat atleastquantifiedformula xml element name r ml atleastquantifiedformula rule atleastquantifiedformula xml element name r ml atleastquantifiedformula r ml atleastquantifiedformula variabl sequenc getelementsbynam r ml objectvari collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e getelementsbynam r ml datavari collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e formula children select e thismodul getalldatavari exclud e thismodul getallobjectvari exclud e e oclistypeof xml element first mincardin getattrv r ml mincardin tointeg rule atmostquantifiedformula creat atmostquantifiedformula xml element name r ml atmostquantifiedformula rule atmostquantifiedformula xml element name r ml atmostquantifiedformula r ml atmostquantifiedformula variabl sequenc getelementsbynam r ml objectvari collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e getelementsbynam r ml datavari collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e formula children select e thismodul getalldatavari exclud e thismodul getallobjectvari exclud e e oclistypeof xml element first maxcardin getattrv r ml maxcardin tointeg rule atleastandatmostquantifiedformula creat atleastandatmostquantifiedformula xml element name r ml atleastandatmostquantifiedformula rule atleastandatmostquantifiedformula xml element name r ml atleastandatmostquantifiedformula r ml atleastandatmostquantifiedformula variabl sequenc getelementsbynam r ml objectvari collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e getelementsbynam r ml datavari collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e formula children select e thismodul getalldatavari exclud e thismodul getallobjectvari exclud e e oclistypeof xml element first maxcardin getattrv r ml maxcardin tointeg mincardin getattrv r ml mincardin tointeg rule objectoperationterm creat objectoperationterm xml element name r ml objectoperationterm rule objectoperationterm xml element name r ml objectoperationterm r ml objectoperationterm oper thismodul objectoper getattr r ml operationid argument sequenc getelementsbynam r ml argument first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e getelementsbynam r ml argument first children select e thismodul getalldatavari includ e collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e getelementsbynam r ml argument first children select e thismodul getallobjectvari exclud e thismodul getalldatavari exclud e contextargu sequenc getelementsbynam r ml contextargu first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first getelementsbynam r ml contextargu first children select e thismodul getallobjectvari exclud e first select c c oclisundefin assequ first lazi rule objectoper creat objectoper xml element name attribut r ml objectoperationterm uniqu lazi rule objectoper xml attribut r ml objectoper name valu rule dataoperationterm creat dataoperationterm xml element name r ml dataoperationterm rule dataoperationterm xml element name r ml dataoperationterm r ml dataoperationterm dataoperationref thismodul dataoper getattr r ml operationid argument sequenc getelementsbynam r ml argument first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e getelementsbynam r ml argument first children select e thismodul getalldatavari includ e collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e getelementsbynam r ml argument first children select e thismodul getallobjectvari exclud e thismodul getalldatavari exclud e contextargu sequenc getelementsbynam r ml contextargu first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first getelementsbynam r ml contextargu first children select e thismodul getallobjectvari exclud e first select c c oclisundefin assequ first lazi rule dataoper creat dataoper xml element name attribut r ml dataoperationterm uniqu lazi rule dataoper xml attribut r ml dataoper name valu,6
147,147,P66-R2ML2RDM.atl,"-- ============================================================
-- Transforms an R2ML metamodel into RDM metamodel.
-- Created as part of M.Sc. theses at GOOD OLD AI Laboratory
-- Author: Milan Milanovic (milan at milanovic.org)
-- Works for R2ML v0.4 (Integrity and Derivation rules)
-- Licence: GNU General Public License, version 2
-- ============================================================

module R2ML2RDM; -- Module Template
create OUT : RDM from IN : R2ML;

uses strings;

-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- HELPER:	firstCharToUpper
-- Converts first character of String to upper and return complete string.
-- CONTEXT:	String
-- OUT:		String
helper context String def: firstCharToUpper() : String =
	let firstChar : String = self.substring(1, 1) in
		firstChar.toUpper() + self.substring(2, self.size());

-- HELPER:	toBoolean
-- Converts String value to Boolean value
-- CONTEXT:	String
-- IN:		String
-- OUT:		Boolean
helper context String def: toBoolean() : Boolean =
	if self = 'true'
	then true
	else false
	endif;

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	R2ML!ObjectClassificationAtom
-- OUT:		R2ML!ObjectVariable
helper context R2ML!ObjectClassificationAtom def: getTerm : R2ML!ObjectVariable = 
	self.term;

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	RDM!Disjunction
-- OUT:		R2ML!ObjectVariable
helper context R2ML!Disjunction def: getTerm : R2ML!ObjectVariable = 
	self.formulas->asSequence()->first().getTerm;

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	RDM!Conjuction
-- OUT:		R2ML!ObjectVariable
helper context R2ML!Conjuction def: getTerm : R2ML!ObjectVariable = 
	self.formulas->asSequence()->first().getTerm;

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	R2ML!UniversallyQuantifiedFormula
-- OUT:		R2ML!ObjectVariable
helper context R2ML!UniversallyQuantifiedFormula def: getTerm : R2ML!ObjectVariable = 
	self.formula.getTerm;

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	R2ML!ExistentiallyQuantifiedFormula
-- OUT:		R2ML!ObjectVariable
helper context R2ML!ExistentiallyQuantifiedFormula def: getTerm : R2ML!ObjectVariable = 
	self.formula.getTerm;

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	R2ML!ReferencePropertyAtom
-- OUT:		R2ML!ObjectVariable
helper context R2ML!ReferencePropertyAtom def: getTerm : R2ML!ObjectVariable = 
	self.subject;

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	R2ML!AtMostQuantifiedFormula
-- OUT:		R2ML!ObjectVariable
helper context R2ML!AtMostQuantifiedFormula def: getTerm : R2ML!ObjectVariable = 
	self.formula.getTerm;

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	R2ML!AtLeastQuantifiedFormula
-- OUT:		R2ML!ObjectVariable
helper context R2ML!AtLeastQuantifiedFormula def: getTerm : R2ML!ObjectVariable = 
	self.formula.getTerm;

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	R2ML!AtLeastAndAtMostQuantifiedFormula
-- OUT:		R2ML!ObjectVariable
helper context R2ML!AtLeastAndAtMostQuantifiedFormula def: getTerm : R2ML!ObjectVariable = 
	self.formula.getTerm;

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	R2ML!EqualityAtom
-- OUT:		R2ML!ObjectVariable
helper context R2ML!EqualityAtom def: getTerm : R2ML!ObjectVariable = 
	self.terms->select(e | e.oclIsTypeOf(R2ML!ObjectVariable))->first();

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	R2ML!DatatypePredicateAtom
-- OUT:		R2ML!DataVariable
helper context R2ML!DatatypePredicateAtom def: getTerm : R2ML!DataVariable = 
	self.dataArguments->select(c | c.oclIsTypeOf(R2ML!DataVariable))->first();

-- HELPER: getTerm
-- Returns object term (variable) from current element.
-- CONTEXT:	R2ML!AttributionAtom
-- OUT:		R2ML!DataVariable
helper context R2ML!AttributionAtom def: getTerm : R2ML!Variable = 
	if self.dataValue.oclIsTypeOf(R2ML!DataVariable) then -- TODO: Check this
		self.dataValue
	else self.subject
	endif;

-- HELPER: getChildren
-- Returns all children for context Implication (for both, antecedent and consequent).
-- CONTEXT:	R2ML!Implication
-- OUT:		Sequence(R2ML!LogicalFormula)
helper context R2ML!Implication def: getChildren : Sequence(R2ML!LogicalFormula) =
	self.getAntecedent->asSequence()->union(self.getConsequent->asSequence());
	
-- HELPER: getAntecedent
-- Returns antecedent children for context Implication.
-- CONTEXT:	R2ML!Implication
-- OUT:		Sequence(R2ML!LogicalFormula)
helper context R2ML!Implication def: getAntecedent : Sequence(R2ML!LogicalFormula) 	=
	 if self.antecedent.oclIsTypeOf(R2ML!Conjuction) then
	 	if self.antecedent.isConjuctionFromIntersection then
			Sequence{self.antecedent}
		else self.antecedent.formulas
		endif
	 else Sequence{self.antecedent}
	 endif;
	
-- HELPER: getConsequent
-- Returns consequent children for context Implication.
-- CONTEXT:	R2ML!Implication
-- OUT:		Sequence(R2ML!LogicalFormula)
helper context R2ML!Implication def: getConsequent : Sequence(R2ML!LogicalFormula) 	=
	if self.consequent.oclIsTypeOf(R2ML!Conjuction) then
	 	if self.consequent.isConjuctionFromIntersection then
			Sequence{self.consequent}
		else self.consequent.formulas
		endif
	 else Sequence{self.consequent}
	 endif; 
	
-- HELPER: getChildrenOfAllTopMostImplications
-- Returns all children elements (both, antecedents and consequents) for all topmost Implications (Rules).
-- OUT:		Sequence(R2ML!LogicalFormula)
helper def: getChildrenOfAllTopMostImplications() : Sequence(R2ML!LogicalFormula) =
	 let allImps : Sequence(R2ML!Implication) = thisModule.getTopMostUniversallyQuantifiedFormulas()->collect(c | c.formula)->flatten() in
  	 	allImps->collect(c | c.getChildren)->flatten();

-- HELPER: isConjuctionFromIntersection
-- Implements algorithm for checking is contextual Conjuction coming from RDM Intersection 
-- to Conjuction transformation. This is important, because Implication (RDM Rule)
-- can containts for antecedent or consequent Conjuction from multiple Atoms or from
-- Intersection.
-- CONTEXT:	R2ML!Conjuction
-- OUT:		Boolean
helper context R2ML!Conjuction def: isConjuctionFromIntersection : Boolean = 
		if R2ML!ExistentiallyQuantifiedFormula.allInstancesFrom('IN')->asSequence()->collect(c | c.formula)->flatten()->excludes(self)
			and	self.formulas->size() = 2
			and self.formulas->asSequence()->first().getTerm = self.formulas->asSequence()->last().getTerm
			and ( self.formulas->select(c | c.oclIsTypeOf(R2ML!Disjunction))->collect(e | e.formulas)->flatten()->forAll(c | c.oclIsTypeOf(R2ML!EqualityAtom))
			and self.formulas->select(c | c.oclIsTypeOf(R2ML!UniversallyQuantifiedFormula))->collect(e | e.formula)->flatten()->forAll(c | c.oclIsTypeOf(R2ML!Implication))
			and self.formulas->select(c | c.oclIsTypeOf(R2ML!ExistentiallyQuantifiedFormula))->collect(e | e.formula)->flatten()->forAll(c | c.oclIsTypeOf(R2ML!Conjuction))
			and self.formulas->select(c | c.oclIsTypeOf(R2ML!AtLeastQuantifiedFormula))->collect(e | e.formula)->flatten()->forAll(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom))
			and self.formulas->select(c | c.oclIsTypeOf(R2ML!AtMostQuantifiedFormula))->collect(e | e.formula)->flatten()->forAll(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom))
			and self.formulas->select(c | c.oclIsTypeOf(R2ML!AtLeastAndAtMostQuantifiedFormula))->collect(e | e.formula)->flatten()->forAll(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom)) 
			and self.formulas->select(c | c.oclIsTypeOf(R2ML!AttributionAtom))->size() = 0
			and self.formulas->select(c | c.oclIsTypeOf(R2ML!DatatypePredicateAtom))->size() = 0 )
			and self.formulas->collect(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom))->flatten()->size() > 0
		then true
		else false
		endif;

-- HELPER: getTopMostUniversallyQuantifiedFormulas
-- Returns all top-most UniversallyQuantifiedFormulas.
-- OUT:		 Sequence(R2ML!UniversallyQuantifiedFormula)
helper def: getTopMostUniversallyQuantifiedFormulas() : Sequence(R2ML!UniversallyQuantifiedFormula) =
	R2ML!AlethicIntegrityRule.allInstancesFrom('IN')->asSequence()->collect(c | c.constraint)->flatten();	
	
-- HELPER: isRefPropAtomForHasValue
-- Implements algorithm for checking is contextual ReferencePropertyAtom candidate
-- for RDM HasValueRestriction.
-- CONTEXT:	R2ML!ReferencePropertyAtom
-- OUT:		Boolean
helper context R2ML!ReferencePropertyAtom def: isRefPropAtomForHasValue : Boolean =
	thisModule.getChildrenOfAllTopMostImplications()->excludes(self) and
	R2ML!UniversallyQuantifiedFormula.allInstancesFrom('IN')->asSequence()->excluding(thisModule.getTopMostUniversallyQuantifiedFormulas())->select(e | e.formula.oclIsTypeOf(R2ML!Implication))->collect(c | c.formula)->flatten()->collect(c | c.antecedent)->flatten()->excludes(self) and
	R2ML!ExistentiallyQuantifiedFormula.allInstancesFrom('IN')->asSequence()->select(e | e.formula.oclIsTypeOf(R2ML!Conjuction))->collect(c | c.formula.formulas->asSequence())->flatten()->excludes(self) and
	R2ML!AtMostQuantifiedFormula.allInstancesFrom('IN')->asSequence()->collect(c | c.formula)->flatten()->excludes(self) and
	R2ML!AtLeastQuantifiedFormula.allInstancesFrom('IN')->asSequence()->collect(c | c.formula)->flatten()->excludes(self) and
	R2ML!AtLeastAndAtMostQuantifiedFormula.allInstancesFrom('IN')->asSequence()->collect(c | c.formula)->flatten()->excludes(self);

----------------------------------------------------------------------------------
-- Helpers for transforming R2ML elements which are transformed from OCL metamodel
----------------------------------------------------------------------------------

-- HELPER:	getDatatypePredicateAtomsWithSubElems
-- Returns all Datatype predicate atoms with their subelems for contextual logical formula
-- CONTEXT:	R2ML!LogicalFormula
-- OUT:		Sequence(OclAny)
helper context R2ML!LogicalFormula def: getDatatypePredicateAtomsWithSubElems() : Sequence(OclAny) =
	if self.oclIsTypeOf(R2ML!Conjuction) then
	    self.formulas->select(c | c.oclIsTypeOf(R2ML!DatatypePredicateAtom))->asSequence()->collect(c | c.getElementWithSubElems())->flatten()->asSequence()
	else if self.oclIsTypeOf(R2ML!DatatypePredicateAtom) then
			self.getElementWithSubElems()
		 else OclUndefined
		 endif
	endif;

-- HELPER:	getReferencePropertyAtomsWithTermsWithSubElems
-- Returns all Reference property atoms with terms for contextual logical formula
-- CONTEXT:	R2ML!LogicalFormula
-- OUT:		Sequence(OclAny)
helper context R2ML!LogicalFormula def: getReferencePropertyAtomsWithTermsWithSubElems() : Sequence(OclAny) =
	if self.oclIsTypeOf(R2ML!Conjuction) then
		Sequence { self.formulas->select(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom))->select(c | not c.subject.oclIsTypeOf(R2ML!ObjectVariable) or not c.object.oclIsTypeOf(R2ML!ObjectVariable))->asSequence()->collect(c | c.getElementWithSubElems())->flatten()->asSequence(),
  				   self.formulas->select(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom))->select(c | c.subject.oclIsTypeOf(R2ML!ObjectVariable) and c.object.oclIsTypeOf(R2ML!ObjectVariable))->flatten()->asSequence() -- get basic ReferencePropertyAtom's
				 }
	else if not self.subject.oclIsTypeOf(R2ML!ObjectVariable) or not self.object.oclIsTypeOf(R2ML!ObjectVariable) then
			self.getElementWithSubElems()->flatten()->asSequence()
		 else self
		 endif
	endif;

-- HELPER:	areAllObjectVariables
-- Returns all object variable in the R2ML ReferencePropertyAtom (for subject and object)
-- CONTEXT:	R2ML!ReferencePropertyAtom
-- OUT:		Boolean
helper context R2ML!ReferencePropertyAtom def: areAllObjectVariables() : Boolean =
	if self.subject.oclIsTypeOf(R2ML!ObjectVariable) then
		if self.object.oclIsTypeOf(R2ML!ObjectVariable) then
			true
		else false
		endif
	else false
	endif;

-- HELPER:	getElementWithSubElems
-- Returns contextual ReferencePropertyAtom with all sub elements
-- CONTEXT:	R2ML!ReferencePropertyAtom
-- OUT:		Sequence(OclAny)
helper context R2ML!ReferencePropertyAtom def: getElementWithSubElems() : Sequence(OclAny) = 
	Sequence{ if not self.subject.oclIsTypeOf(R2ML!ObjectVariable) then
				self.subject.getElementWithSubElems()->flatten()->asSequence()
			  else OclUndefined
			  endif,
			  if not self.object.oclIsTypeOf(R2ML!ObjectVariable) then
				self.object.getElementWithSubElems()->flatten()->asSequence()
			  else OclUndefined
			  endif
	}->flatten()->asSequence()->append(self);
	
-- HELPER:	getElementWithSubElems
-- Returns contextual DatatypePredicateAtom with all sub elements
-- CONTEXT:	R2ML!DatatypePredicateAtom
-- OUT:		Sequence(OclAny)
helper context R2ML!DatatypePredicateAtom def: getElementWithSubElems() : Sequence(OclAny) = 
	self.dataArguments->select(c | not c.oclIsKindOf(R2ML!DataLiteral))->asSequence()->collect(c | c.getElementWithSubElems())->flatten()->asSequence()->append(self);

-- HELPER:	getElementWithSubElems
-- Returns contextual AttributeFunctionTerm with all sub elements
-- CONTEXT:	R2ML!AttributeFunctionTerm
-- OUT:		Sequence(OclAny)
helper context R2ML!AttributeFunctionTerm def: getElementWithSubElems() : Sequence(OclAny) = 
	Sequence { self.contextArgument.getElementWithSubElems() }->flatten()->append(self);
	
-- HELPER:	getElementWithSubElems
-- Returns contextual ReferencePropertyFunctionTerm with all sub elements
-- CONTEXT:	R2ML!ReferencePropertyFunctionTerm
-- OUT:		Sequence(OclAny)
helper context R2ML!ReferencePropertyFunctionTerm def: getElementWithSubElems() : Sequence(OclAny) = 
	Sequence { self.contextArgument.getElementWithSubElems() }->flatten()->append(self);
	
-- HELPER:	getElementWithSubElems
-- Returns contextual DataOperationTerm with all sub elements
-- CONTEXT:	R2ML!DataOperationTerm
-- OUT:		Sequence(OclAny)
helper context R2ML!DataOperationTerm def: getElementWithSubElems() : Sequence(OclAny) = 
	Sequence { self.contextArgument.getElementWithSubElems() }->flatten()->append(self);
	
-- HELPER:	getElementWithSubElems
-- Returns contextual ObjectVariable with all sub elements (itself)
-- CONTEXT:	R2ML!ObjectVariable
-- OUT:		Sequence(OclAny)
helper context R2ML!ObjectVariable def: getElementWithSubElems() : Sequence(OclAny) = 
	Sequence { self };
	
-- HELPER:	getVariableName
-- Returns ReferencePropertyFunctionTerm contextArgument name (i.e. variable) with
-- referencePropertyRef name
-- CONTEXT:	R2ML!ReferencePropertyFunctionTerm
-- OUT:		String
helper context R2ML!ReferencePropertyFunctionTerm def: getVariableName() : String = 
		self.contextArgument.name + self.referencePropertyRef.name.firstCharToUpper();

-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'Implication2Rule'
-- Create RDM Rule element from R2ML Implication element 
rule Implication2Rule {
	from i : R2ML!Implication (
		thisModule.getTopMostUniversallyQuantifiedFormulas()->collect(c | c.formula)->flatten()->includes(i)
		)
	to o : RDM!Rule (
		hasAntecedent <- ant,
		hasConsequent <- con
		),
	ant : RDM!Antecedent (
		containsAtom <- if i.antecedent.oclIsTypeOf(R2ML!Conjuction) then
							if	i.antecedent.isConjuctionFromIntersection
							then
								i.antecedent
							else Sequence { i.antecedent.formulas->select(c | not c.oclIsTypeOf(R2ML!DatatypePredicateAtom) and not c.oclIsTypeOf(R2ML!ReferencePropertyAtom))->asSequence(),
											i.antecedent.getDatatypePredicateAtomsWithSubElems(),
											i.antecedent.getReferencePropertyAtomsWithTermsWithSubElems()
											}
							endif
						else if i.antecedent.oclIsTypeOf(R2ML!DatatypePredicateAtom) then
								i.antecedent.getDatatypePredicateAtomsWithSubElems()
							 else if i.antecedent.oclIsTypeOf(R2ML!ReferencePropertyAtom) then
							 		i.antecedent.getElementWithSubElems()
									   -- Check because of Intersection element with type of term
							 	  else if i.antecedent.oclIsTypeOf(R2ML!Disjunction) then
							 		    if i.antecedent.getTerm.oclIsTypeOf(R2ML!ObjectVariable) then
							 			   if not i.antecedent.getTerm.classRef.oclIsUndefined() then
											 -- Create Intersection with this type
											 thisModule.LogicalFormula2Intersection(i.antecedent)
										   else i.antecedent
										   endif
							 	        else i.antecedent
								        endif
								      else i.antecedent
								      endif
								 endif
							 endif
						endif
		),
	con : RDM!Consequent (
		containsAtom <- if i.consequent.oclIsTypeOf(R2ML!Conjuction) then
								if	i.consequent.isConjuctionFromIntersection
							then
								i.consequent
							else Sequence { i.consequent.formulas->select(c | not c.oclIsTypeOf(R2ML!DatatypePrediacateAtom) and not c.oclIsTypeOf(R2ML!ReferencePropertyAtom))->asSequence(),
											i.consequent.getDatatypePredicateAtomsWithSubElems(),
											i.consequent.getReferencePropertyAtomsWithTermsWithSubElems()
											}
							endif
						else if i.consequent.oclIsTypeOf(R2ML!DatatypePredicateAtom) then
								i.consequent.getDatatypePredicateAtomsWithSubElems()
							 else if i.consequent.oclIsTypeOf(R2ML!ReferencePropertyAtom) then
							 		i.consequent.getElementWithSubElems()
							 		   -- Check because of Intersection element with type of term
							 	  else if i.consequent.oclIsTypeOf(R2ML!Disjunction) then
							 		       if i.consequent.getTerm.oclIsTypeOf(R2ML!ObjectVariable) then
							 			       if not i.consequent.getTerm.classRef.oclIsUndefined() then
											      -- Create Intersection with this type
										      	thisModule.LogicalFormula2Intersection(i.consequent)
										       else i.consequent
										       endif
							 	          else i.consequent
								          endif
								       else i.consequent
								       endif
							     endif
							 endif
						endif
		)
}

-- Lazy rule 'LogicalFormula2Intersection'
-- Creates IntersectionClass RDM element from LogicalFormula R2ML element.
unique lazy rule LogicalFormula2Intersection {
	from i : R2ML!LogicalFormula
	to o :  RDM!Atom (
				name <- 'ClassAtom',
				hasPredicateSymbol <- intCla,
				terms <- thisModule.ObjectVariable2IndividualVariable(i.getTerm)
			),
		intCla : RDM!IntersectionClass (
			intersectionOf <- Sequence { thisModule.Class2Class(i.getTerm.classRef),
										 i
									   }
			)	
}

-- IndividualPropertyAtom

-- Rule 'ReferencePropertyAtom2IndividualPropertyAtom'
-- Creates Atom RDM element (IndividualPropertyAtom) from ReferencePropertyAtom R2ML element.
rule ReferencePropertyAtom2IndividualPropertyAtom {
	from i : R2ML!ReferencePropertyAtom (
		not i.isRefPropAtomForHasValue and i.areAllObjectVariables()
		)
	to o : RDM!Atom (
		name <- 'IndividualPropertyAtom',
		hasPredicateSymbol <- thisModule.ReferenceProperty2ObjectProperty(i.referenceProperty),
		terms <- Sequence { thisModule.ObjectVariable2IndividualVariable(i.object),
							thisModule.ObjectVariable2IndividualVariable(i.subject)}
		)
}

-- Rule 'ReferenceProperty2ObjectProperty'
-- Transformation from R2ML ReferenceProperty element to RDM ObjectProperty element.
unique lazy rule ReferenceProperty2ObjectProperty {
	from i : R2ML!ReferenceProperty
	to o : RDM!ObjectProperty (
			name <- i.name
		)
}

-- Rule 'ReferenceProperty2DatatypeProperty'
-- Transformation from R2ML ReferenceProperty element to RDM DatatypeProperty element.
unique lazy rule ReferenceProperty2DatatypeProperty {
	from i : R2ML!ReferenceProperty
	to o : RDM!DatatypeProperty (
			name <- i.name
		)
}

-- Rule 'ObjectVariable2IndividualVariable'
-- Create RDM IndividualVariable from R2ML ObjectVariable.
unique lazy rule ObjectVariable2IndividualVariable {
	from i : R2ML!ObjectVariable
	to o : RDM!IndividualVariable (
			name <- i.name,
			classRef <- if not i.classRef.oclIsUndefined() then
							thisModule.Class2Class(i.classRef)
						else OclUndefined
						endif
		)		
}

-- Rule 'DataVariable2IndividualVariable'
-- Create RDM IndividualVariable from R2ML DataVariable.
unique lazy rule DataVariable2IndividualVariable {
	from i : R2ML!DataVariable
	to o : RDM!IndividualVariable (
			name <- i.name
		)		
}

-- ClassAtom

-- Rule 'Conjuction2ClassAtom'
-- Create RDM ClassAtom with Intersection predicate symbol from R2ML Conjuction
rule Conjuction2ClassAtom {
	from i : R2ML!Conjuction (
		i.isConjuctionFromIntersection and
		-- Because of defining type with Intersection
			if i.formulas->asSequence()->first().getTerm.oclIsTypeOf(R2ML!ObjectVariable) then
				if not i.formulas->asSequence()->first().getTerm.classRef.oclIsUndefined() then
					false
				else true
				endif
			else true
			endif
 	)
	to o : RDM!Atom (
		name <- 'ClassAtom',
		hasPredicateSymbol <- intCla,
		terms <- thisModule.ObjectVariable2IndividualVariable(i.formulas->asSequence()->first().getTerm)
		),
		intCla : RDM!IntersectionClass (
			intersectionOf <- Sequence { i.formulas->asSequence()->select(c | c.oclIsTypeOf(R2ML!ObjectClassificationAtom))->collect(e | thisModule.Class2Class(e.type)),
								  		 i.formulas->asSequence()->select(c | not c.oclIsTypeOf(R2ML!ObjectClassificationAtom))
									   }
			)	
}

-- Rule 'DisjunctionAtom2Union'
-- Create RDM ClassAtom with UnionClass predicate symbol from R2ML Disjunction,
-- which not have EqualityAtom or DatatypePredicateAtom as its formula, and it is
-- children of top-most Implication.
rule DisjunctionAtom2Union {
	from i : R2ML!Disjunction (
		R2ML!Conjuction.allInstancesFrom('IN')->asSequence()->select(c | c.isConjuctionFromIntersection)->collect(e | e.formulas)->flatten()->excludes(i) and
		R2ML!Disjunction.allInstancesFrom('IN')->asSequence()->select(e | e.formulas->asSequence()->first().oclIsTypeOf(R2ML!EqualityAtom) or e.formulas->asSequence()->first().oclIsTypeOf(R2ML!DatatypePredicateAtom))->excludes(i) and
		
		  ( thisModule.getChildrenOfAllTopMostImplications()->includes(i) and 
			if i.formulas->asSequence()->first().getTerm.oclIsTypeOf(R2ML!ObjectVariable) then
				if not i.formulas->asSequence()->first().getTerm.classRef.oclIsUndefined() then
					false
				else true
				endif
			else true
			endif
		  )
		)
	to o : RDM!Atom (
		name <- 'ClassAtom',
		hasPredicateSymbol <- uniCla,
		terms <- thisModule.ObjectVariable2IndividualVariable(i.formulas->asSequence()->first().getTerm)
		),
		uniCla : RDM!UnionClass (
			unionOf <- Sequence { i.formulas->asSequence()->select(c | c.oclIsTypeOf(R2ML!ObjectClassificationAtom))->collect(e | thisModule.Class2Class(e.type)),
								  i.formulas->asSequence()->select(c | not c.oclIsTypeOf(R2ML!ObjectClassificationAtom))
								}
			)
}

-- Rule 'Disjunction2Union'
-- Create UnionClass predicateR2ML Disjunction,
-- which not have EqualityAtom or DatatypePredicateAtom as its formula, and it is
-- not children of top-most Implication.
rule Disjunction2Union {
	from i : R2ML!Disjunction (
		R2ML!Conjuction.allInstancesFrom('IN')->asSequence()->select(c | c.isConjuctionFromIntersection)->collect(e | e.formulas)->flatten()->excludes(i) and
		R2ML!Disjunction.allInstancesFrom('IN')->asSequence()->select(e | e.formulas->asSequence()->first().oclIsTypeOf(R2ML!EqualityAtom) or e.formulas->asSequence()->first().oclIsTypeOf(R2ML!DatatypePredicateAtom))->excludes(i)
		and
		
		  ( thisModule.getChildrenOfAllTopMostImplications()->excludes(i) or 
			-- Because of defining type with Intersection
			if i.formulas->asSequence()->first().getTerm.oclIsTypeOf(R2ML!ObjectVariable) then
				if not i.formulas->asSequence()->first().getTerm.classRef.oclIsUndefined() then
					true
				else false
				endif
			else true
			endif
		  )
		)
	to uniCla : RDM!UnionClass (
			unionOf <- Sequence { i.formulas->asSequence()->select(c | c.oclIsTypeOf(R2ML!ObjectClassificationAtom))->collect(e | thisModule.Class2Class(e.type)),
								  i.formulas->asSequence()->select(c | not c.oclIsTypeOf(R2ML!ObjectClassificationAtom))
								}
			)
}

-- Rule 'NegationAtom2Complement'
-- Create RDM ClassAtom with ComplementClass predicate symbol from R2ML NegationAsFailure.
rule NegationAtom2Complement {
	from i : R2ML!StrongNegation (
			i.oclIsTypeOf(R2ML!StrongNegation) and thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o : RDM!Atom (
		name <- 'ClassAtom',
		hasPredicateSymbol <- comCla,
		terms <- thisModule.ObjectVariable2IndividualVariable(i.formula.getTerm)
		),
		comCla : RDM!ComplementClass (
			complementOf <- if i.formula.oclIsTypeOf(R2ML!ObjectClassificationAtom) then
								thisModule.Class2Class(i.formula.type)
							else i.formula
							endif
			)
}

-- Rule 'Negation2Complement'
-- Create RDM ClassAtom with ComplementClass predicate symbol from R2ML NegationAsFailure.
rule Negation2Complement {
	from i : R2ML!StrongNegation (
			i.oclIsTypeOf(R2ML!StrongNegation) and thisModule.getChildrenOfAllTopMostImplications()->excludes(i)
		)
	to comCla : RDM!ComplementClass (
			complementOf <- if i.formula.oclIsTypeOf(R2ML!ObjectClassificationAtom) then
								thisModule.Class2Class(i.formula.type)
							else i.formula
							endif
			)
}

-- Rule 'Disjunction2EnumeratedClass'
-- Create EnumeratedClass from R2ML Disjunction.
rule DisjunctionFromIntersection2EnumeratedClass {
	from i : R2ML!Disjunction (
			R2ML!Conjuction.allInstancesFrom('IN')->asSequence()->select(c | c.isConjuctionFromIntersection)->collect(e | e.formulas)->flatten()->includes(i)
			and		
			i.formulas->select(e | e.oclIsTypeOf(R2ML!EqualityAtom))->size() > 0
		)
	to enumClass : RDM!EnumeratedClass (
			oneOf <- i.formulas->asSequence()->collect(c | c.terms)->flatten()->select(c | c.oclIsTypeOf(R2ML!ObjectName))->asSequence()
			)
}

-- Rule 'DisjunctionFromAtom2EnumeratedClass'
-- Create RDM ClassAtom with EnumeratedClass predicate symbol from R2ML Disjunction.
rule DisjunctionFromAtom2EnumeratedClass {
	from i : R2ML!Disjunction (
			R2ML!Conjuction.allInstancesFrom('IN')->asSequence()->select(c | c.isConjuctionFromIntersection)->collect(e | e.formulas)->flatten()->excludes(i)
			and		
			i.formulas->select(e | e.oclIsTypeOf(R2ML!EqualityAtom))->size() > 0
		)
	to o : RDM!Atom	(
			name <- 'ClassAtom',
			hasPredicateSymbol <- enumClass,
			terms <- thisModule.ObjectVariable2IndividualVariable(i.formulas->asSequence()->first().getTerm)
		),
		enumClass : RDM!EnumeratedClass (
			oneOf <- i.formulas->collect(e | e.terms)->flatten()->select(c | c.oclIsTypeOf(R2ML!ObjectName))
			)
}

-- Rule 'ObjectName2Individual'
-- Create RDM Individual from R2ML ObjectName.
rule ObjectName2Individual {
	from i : R2ML!ObjectName (
		R2ML!EqualityAtom.allInstancesFrom('IN')->asSequence()->collect(c | c.terms)->flatten()->select(e | e.oclIsTypeOf(R2ML!ObjectName))->includes(i)
		)
	to o : RDM!Individual (
		name <- i.name
		)
}

-- Rule 'ObjectClassificationAtom2ClassAtom'
-- Creates ClassAtom RDM element from R2ML ObjectClassificationAtom element.
rule ObjectClassificationAtom2ClassAtom {
	from i : R2ML!ObjectClassificationAtom (		
		thisModule.getChildrenOfAllTopMostImplications()->includes(i) and
		R2ML!Conjuction.allInstancesFrom('IN')->asSequence()->select(e | e.isConjuctionFromIntersection)->collect(e | e.formulas)->flatten()->excludes(i)
		and i.isNegated = false
		)
	to o : RDM!Atom (
		name <- 'ClassAtom',
		hasPredicateSymbol <- thisModule.Class2Class(i.type),
		terms <- thisModule.ObjectVariable2IndividualVariable(i.term)
	)
}

-- Rule 'ObjectClassificationAtom'
-- Creates ClassAtom RDM element from R2ML ObjectClassificationAtom element (that is negated).
rule ObjectClassificationAtomNegated2ComplementClassAtom {
	from i : R2ML!ObjectClassificationAtom (		
		thisModule.getChildrenOfAllTopMostImplications()->includes(i) and
		R2ML!Conjuction.allInstancesFrom('IN')->asSequence()->select(e | e.isConjuctionFromIntersection)->collect(e | e.formulas)->flatten()->excludes(i)
		and i.isNegated = true
		)
	to o : RDM!Atom (
		name <- 'ClassAtom',
		hasPredicateSymbol <- cla,
		terms <- thisModule.ObjectVariable2IndividualVariable(i.term)
	),
	cla : RDM!Class (
			subClassOf <- Sequence { cs }
		),
	cs : RDM!ComplementClass (
			complementOf <- thisModule.Class2Class(i.type)
	)
}


-- Rule 'Class2Class'
-- Create RDM Class from R2ML Class element.
unique lazy rule Class2Class {
	from i : R2ML!Class
	to cla : RDM!Class (
				name <- i.name
			)
}

-- Rule 'ExistentiallyQuantifiedFormulaClass2SomeValuesFromRestriction'
-- Creates SomeValuesFromRestriction RDM element from R2ML ExistentiallyQuantifiedFormula element,
-- which have ReferencePropertyAtoms as formulas.
rule ExistentiallyQuantifiedFormulaClass2SomeValuesFromRestriction {
	from i : R2ML!ExistentiallyQuantifiedFormula (
		thisModule.getChildrenOfAllTopMostImplications()->excludes(i) and
		i.formula.formulas->select(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom))->size() > 0
		)
	to o : RDM!SomeValuesFromRestriction (
		someValuesFromClass <- Sequence { i.formula.formulas->select(c | c.oclIsTypeOf(R2ML!ObjectClassificationAtom))->collect(c | thisModule.Class2Class(c.type))->first(),
										  i.formula.formulas->select(c | not c.oclIsTypeOf(R2ML!ReferencePropertyAtom) and not c.oclIsTypeOf(R2ML!ObjectClassificationAtom))->first()
										}->select(c | not c.oclIsUndefined())->asSequence()->first(),
		onProperty <- thisModule.ReferenceProperty2ObjectProperty(i.formula.formulas->select(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom))->first().referenceProperty)
		)
}

-- Rule 'ExistentiallyQuantifiedFormulaClass2ClassAtomSomeValuesFromRestriction'
-- Creates RDM Atom with SomeValuesFromRestriction as predicate symbol from 
-- R2ML ExistentiallyQuantifiedFormula element, which have ReferencePropertyAtoms 
-- as formulas.
rule ExistentiallyQuantifiedFormulaClass2ClassAtomSomeValuesFromRestriction {
	from i : R2ML!ExistentiallyQuantifiedFormula (
		thisModule.getChildrenOfAllTopMostImplications()->includes(i) and
		i.formula.formulas->select(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom))->size() > 0
		)
	to o : RDM!Atom (
			name <- 'ClassAtom',
			hasPredicateSymbol <- svf,
			terms <- thisModule.ObjectVariable2IndividualVariable(i.formula.formulas->select(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom))->first().getTerm)
		),
	svf : RDM!SomeValuesFromRestriction (
		someValuesFromClass <- Sequence { i.formula.formulas->select(c | c.oclIsTypeOf(R2ML!ObjectClassificationAtom))->collect(c | thisModule.Class2Class(c.type))->first(),
										  i.formula.formulas->select(c | not c.oclIsTypeOf(R2ML!ReferencePropertyAtom) and not c.oclIsTypeOf(R2ML!ObjectClassificationAtom))->first()
										}->select(c | not c.oclIsUndefined())->asSequence()->first(),
		onProperty <- thisModule.ReferenceProperty2ObjectProperty(i.formula.formulas->select(c | c.oclIsTypeOf(R2ML!ReferencePropertyAtom))->first().referenceProperty)
		)
}

-- Rule 'UniversallyQuantifiedFormulaClass2AllValuesFromRestriction'
-- Creates AllValuesFromRestriction RDM element from R2ML UniversallyQuantifiedFormula element,
-- which have Implication as its formula and ReferencePropertyAtom as antecedent.
rule UniversallyQuantifiedFormulaClass2AllValuesFromRestriction {
	from i : R2ML!UniversallyQuantifiedFormula (
		thisModule.getTopMostUniversallyQuantifiedFormulas()->excludes(i) and
		if i.formula.oclIsTypeOf(R2ML!Implication) then
			if i.formula.antecedent.oclIsTypeOf(R2ML!ReferencePropertyAtom)
			then true
			else false
			endif
		else false
		endif
		)
	to o : RDM!AllValuesFromRestriction (
		allValuesFromClass <- if i.formula.consequent.oclIsTypeOf(R2ML!ObjectClassificationAtom) then
									thisModule.Class2Class(i.formula.consequent)
							  else i.formula.consequent
							  endif,
		onProperty <- thisModule.ReferenceProperty2ObjectProperty(i.formula.antecedent.referenceProperty)
		)
}

-- Rule 'ReferencePropertyAtomClass2HasValue'
-- Creates HasValueRestriction RDM element from R2ML ReferencePropertyAtom, if
-- ReferencePropertyAtom is for this type of Restriction (uses helper isRefPropAtomForHasValue for checking).
rule ReferencePropertyAtomClass2HasValue {
	from i : R2ML!ReferencePropertyAtom (
			i.isRefPropAtomForHasValue and thisModule.getChildrenOfAllTopMostImplications()->excludes(i)
		)
	to o : RDM!HasValueRestriction (
		hasValue <- thisModule.ObjectVariable2Individual(i.object),
		onProperty <- thisModule.ReferenceProperty2ObjectProperty(i.referenceProperty)
		)
}

-- Rule 'ReferencePropertyAtomClass2ClassAtomHasValue'
-- Creates RDM Atom with HasValueRestriction as predicate symbol from 
-- R2ML ReferencePropertyAtom, if ReferencePropertyAtom is for this 
-- type of Restriction (uses helper isRefPropAtomForHasValue for checking).
rule ReferencePropertyAtomClass2ClassAtomHasValue {
	from i : R2ML!ReferencePropertyAtom (
			i.isRefPropAtomForHasValue and thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o : RDM!Atom (
		name <- 'ClassAtom',
		hasPredicateSymbol <- hvr,
		terms <- thisModule.ObjectVariable2IndividualVariable(i.subject)
		),
	hvr : RDM!HasValueRestriction (
		hasValue <- thisModule.ObjectVariable2Individual(i.object),
		onProperty <- thisModule.ReferenceProperty2ObjectProperty(i.referenceProperty)
		)
}

-- Rule 'ObjectVariable2Individual'
-- Creates Individual RDM element from R2ML ObjectVariable (lazy rule).
unique lazy rule ObjectVariable2Individual {
	from i : R2ML!ObjectVariable
	to o : RDM!Individual (
			name <- i.name
		)		
}

-- Rule 'AtLeastQuantifiedFormula2MinCardinalityRestriction'
-- Creates MinCardinalityRestriction RDM element from R2ML AtLeastQuantifiedFormula.
-- Works for DataRangeAtom and ClassAtom cardinality restrictions.
rule AtLeastQuantifiedFormula2MinCardinalityRestriction {
	from i : R2ML!AtLeastQuantifiedFormula (
			i.oclIsTypeOf(R2ML!AtLeastQuantifiedFormula) and thisModule.getChildrenOfAllTopMostImplications()->excludes(i)
		)
	to o : RDM!MinCardinalityRestriction (
		minCardinality <- card,
		onProperty <- if i.formula.oclIsTypeOf(R2ML!ReferencePropertyAtom) then
						thisModule.ReferenceProperty2ObjectProperty(i.formula.referenceProperty)
					  else thisModule.Attribute2DatatypeProperty(i.formula.attribute)
					  endif
		),
	   card : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.minCardinality.toString()
			)
}

-- Rule 'AtLeastQuantifiedFormulaInClassAtom2MinCardinalityRestriction'
-- Creates RDM Atom with MinCardinalityRestriction as predicate symbol from 
-- R2ML AtLeastQuantifiedFormula. Works for ClassAtom cardinality restrictions.
rule AtLeastQuantifiedFormulaInClassAtom2MinCardinalityRestriction {
	from i : R2ML!AtLeastQuantifiedFormula (
			i.oclIsTypeOf(R2ML!AtLeastQuantifiedFormula) and i.formula.oclIsTypeOf(R2ML!ReferencePropertyAtom)
			and thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o : RDM!Atom (
			name <- 'ClassAtom',
			hasPredicateSymbol <- mcr,
			terms <- thisModule.ObjectVariable2IndividualVariable(i.formula.subject)
		),
	  mcr : RDM!MinCardinalityRestriction (
			minCardinality <- card,
			onProperty <- thisModule.ReferenceProperty2ObjectProperty(i.formula.referenceProperty)
		),
		card : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.minCardinality.toString()
		)
}

-- Rule 'AtLeastQuantifiedFormulaInDataRangeAtom2MinCardinalityRestriction'
-- Creates RDM Atom with MinCardinalityRestriction as predicate symbol from 
-- R2ML AtLeastQuantifiedFormula. Works for DataRangeAtom cardinality restrictions.
rule AtLeastQuantifiedFormulaInDataRangeAtom2MinCardinalityRestriction {
	from i : R2ML!AtLeastQuantifiedFormula (
			i.oclIsTypeOf(R2ML!AtLeastQuantifiedFormula) and i.formula.oclIsTypeOf(R2ML!AttributionAtom)
			and thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o : RDM!Atom (
			name <- 'DataRangeAtom',
			hasPredicateSymbol <- mcr,
			terms <- thisModule.DataVariable2IndividualVariable(i.formula.dataValue)
		),
	  mcr : RDM!MinCardinalityRestriction (
			minCardinality <- card,
			onProperty <-thisModule.Attribute2DatatypeProperty(i.formula.attribute)
		),
		card : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.minCardinality.toString()
		)
}

-- Rule 'AtMostQuantifiedFormulaClass2MaxCardinalityRestriction'
-- Creates MaxCardinalityRestriction RDM element from R2ML AtMostQuantifiedFormula.
-- Works for DataRangeAtom and ClassAtom cardinality restrictions.
rule AtMostQuantifiedFormulaClass2MaxCardinalityRestriction {
	from i : R2ML!AtMostQuantifiedFormula (
			i.oclIsTypeOf(R2ML!AtMostQuantifiedFormula) and thisModule.getChildrenOfAllTopMostImplications()->excludes(i)
		)
	to o : RDM!MaxCardinalityRestriction (
		maxCardinality <- card,
		onProperty <- if i.formula.oclIsTypeOf(R2ML!ReferencePropertyAtom) then
						thisModule.ReferenceProperty2ObjectProperty(i.formula.referenceProperty)
					  else thisModule.Attribute2DatatypeProperty(i.formula.attribute)
					  endif
		),
		card : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.maxCardinality.toString()
			)
}

-- Rule 'AtMostQuantifiedFormulaInClassAtom2MaxCardinalityRestriction'
-- Creates RDM Atom with MaxCardinalityRestriction as predicate symbol from 
-- R2ML AtMostQuantifiedFormula. Works for ClassAtom cardinality restrictions.
rule AtMostQuantifiedFormulaInClassAtom2MaxCardinalityRestriction {
	from i : R2ML!AtMostQuantifiedFormula (
			i.oclIsTypeOf(R2ML!AtMostQuantifiedFormula) and i.formula.oclIsTypeOf(R2ML!ReferencePropertyAtom)
			and thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o : RDM!Atom (
			name <- 'ClassAtom',
			hasPredicateSymbol <- mcr,
			terms <- thisModule.ObjectVariable2IndividualVariable(i.formula.subject)
		),
	  mcr : RDM!MaxCardinalityRestriction (
			maxCardinality <- card,
			onProperty <- thisModule.ReferenceProperty2ObjectProperty(i.formula.referenceProperty)
		),
		card : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.maxCardinality.toString()
		)
}

-- Rule 'AtMostQuantifiedFormulaInDataRangeAtom2MaxCardinalityRestriction'
-- Creates RDM Atom with MaxCardinalityRestriction as predicate symbol from 
-- R2ML AtMostQuantifiedFormula. Works for DataRangeAtom cardinality restrictions.
rule AtMostQuantifiedFormulaInDataRangeAtom2MaxCardinalityRestriction {
	from i : R2ML!AtMostQuantifiedFormula (
			i.oclIsTypeOf(R2ML!AtMostQuantifiedFormula) and i.formula.oclIsTypeOf(R2ML!AttributionAtom)
			and thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o : RDM!Atom (
			name <- 'DataRangeAtom',
			hasPredicateSymbol <- mcr,
			terms <- thisModule.DataVariable2IndividualVariable(i.formula.dataValue)
		),
	  mcr : RDM!MaxCardinalityRestriction (
			maxCardinality <- card,
			onProperty <- thisModule.Attribute2DatatypeProperty(i.formula.attribute)
		),
		card : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.maxCardinality.toString()
		)
}

-- Rule 'AtLeastAndAtMostQuantifiedFormulaClass2CardinalityRestriction'
-- Creates CardinalityRestriction RDM element from R2ML AtLeastAndAtMostQuantifiedFormula.
-- Works for DataRangeAtom and ClassAtom cardinality restrictions.
rule AtLeastAndAtMostQuantifiedFormulaClass2CardinalityRestriction {
	from i : R2ML!AtLeastAndAtMostQuantifiedFormula (
		i.oclIsTypeOf(R2ML!AtLeastAndAtMostQuantifiedFormula) and
		i.maxCardinality = i.minCardinality and
		thisModule.getChildrenOfAllTopMostImplications()->excludes(i)
		)
	to o : RDM!CardinalityRestriction (
		cardinality <- card,
		onProperty <- if i.formula.oclIsTypeOf(R2ML!ReferencePropertyAtom) then
						thisModule.ReferenceProperty2ObjectProperty(i.formula.referenceProperty)
					  else thisModule.Attribute2DatatypeProperty(i.formula.attribute)
					  endif
		),
		card : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.maxCardinality.toString()
			)
}

-- Rule 'AtLeastAndAtMostQuantifiedFormulaInClassAtom2CardinalityRestriction'
-- Creates RDM Atom with CardinalityRestriction as predicate symbol from 
-- R2ML AtLeastAndAtMostQuantifiedFormula. Works for ClassAtom cardinality restrictions.
rule AtLeastAndAtMostQuantifiedFormulaInClassAtom2CardinalityRestriction {
	from i : R2ML!AtLeastAndAtMostQuantifiedFormula (
			i.oclIsTypeOf(R2ML!AtLeastAndAtMostQuantifiedFormula) and i.formula.oclIsTypeOf(R2ML!ReferencePropertyAtom) and
			i.maxCardinality = i.minCardinality and
			thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o : RDM!Atom (
			name <- 'ClassAtom',
			hasPredicateSymbol <- mcr,
			terms <- thisModule.ObjectVariable2IndividualVariable(i.formula.subject)
		),
	  mcr : RDM!CardinalityRestriction (
			cardinality <- card,
			onProperty <- thisModule.ReferenceProperty2ObjectProperty(i.formula.referenceProperty)
		),
		card : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.maxCardinality.toString()
		)
}

-- Rule 'AtLeastAndAtMostQuantifiedFormulaInDataRangeAtom2CardinalityRestriction'
-- Creates RDM Atom with CardinalityRestriction as predicate symbol from 
-- R2ML AtLeastAndAtMostQuantifiedFormula. Works for DataRangeAtom cardinality restrictions.
rule AtLeastAndAtMostQuantifiedFormulaInDataRangeAtom2CardinalityRestriction {
	from i : R2ML!AtLeastAndAtMostQuantifiedFormula (
			i.oclIsTypeOf(R2ML!AtLeastAndAtMostQuantifiedFormula) and i.formula.oclIsTypeOf(R2ML!AttributionAtom) and
			i.maxCardinality = i.minCardinality and
			thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o : RDM!Atom (
			name <- 'DataRangeAtom',
			hasPredicateSymbol <- mcr,
			terms <- thisModule.DataVariable2IndividualVariable(i.formula.dataValue)
		),
	  mcr : RDM!CardinalityRestriction (
			cardinality <- card,
			onProperty <- thisModule.Attribute2DatatypeProperty(i.formula.attribute)
		),
		card : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.maxCardinality.toString()
		)
}

-- Rule 'AtLeastAndAtMostQuantifiedFormulaClass2MinMaxCardinalityRestriction'
-- Creates MinCardinalityRestriction and MaxCardinalityRestriction RDM elements
-- from R2ML AtLeastAndAtMostQuantifiedFormula, which have different max and
-- min cardinality.
-- Works for DataRangeAtom and ClassAtom cardinality restrictions.
rule AtLeastAndAtMostQuantifiedFormulaClass2MinMaxCardinalityRestriction {
	from i : R2ML!AtLeastAndAtMostQuantifiedFormula (
		i.oclIsTypeOf(R2ML!AtLeastAndAtMostQuantifiedFormula) and
		i.maxCardinality <> i.minCardinality and
		thisModule.getChildrenOfAllTopMostImplications()->excludes(i)
		)
	to o : RDM!MinCardinalityRestriction (
		minCardinality <- cardMin,
		onProperty <- if i.formula.oclIsTypeOf(R2ML!ReferencePropertyAtom) then
						thisModule.ReferenceProperty2ObjectProperty(i.formula.referenceProperty)
					  else thisModule.Attribute2DatatypeProperty(i.formula.attribute)
					  endif
		),
		cardMin : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.minCardinality.toString()
		),
		u : RDM!MaxCardinalityRestriction (
			maxCardinality <- cardMax,
			onProperty <- if i.formula.oclIsTypeOf(R2ML!ReferencePropertyAtom) then
							thisModule.ReferenceProperty2ObjectProperty(i.formula.referenceProperty)
					  	  else thisModule.Attribute2DatatypeProperty(i.formula.attribute)
					      endif
		),
		cardMax : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.maxCardinality.toString()
		)
}

-- Rule 'AtLeastAndAtMostQuantifiedFormulaClassAtom2MinMaxCardinalityRestriction'
-- Creates RDM Atom with MinCardinalityRestriction as predicate symbol and 
-- MaxCardinalityRestriction RDM elementfrom R2ML AtLeastAndAtMostQuantifiedFormula, 
-- which have different max and min cardinality.
-- Works for ClassAtom cardinality restrictions.
rule AtLeastAndAtMostQuantifiedFormulaClassAtom2MinMaxCardinalityRestriction {
	from i : R2ML!AtLeastAndAtMostQuantifiedFormula (
		i.oclIsTypeOf(R2ML!AtLeastAndAtMostQuantifiedFormula) and
		i.formula.oclIsTypeOf(R2ML!ReferencePropertyAtom) and
		i.maxCardinality <> i.minCardinality and
		thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o : RDM!Atom (
			name <- 'ClassAtom',
			hasPredicateSymbol <- mcr,
			terms <- thisModule.ObjectVariable2IndividualVariable(i.formula.subject)
		),
	
	  mcr : RDM!MinCardinalityRestriction (
		minCardinality <- cardMin,
		onProperty <- thisModule.ReferenceProperty2ObjectProperty(i.formula.referenceProperty)
		),
		cardMin : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.minCardinality.toString()
		),
		u : RDM!MaxCardinalityRestriction (
			maxCardinality <- cardMax,
			onProperty <- thisModule.ReferenceProperty2ObjectProperty(i.formula.referenceProperty)
		),
		cardMax : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.maxCardinality.toString()
		)
}

-- Rule 'AtLeastAndAtMostQuantifiedFormulaDataRangeAtom2MinMaxCardinalityRestriction'
-- Creates RDM Atom with MinCardinalityRestriction as predicate symbol and 
-- MaxCardinalityRestriction RDM elementfrom R2ML AtLeastAndAtMostQuantifiedFormula, 
-- which have different max and min cardinality.
-- Works for DataRangeAtom cardinality restrictions.
rule AtLeastAndAtMostQuantifiedFormulaDataRangeAtom2MinMaxCardinalityRestriction {
	from i : R2ML!AtLeastAndAtMostQuantifiedFormula (
		i.oclIsTypeOf(R2ML!AtLeastAndAtMostQuantifiedFormula) and
		i.formula.oclIsTypeOf(R2ML!AttributionAtom) and
		i.maxCardinality <> i.minCardinality and
		thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o : RDM!Atom (
			name <- 'DataRangeAtom',
			hasPredicateSymbol <- mcr,
			terms <- thisModule.DataVariable2IndividualVariable(i.formula.dataValue)
		),
	  mcr : RDM!MinCardinalityRestriction (
		minCardinality <- cardMin,
		onProperty <- thisModule.Attribute2DatatypeProperty(i.formula.attribute)
		),
		cardMin : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.minCardinality.toString()
		),
		u : RDM!MaxCardinalityRestriction (
			maxCardinality <- cardMax,
			onProperty <- thisModule.Attribute2DatatypeProperty(i.formula.attribute)
		),
		cardMax : RDM!TypedLiteral (
			theType <- 'int',
			lexicalForm <- i.maxCardinality.toString()
		)
}

-- DataRange Atom

-- Rule 'DataClassificationAtom2DataRangeAtomOneOf'
-- Create RDM Atom from R2ML DataClassificationAtom element, which is
-- children of top most Implication.
rule DataClassificationAtom2DataRangeAtomOneOf {
	from i : R2ML!DataClassificationAtom (
		thisModule.getChildrenOfAllTopMostImplications()->includes(i)
	)
	to o : RDM!Atom (
		name <- 'DataRangeAtom',
		hasPredicateSymbol <- dtr,
		terms <- thisModule.DataVariable2IndividualVariable(i.term)
		),
		dtr : RDM!DataRange(
			datatype <- i.type
			)
}

-- Rule 'DataClassificationAtom2DataRange'
-- Create RDM DataRange from R2ML DataClassificationAtom element, which is not
-- children of top most Implication.
rule DataClassificationAtom2DataRange {
	from i : R2ML!DataClassificationAtom (
		thisModule.getChildrenOfAllTopMostImplications()->excludes(i)
	)
	to dtr : RDM!DataRange(
		datatype <- i.type
		)
}

-- Rule 'Disjunction2DataRangeAtom'
-- Create RDM Atom from R2ML Disjunction element, which is
-- children of top most Implication and have DatatypePredicateAtom as its formula.
rule Disjunction2DataRangeAtom {
	from i : R2ML!Disjunction (
		thisModule.getChildrenOfAllTopMostImplications()->includes(i) and
		i.formulas->asSequence()->first().oclIsTypeOf(R2ML!DatatypePredicateAtom)
		)
	to o : RDM!Atom (
		name <- 'DataRangeAtom',
		hasPredicateSymbol <- dtr,
		terms <- Sequence{thisModule.DataVariable2IndividualVariable(i.formulas->asSequence()->first().getTerm)}
		),
		dtr : RDM!DataRange(
			oneOf <- i.formulas
			)
}

-- Rule 'Disjunction2DataRange'
-- Create RDM DataRange from R2ML Disjunction element, which is not
-- children of top most Implication and have DatatypePredicateAtom as its formula.
rule Disjunction2DataRange {
	from i : R2ML!Disjunction (
		thisModule.getChildrenOfAllTopMostImplications()->excludes(i) and
		i.formulas->asSequence()->first().oclIsTypeOf(R2ML!DatatypePredicateAtom)
		)
	to o : RDM!DataRange (
		oneOf <- i.formulas
		)
}

-- Rule 'Datatype2PrimitiveType'
-- Create RDM PrimitiveType from R2ML Datatype element.
rule Datatype2PrimitiveType {
	from i : R2ML!Datatype (
		i.oclIsTypeOf(R2ML!Datatype)
		)
	to o : RDM!PrimitiveType (
		name <- i.name
		)
}

-- Rule 'PlainLiteral2PlainLiteral'
-- Create RDM PlainLiteral from R2ML PlainLiteral element, if it is not 
-- value of top most AttributionAtom and not dataArgument of DatatypePredicateAtom.
rule PlainLiteral2PlainLiteral {
	from i : R2ML!PlainLiteral (
		i.oclIsTypeOf(R2ML!PlainLiteral) and 
		thisModule.getChildrenOfAllTopMostImplications()->select(c | c.oclIsTypeOf(R2ML!AttributionAtom))->collect(c | c.value)->flatten()->excludes(i) and
		R2ML!DatatypePredicateAtom.allInstancesFrom('IN')->asSequence()->collect(c | c.dataArguments)->flatten()->excludes(i)
		)
	to o : RDM!PlainLiteral (
	    language <- i.languageTag,
		lexicalForm <- i.lexicalValue
		)
}

-- Rule 'TypedLiteral2TypedLiteral'
-- Create RDM TypedLiteral from R2ML TypedLiteral element.
rule TypedLiteral2TypedLiteral {
	from i : R2ML!TypedLiteral (
		i.oclIsTypeOf(R2ML!TypedLiteral) 
		and R2ML!DatatypePredicateAtom.allInstancesFrom('IN')->asSequence()->collect(c | c.dataArguments )->flatten()->excludes(i)
		)
	to o : RDM!TypedLiteral (
			theType <- i.type.name,
			lexicalForm <- i.lexicalValue
		)
}

-- Rule 'DatatypePredicateAtom2PlainLiteral'
-- Create RDM PlainLiteral from R2ML DatatypePredicateAtom element, 
-- if this Atom have as dataArgument PlainLiteral and it is not formula
-- of some Disjunction.
rule DatatypePredicateAtom2PlainLiteral {
	from i : R2ML!DatatypePredicateAtom (
		if i.dataArguments->select(c | c.oclIsTypeOf(R2ML!PlainLiteral))->size() > 0 and
			R2ML!Disjunction.allInstancesFrom('IN')->asSequence()->collect(e | e.formulas)->flatten()->includes(i) and
			i.dataArguments->select(c | c.oclIsTypeOf(R2ML!AttributeFunctionTerm))->size() = 0
		then true
		else false
		endif
		)
	to o : RDM!PlainLiteral (
		language <- i.dataArguments->select(c | c.oclIsKindOf(R2ML!DataLiteral))->asSequence()->first().languageTag,
		lexicalForm <- i.dataArguments->select(c | c.oclIsKindOf(R2ML!DataLiteral))->asSequence()->first().lexicalValue
		)
}

-- Rule 'DatatypePredicateAtom2TypedLiteral'
-- Create RDM TypedLiteral from R2ML DatatypePredicateAtom element, 
-- if this Atom have as dataArgument TypedLiteral and it is not formula
-- of some Disjunction.
rule DatatypePredicateAtom2TypedLiteral {
	from i : R2ML!DatatypePredicateAtom (
		if i.dataArguments->select(c | c.oclIsTypeOf(R2ML!TypedLiteral))->size() > 0 and
			R2ML!Disjunction.allInstancesFrom('IN')->asSequence()->collect(e | e.formulas)->flatten()->includes(i) and
			i.dataArguments->select(c | c.oclIsTypeOf(R2ML!AttributeFunctionTerm))->size() = 0
		then true
		else false
		endif
		)
	to o : RDM!TypedLiteral (
		theType <- i.dataArguments->select(c | c.oclIsTypeOf(R2ML!TypedLiteral))->asSequence()->first().type.name,
		lexicalForm <- i.dataArguments->select(c | c.oclIsTypeOf(R2ML!TypedLiteral))->asSequence()->first().lexicalValue
		)
}

-- Rule 'UniversallyQuantifiedFormulaData2AllValuesFromRestriction'
-- Creates AllValuesFromRestriction RDM element from R2ML UniversallyQuantifiedFormula element,
-- which have Implication as its formula and AttributionAtom as antecedent.
rule UniversallyQuantifiedFormulaData2AllValuesFromRestriction {
	from i : R2ML!UniversallyQuantifiedFormula (
		thisModule.getTopMostUniversallyQuantifiedFormulas()->excludes(i) and
		thisModule.getChildrenOfAllTopMostImplications()->excludes(i) and
		if i.formula.oclIsTypeOf(R2ML!Implication) then
			if i.formula.antecedent.oclIsTypeOf(R2ML!AttributionAtom) then
			true
			else false
			endif
		else false
		endif
		)
	to o : RDM!AllValuesFromRestriction (
		allValuesFromRange <- i.formula.consequent,
		onProperty <- thisModule.Attribute2DatatypeProperty(i.formula.antecedent.attribute)
		)
}

-- Rule 'UniversallyQuantifiedFormulaData2AllValuesFromRestriction'
-- Creates RDM Atom with AllValuesFromRestriction as predicate symbol from 
-- R2ML UniversallyQuantifiedFormula element, which have Implication as its 
-- formula and AttributionAtom as antecedent.
rule UniversallyQuantifiedFormulaData2DataRangeAtomAllValuesFromRestriction {
	from i : R2ML!UniversallyQuantifiedFormula (
		thisModule.getTopMostUniversallyQuantifiedFormulas()->excludes(i) and
		thisModule.getChildrenOfAllTopMostImplications()->includes(i) and
		if i.formula.oclIsTypeOf(R2ML!Implication) then
			if i.formula.antecedent.oclIsTypeOf(R2ML!AttributionAtom) then
			true
			else false
			endif
		else false
		endif
		)
	to dra : RDM!Atom (
		name <- 'DataRangeAtom',
		hasPredicateSymbol <- alr,
		terms <- thisModule.DataVariable2IndividualVariable(i.formula.antecedent.getTerm)
		),
	alr : RDM!AllValuesFromRestriction (
		allValuesFromRange <- i.formula.consequent,
		onProperty <- thisModule.Attribute2DatatypeProperty(i.formula.antecedent.attribute)
		)
}

-- Rule 'ExistentiallyQuantifiedFormulaData2SomeValuesFromRestriction'
-- Creates SomeValuesFromRestriction RDM element from R2ML ExistentiallyQuantifiedFormula element,
-- which have AttributionAtom as formulas.
rule ExistentiallyQuantifiedFormulaData2SomeValuesFromRestriction {
	from i : R2ML!ExistentiallyQuantifiedFormula (
		thisModule.getChildrenOfAllTopMostImplications()->excludes(i) and
		if i.formula.oclIsTypeOf(R2ML!Conjuction) then
			if i.formula.formulas->select(e | e.oclIsTypeOf(R2ML!AttributionAtom))->size() > 0 then
			true
			else false
			endif
		else false
		endif
		)
	to o : RDM!SomeValuesFromRestriction (
		someValuesFromRange <- i.formula.formulas->select(c | not c.oclIsTypeOf(R2ML!AttributionAtom))->first(),
		onProperty <- thisModule.Attribute2DatatypeProperty(i.formula.formulas->select(c | c.oclIsTypeOf(R2ML!AttributionAtom))->first().attribute)
		)
}

-- Rule 'ExistentiallyQuantifiedFormulaData2DataRangeAtomSomeValuesFromRestriction'
-- Creates RDM Atom with SomeValuesFromRestriction as predicate symbol from 
-- R2ML ExistentiallyQuantifiedFormula element, which have AttributionAtom as formulas.
rule ExistentiallyQuantifiedFormulaData2DataRangeAtomSomeValuesFromRestriction {
	from i : R2ML!ExistentiallyQuantifiedFormula (
		thisModule.getChildrenOfAllTopMostImplications()->includes(i) and
		if i.formula.oclIsTypeOf(R2ML!Conjuction) then
			if i.formula.formulas->select(e | e.oclIsTypeOf(R2ML!AttributionAtom))->size() > 0 then
			true
			else false
			endif
		else false
		endif
		)
	to dra : RDM!Atom (
		name <- 'DataRangeAtom',
		hasPredicateSymbol <- smr,
		terms <- thisModule.DataVariable2IndividualVariable(i.formula.antecedent.getTerm)
		),
	smr : RDM!SomeValuesFromRestriction (
		someValuesFromRange <- i.formula.formulas->select(c | not c.oclIsTypeOf(R2ML!AttributionAtom))->first(),
		onProperty <- thisModule.Attribute2DatatypeProperty(i.formula.formulas->select(c | c.oclIsTypeOf(R2ML!AttributionAtom))->first().attribute)
		)
}

-- Rule 'Attribute2DatatypeProperty'
-- Lazy rule which creates RDM DatatypeProperty from R2ML Attribute.
unique lazy rule Attribute2DatatypeProperty {
	from i : R2ML!Attribute
	to o : RDM!DatatypeProperty (
			name <- i.name
		)
}

-- Rule 'TypedLiteral2DataValue'
-- Lazy rule which creates RDM DataValue from R2ML TypedLiteral.
unique lazy rule TypedLiteral2DataValue {
	from i : R2ML!TypedLiteral
	to o : RDM!DataValue(
			value <- i.lexicalValue,
			type <- i.type
		)
}

-- Rule 'AttributeAtomData2DataValuedPropertyAtom'
-- Creates RDM Atom from R2ML AttributionAtom, which is children of
-- top most Implication.
rule AttributeAtomData2DataValuedPropertyAtom {
	from i : R2ML!AttributionAtom (
		thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o : RDM!Atom (
		name <- 'DataValuedPropertyAtom',
		hasPredicateSymbol <- thisModule.Attribute2DatatypeProperty(i.attribute),
		terms <- if i.dataValue.oclIsTypeOf(R2ML!TypedLiteral) then
					Sequence { thisModule.TypedLiteral2DataValue(i.dataValue),
							   thisModule.ObjectVariable2IndividualVariable(i.subject)
							 }
				 else
					Sequence { thisModule.DataVariable2DataVariable(i.dataValue),
				 			   thisModule.ObjectVariable2IndividualVariable(i.subject)
				 			 }
				 endif
		)
}

-- Rule 'AttributionAtomData2HasValueRestriction'
-- Creates RDM HasValueRestriction from R2ML AttributionAtom, which is not children of
-- top most Implications.
rule AttributionAtomData2HasValueRestriction {
	from i : R2ML!AttributionAtom (
		not thisModule.getChildrenOfAllTopMostImplications()->includes(i)
		)
	to o :  RDM!HasValueRestriction (
			hasLiteralValue <- i.dataValue,
			onProperty <- thisModule.Attribute2DatatypeProperty(i.attribute)
		)
}

-- Rule 'DataVariable2DataVariable'
-- Lazy rule which creates RDM DataVariable from R2ML DataVariable.
unique lazy rule DataVariable2DataVariable {
	from i : R2ML!DataVariable
	to o : RDM!DataVariable (
			name <- i.name
		)		
}

-- Rule 'EqualityAtom2SameIndividualAtom'
-- Creates RDM Atom from R2ML EqualityAtom, which is not
-- children (formulas) of Disjunction.
rule EqualityAtom2SameIndividualAtom {
	from i : R2ML!EqualityAtom (
		R2ML!Disjunction.allInstancesFrom('IN')->asSequence()->collect(e | e.formulas)->flatten()->excludes(i)
		)
	to o : RDM!Atom (
		name <- 'SameIndividualAtom',
		hasPredicateSymbol <- same,
		terms <- i.terms->select(e | e.oclIsTypeOf(R2ML!ObjectVariable))->collect(c | thisModule.ObjectVariable2IndividualVariable(c))			
		),
		same : RDM!SameAs
}

-- Rule 'InequalityAtom2DifferentIndividualAtom'
-- Creates RDM Atom from R2ML InequalityAtom.
rule InequalityAtom2DifferentIndividualAtom {
	from i : R2ML!InequalityAtom (
		i.oclIsTypeOf(R2ML!InequalityAtom)
		)
	to o : RDM!Atom (
		name <- 'DifferentIndividualAtom',
		hasPredicateSymbol <- different,
		terms <- i.terms->select(e | e.oclIsTypeOf(R2ML!ObjectVariable))->collect(c | thisModule.ObjectVariable2IndividualVariable(c))			
		),
		different : RDM!DifferentFrom
}

-- Rule 'DatatypePredicateAtom2BulitinAtom'
-- Creates RDM Atom from R2ML DatatypePredicateAtom, which is not
-- formula of some Disjunction.
rule DatatypePredicateAtom2BulitinAtom {
	from i : R2ML!DatatypePredicateAtom (
		R2ML!Disjunction.allInstancesFrom('IN')->asSequence()->collect(e | e.formulas)->flatten()->excludes(i) and
		i.dataArguments->select(c | c.oclIsTypeOf(R2ML!AttributeFunctionTerm))->size() = 0 and
		i.dataArguments->select(c | c.oclIsTypeOf(R2ML!DataOperationTerm))->size() = 0
		)
	to o : RDM!Atom (
		name <- 'BulitinAtom',
		hasPredicateSymbol <- thisModule.DatatypePredicate2BuiltIn(i.predicate),
		terms <-  Sequence { i.dataArguments->select(e | e.oclIsKindOf(R2ML!DataVariable))->collect(c | thisModule.DataVariable2DataVariable(c)),
							 i.dataArguments->select(e | e.oclIsKindOf(R2ML!TypedLiteral))->collect(c | thisModule.TypedLiteral2DataValue(c))							
						    }
		)
}

-- Rule 'DatatypePredicate2BuiltIn'
-- Lazy rule which creates RDM BuiltIn from R2ML DatatypePredicate.
unique lazy rule DatatypePredicate2BuiltIn {
	from i : R2ML!DatatypePredicate 
	to o : RDM!BuiltIn (
		buildInID <- i.name
		)
}",transform r ml metamodel rdm metamodel creat part m sc these good old ai laboratori author milan milanov milan milanov org work r ml v integr deriv rule licenc gnu general public licens version modul r ml rdm modul templat creat out rdm in r ml use string helper helper firstchartoupp convert first charact string upper return complet string context string out string helper context string def firstchartoupp string let firstchar string self substr firstchar toupper self substr self size helper toboolean convert string valu boolean valu context string in string out boolean helper context string def toboolean boolean self true true els fals endif helper getterm return object term variabl current element context r ml objectclassificationatom out r ml objectvari helper context r ml objectclassificationatom def getterm r ml objectvari self term helper getterm return object term variabl current element context rdm disjunct out r ml objectvari helper context r ml disjunct def getterm r ml objectvari self formula assequ first getterm helper getterm return object term variabl current element context rdm conjuct out r ml objectvari helper context r ml conjuct def getterm r ml objectvari self formula assequ first getterm helper getterm return object term variabl current element context r ml universallyquantifiedformula out r ml objectvari helper context r ml universallyquantifiedformula def getterm r ml objectvari self formula getterm helper getterm return object term variabl current element context r ml existentiallyquantifiedformula out r ml objectvari helper context r ml existentiallyquantifiedformula def getterm r ml objectvari self formula getterm helper getterm return object term variabl current element context r ml referencepropertyatom out r ml objectvari helper context r ml referencepropertyatom def getterm r ml objectvari self subject helper getterm return object term variabl current element context r ml atmostquantifiedformula out r ml objectvari helper context r ml atmostquantifiedformula def getterm r ml objectvari self formula getterm helper getterm return object term variabl current element context r ml atleastquantifiedformula out r ml objectvari helper context r ml atleastquantifiedformula def getterm r ml objectvari self formula getterm helper getterm return object term variabl current element context r ml atleastandatmostquantifiedformula out r ml objectvari helper context r ml atleastandatmostquantifiedformula def getterm r ml objectvari self formula getterm helper getterm return object term variabl current element context r ml equalityatom out r ml objectvari helper context r ml equalityatom def getterm r ml objectvari self term select e e oclistypeof r ml objectvari first helper getterm return object term variabl current element context r ml datatypepredicateatom out r ml datavari helper context r ml datatypepredicateatom def getterm r ml datavari self dataargu select c c oclistypeof r ml datavari first helper getterm return object term variabl current element context r ml attributionatom out r ml datavari helper context r ml attributionatom def getterm r ml variabl self datavalu oclistypeof r ml datavari todo check self datavalu els self subject endif helper getchildren return children context implic anteced consequ context r ml implic out sequenc r ml logicalformula helper context r ml implic def getchildren sequenc r ml logicalformula self getanteced assequ union self getconsequ assequ helper getanteced return anteced children context implic context r ml implic out sequenc r ml logicalformula helper context r ml implic def getanteced sequenc r ml logicalformula self anteced oclistypeof r ml conjuct self anteced isconjuctionfromintersect sequenc self anteced els self anteced formula endif els sequenc self anteced endif helper getconsequ return consequ children context implic context r ml implic out sequenc r ml logicalformula helper context r ml implic def getconsequ sequenc r ml logicalformula self consequ oclistypeof r ml conjuct self consequ isconjuctionfromintersect sequenc self consequ els self consequ formula endif els sequenc self consequ endif helper getchildrenofalltopmostimpl return children element anteced consequ topmost implic rule out sequenc r ml logicalformula helper def getchildrenofalltopmostimpl sequenc r ml logicalformula let allimp sequenc r ml implic thismodul gettopmostuniversallyquantifiedformula collect c c formula flatten allimp collect c c getchildren flatten helper isconjuctionfromintersect implement algorithm check contextu conjuct come rdm intersect conjuct transform this import implic rdm rule containt anteced consequ conjuct multipl atom intersect context r ml conjuct out boolean helper context r ml conjuct def isconjuctionfromintersect boolean r ml existentiallyquantifiedformula allinstancesfrom in assequ collect c c formula flatten exclud self self formula size self formula assequ first getterm self formula assequ last getterm self formula select c c oclistypeof r ml disjunct collect e e formula flatten foral c c oclistypeof r ml equalityatom self formula select c c oclistypeof r ml universallyquantifiedformula collect e e formula flatten foral c c oclistypeof r ml implic self formula select c c oclistypeof r ml existentiallyquantifiedformula collect e e formula flatten foral c c oclistypeof r ml conjuct self formula select c c oclistypeof r ml atleastquantifiedformula collect e e formula flatten foral c c oclistypeof r ml referencepropertyatom self formula select c c oclistypeof r ml atmostquantifiedformula collect e e formula flatten foral c c oclistypeof r ml referencepropertyatom self formula select c c oclistypeof r ml atleastandatmostquantifiedformula collect e e formula flatten foral c c oclistypeof r ml referencepropertyatom self formula select c c oclistypeof r ml attributionatom size self formula select c c oclistypeof r ml datatypepredicateatom size self formula collect c c oclistypeof r ml referencepropertyatom flatten size true els fals endif helper gettopmostuniversallyquantifiedformula return top universallyquantifiedformula out sequenc r ml universallyquantifiedformula helper def gettopmostuniversallyquantifiedformula sequenc r ml universallyquantifiedformula r ml alethicintegrityrul allinstancesfrom in assequ collect c c constraint flatten helper isrefpropatomforhasvalu implement algorithm check contextu referencepropertyatom candid rdm hasvaluerestrict context r ml referencepropertyatom out boolean helper context r ml referencepropertyatom def isrefpropatomforhasvalu boolean thismodul getchildrenofalltopmostimpl exclud self r ml universallyquantifiedformula allinstancesfrom in assequ exclud thismodul gettopmostuniversallyquantifiedformula select e e formula oclistypeof r ml implic collect c c formula flatten collect c c anteced flatten exclud self r ml existentiallyquantifiedformula allinstancesfrom in assequ select e e formula oclistypeof r ml conjuct collect c c formula formula assequ flatten exclud self r ml atmostquantifiedformula allinstancesfrom in assequ collect c c formula flatten exclud self r ml atleastquantifiedformula allinstancesfrom in assequ collect c c formula flatten exclud self r ml atleastandatmostquantifiedformula allinstancesfrom in assequ collect c c formula flatten exclud self helper transform r ml element transform ocl metamodel helper getdatatypepredicateatomswithsubelem return datatyp predic atom subelem contextu logic formula context r ml logicalformula out sequenc oclani helper context r ml logicalformula def getdatatypepredicateatomswithsubelem sequenc oclani self oclistypeof r ml conjuct self formula select c c oclistypeof r ml datatypepredicateatom assequ collect c c getelementwithsubelem flatten assequ els self oclistypeof r ml datatypepredicateatom self getelementwithsubelem els oclundefin endif endif helper getreferencepropertyatomswithtermswithsubelem return refer properti atom term contextu logic formula context r ml logicalformula out sequenc oclani helper context r ml logicalformula def getreferencepropertyatomswithtermswithsubelem sequenc oclani self oclistypeof r ml conjuct sequenc self formula select c c oclistypeof r ml referencepropertyatom select c c subject oclistypeof r ml objectvari c object oclistypeof r ml objectvari assequ collect c c getelementwithsubelem flatten assequ self formula select c c oclistypeof r ml referencepropertyatom select c c subject oclistypeof r ml objectvari c object oclistypeof r ml objectvari flatten assequ get basic referencepropertyatom els self subject oclistypeof r ml objectvari self object oclistypeof r ml objectvari self getelementwithsubelem flatten assequ els self endif endif helper areallobjectvari return object variabl r ml referencepropertyatom subject object context r ml referencepropertyatom out boolean helper context r ml referencepropertyatom def areallobjectvari boolean self subject oclistypeof r ml objectvari self object oclistypeof r ml objectvari true els fals endif els fals endif helper getelementwithsubelem return contextu referencepropertyatom sub element context r ml referencepropertyatom out sequenc oclani helper context r ml referencepropertyatom def getelementwithsubelem sequenc oclani sequenc self subject oclistypeof r ml objectvari self subject getelementwithsubelem flatten assequ els oclundefin endif self object oclistypeof r ml objectvari self object getelementwithsubelem flatten assequ els oclundefin endif flatten assequ append self helper getelementwithsubelem return contextu datatypepredicateatom sub element context r ml datatypepredicateatom out sequenc oclani helper context r ml datatypepredicateatom def getelementwithsubelem sequenc oclani self dataargu select c c ocliskindof r ml dataliter assequ collect c c getelementwithsubelem flatten assequ append self helper getelementwithsubelem return contextu attributefunctionterm sub element context r ml attributefunctionterm out sequenc oclani helper context r ml attributefunctionterm def getelementwithsubelem sequenc oclani sequenc self contextargu getelementwithsubelem flatten append self helper getelementwithsubelem return contextu referencepropertyfunctionterm sub element context r ml referencepropertyfunctionterm out sequenc oclani helper context r ml referencepropertyfunctionterm def getelementwithsubelem sequenc oclani sequenc self contextargu getelementwithsubelem flatten append self helper getelementwithsubelem return contextu dataoperationterm sub element context r ml dataoperationterm out sequenc oclani helper context r ml dataoperationterm def getelementwithsubelem sequenc oclani sequenc self contextargu getelementwithsubelem flatten append self helper getelementwithsubelem return contextu objectvari sub element context r ml objectvari out sequenc oclani helper context r ml objectvari def getelementwithsubelem sequenc oclani sequenc self helper getvariablenam return referencepropertyfunctionterm contextargu name e variabl referencepropertyref name context r ml referencepropertyfunctionterm out string helper context r ml referencepropertyfunctionterm def getvariablenam string self contextargu name self referencepropertyref name firstchartoupp rule rule implic rule creat rdm rule element r ml implic element rule implic rule r ml implic thismodul gettopmostuniversallyquantifiedformula collect c c formula flatten includ rdm rule hasanteced ant hasconsequ con ant rdm anteced containsatom anteced oclistypeof r ml conjuct anteced isconjuctionfromintersect anteced els sequenc anteced formula select c c oclistypeof r ml datatypepredicateatom c oclistypeof r ml referencepropertyatom assequ anteced getdatatypepredicateatomswithsubelem anteced getreferencepropertyatomswithtermswithsubelem endif els anteced oclistypeof r ml datatypepredicateatom anteced getdatatypepredicateatomswithsubelem els anteced oclistypeof r ml referencepropertyatom anteced getelementwithsubelem check intersect element type term els anteced oclistypeof r ml disjunct anteced getterm oclistypeof r ml objectvari anteced getterm classref oclisundefin creat intersect type thismodul logicalformula intersect anteced els anteced endif els anteced endif els anteced endif endif endif endif con rdm consequ containsatom consequ oclistypeof r ml conjuct consequ isconjuctionfromintersect consequ els sequenc consequ formula select c c oclistypeof r ml datatypeprediacateatom c oclistypeof r ml referencepropertyatom assequ consequ getdatatypepredicateatomswithsubelem consequ getreferencepropertyatomswithtermswithsubelem endif els consequ oclistypeof r ml datatypepredicateatom consequ getdatatypepredicateatomswithsubelem els consequ oclistypeof r ml referencepropertyatom consequ getelementwithsubelem check intersect element type term els consequ oclistypeof r ml disjunct consequ getterm oclistypeof r ml objectvari consequ getterm classref oclisundefin creat intersect type thismodul logicalformula intersect consequ els consequ endif els consequ endif els consequ endif endif endif endif lazi rule logicalformula intersect creat intersectionclass rdm element logicalformula r ml element uniqu lazi rule logicalformula intersect r ml logicalformula rdm atom name classatom haspredicatesymbol intcla term thismodul objectvari individualvari getterm intcla rdm intersectionclass intersectionof sequenc thismodul class class getterm classref individualpropertyatom rule referencepropertyatom individualpropertyatom creat atom rdm element individualpropertyatom referencepropertyatom r ml element rule referencepropertyatom individualpropertyatom r ml referencepropertyatom isrefpropatomforhasvalu areallobjectvari rdm atom name individualpropertyatom haspredicatesymbol thismodul referenceproperti objectproperti referenceproperti term sequenc thismodul objectvari individualvari object thismodul objectvari individualvari subject rule referenceproperti objectproperti transform r ml referenceproperti element rdm objectproperti element uniqu lazi rule referenceproperti objectproperti r ml referenceproperti rdm objectproperti name name rule referenceproperti datatypeproperti transform r ml referenceproperti element rdm datatypeproperti element uniqu lazi rule referenceproperti datatypeproperti r ml referenceproperti rdm datatypeproperti name name rule objectvari individualvari creat rdm individualvari r ml objectvari uniqu lazi rule objectvari individualvari r ml objectvari rdm individualvari name name classref classref oclisundefin thismodul class class classref els oclundefin endif rule datavari individualvari creat rdm individualvari r ml datavari uniqu lazi rule datavari individualvari r ml datavari rdm individualvari name name classatom rule conjuct classatom creat rdm classatom intersect predic symbol r ml conjuct rule conjuct classatom r ml conjuct isconjuctionfromintersect becaus defin type intersect formula assequ first getterm oclistypeof r ml objectvari formula assequ first getterm classref oclisundefin fals els true endif els true endif rdm atom name classatom haspredicatesymbol intcla term thismodul objectvari individualvari formula assequ first getterm intcla rdm intersectionclass intersectionof sequenc formula assequ select c c oclistypeof r ml objectclassificationatom collect e thismodul class class e type formula assequ select c c oclistypeof r ml objectclassificationatom rule disjunctionatom union creat rdm classatom unionclass predic symbol r ml disjunct equalityatom datatypepredicateatom formula children top implic rule disjunctionatom union r ml disjunct r ml conjuct allinstancesfrom in assequ select c c isconjuctionfromintersect collect e e formula flatten exclud r ml disjunct allinstancesfrom in assequ select e e formula assequ first oclistypeof r ml equalityatom e formula assequ first oclistypeof r ml datatypepredicateatom exclud thismodul getchildrenofalltopmostimpl includ formula assequ first getterm oclistypeof r ml objectvari formula assequ first getterm classref oclisundefin fals els true endif els true endif rdm atom name classatom haspredicatesymbol unicla term thismodul objectvari individualvari formula assequ first getterm unicla rdm unionclass unionof sequenc formula assequ select c c oclistypeof r ml objectclassificationatom collect e thismodul class class e type formula assequ select c c oclistypeof r ml objectclassificationatom rule disjunct union creat unionclass predicat ml disjunct equalityatom datatypepredicateatom formula children top implic rule disjunct union r ml disjunct r ml conjuct allinstancesfrom in assequ select c c isconjuctionfromintersect collect e e formula flatten exclud r ml disjunct allinstancesfrom in assequ select e e formula assequ first oclistypeof r ml equalityatom e formula assequ first oclistypeof r ml datatypepredicateatom exclud thismodul getchildrenofalltopmostimpl exclud becaus defin type intersect formula assequ first getterm oclistypeof r ml objectvari formula assequ first getterm classref oclisundefin true els fals endif els true endif unicla rdm unionclass unionof sequenc formula assequ select c c oclistypeof r ml objectclassificationatom collect e thismodul class class e type formula assequ select c c oclistypeof r ml objectclassificationatom rule negationatom complement creat rdm classatom complementclass predic symbol r ml negationasfailur rule negationatom complement r ml strongneg oclistypeof r ml strongneg thismodul getchildrenofalltopmostimpl includ rdm atom name classatom haspredicatesymbol comcla term thismodul objectvari individualvari formula getterm comcla rdm complementclass complementof formula oclistypeof r ml objectclassificationatom thismodul class class formula type els formula endif rule negat complement creat rdm classatom complementclass predic symbol r ml negationasfailur rule negat complement r ml strongneg oclistypeof r ml strongneg thismodul getchildrenofalltopmostimpl exclud comcla rdm complementclass complementof formula oclistypeof r ml objectclassificationatom thismodul class class formula type els formula endif rule disjunct enumeratedclass creat enumeratedclass r ml disjunct rule disjunctionfromintersect enumeratedclass r ml disjunct r ml conjuct allinstancesfrom in assequ select c c isconjuctionfromintersect collect e e formula flatten includ formula select e e oclistypeof r ml equalityatom size enumclass rdm enumeratedclass oneof formula assequ collect c c term flatten select c c oclistypeof r ml objectnam assequ rule disjunctionfromatom enumeratedclass creat rdm classatom enumeratedclass predic symbol r ml disjunct rule disjunctionfromatom enumeratedclass r ml disjunct r ml conjuct allinstancesfrom in assequ select c c isconjuctionfromintersect collect e e formula flatten exclud formula select e e oclistypeof r ml equalityatom size rdm atom name classatom haspredicatesymbol enumclass term thismodul objectvari individualvari formula assequ first getterm enumclass rdm enumeratedclass oneof formula collect e e term flatten select c c oclistypeof r ml objectnam rule objectnam individu creat rdm individu r ml objectnam rule objectnam individu r ml objectnam r ml equalityatom allinstancesfrom in assequ collect c c term flatten select e e oclistypeof r ml objectnam includ rdm individu name name rule objectclassificationatom classatom creat classatom rdm element r ml objectclassificationatom element rule objectclassificationatom classatom r ml objectclassificationatom thismodul getchildrenofalltopmostimpl includ r ml conjuct allinstancesfrom in assequ select e e isconjuctionfromintersect collect e e formula flatten exclud isneg fals rdm atom name classatom haspredicatesymbol thismodul class class type term thismodul objectvari individualvari term rule objectclassificationatom creat classatom rdm element r ml objectclassificationatom element negat rule objectclassificationatomneg complementclassatom r ml objectclassificationatom thismodul getchildrenofalltopmostimpl includ r ml conjuct allinstancesfrom in assequ select e e isconjuctionfromintersect collect e e formula flatten exclud isneg true rdm atom name classatom haspredicatesymbol cla term thismodul objectvari individualvari term cla rdm class subclassof sequenc cs cs rdm complementclass complementof thismodul class class type rule class class creat rdm class r ml class element uniqu lazi rule class class r ml class cla rdm class name name rule existentiallyquantifiedformulaclass somevaluesfromrestrict creat somevaluesfromrestrict rdm element r ml existentiallyquantifiedformula element referencepropertyatom formula rule existentiallyquantifiedformulaclass somevaluesfromrestrict r ml existentiallyquantifiedformula thismodul getchildrenofalltopmostimpl exclud formula formula select c c oclistypeof r ml referencepropertyatom size rdm somevaluesfromrestrict somevaluesfromclass sequenc formula formula select c c oclistypeof r ml objectclassificationatom collect c thismodul class class c type first formula formula select c c oclistypeof r ml referencepropertyatom c oclistypeof r ml objectclassificationatom first select c c oclisundefin assequ first onproperti thismodul referenceproperti objectproperti formula formula select c c oclistypeof r ml referencepropertyatom first referenceproperti rule existentiallyquantifiedformulaclass classatomsomevaluesfromrestrict creat rdm atom somevaluesfromrestrict predic symbol r ml existentiallyquantifiedformula element referencepropertyatom formula rule existentiallyquantifiedformulaclass classatomsomevaluesfromrestrict r ml existentiallyquantifiedformula thismodul getchildrenofalltopmostimpl includ formula formula select c c oclistypeof r ml referencepropertyatom size rdm atom name classatom haspredicatesymbol svf term thismodul objectvari individualvari formula formula select c c oclistypeof r ml referencepropertyatom first getterm svf rdm somevaluesfromrestrict somevaluesfromclass sequenc formula formula select c c oclistypeof r ml objectclassificationatom collect c thismodul class class c type first formula formula select c c oclistypeof r ml referencepropertyatom c oclistypeof r ml objectclassificationatom first select c c oclisundefin assequ first onproperti thismodul referenceproperti objectproperti formula formula select c c oclistypeof r ml referencepropertyatom first referenceproperti rule universallyquantifiedformulaclass allvaluesfromrestrict creat allvaluesfromrestrict rdm element r ml universallyquantifiedformula element implic formula referencepropertyatom anteced rule universallyquantifiedformulaclass allvaluesfromrestrict r ml universallyquantifiedformula thismodul gettopmostuniversallyquantifiedformula exclud formula oclistypeof r ml implic formula anteced oclistypeof r ml referencepropertyatom true els fals endif els fals endif rdm allvaluesfromrestrict allvaluesfromclass formula consequ oclistypeof r ml objectclassificationatom thismodul class class formula consequ els formula consequ endif onproperti thismodul referenceproperti objectproperti formula anteced referenceproperti rule referencepropertyatomclass hasvalu creat hasvaluerestrict rdm element r ml referencepropertyatom referencepropertyatom type restrict use helper isrefpropatomforhasvalu check rule referencepropertyatomclass hasvalu r ml referencepropertyatom isrefpropatomforhasvalu thismodul getchildrenofalltopmostimpl exclud rdm hasvaluerestrict hasvalu thismodul objectvari individu object onproperti thismodul referenceproperti objectproperti referenceproperti rule referencepropertyatomclass classatomhasvalu creat rdm atom hasvaluerestrict predic symbol r ml referencepropertyatom referencepropertyatom type restrict use helper isrefpropatomforhasvalu check rule referencepropertyatomclass classatomhasvalu r ml referencepropertyatom isrefpropatomforhasvalu thismodul getchildrenofalltopmostimpl includ rdm atom name classatom haspredicatesymbol hvr term thismodul objectvari individualvari subject hvr rdm hasvaluerestrict hasvalu thismodul objectvari individu object onproperti thismodul referenceproperti objectproperti referenceproperti rule objectvari individu creat individu rdm element r ml objectvari lazi rule uniqu lazi rule objectvari individu r ml objectvari rdm individu name name rule atleastquantifiedformula mincardinalityrestrict creat mincardinalityrestrict rdm element r ml atleastquantifiedformula work datarangeatom classatom cardin restrict rule atleastquantifiedformula mincardinalityrestrict r ml atleastquantifiedformula oclistypeof r ml atleastquantifiedformula thismodul getchildrenofalltopmostimpl exclud rdm mincardinalityrestrict mincardin card onproperti formula oclistypeof r ml referencepropertyatom thismodul referenceproperti objectproperti formula referenceproperti els thismodul attribut datatypeproperti formula attribut endif card rdm typedliter thetyp int lexicalform mincardin tostr rule atleastquantifiedformulainclassatom mincardinalityrestrict creat rdm atom mincardinalityrestrict predic symbol r ml atleastquantifiedformula work classatom cardin restrict rule atleastquantifiedformulainclassatom mincardinalityrestrict r ml atleastquantifiedformula oclistypeof r ml atleastquantifiedformula formula oclistypeof r ml referencepropertyatom thismodul getchildrenofalltopmostimpl includ rdm atom name classatom haspredicatesymbol mcr term thismodul objectvari individualvari formula subject mcr rdm mincardinalityrestrict mincardin card onproperti thismodul referenceproperti objectproperti formula referenceproperti card rdm typedliter thetyp int lexicalform mincardin tostr rule atleastquantifiedformulaindatarangeatom mincardinalityrestrict creat rdm atom mincardinalityrestrict predic symbol r ml atleastquantifiedformula work datarangeatom cardin restrict rule atleastquantifiedformulaindatarangeatom mincardinalityrestrict r ml atleastquantifiedformula oclistypeof r ml atleastquantifiedformula formula oclistypeof r ml attributionatom thismodul getchildrenofalltopmostimpl includ rdm atom name datarangeatom haspredicatesymbol mcr term thismodul datavari individualvari formula datavalu mcr rdm mincardinalityrestrict mincardin card onproperti thismodul attribut datatypeproperti formula attribut card rdm typedliter thetyp int lexicalform mincardin tostr rule atmostquantifiedformulaclass maxcardinalityrestrict creat maxcardinalityrestrict rdm element r ml atmostquantifiedformula work datarangeatom classatom cardin restrict rule atmostquantifiedformulaclass maxcardinalityrestrict r ml atmostquantifiedformula oclistypeof r ml atmostquantifiedformula thismodul getchildrenofalltopmostimpl exclud rdm maxcardinalityrestrict maxcardin card onproperti formula oclistypeof r ml referencepropertyatom thismodul referenceproperti objectproperti formula referenceproperti els thismodul attribut datatypeproperti formula attribut endif card rdm typedliter thetyp int lexicalform maxcardin tostr rule atmostquantifiedformulainclassatom maxcardinalityrestrict creat rdm atom maxcardinalityrestrict predic symbol r ml atmostquantifiedformula work classatom cardin restrict rule atmostquantifiedformulainclassatom maxcardinalityrestrict r ml atmostquantifiedformula oclistypeof r ml atmostquantifiedformula formula oclistypeof r ml referencepropertyatom thismodul getchildrenofalltopmostimpl includ rdm atom name classatom haspredicatesymbol mcr term thismodul objectvari individualvari formula subject mcr rdm maxcardinalityrestrict maxcardin card onproperti thismodul referenceproperti objectproperti formula referenceproperti card rdm typedliter thetyp int lexicalform maxcardin tostr rule atmostquantifiedformulaindatarangeatom maxcardinalityrestrict creat rdm atom maxcardinalityrestrict predic symbol r ml atmostquantifiedformula work datarangeatom cardin restrict rule atmostquantifiedformulaindatarangeatom maxcardinalityrestrict r ml atmostquantifiedformula oclistypeof r ml atmostquantifiedformula formula oclistypeof r ml attributionatom thismodul getchildrenofalltopmostimpl includ rdm atom name datarangeatom haspredicatesymbol mcr term thismodul datavari individualvari formula datavalu mcr rdm maxcardinalityrestrict maxcardin card onproperti thismodul attribut datatypeproperti formula attribut card rdm typedliter thetyp int lexicalform maxcardin tostr rule atleastandatmostquantifiedformulaclass cardinalityrestrict creat cardinalityrestrict rdm element r ml atleastandatmostquantifiedformula work datarangeatom classatom cardin restrict rule atleastandatmostquantifiedformulaclass cardinalityrestrict r ml atleastandatmostquantifiedformula oclistypeof r ml atleastandatmostquantifiedformula maxcardin mincardin thismodul getchildrenofalltopmostimpl exclud rdm cardinalityrestrict cardin card onproperti formula oclistypeof r ml referencepropertyatom thismodul referenceproperti objectproperti formula referenceproperti els thismodul attribut datatypeproperti formula attribut endif card rdm typedliter thetyp int lexicalform maxcardin tostr rule atleastandatmostquantifiedformulainclassatom cardinalityrestrict creat rdm atom cardinalityrestrict predic symbol r ml atleastandatmostquantifiedformula work classatom cardin restrict rule atleastandatmostquantifiedformulainclassatom cardinalityrestrict r ml atleastandatmostquantifiedformula oclistypeof r ml atleastandatmostquantifiedformula formula oclistypeof r ml referencepropertyatom maxcardin mincardin thismodul getchildrenofalltopmostimpl includ rdm atom name classatom haspredicatesymbol mcr term thismodul objectvari individualvari formula subject mcr rdm cardinalityrestrict cardin card onproperti thismodul referenceproperti objectproperti formula referenceproperti card rdm typedliter thetyp int lexicalform maxcardin tostr rule atleastandatmostquantifiedformulaindatarangeatom cardinalityrestrict creat rdm atom cardinalityrestrict predic symbol r ml atleastandatmostquantifiedformula work datarangeatom cardin restrict rule atleastandatmostquantifiedformulaindatarangeatom cardinalityrestrict r ml atleastandatmostquantifiedformula oclistypeof r ml atleastandatmostquantifiedformula formula oclistypeof r ml attributionatom maxcardin mincardin thismodul getchildrenofalltopmostimpl includ rdm atom name datarangeatom haspredicatesymbol mcr term thismodul datavari individualvari formula datavalu mcr rdm cardinalityrestrict cardin card onproperti thismodul attribut datatypeproperti formula attribut card rdm typedliter thetyp int lexicalform maxcardin tostr rule atleastandatmostquantifiedformulaclass minmaxcardinalityrestrict creat mincardinalityrestrict maxcardinalityrestrict rdm element r ml atleastandatmostquantifiedformula differ max min cardin work datarangeatom classatom cardin restrict rule atleastandatmostquantifiedformulaclass minmaxcardinalityrestrict r ml atleastandatmostquantifiedformula oclistypeof r ml atleastandatmostquantifiedformula maxcardin mincardin thismodul getchildrenofalltopmostimpl exclud rdm mincardinalityrestrict mincardin cardmin onproperti formula oclistypeof r ml referencepropertyatom thismodul referenceproperti objectproperti formula referenceproperti els thismodul attribut datatypeproperti formula attribut endif cardmin rdm typedliter thetyp int lexicalform mincardin tostr u rdm maxcardinalityrestrict maxcardin cardmax onproperti formula oclistypeof r ml referencepropertyatom thismodul referenceproperti objectproperti formula referenceproperti els thismodul attribut datatypeproperti formula attribut endif cardmax rdm typedliter thetyp int lexicalform maxcardin tostr rule atleastandatmostquantifiedformulaclassatom minmaxcardinalityrestrict creat rdm atom mincardinalityrestrict predic symbol maxcardinalityrestrict rdm elementfrom r ml atleastandatmostquantifiedformula differ max min cardin work classatom cardin restrict rule atleastandatmostquantifiedformulaclassatom minmaxcardinalityrestrict r ml atleastandatmostquantifiedformula oclistypeof r ml atleastandatmostquantifiedformula formula oclistypeof r ml referencepropertyatom maxcardin mincardin thismodul getchildrenofalltopmostimpl includ rdm atom name classatom haspredicatesymbol mcr term thismodul objectvari individualvari formula subject mcr rdm mincardinalityrestrict mincardin cardmin onproperti thismodul referenceproperti objectproperti formula referenceproperti cardmin rdm typedliter thetyp int lexicalform mincardin tostr u rdm maxcardinalityrestrict maxcardin cardmax onproperti thismodul referenceproperti objectproperti formula referenceproperti cardmax rdm typedliter thetyp int lexicalform maxcardin tostr rule atleastandatmostquantifiedformuladatarangeatom minmaxcardinalityrestrict creat rdm atom mincardinalityrestrict predic symbol maxcardinalityrestrict rdm elementfrom r ml atleastandatmostquantifiedformula differ max min cardin work datarangeatom cardin restrict rule atleastandatmostquantifiedformuladatarangeatom minmaxcardinalityrestrict r ml atleastandatmostquantifiedformula oclistypeof r ml atleastandatmostquantifiedformula formula oclistypeof r ml attributionatom maxcardin mincardin thismodul getchildrenofalltopmostimpl includ rdm atom name datarangeatom haspredicatesymbol mcr term thismodul datavari individualvari formula datavalu mcr rdm mincardinalityrestrict mincardin cardmin onproperti thismodul attribut datatypeproperti formula attribut cardmin rdm typedliter thetyp int lexicalform mincardin tostr u rdm maxcardinalityrestrict maxcardin cardmax onproperti thismodul attribut datatypeproperti formula attribut cardmax rdm typedliter thetyp int lexicalform maxcardin tostr datarang atom rule dataclassificationatom datarangeatomoneof creat rdm atom r ml dataclassificationatom element children top implic rule dataclassificationatom datarangeatomoneof r ml dataclassificationatom thismodul getchildrenofalltopmostimpl includ rdm atom name datarangeatom haspredicatesymbol dtr term thismodul datavari individualvari term dtr rdm datarang datatyp type rule dataclassificationatom datarang creat rdm datarang r ml dataclassificationatom element children top implic rule dataclassificationatom datarang r ml dataclassificationatom thismodul getchildrenofalltopmostimpl exclud dtr rdm datarang datatyp type rule disjunct datarangeatom creat rdm atom r ml disjunct element children top implic datatypepredicateatom formula rule disjunct datarangeatom r ml disjunct thismodul getchildrenofalltopmostimpl includ formula assequ first oclistypeof r ml datatypepredicateatom rdm atom name datarangeatom haspredicatesymbol dtr term sequenc thismodul datavari individualvari formula assequ first getterm dtr rdm datarang oneof formula rule disjunct datarang creat rdm datarang r ml disjunct element children top implic datatypepredicateatom formula rule disjunct datarang r ml disjunct thismodul getchildrenofalltopmostimpl exclud formula assequ first oclistypeof r ml datatypepredicateatom rdm datarang oneof formula rule datatyp primitivetyp creat rdm primitivetyp r ml datatyp element rule datatyp primitivetyp r ml datatyp oclistypeof r ml datatyp rdm primitivetyp name name rule plainliter plainliter creat rdm plainliter r ml plainliter element valu top attributionatom dataargu datatypepredicateatom rule plainliter plainliter r ml plainliter oclistypeof r ml plainliter thismodul getchildrenofalltopmostimpl select c c oclistypeof r ml attributionatom collect c c valu flatten exclud r ml datatypepredicateatom allinstancesfrom in assequ collect c c dataargu flatten exclud rdm plainliter languag languagetag lexicalform lexicalvalu rule typedliter typedliter creat rdm typedliter r ml typedliter element rule typedliter typedliter r ml typedliter oclistypeof r ml typedliter r ml datatypepredicateatom allinstancesfrom in assequ collect c c dataargu flatten exclud rdm typedliter thetyp type name lexicalform lexicalvalu rule datatypepredicateatom plainliter creat rdm plainliter r ml datatypepredicateatom element atom dataargu plainliter formula disjunct rule datatypepredicateatom plainliter r ml datatypepredicateatom dataargu select c c oclistypeof r ml plainliter size r ml disjunct allinstancesfrom in assequ collect e e formula flatten includ dataargu select c c oclistypeof r ml attributefunctionterm size true els fals endif rdm plainliter languag dataargu select c c ocliskindof r ml dataliter assequ first languagetag lexicalform dataargu select c c ocliskindof r ml dataliter assequ first lexicalvalu rule datatypepredicateatom typedliter creat rdm typedliter r ml datatypepredicateatom element atom dataargu typedliter formula disjunct rule datatypepredicateatom typedliter r ml datatypepredicateatom dataargu select c c oclistypeof r ml typedliter size r ml disjunct allinstancesfrom in assequ collect e e formula flatten includ dataargu select c c oclistypeof r ml attributefunctionterm size true els fals endif rdm typedliter thetyp dataargu select c c oclistypeof r ml typedliter assequ first type name lexicalform dataargu select c c oclistypeof r ml typedliter assequ first lexicalvalu rule universallyquantifiedformuladata allvaluesfromrestrict creat allvaluesfromrestrict rdm element r ml universallyquantifiedformula element implic formula attributionatom anteced rule universallyquantifiedformuladata allvaluesfromrestrict r ml universallyquantifiedformula thismodul gettopmostuniversallyquantifiedformula exclud thismodul getchildrenofalltopmostimpl exclud formula oclistypeof r ml implic formula anteced oclistypeof r ml attributionatom true els fals endif els fals endif rdm allvaluesfromrestrict allvaluesfromrang formula consequ onproperti thismodul attribut datatypeproperti formula anteced attribut rule universallyquantifiedformuladata allvaluesfromrestrict creat rdm atom allvaluesfromrestrict predic symbol r ml universallyquantifiedformula element implic formula attributionatom anteced rule universallyquantifiedformuladata datarangeatomallvaluesfromrestrict r ml universallyquantifiedformula thismodul gettopmostuniversallyquantifiedformula exclud thismodul getchildrenofalltopmostimpl includ formula oclistypeof r ml implic formula anteced oclistypeof r ml attributionatom true els fals endif els fals endif dra rdm atom name datarangeatom haspredicatesymbol alr term thismodul datavari individualvari formula anteced getterm alr rdm allvaluesfromrestrict allvaluesfromrang formula consequ onproperti thismodul attribut datatypeproperti formula anteced attribut rule existentiallyquantifiedformuladata somevaluesfromrestrict creat somevaluesfromrestrict rdm element r ml existentiallyquantifiedformula element attributionatom formula rule existentiallyquantifiedformuladata somevaluesfromrestrict r ml existentiallyquantifiedformula thismodul getchildrenofalltopmostimpl exclud formula oclistypeof r ml conjuct formula formula select e e oclistypeof r ml attributionatom size true els fals endif els fals endif rdm somevaluesfromrestrict somevaluesfromrang formula formula select c c oclistypeof r ml attributionatom first onproperti thismodul attribut datatypeproperti formula formula select c c oclistypeof r ml attributionatom first attribut rule existentiallyquantifiedformuladata datarangeatomsomevaluesfromrestrict creat rdm atom somevaluesfromrestrict predic symbol r ml existentiallyquantifiedformula element attributionatom formula rule existentiallyquantifiedformuladata datarangeatomsomevaluesfromrestrict r ml existentiallyquantifiedformula thismodul getchildrenofalltopmostimpl includ formula oclistypeof r ml conjuct formula formula select e e oclistypeof r ml attributionatom size true els fals endif els fals endif dra rdm atom name datarangeatom haspredicatesymbol smr term thismodul datavari individualvari formula anteced getterm smr rdm somevaluesfromrestrict somevaluesfromrang formula formula select c c oclistypeof r ml attributionatom first onproperti thismodul attribut datatypeproperti formula formula select c c oclistypeof r ml attributionatom first attribut rule attribut datatypeproperti lazi rule creat rdm datatypeproperti r ml attribut uniqu lazi rule attribut datatypeproperti r ml attribut rdm datatypeproperti name name rule typedliter datavalu lazi rule creat rdm datavalu r ml typedliter uniqu lazi rule typedliter datavalu r ml typedliter rdm datavalu valu lexicalvalu type type rule attributeatomdata datavaluedpropertyatom creat rdm atom r ml attributionatom children top implic rule attributeatomdata datavaluedpropertyatom r ml attributionatom thismodul getchildrenofalltopmostimpl includ rdm atom name datavaluedpropertyatom haspredicatesymbol thismodul attribut datatypeproperti attribut term datavalu oclistypeof r ml typedliter sequenc thismodul typedliter datavalu datavalu thismodul objectvari individualvari subject els sequenc thismodul datavari datavari datavalu thismodul objectvari individualvari subject endif rule attributionatomdata hasvaluerestrict creat rdm hasvaluerestrict r ml attributionatom children top implic rule attributionatomdata hasvaluerestrict r ml attributionatom thismodul getchildrenofalltopmostimpl includ rdm hasvaluerestrict hasliteralvalu datavalu onproperti thismodul attribut datatypeproperti attribut rule datavari datavari lazi rule creat rdm datavari r ml datavari uniqu lazi rule datavari datavari r ml datavari rdm datavari name name rule equalityatom sameindividualatom creat rdm atom r ml equalityatom children formula disjunct rule equalityatom sameindividualatom r ml equalityatom r ml disjunct allinstancesfrom in assequ collect e e formula flatten exclud rdm atom name sameindividualatom haspredicatesymbol term term select e e oclistypeof r ml objectvari collect c thismodul objectvari individualvari c rdm samea rule inequalityatom differentindividualatom creat rdm atom r ml inequalityatom rule inequalityatom differentindividualatom r ml inequalityatom oclistypeof r ml inequalityatom rdm atom name differentindividualatom haspredicatesymbol differ term term select e e oclistypeof r ml objectvari collect c thismodul objectvari individualvari c differ rdm differentfrom rule datatypepredicateatom bulitinatom creat rdm atom r ml datatypepredicateatom formula disjunct rule datatypepredicateatom bulitinatom r ml datatypepredicateatom r ml disjunct allinstancesfrom in assequ collect e e formula flatten exclud dataargu select c c oclistypeof r ml attributefunctionterm size dataargu select c c oclistypeof r ml dataoperationterm size rdm atom name bulitinatom haspredicatesymbol thismodul datatypepred builtin predic term sequenc dataargu select e e ocliskindof r ml datavari collect c thismodul datavari datavari c dataargu select e e ocliskindof r ml typedliter collect c thismodul typedliter datavalu c rule datatypepred builtin lazi rule creat rdm builtin r ml datatypepred uniqu lazi rule datatypepred builtin r ml datatypepred rdm builtin buildinid name,6
148,148,P66-RDM2XML.atl,"-- ============================================================
-- Transforms an RDM (SWRL/OWL) metamodel to XML metamodel.
-- Created as part of M.Sc. theses at GOOD OLD AI Laboratory
-- Author: Milan Milanovic (milan at milanovic.org)
-- Works for SWRL v0.6 (XML syntax)
-- Licence: GNU General Public License, version 2
-- ============================================================
	
module RDM2XML; -- Module Template
create OUT : XML from IN : RDM;

uses strings;

-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- HELPER: elementsForProperty
-- Returns all Restriction inerhited elements which have restriction on this property.
-- Works for Object and Data properties.
-- CONTEXT:	RDM!Property
-- OUT:		Sequence (RDM!Restriction)
helper context RDM!Property def: elementsForProperty : Sequence (RDM!Restriction) = 
	RDM!Restriction.allInstancesFrom('IN')->asSequence()->select(c | c.onProperty->includes(self))->asSequence();

-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'Ontology'
-- Create XML Root element from the RDM Ontology element 
rule Ontology {
	from i : RDM!Ontology (
			i.oclIsTypeOf(RDM!Ontology)
		)
	to o : XML!Root (
		children <- Sequence { attr, i.elements},
		name <- 'swrlx:Ontology'
		),
	attr : XML!Attribute (
		name <- 'swrlx:name',
		value <- 'Ontology'
		)
}

-- Rule 'RuleOne'
-- Create XML Root element from the RDM Rule element 
rule RuleOne {
	from i : RDM!Rule (
		i.oclIsTypeOf(RDM!Rule) and
		RDM!Ontology.allInstancesFrom('IN')->asSequence()->size() = 0
		)
	to o : XML!Root (
		name <- 'ruleml:imp',
		children <- Sequence {owlxns, swrlxns, rulemlns, i.hasAntecedent, i.hasConsequent }
		),
	owlxns : XML!Attribute (
		name <- 'xmlns:owlx',
		value <- 'http://www.w3.org/2003/05/owl-xml'
		),
	swrlxns : XML!Attribute (
		name <- 'xmlns:swrlx',
		value <- 'http://www.w3.org/2003/11/swrlx'
		),
	rulemlns : XML!Attribute (
		name <- 'xmlns:ruleml',
		value <- 'http://www.w3.org/2003/11/ruleml'
		)
}

-- Rule 'RuleMoreThanOne'
-- Create XML Element (ruleml:imp) element from the RDM Rule element 
rule RuleMoreThanOne {
	from i : RDM!Rule (
		i.oclIsTypeOf(RDM!Rule) and 
		( RDM!Rule.allInstancesFrom('IN')->asSequence()->size() > 1 or
		  RDM!Ontology.allInstancesFrom('IN')->asSequence()->size() > 0 )
		)
	to o : XML!Element (
		name <- 'ruleml:imp',
		children <- Sequence {owlxns, swrlxns, rulemlns, i.hasAntecedent, i.hasConsequent }
		),
	owlxns : XML!Attribute (
		name <- 'xmlns:owlx',
		value <- 'http://www.w3.org/2003/05/owl-xml'
		),
	swrlxns : XML!Attribute (
		name <- 'xmlns:swrlx',
		value <- 'http://www.w3.org/2003/11/swrlx'
		),
	rulemlns : XML!Attribute (
		name <- 'xmlns:ruleml',
		value <- 'http://www.w3.org/2003/11/ruleml'
		)
}

-- Rule 'Consequent'
-- Create XML Element (ruleml:_head) element from the RDM Consequent element 
rule Consequent {
	from i : RDM!Consequent (
			i.oclIsTypeOf(RDM!Consequent)
		)
	to o : XML!Element (
		name <- 'ruleml:_head',
				-- ANNOTATION: This is because we can have same Atom in consequent and antecedent.
				--             E.g. when we have two ClassAtoms from two DatatypePredicateAtom-s.
		children <- let thisRule : RDM!Rule = RDM!Rule.allInstancesFrom('IN')->asSequence()->select(c | c.hasConsequent = i)->first() in
						i.containsAtom->asSequence()->select(c | thisRule.hasAntecedent.containsAtom->excludes(c))->asSequence()
		)
}

-- Rule 'Antecedent'
-- Create XML Element (ruleml:_body) element from the RDM Antecedent element 
rule Antecedent {
	from i : RDM!Antecedent (
			i.oclIsTypeOf(RDM!Antecedent)
		)
	to o : XML!Element (
		name <- 'ruleml:_body',
		children <- i.containsAtom
		)
}

-- Atoms 

-- Rule 'IndividualPropertyAtom'
-- Create XML Element (swrlx:individualPropertyAtom) element from the RDM Atom (IndividualPropertyAtom) element 
rule IndividualPropertyAtom {
	from i : RDM!Atom (
			i.name = 'IndividualPropertyAtom'
		)
	to o : XML!Element (
		name <- 'swrlx:individualPropertyAtom',
		children <- Sequence { prop, i.terms->select(c | c.oclIsTypeOf(RDM!IndividualVariable))->collect(c | thisModule.IndividualVariable(c)),
									 i.terms->select(c | not c.oclIsTypeOf(RDM!IndividualVariable))
							 }
		),
	prop : XML!Attribute (
		name <- 'swrlx:property',
		value <- i.hasPredicateSymbol.name
		)
}

-- Rule 'ClassAtom'
-- Create XML Element (swrlx:classAtom) element from the RDM Atom (ClassAtom) element
rule ClassAtom {
	from i : RDM!Atom (
			i.name = 'ClassAtom'
		)
	to o : XML!Element (
		name <- 'swrlx:classAtom',
		children <- Sequence { if i.hasPredicateSymbol.oclIsTypeOf(RDM!Class) then
									thisModule.Class(i.hasPredicateSymbol)
								else if i.hasPredicateSymbol.oclIsKindOf(RDM!Restriction) then
										i.hasPredicateSymbol.onProperty
	  							     else i.hasPredicateSymbol
							         endif
								endif,
								i.terms->asSequence()->select(c | c.oclIsTypeOf(RDM!IndividualVariable))->collect(e | thisModule.IndividualVariable(e)),
								i.terms->asSequence()->select(c | not c.oclIsTypeOf(RDM!IndividualVariable))
							}
		)
}

-- Rule 'DataRangeAtom'
-- Create XML Element (swrlx:datarangeAtom) element from the RDM Atom (DataRangeAtom) element
rule DataRangeAtom {
	from i : RDM!Atom (
			i.name = 'DataRangeAtom'
		)
	to o : XML!Element (
		name <- 'swrlx:datarangeAtom',
		children <- Sequence { if i.hasPredicateSymbol.oclIsKindOf(RDM!Restriction) then
									i.hasPredicateSymbol.onProperty
							   else i.hasPredicateSymbol
							   endif,
							   i.terms->asSequence()->select(c | c.oclIsTypeOf(RDM!IndividualVariable))->collect(e | thisModule.IndividualVariable(e)),
							   i.terms->asSequence()->select(c | not c.oclIsTypeOf(RDM!IndividualVariable))
							}
		)
}

-- Rule 'DataValuedPropertyAtom'
-- Create XML Element (swrlx:datavaluedPropertyAtom) element from the RDM Atom (DataValuedPropertyAtom) element
rule DataValuedPropertyAtom {
	from i : RDM!Atom (
			i.name = 'DataValuedPropertyAtom'
		)
	to o : XML!Element (
		name <- 'swrlx:datavaluedPropertyAtom',
		children <- Sequence { prop, i.terms->asSequence()->select(c | c.oclIsTypeOf(RDM!IndividualVariable))->collect(e | thisModule.IndividualVariable(e)),
									 i.terms->asSequence()->select(c | c.oclIsTypeOf(RDM!DataVariable))->collect(e | thisModule.DataVariable(e)),
									 i.terms->asSequence()->select(c | not c.oclIsTypeOf(RDM!IndividualVariable) and not c.oclIsTypeOf(RDM!DataVariable))
							}
		),
	prop : XML!Attribute (
		name <- 'swrlx:property',
		value <- i.hasPredicateSymbol.name
		)
}

-- Rule 'SameIndividualAtom'
-- Create XML Element (swrlx:sameIndividualAtom) element from the RDM Atom (SameIndividualAtom) element
rule SameIndividualAtom {
	from i : RDM!Atom (
			i.name = 'SameIndividualAtom'
		)
	to o : XML!Element (
		name <- 'swrlx:sameIndividualAtom',
		children <- Sequence { i.terms->asSequence()->select(c | c.oclIsTypeOf(RDM!IndividualVariable))->collect(e | thisModule.IndividualVariable(e)),
							   i.terms->asSequence()->select(c | not c.oclIsTypeOf(RDM!IndividualVariable))
							 }
		)
}

-- Rule 'DifferentIndividualAtom'
-- Create XML Element (swrlx:differentIndividualsAtom) element from the RDM Atom (DifferentIndividualAtom) element
rule DifferentIndividualsAtom {
	from i : RDM!Atom (
			i.name = 'DifferentIndividualAtom'
		)
	to o : XML!Element (
		name <- 'swrlx:differentIndividualsAtom',
		children <- Sequence { i.terms->asSequence()->select(c | c.oclIsTypeOf(RDM!IndividualVariable))->collect(e | thisModule.IndividualVariable(e)),
							   i.terms->asSequence()->select(c | not c.oclIsTypeOf(RDM!IndividualVariable))
							 }
		)
}

-- Rule 'BuiltinAtom'
-- Create XML Element (swrlx:builtinAtom) element from the RDM Atom (BuiltinAtom) element
rule BuiltinAtom {
	from i : RDM!Atom (
			i.name = 'BulitinAtom'
		)
	to o : XML!Element (
		name <- 'swrlx:builtinAtom',
		children <- Sequence { attr, 
							   i.terms->asSequence()->select(c | c.oclIsTypeOf(RDM!DataVariable))->collect(e | thisModule.DataVariable(e)),
							   i.terms->asSequence()->select(c | c.oclIsTypeOf(RDM!IndividualVariable))->collect(e | thisModule.IndividualVariable(e)),
							   i.terms->asSequence()->select(c | not c.oclIsTypeOf(RDM!DataVariable) and not c.oclIsTypeOf(RDM!IndividualVariable))
							 }
		),
	attr : XML!Attribute (
		name <- 'swrlx:builtin',
		value <- i.hasPredicateSymbol.buildInID
		)
}

-- Lazy Rule 'DataVariable'
-- Create XML Element element (ruleml:var) from the RDM DataVariable element
lazy rule DataVariable {
	from i : RDM!DataVariable
	to o : XML!Element (
		name <- 'ruleml:var',
		children <- Sequence { txt }
		),
	txt : XML!Text (
		name <- '#text',
		value <- i.name
		)
}

-- Lazy Rule 'Individual'
-- Create XML Element element (owlx:Individual) from the RDM Individual element
rule Individual {
	from i : RDM!Individual (
			i.oclIsTypeOf(RDM!Individual)
		)
	to o : XML!Element (
		name <- 'owlx:Individual',
		children <- Sequence { attr }
		),
	attr : XML!Attribute (
		name <- 'owlx:name',
		value <- i.name
		)
}

-- Rule 'DataType'
-- Create XML Element element (owlx:Datatype) from the RDM DataRange element
rule DataType {
	from i : RDM!DataRange (
			not	i.datatype.oclIsUndefined()
		)
	to o : XML!Element (
		name <- 'owlx:Datatype',
		children <- Sequence { attr }
		),
	attr : XML!Attribute (
		name <- 'owlx:name',
		value <- i.datatype.name
		)
}

-- Rule 'DataValue'
-- Create XML Element element (owlx:DataValue) from the RDM DataValue element
rule DataValue {
	from i : RDM!DataValue (
			i.oclIsTypeOf(RDM!DataValue)
		)
	to o : XML!Element (
		name <- 'owlx:DataValue',
		children <- Sequence { attr, txt }
		),
	attr : XML!Attribute (
		name <- 'owlx:datatype',
		value <- i.type.name
		),
	txt : XML!Text (
		name <- '#text',
		value <- i.value
		)
}

-- Rule 'TypedLiteralOfDataRange'
-- Create XML Element element (owlx:DataValue) from the RDM TypedLiteral element
rule TypedLiteralOfDataRange {
	from i : RDM!TypedLiteral (
			RDM!DataRange.allInstancesFrom('IN')->asSequence()->collect(c | c.oneOf)->flatten()->includes(i)
		)
	to o : XML!Element (
		name <- 'owlx:DataValue',
		children <- Sequence { attr, txt }
		),
	attr : XML!Attribute (
		name <- 'owlx:datatype',
		value <- i.theType
		),
	txt : XML!Text (
		name <- '#text',
		value <- i.lexicalForm
		)
}

-- Rule 'IntersectionOf'
-- Create XML Element element (owlx:IntersectionOf) from the RDM IntersectionClass element
rule IntersectionOf {
	from i : RDM!IntersectionClass (
			i.oclIsTypeOf(RDM!IntersectionClass)
		)
	to o : XML!Element (
		name <- 'owlx:IntersectionOf',
 		children <- Sequence { i.intersectionOf->asSequence()->select(c | c.oclIsTypeOf(RDM!Class))->collect(c | thisModule.Class(c)),
							   i.intersectionOf->asSequence()->select(c | not c.oclIsTypeOf(RDM!Class) and c.oclIsKindOf(RDM!Restriction))->collect(e | e.onProperty)->flatten(),
							   i.intersectionOf->asSequence()->select(c | not c.oclIsTypeOf(RDM!Class) and not c.oclIsKindOf(RDM!Restriction))
							}
		)
}

-- Rule 'UnionOf'
-- Create XML Element element (owlx:UnionOf) from the RDM UnionClass element
rule UnionOf {
	from i : RDM!UnionClass (
			i.oclIsTypeOf(RDM!UnionClass)
		)
	to o : XML!Element (
		name <- 'owlx:UnionOf',
 		children <- Sequence { i.unionOf->asSequence()->select(c | c.oclIsTypeOf(RDM!Class))->collect(c | thisModule.Class(c)),
							   i.unionOf->asSequence()->select(c | not c.oclIsTypeOf(RDM!Class) and c.oclIsKindOf(RDM!Restriction))->collect(e | e.onProperty)->flatten(),
							   i.unionOf->asSequence()->select(c | not c.oclIsTypeOf(RDM!Class) and not c.oclIsKindOf(RDM!Restriction))
							}
		)
}

-- Rule 'ComplementOf'
-- Create XML Element element (owlx:ComplementOf) from the RDM ComplementClass element
rule ComplementOf {
	from i : RDM!ComplementClass (
			i.oclIsTypeOf(RDM!ComplementClass)
		)
	to o : XML!Element (
		name <- 'owlx:ComplementOf',
 		children <- Sequence { if i.complementOf.oclIsTypeOf(RDM!Class) then
								thisModule.Class(i.complementOf)
								else
									if i.complementOf.oclIsKindOf(RDM!Restriction) then
										i.complementOf.onProperty
									else
										i.complementOf
									endif
							   endif
 							 }
		)
}

-- Rule 'SomeValuesFromAttrClass'
-- Create XML Element element (owlx:someValuesFrom) from the RDM SomeValuesFromRestriction element
rule SomeValuesFromAttrClass {
	from i : RDM!SomeValuesFromRestriction (
			if not i.someValuesFromClass.oclIsUndefined()
				then i.someValuesFromClass.oclIsTypeOf(RDM!Class)
				else false
			endif
		)
	to	someValuesFrom : XML!Element (
		name <- 'owlx:someValuesFrom',
		children <- Sequence { class }
		),
	class : XML!Attribute (
		name <- 'owlx:class',
		value <- i.someValuesFromClass.name
		)
}

-- Rule 'SomeValuesFromElemClass'
-- Create XML Element element (owlx:someValuesFrom) from the RDM SomeValuesFromRestriction element
rule SomeValuesFromElemClass {
	from i : RDM!SomeValuesFromRestriction (
			if not i.someValuesFromClass.oclIsUndefined()
				then if not i.someValuesFromClass.oclIsTypeOf(RDM!Class) and  not i.someValuesFromClass.oclIsTypeOf(RDM!UnionClass) then
						true
					else false
					endif
				else false
			endif
		)
	to someValuesFrom : XML!Element (
		name <- 'owlx:someValuesFrom',
		children <- i.someValuesFromClass
		)
}


-- Rule 'SomeValuesFromChild'
-- Create XML Element element (owlx:someValuesFrom) from the RDM SomeValuesFromRestriction element
rule SomeValuesFromChild {
	from i : RDM!SomeValuesFromRestriction (
			if not i.someValuesFromClass.oclIsUndefined()
				then i.someValuesFromClass.oclIsTypeOf(RDM!UnionClass)
				else false
			endif
		)
	to someValuesFrom : XML!Element (
		name <- 'owlx:someValuesFrom',
		children <- Sequence { i.someValuesFromClass.unionOf->asSequence()->select(c | c.oclIsTypeOf(RDM!Class))->collect(c | thisModule.Class(c)),
							   i.someValuesFromClass.unionOf->asSequence()->select(c | not c.oclIsTypeOf(RDM!Class))
							 }
		)
}

-- Rule 'SomeValuesFromAttrDatatype'
-- Create XML Element element (owlx:someValuesFrom) from the RDM SomeValuesFromRestriction element
rule SomeValuesFromAttrDatatype {
	from i : RDM!SomeValuesFromRestriction (
			if not i.someValuesFromRange.oclIsUndefined()
				then i.someValuesFromRange.oclIsTypeOf(RDM!DataRange)
				else false
			endif
		)
	to someValuesFrom : XML!Element (
		name <- 'owlx:someValuesFrom',
		children <- Sequence { datatype }
		),
	datatype : XML!Attribute (
		name <- 'owlx:datatype',
		value <- i.someValuesFromRange.datatype.name
		)
}

-- Rule 'AllValuesFromAttrClass'
-- Create XML Element element (owlx:allValuesFrom) from the RDM AllValuesFromRestriction element
rule AllValuesFromAttrClass {
	from i : RDM!AllValuesFromRestriction (
			if not i.allValuesFromClass.oclIsUndefined()
				then i.allValuesFromClass.oclIsTypeOf(RDM!Class)
				else false
			endif
		)
	to allValuesFrom : XML!Element (
		name <- 'owlx:allValuesFrom',
		children <- Sequence { class }
		),
	class : XML!Attribute (
		name <- 'owlx:class',
		value <- i.allValuesFromClass.name
		)
}

-- Rule 'AllValuesFromAttrDatatype'
-- Create XML Element element (owlx:allValuesFrom) from the RDM AllValuesFromRestriction element
rule AllValuesFromAttrDatatype {
	from i : RDM!AllValuesFromRestriction (
			if not i.allValuesFromRange.oclIsUndefined()
				then i.allValuesFromRange.oclIsTypeOf(RDM!DataRange)
				else false
			endif
		)
	to allValuesFrom : XML!Element (
		name <- 'owlx:allValuesFrom',
		children <- Sequence { datatype }
		),
	datatype : XML!Attribute (
		name <- 'owlx:datatype',
		value <- i.allValuesFromRange.datatype.name
		)
}

-- Rule 'AllValuesFromElemClass'
-- Create XML Element element (owlx:allValuesFrom) from the RDM AllValuesFromRestriction element
rule AllValuesFromElemClass {
	from i : RDM!AllValuesFromRestriction (
			if not i.allValuesFromClass.oclIsUndefined()
				then if not i.allValuesFromClass.oclIsTypeOf(RDM!Class) and not i.someValuesFromClass.oclIsTypeOf(RDM!UnionClass) then
						true
					else false
					endif
				else false
			endif
		)
	to allValuesFrom : XML!Element (
		name <- 'owlx:allValuesFrom',
		children <- i.allValuesFromClass
		)
}

-- Rule 'AllValuesFromChild'
-- Create XML Element element (owlx:allValuesFrom) from the RDM AllValuesFromRestriction element
rule AllValuesFromChild {
	from i : RDM!AllValuesFromRestriction (
			if not i.allValuesFromClass.oclIsUndefined()
				then i.allValuesFromClass.oclIsTypeOf(RDM!UnionClass)
				else false
			endif
		)
	to allValuesFrom : XML!Element (
		name <- 'owlx:allValuesFrom',
		children <- Sequence { i.allValuesFromClass.unionOf->asSequence()->select(c | c.oclIsTypeOf(RDM!Class))->collect(c | thisModule.Class(c)),
							   i.allValuesFromClass.unionOf->asSequence()->select(c | not c.oclIsTypeOf(RDM!Class))
							 }
		)
}

-- Rule 'HasValueObject'
-- Create XML Element element (owlx:hasValue) from the RDM HasValueRestriction element
rule HasValueObject {
	from i : RDM!HasValueRestriction (
			if not i.hasValue.oclIsUndefined() then
				i.hasValue.oclIsTypeOf(RDM!Individual)
			else false
			endif
		)
	to hasValue : XML!Element (
		name <- 'owlx:hasValue',
		children <- Sequence { hattr }
		),
	hattr : XML!Attribute (
		name <- 'owlx:name',
		value <- i.hasValue.name
		)
}

-- Rule 'HasValueData'
-- Create XML Element element (owlx:hasValue) from the RDM HasValueRestriction element
rule HasValueData {
	from i : RDM!HasValueRestriction (
			if not i.hasLiteralValue.oclIsUndefined() then
				i.hasLiteralValue.oclIsKindOf(RDM!Literal)
			else false
			endif
		)
	to hasValue : XML!Element (
		name <- 'owlx:hasValue',
		children <- Sequence { hattr }
		),
	hattr : XML!Attribute (
		name <- 'owlx:name',
		value <- i.hasLiteralValue.lexicalForm
		)
}

-- Rule 'CardinalityRestriction'
-- Create XML Element element (owlx:cardinality) from the RDM CardinalityRestriction element
rule CardinalityRestriction {
	from i : RDM!CardinalityRestriction (
			i.oclIsTypeOf(RDM!CardinalityRestriction)
		)
	to o : XML!Element (
		name <- 'owlx:cardinality',
		children <- Sequence { attr } 
		),
	attr : XML!Attribute (
		name <- 'owlx:value',
		value <- i.cardinality.lexicalForm
		)
}

-- Rule 'MinCardinalityRestriction'
-- Create XML Element element (owlx:minCardinality) from the RDM MinCardinalityRestriction element
rule MinCardinalityRestriction {
	from i : RDM!MinCardinalityRestriction (
			i.oclIsTypeOf(RDM!MinCardinalityRestriction)
		)
	to o : XML!Element (
		name <- 'owlx:minCardinality',
		children <- Sequence { attr } 
		),
	attr : XML!Attribute (
		name <- 'owlx:value',
		value <- i.minCardinality.lexicalForm
		)
}

-- Rule 'MaxCardinalityRestriction'
-- Create XML Element element (owlx:maxCardinality) from the RDM MaxCardinalityRestriction element
rule MaxCardinalityRestriction {
	from i : RDM!MaxCardinalityRestriction (
			i.oclIsTypeOf(RDM!MaxCardinalityRestriction)
		)
	to o : XML!Element (
		name <- 'owlx:maxCardinality',
		children <- Sequence { attr } 
		),
	attr : XML!Attribute (
		name <- 'owlx:value',
		value <- i.maxCardinality.lexicalForm
		)
}

-- Rule 'ObjectRestriction'
-- Create XML Element element (owlx:ObjectRestriction) from the RDM ObjectProperty element
rule ObjectRestriction {
	from i : RDM!ObjectProperty (
			i.oclIsTypeOf(RDM!ObjectProperty) and
			RDM!Atom.allInstancesFrom('IN')->asSequence()->collect(c | c.hasPredicateSymbol)->flatten()->excludes(i)
		)
	to o : XML!Element (
		name <- 'owlx:ObjectRestriction',
		children <- Sequence { attr , i.elementsForProperty }
		),
	attr : XML!Attribute (
		name <- 'owlx:property',
		value <- i.name
		)
}
		
-- Rule 'DataRestriction'
-- Create XML Element element (owlx:DataRestriction) from the RDM DatatypeProperty element
rule DataRestriction {
	from i : RDM!DatatypeProperty (
			i.oclIsTypeOf(RDM!DatatypeProperty) and
			RDM!Atom.allInstancesFrom('IN')->asSequence()->collect(c | c.hasPredicateSymbol)->flatten()->excludes(i)
		)
	to o : XML!Element (
		name <- 'owlx:DataRestriction',
		children <- Sequence { attr , i.elementsForProperty }
		),
	attr : XML!Attribute (
		name <- 'owlx:property',
		value <- i.name
		)
}

-- Lazy Rule 'Class'
-- Create XML Element element (owlx:Class) from the RDM Class element
lazy rule Class {
	from i : RDM!Class 
	to o : XML!Element (
		name <- 'owlx:Class',
		children <- Sequence { attr, i.subClassOf->select(c | c.oclIsKindOf(RDM!Restriction))->collect(c | c.onProperty)->flatten(),
									 i.subClassOf->select(c | not c.oclIsKindOf(RDM!Restriction))
					}
		),
	attr : XML!Attribute (
		name <- 'owlx:name', 
		value <- i.name
		)
}

-- Lazy Rule 'IndividualVariable'
-- Create XML Element element (ruleml:var) from the RDM IndividualVariable element
lazy rule IndividualVariable {
	from i : RDM!IndividualVariable
	to o : XML!Element (
		name <- 'ruleml:var',
		children <- Sequence { txt }
		),
	txt : XML!Text (
		name <- '#text',
		value <- i.name
		)
}

-- Rule 'OneOfIndividual'
-- Create XML Element element (owlx:OneOf) from the RDM EnumeratedClass element
rule OneOfIndividual {
	from i : RDM!EnumeratedClass (
			i.oclIsTypeOf(RDM!EnumeratedClass)
		)
	to o : XML!Element (
		name <- 'owlx:OneOf',
		children <- i.oneOf
		)
}

-- Rule 'OneOfDataValue'
-- Create XML Element element (owlx:OneOf) from the RDM DataRange element
rule OneOfDataValue {
	from i : RDM!DataRange (
			i.oneOf->size() > 0
		)
	to o : XML!Element (
		name <- 'owlx:OneOf',
		children <- i.oneOf
		)
}",transform rdm swrl owl metamodel xml metamodel creat part m sc these good old ai laboratori author milan milanov milan milanov org work swrl v xml syntax licenc gnu general public licens version modul rdm xml modul templat creat out xml in rdm use string helper helper elementsforproperti return restrict inerhit element restrict properti work object data properti context rdm properti out sequenc rdm restrict helper context rdm properti def elementsforproperti sequenc rdm restrict rdm restrict allinstancesfrom in assequ select c c onproperti includ self assequ rule rule ontolog creat xml root element rdm ontolog element rule ontolog rdm ontolog oclistypeof rdm ontolog xml root children sequenc attr element name swrlx ontolog attr xml attribut name swrlx name valu ontolog rule ruleon creat xml root element rdm rule element rule ruleon rdm rule oclistypeof rdm rule rdm ontolog allinstancesfrom in assequ size xml root name ruleml imp children sequenc owlxn swrlxns rulemln hasanteced hasconsequ owlxn xml attribut name xmlns owlx valu http www w org owl xml swrlxns xml attribut name xmlns swrlx valu http www w org swrlx rulemln xml attribut name xmlns ruleml valu http www w org ruleml rule rulemorethanon creat xml element ruleml imp element rdm rule element rule rulemorethanon rdm rule oclistypeof rdm rule rdm rule allinstancesfrom in assequ size rdm ontolog allinstancesfrom in assequ size xml element name ruleml imp children sequenc owlxn swrlxns rulemln hasanteced hasconsequ owlxn xml attribut name xmlns owlx valu http www w org owl xml swrlxns xml attribut name xmlns swrlx valu http www w org swrlx rulemln xml attribut name xmlns ruleml valu http www w org ruleml rule consequ creat xml element ruleml head element rdm consequ element rule consequ rdm consequ oclistypeof rdm consequ xml element name ruleml head annot this atom consequ anteced e g two classatom two datatypepredicateatom children let thisrul rdm rule rdm rule allinstancesfrom in assequ select c c hasconsequ first containsatom assequ select c thisrul hasanteced containsatom exclud c assequ rule anteced creat xml element ruleml bodi element rdm anteced element rule anteced rdm anteced oclistypeof rdm anteced xml element name ruleml bodi children containsatom atom rule individualpropertyatom creat xml element swrlx individualpropertyatom element rdm atom individualpropertyatom element rule individualpropertyatom rdm atom name individualpropertyatom xml element name swrlx individualpropertyatom children sequenc prop term select c c oclistypeof rdm individualvari collect c thismodul individualvari c term select c c oclistypeof rdm individualvari prop xml attribut name swrlx properti valu haspredicatesymbol name rule classatom creat xml element swrlx classatom element rdm atom classatom element rule classatom rdm atom name classatom xml element name swrlx classatom children sequenc haspredicatesymbol oclistypeof rdm class thismodul class haspredicatesymbol els haspredicatesymbol ocliskindof rdm restrict haspredicatesymbol onproperti els haspredicatesymbol endif endif term assequ select c c oclistypeof rdm individualvari collect e thismodul individualvari e term assequ select c c oclistypeof rdm individualvari rule datarangeatom creat xml element swrlx datarangeatom element rdm atom datarangeatom element rule datarangeatom rdm atom name datarangeatom xml element name swrlx datarangeatom children sequenc haspredicatesymbol ocliskindof rdm restrict haspredicatesymbol onproperti els haspredicatesymbol endif term assequ select c c oclistypeof rdm individualvari collect e thismodul individualvari e term assequ select c c oclistypeof rdm individualvari rule datavaluedpropertyatom creat xml element swrlx datavaluedpropertyatom element rdm atom datavaluedpropertyatom element rule datavaluedpropertyatom rdm atom name datavaluedpropertyatom xml element name swrlx datavaluedpropertyatom children sequenc prop term assequ select c c oclistypeof rdm individualvari collect e thismodul individualvari e term assequ select c c oclistypeof rdm datavari collect e thismodul datavari e term assequ select c c oclistypeof rdm individualvari c oclistypeof rdm datavari prop xml attribut name swrlx properti valu haspredicatesymbol name rule sameindividualatom creat xml element swrlx sameindividualatom element rdm atom sameindividualatom element rule sameindividualatom rdm atom name sameindividualatom xml element name swrlx sameindividualatom children sequenc term assequ select c c oclistypeof rdm individualvari collect e thismodul individualvari e term assequ select c c oclistypeof rdm individualvari rule differentindividualatom creat xml element swrlx differentindividualsatom element rdm atom differentindividualatom element rule differentindividualsatom rdm atom name differentindividualatom xml element name swrlx differentindividualsatom children sequenc term assequ select c c oclistypeof rdm individualvari collect e thismodul individualvari e term assequ select c c oclistypeof rdm individualvari rule builtinatom creat xml element swrlx builtinatom element rdm atom builtinatom element rule builtinatom rdm atom name bulitinatom xml element name swrlx builtinatom children sequenc attr term assequ select c c oclistypeof rdm datavari collect e thismodul datavari e term assequ select c c oclistypeof rdm individualvari collect e thismodul individualvari e term assequ select c c oclistypeof rdm datavari c oclistypeof rdm individualvari attr xml attribut name swrlx builtin valu haspredicatesymbol buildinid lazi rule datavari creat xml element element ruleml var rdm datavari element lazi rule datavari rdm datavari xml element name ruleml var children sequenc txt txt xml text name text valu name lazi rule individu creat xml element element owlx individu rdm individu element rule individu rdm individu oclistypeof rdm individu xml element name owlx individu children sequenc attr attr xml attribut name owlx name valu name rule datatyp creat xml element element owlx datatyp rdm datarang element rule datatyp rdm datarang datatyp oclisundefin xml element name owlx datatyp children sequenc attr attr xml attribut name owlx name valu datatyp name rule datavalu creat xml element element owlx datavalu rdm datavalu element rule datavalu rdm datavalu oclistypeof rdm datavalu xml element name owlx datavalu children sequenc attr txt attr xml attribut name owlx datatyp valu type name txt xml text name text valu valu rule typedliteralofdatarang creat xml element element owlx datavalu rdm typedliter element rule typedliteralofdatarang rdm typedliter rdm datarang allinstancesfrom in assequ collect c c oneof flatten includ xml element name owlx datavalu children sequenc attr txt attr xml attribut name owlx datatyp valu thetyp txt xml text name text valu lexicalform rule intersectionof creat xml element element owlx intersectionof rdm intersectionclass element rule intersectionof rdm intersectionclass oclistypeof rdm intersectionclass xml element name owlx intersectionof children sequenc intersectionof assequ select c c oclistypeof rdm class collect c thismodul class c intersectionof assequ select c c oclistypeof rdm class c ocliskindof rdm restrict collect e e onproperti flatten intersectionof assequ select c c oclistypeof rdm class c ocliskindof rdm restrict rule unionof creat xml element element owlx unionof rdm unionclass element rule unionof rdm unionclass oclistypeof rdm unionclass xml element name owlx unionof children sequenc unionof assequ select c c oclistypeof rdm class collect c thismodul class c unionof assequ select c c oclistypeof rdm class c ocliskindof rdm restrict collect e e onproperti flatten unionof assequ select c c oclistypeof rdm class c ocliskindof rdm restrict rule complementof creat xml element element owlx complementof rdm complementclass element rule complementof rdm complementclass oclistypeof rdm complementclass xml element name owlx complementof children sequenc complementof oclistypeof rdm class thismodul class complementof els complementof ocliskindof rdm restrict complementof onproperti els complementof endif endif rule somevaluesfromattrclass creat xml element element owlx somevaluesfrom rdm somevaluesfromrestrict element rule somevaluesfromattrclass rdm somevaluesfromrestrict somevaluesfromclass oclisundefin somevaluesfromclass oclistypeof rdm class els fals endif somevaluesfrom xml element name owlx somevaluesfrom children sequenc class class xml attribut name owlx class valu somevaluesfromclass name rule somevaluesfromelemclass creat xml element element owlx somevaluesfrom rdm somevaluesfromrestrict element rule somevaluesfromelemclass rdm somevaluesfromrestrict somevaluesfromclass oclisundefin somevaluesfromclass oclistypeof rdm class somevaluesfromclass oclistypeof rdm unionclass true els fals endif els fals endif somevaluesfrom xml element name owlx somevaluesfrom children somevaluesfromclass rule somevaluesfromchild creat xml element element owlx somevaluesfrom rdm somevaluesfromrestrict element rule somevaluesfromchild rdm somevaluesfromrestrict somevaluesfromclass oclisundefin somevaluesfromclass oclistypeof rdm unionclass els fals endif somevaluesfrom xml element name owlx somevaluesfrom children sequenc somevaluesfromclass unionof assequ select c c oclistypeof rdm class collect c thismodul class c somevaluesfromclass unionof assequ select c c oclistypeof rdm class rule somevaluesfromattrdatatyp creat xml element element owlx somevaluesfrom rdm somevaluesfromrestrict element rule somevaluesfromattrdatatyp rdm somevaluesfromrestrict somevaluesfromrang oclisundefin somevaluesfromrang oclistypeof rdm datarang els fals endif somevaluesfrom xml element name owlx somevaluesfrom children sequenc datatyp datatyp xml attribut name owlx datatyp valu somevaluesfromrang datatyp name rule allvaluesfromattrclass creat xml element element owlx allvaluesfrom rdm allvaluesfromrestrict element rule allvaluesfromattrclass rdm allvaluesfromrestrict allvaluesfromclass oclisundefin allvaluesfromclass oclistypeof rdm class els fals endif allvaluesfrom xml element name owlx allvaluesfrom children sequenc class class xml attribut name owlx class valu allvaluesfromclass name rule allvaluesfromattrdatatyp creat xml element element owlx allvaluesfrom rdm allvaluesfromrestrict element rule allvaluesfromattrdatatyp rdm allvaluesfromrestrict allvaluesfromrang oclisundefin allvaluesfromrang oclistypeof rdm datarang els fals endif allvaluesfrom xml element name owlx allvaluesfrom children sequenc datatyp datatyp xml attribut name owlx datatyp valu allvaluesfromrang datatyp name rule allvaluesfromelemclass creat xml element element owlx allvaluesfrom rdm allvaluesfromrestrict element rule allvaluesfromelemclass rdm allvaluesfromrestrict allvaluesfromclass oclisundefin allvaluesfromclass oclistypeof rdm class somevaluesfromclass oclistypeof rdm unionclass true els fals endif els fals endif allvaluesfrom xml element name owlx allvaluesfrom children allvaluesfromclass rule allvaluesfromchild creat xml element element owlx allvaluesfrom rdm allvaluesfromrestrict element rule allvaluesfromchild rdm allvaluesfromrestrict allvaluesfromclass oclisundefin allvaluesfromclass oclistypeof rdm unionclass els fals endif allvaluesfrom xml element name owlx allvaluesfrom children sequenc allvaluesfromclass unionof assequ select c c oclistypeof rdm class collect c thismodul class c allvaluesfromclass unionof assequ select c c oclistypeof rdm class rule hasvalueobject creat xml element element owlx hasvalu rdm hasvaluerestrict element rule hasvalueobject rdm hasvaluerestrict hasvalu oclisundefin hasvalu oclistypeof rdm individu els fals endif hasvalu xml element name owlx hasvalu children sequenc hattr hattr xml attribut name owlx name valu hasvalu name rule hasvaluedata creat xml element element owlx hasvalu rdm hasvaluerestrict element rule hasvaluedata rdm hasvaluerestrict hasliteralvalu oclisundefin hasliteralvalu ocliskindof rdm liter els fals endif hasvalu xml element name owlx hasvalu children sequenc hattr hattr xml attribut name owlx name valu hasliteralvalu lexicalform rule cardinalityrestrict creat xml element element owlx cardin rdm cardinalityrestrict element rule cardinalityrestrict rdm cardinalityrestrict oclistypeof rdm cardinalityrestrict xml element name owlx cardin children sequenc attr attr xml attribut name owlx valu valu cardin lexicalform rule mincardinalityrestrict creat xml element element owlx mincardin rdm mincardinalityrestrict element rule mincardinalityrestrict rdm mincardinalityrestrict oclistypeof rdm mincardinalityrestrict xml element name owlx mincardin children sequenc attr attr xml attribut name owlx valu valu mincardin lexicalform rule maxcardinalityrestrict creat xml element element owlx maxcardin rdm maxcardinalityrestrict element rule maxcardinalityrestrict rdm maxcardinalityrestrict oclistypeof rdm maxcardinalityrestrict xml element name owlx maxcardin children sequenc attr attr xml attribut name owlx valu valu maxcardin lexicalform rule objectrestrict creat xml element element owlx objectrestrict rdm objectproperti element rule objectrestrict rdm objectproperti oclistypeof rdm objectproperti rdm atom allinstancesfrom in assequ collect c c haspredicatesymbol flatten exclud xml element name owlx objectrestrict children sequenc attr elementsforproperti attr xml attribut name owlx properti valu name rule datarestrict creat xml element element owlx datarestrict rdm datatypeproperti element rule datarestrict rdm datatypeproperti oclistypeof rdm datatypeproperti rdm atom allinstancesfrom in assequ collect c c haspredicatesymbol flatten exclud xml element name owlx datarestrict children sequenc attr elementsforproperti attr xml attribut name owlx properti valu name lazi rule class creat xml element element owlx class rdm class element lazi rule class rdm class xml element name owlx class children sequenc attr subclassof select c c ocliskindof rdm restrict collect c c onproperti flatten subclassof select c c ocliskindof rdm restrict attr xml attribut name owlx name valu name lazi rule individualvari creat xml element element ruleml var rdm individualvari element lazi rule individualvari rdm individualvari xml element name ruleml var children sequenc txt txt xml text name text valu name rule oneofindividu creat xml element element owlx oneof rdm enumeratedclass element rule oneofindividu rdm enumeratedclass oclistypeof rdm enumeratedclass xml element name owlx oneof children oneof rule oneofdatavalu creat xml element element owlx oneof rdm datarang element rule oneofdatavalu rdm datarang oneof size xml element name owlx oneof children oneof,6
149,149,P66-XML2R2ML.atl,"-- ============================================================
-- Transforms an XML metamodel into a R2ML metamodel.
-- Created as part of M.Sc. theses at GOOD OLD AI Laboratory
-- Author: Milan Milanovic (milan at milanovic.org)
-- Works for R2ML XML Schema and Metamodel v0.4
-- Licence: GNU General Public License, version 2
-- ============================================================

module XML2R2ML;
create OUT : R2ML from IN : XML;

uses strings;
uses XMLHelpers; -- General XML metamodel helpers

-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- XML2R2ML Transformation specific XML helpers

-- HELPER:	isNegated()
-- Returns a boolean that statement is XML!Element attribute XML!Attribute with name 'r2ml:isNegated' is true or false
-- contextual XML!Element.
-- CONTEXT:	XML!Element
-- OUT:		Boolean
helper context XML!Element def: isNegated() : Boolean =
	let collection : Sequence(XML!Attribute) = self.children->select(c | c.oclIsKindOf(XML!Attribute) and c.name = 'r2ml:isNegated') in
	if collection->isEmpty()
	then
		false
	else -- not empty
		let val : String = kolekcija->first().value in
		if val = 'true'
		then
			true
		else 
			false
		endif
	endif;

-- HELPER:	getAllRules()
-- Returns a sequence of all XML elements which name is IntegrityRule of DerivationRule
-- CONTEXT:	thisModule
-- OUT:		Sequence of XML elements
-- TODO: Add other type of rules
helper def: getAllRules() : Sequence(XML!Element) = 
	XML!Element.allInstances()->select(e | e.name = 'r2ml:AlethicIntegrityRule' or e.name = 'r2ml:DeonticIntegrityRule' or e.name = 'r2ml:DerivationRule')->asSequence();

-- HELPER: allSubElements
-- Returns a sequence of all XML sub elements for XML element, recursivelly
-- from this element to last element (children)
-- ANNOTATION: Based on ""Transforming Models with ATL"", Frederic Jouault, Ivan Kurtev.
-- CONTEXT:	XML!Element
-- OUT:		Sequence of XML elements
helper context XML!Element def : allSubElements : Sequence(XML!Element) = 
	let subElems : Sequence(XML!Element) = 
		XML!Element.allInstances()->select(c |      			-- 1. get all elements with this parent
			c.parent = self
		)->collect(elems | elems.allSubElements)->flatten()  in -- 2. for every element get subelements
		subElems->union( 										-- 3. when all subelements are apprehended 
																--    for every element, add topmost elements (child of this parent).
			self.children->select(ch | ch.oclIsTypeOf(XML!Element)
	    ))->flatten();

-- HELPER: allSubAttributes
-- Returns a sequence of all XML sub attributes for XML element, recursivelly
-- from this attribute to last attribute (children)
-- CONTEXT:	XML!Element
-- OUT:		Sequence of XML attributes
helper context XML!Element def : allSubAttributes : Sequence(XML!Attribute) = 
	let subAttrs : Sequence(XML!Attribute) = 
    	XML!Element.allInstances()->select(c | 
        	c.parent = self
		)->collect(attrs | attrs.allSubAttributes)->flatten()  in
		subAttrs->union(
			self.children->select(at | at.oclIsTypeOf(XML!Attribute)
		))->flatten();

-- HELPER: getRuleForElement()
-- Returns XML element (Rule, Integrity of Derivation) which contains context-ual XML element
-- CONTEXT:	XML!Element
-- OUT:		XML element
helper context XML!Element def: getRuleForElement() : XML!Element = 
	thisModule.getAllRules()->select(c | c.allSubElements->includes(self))->asSequence()->first();

-- HELPER: getRuleForAttribute()
-- Returns XML element (Rule, Integrity of Derivation) which contains context-ual XML attribute
-- CONTEXT:	XML!Attribute
-- OUT:		XML element
helper context XML!Attribute def: getRuleForAttribute() : XML!Element = 
	thisModule.getAllRules()->select(c | c.allSubAttributes->includes(self))->asSequence()->first();

-- HELPER:	getDefaultObjectVariable()
-- Return always first ObjectVariable with value
-- This is necessary for unique lazy rule that creates just one 
-- output ObjectVariable for multiple input (with same value)
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		XML!Element
helper def: getDefaultObjectVariable(elem : XML!Element, value: String) : XML!Element = 
	let objVar : Sequence(XML!Element) = elem.getRuleForElement().allSubElements->select(e | e.name = 'r2ml:ObjectVariable')->select(e | e.getAttrVal('r2ml:name') = value and e.hasAttr('r2ml:classID'))->asSequence() in 
	if objVar->isEmpty() then
		elem.getRuleForElement().allSubElements->select(e | e.name = 'r2ml:ObjectVariable')->select(e | e.getAttrVal('r2ml:name') = value)->asSequence()->first()
	else objVar->first()
	endif;

-- HELPER:	getDefaultDataVariable()
-- Same as previous but for Data variable
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		XML!Element
helper def: getDefaultDataVariable(elem: XML!Element, value: String) : XML!Element = 
	elem.getRuleForElement().allSubElements->select(e | e.name = 'r2ml:DataVariable')->select(e | e.getAttrVal('r2ml:name') = value)->asSequence()->first();

-- HELPER:	getDefaultGenericVariable()
-- Same as previous but for Variable
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		XML!Element
helper def: getDefaultGenericVariable(elem : XML!Element, value: String) : XML!Element = 
	elem.getRuleForElement().allSubElements->select(e | e.name = 'r2ml:Variable' or e.name = 'r2ml:GenericVariable')->select(e | e.getAttrVal('r2ml:name') = value)->asSequence()->first();
	
-- HELPER:	getDefaultGenericPredicate()
-- Always returns first predicate associated with GenericAtom
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		XML!Attribute
helper def: getDefaultGenericPredicate(attr : XML!Attribute, value: String) : XML!Attribute = 
	attr.getRuleForAttribute().allSubAttributes->select(e | e.name = 'r2ml:predicateID')->select(e | e.value = value)->asSequence()->first();

-- HELPER:	getDefaultAttribute()
-- Always returns first attribute associated with term
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		XML!Attribute
helper def: getDefaultAttribute(attr : XML!Attribute, value: String) : XML!Attribute = 
	attr.getRuleForAttribute().allSubAttributes->select(e | e.name = 'r2ml:attributeID')->select(e | e.value = value)->asSequence()->first();

-- HELPER:	getDefaultDataType()
-- Always returns first data type
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		XML!Attribute
helper def: getDefaultDataType(attr : XML!Attribute, value: String) : XML!Attribute = 
	attr.getRuleForAttribute().allSubAttributes->select(e | e.name = 'r2ml:datatypeID' or e.name = 'r2ml:type')->select(e | e.value = value)->asSequence()->first();

-- HELPER:	getAllObjectVariables()
-- Return all Object variables from input file
-- CONTEXT:	thisModule
-- OUT:		Sequence of XML Elements
helper def: getAllObjectVariables() : Sequence(XML!Element) = 
	XML!Element.allInstances()->select(e | e.name = 'r2ml:ObjectVariable');

-- HELPER:	getAllDataVariables()
-- Return all Data variables from input file
-- CONTEXT:	thisModule
-- OUT:		Sequence of XML Elements
helper def: getAllDataVariables() : Sequence(XML!Element) = 
	XML!Element.allInstances()->select(e | e.name = 'r2ml:DataVariable');

-- HELPER:	getAllVariables()
-- Return all Variables from input file
-- CONTEXT:	thisModule
-- OUT:		Sequence of XML Elements
helper def: getAllVariables() : Sequence(XML!Element) = 
	XML!Element.allInstances()->select(e | e.name = 'r2ml:Variable' or e.name = 'r2ml:GenericVariable');

-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'RuleBase'
-- Creates RuleBase from the Root element.
rule RuleBase {
	from
		i : XML!Element (
				i.name = 'r2ml:RuleBase'
			)		
	to
		o : R2ML!RuleBase (                 
				ruleBaseID <- i.getAttrVal('xmlns:r2ml'),
				rules <- i.children->select(c | c.oclIsKindOf(XML!Element))->asSequence()
		)
}

-- Rule 'DerivationRuleSet'
-- Creates DerivationRuleSet from an XML!Element named 'r2ml:DerivationRuleSet'.
rule DerivationRuleSet {
	from
		i : XML!Element(
				i.name = 'r2ml:DerivationRuleSet'
			)
		to
		o : R2ML!DerivationRuleSet (
				rules <- i.children->select(c | c.oclIsKindOf(XML!Element))->asSequence()
		)
}

-- Rule 'IntegrityRuleSet'
-- Creates IntegrityRuleSet from an XML!Element named 'r2ml:IntegrityRuleSet'.
rule IntegrityRuleSet {
	from
		i : XML!Element(
				i.name = 'r2ml:IntegrityRuleSet'
			)
		to
		o : R2ML!IntegrityRuleSet (
				rules <- i.children->select(c | c.oclIsKindOf(XML!Element))->asSequence()
			)		
}

-- Rule 'ReactionRuleSet'
-- Creates ReactionRuleSet from an XML!Element named 'r2ml:ReactionRuleSet'.
rule ReactionRuleSet {
	from
		i : XML!Element(
				i.name = 'r2ml:ReactionRuleSet'
			)
		to
		o : R2ML!ReactionRuleSet (
				rules <- i.children->select(c | c.oclIsKindOf(XML!Element))->asSequence()
			)		
}

-- Rule 'ProductionRuleSet'
-- Creates ProductionRuleSet from an XML!Element named 'r2ml:ProductionRuleSet'.
rule ProductionRuleSet {
	from
		i : XML!Element(
				i.name = 'r2ml:ProductionRuleSet'
			)
		to
		o : R2ML!ProductionRuleSet (
				rules <-  i.children->select(c | c.oclIsKindOf(XML!Element))->asSequence()
			)
}

-- Rule 'AlethicIntegrityRule'
-- Creates AlethicIntegrityRule from an XML!Element named 'r2ml:AlethicIntegrityRule'.
rule AlethicIntegrityRule { 
	from
		i : XML!Element (
				i.name = 'r2ml:AlethicIntegrityRule'
			)
  to
		o : R2ML!AlethicIntegrityRule (
				constraint <- i.getElementsByName('r2ml:constraint')->first().children->select(c | c.oclIsKindOf(XML!Element))->first(),
				ruleID <- if i.hasAttr('r2ml:ruleID') = true then
							i.getAttrVal('r2ml:ruleID')
						  else OclUndefined
						  endif
			)
}

-- Rule 'DeonticIntegrityRule'
-- Creates DeonticIntegrityRule from an XML!Element named 'r2ml:DeonticIntegrityRule'.
rule DeonticIntegrityRule { 
	from
		i : XML!Element (
				i.name = 'r2ml:DeonticIntegrityRule'
			)
  to
		o : R2ML!DeonticIntegrityRule (
				constraint <- i.getElementsByName('r2ml:constraint')->first().children->select(c | c.oclIsKindOf(XML!Element))->first(),
				ruleID <- if i.hasAttr('r2ml:ruleID') = true then
							i.getAttrVal('r2ml:ruleID')
						  else OclUndefined
						  endif
			)
}

-- Rule 'UniversallyQuantifiedFormula'
-- Creates UniversallyQuantifiedFormula from an XML!Element named 'r2ml:UniversallyQuantifiedFormula'.
rule UniversallyQuantifiedFormula {
	from i : XML!Element (
				i.name = 'r2ml:UniversallyQuantifiedFormula'
			)
  to
		o : R2ML!UniversallyQuantifiedFormula (
				-- ANNOTATION: Remark on this first time generating variable, we get ObjectVariable elements (children), then with helper getDefaultObjectVariable we get
				--             always same input element (Variable) with that name, and then call unique lazy rule ObjectVariable() to generate variable.
				variables <- Sequence { i.getElementsByName('r2ml:ObjectVariable')->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
									    i.getElementsByName('r2ml:DataVariable')->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e)) },
				formula <- i.children->select(e | thisModule.getAllDataVariables()->excludes(e) and thisModule.getAllObjectVariables()->excludes(e) and e.oclIsTypeOf(XML!Element))->first()
			)
}

-- Rule 'ExistentiallyQuantifiedFormula'
-- Creates ExistentiallyQuantifiedFormula from an XML!Element named 'r2ml:ExistentiallyQuantifiedFormula'.
rule ExistentiallyQuantifiedFormula {
	from i : XML!Element (
				i.name = 'r2ml:ExistentiallyQuantifiedFormula'
			)
  to
		o : R2ML!ExistentiallyQuantifiedFormula (
				variables <- Sequence { i.getElementsByName('r2ml:ObjectVariable')->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
										i.getElementsByName('r2ml:DataVariable')->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e)) },
				formula <- i.children->select(e | thisModule.getAllDataVariables()->excludes(e) and thisModule.getAllObjectVariables()->excludes(e) and e.oclIsTypeOf(XML!Element))->first()
			)
}

-- Rule 'Implication'
-- Creates Implication from an XML!Element named 'r2ml:Implication'.
rule Implication {
	from i : XML!Element (
				i.name = 'r2ml:Implication'
			)
    to
		o : R2ML!Implication (
				antecedent <- i.getElementsByName('r2ml:antecedent')->first().children->select(c | c.oclIsTypeOf(XML!Element))->asSequence()->first(),
				consequent <- i.getElementsByName('r2ml:consequent')->first().children->select(c | c.oclIsTypeOf(XML!Element))->asSequence()->first()
			)
}

-- Rule 'Conjuction'
-- Creates Conjuction from an XML!Element named 'r2ml:Conjuction'.
rule Conjuction {
	from i : XML!Element (
				i.name = 'r2ml:Conjunction'
			)
    to
		o : R2ML!Conjuction (
				formulas <- i.children->select(c | c.oclIsKindOf(XML!Element))->asSet()
			)
}

-- Rule 'Disjunction'
-- Creates Disjunction from an XML!Element named 'r2ml:Disjunction'.
rule Disjunction {
	from i : XML!Element (
				i.name = 'r2ml:Disjunction'
			)
    to
		o : R2ML!Disjunction (
				formulas <- i.children->select(c | c.oclIsKindOf(XML!Element))->asSet()
			)
}

-- Rule 'NegationAsFailure'
-- Creates NegationAsFailure from an XML!Element named 'r2ml:NegationAsFailure'.
rule NegationAsFailure {
	from i : XML!Element (
				i.name = 'r2ml:NegationAsFailure'
			)
    to
		o : R2ML!NegationAsFailure (
				formula <- i.children->select(c | c.oclIsKindOf(XML!Element))->first()
		)
}

-- Rule 'StrongNegation'
-- Creates StrongNegation from an XML!Element named 'r2ml:StrongNegation'.
rule StrongNegation {
	from i : XML!Element (
				i.name = 'r2ml:StrongNegation'
			)
    to
		o : R2ML!StrongNegation (
				formula <- i.children->select(c | c.oclIsKindOf(XML!Element))->first()
		)
}

-- Rule 'EqualityAtom'
-- Creates EqualityAtom from an XML!Element named 'r2ml:EqualityAtom'.
rule EqualityAtom {
	from i : XML!Element (
				i.name = 'r2ml:EqualityAtom'
			)
    to
		o : R2ML!EqualityAtom (
				terms <- Sequence { i.children->select(c | c.oclIsKindOf(XML!Element) and c.name = 'r2ml:ObjectVariable')->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
									i.children->select(c | c.oclIsKindOf(XML!Element) and c.name <> 'r2ml:ObjectVariable')				
								  }
			)
}

-- Rule 'InequalityAtom'
-- Creates InequalityAtom from an XML!Element named 'r2ml:InequalityAtom'.
rule InequalityAtom {
	from i : XML!Element (
				i.name = 'r2ml:InequalityAtom'
			)
    to
		o : R2ML!InequalityAtom (
				terms <- Sequence { i.children->select(c | c.oclIsKindOf(XML!Element) and c.name = 'r2ml:ObjectVariable')->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
									i.children->select(c | c.oclIsKindOf(XML!Element) and c.name <> 'r2ml:ObjectVariable')				
								  }
			)
}

-- Rule 'DerivationRule'
-- Creates DerivationRule from an XML!Element named 'r2ml:DerivationRule'.
rule DerivationRule { 
	from
		i : XML!Element (
				i.name = 'r2ml:DerivationRule'
			)
  to
		o : R2ML!DerivationRule (
				conditions <- i.getElementsByName('r2ml:conditions')->first().children->select(c | c.oclIsKindOf(XML!Element))->asSequence(),
				conclusions <- i.getElementsByName('r2ml:conclusion')->first(),
				ruleID <- if i.hasAttr('r2ml:ruleID') = true then
							i.getAttrVal('r2ml:ruleID')
						  else OclUndefined
						  endif
	)
}

-- Rule 'LiteralConjuction'
-- Creates atoms from an XML!Element named r2ml:DerivationRule conclusions'.
rule LiteralConjuction {
	from
		i : XML!Element (
				i.name = 'r2ml:conclusion'
			)
	to
		o : R2ML!LiteralConjunction (	     
				atoms <- i.children->select(c | c.oclIsKindOf(XML!Element))->asSet()
			)
}

-- Rule 'ClassRule'
-- Create Class from XML!Attribute 
-- This is lazy rule which is called from other rules
unique lazy rule ClassRule {
	from
		i : XML!Attribute 
	to
		cla : R2ML!Class (
			name <- i.value,
			predicateCategory <- #closed
		)
}

-- Rule 'ObjectClassificationAtom'
-- Creates ObjectClassificationAtom  from an XML!Element named 'r2ml:ObjectClassificationAtom'.
rule ObjectClassificationAtom {
	from i : XML!Element (
			i.name = 'r2ml:ObjectClassificationAtom'
		)
	to 
		obj : R2ML!ObjectClassificationAtom (
			isNegated <- i.isNegated(),
			type <- i.children->select(c | c.oclIsKindOf(XML!Attribute) and c.name = 'r2ml:classID')->collect(e | thisModule.ClassRule(e))->first(),
			term <- i.children->select(c | c.oclIsKindOf(XML!Element) and c.name = 'r2ml:ObjectVariable')->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first()			
		)
}

-- Rule 'DataClassificationAtom'
-- Creates DataClassificationAtom  from an XML!Element named 'r2ml:DataClassificationAtom'.
rule DataClassificationAtom {
	from i : XML!Element (
			i.name = 'r2ml:DataClassificationAtom'
		)
	to 
		obj : R2ML!DataClassificationAtom (
			isNegated <- i.isNegated(),
			type <- thisModule.Datatype(thisModule.getDefaultDataType(i.getAttr('r2ml:datatypeID'), i.getAttrVal('r2ml:datatypeID'))),
			term <- i.children->select(c | c.oclIsKindOf(XML!Element) and c.name = 'r2ml:DataVariable')->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e))->first()			
		)
}

-- Rule 'ObjectVariable'
-- Creates ObjectVariable from an XML!Element named 'r2ml:ObjectVariable'.
-- This rule is unique lazy rule, which means that is called from other rules
unique lazy rule ObjectVariable {
	from i : XML!Element (
			i.name = 'r2ml:ObjectVariable'
		)
	to 
		ov : R2ML!ObjectVariable (
			classRef <- i.children->select(c | c.oclIsKindOf(XML!Attribute) and c.name = 'r2ml:classID')->collect(e | thisModule.ClassRule(e))->first(),
  	        name <- i.getAttrVal('r2ml:name'),
			typeCategory <- #individual
		)		
}

-- Rule 'DataVariable'
-- Creates DataVariable from an XML!Element named 'r2ml:DataVariable'.
-- This rule is unique lazy rule, which means that is called from other rules
unique lazy rule DataVariable {
	from i : XML!Element (
			i.name = 'r2ml:DataVariable'
		)
	to 
		odv : R2ML!DataVariable (	
			datatypeRef <- if(i.hasAttr('r2ml:dataTypeID')) then
							thisModule.Datatype(thisModule.getDefaultDataType(i.getAttr('r2ml:dataTypeID'), i.getAttrVal('r2ml:dataTypeID')))
						   else OclUndefined
						   endif,
			name <- i.getAttrVal('r2ml:name'),
			typeCategory <- if i.hasAttr('r2ml:typeCategory') = true then
								if i.getAttrVal('r2ml:typeCategory') = 'individual' then
									#individual
								else if i.getAttrVal('r2ml:typeCategory') = 'set' then
										#set
									 else if i.getAttrVal('r2ml:typeCategory') = 'order' then
									 		#orderedSet
										  else if i.getAttrVal('r2ml:typeCategory') = 'bag' then
										  		#bag
											   else if i.getAttrVal('r2ml:typeCategory') = 'sequence' then
											   		 #sequence
													else #individual
													endif
											   endif
										  endif
									 endif
								endif								
							else OclUndefined
							endif
		)		
}

-- Rule 'Datatype'
-- Creates Datatype from an XML!Attribute
-- This rule is unique lazy rule, which means that is called from other rules
unique lazy rule Datatype {
	from i : XML!Attribute 
	to o : R2ML!Datatype (
			predicateCategory <- #closed,
			name <- i.value
		)
}

-- Rule 'QFDisjunction'
-- Creates QFDisjunction from an XML!Element named 'r2ml:qf.Disjunction'.
rule QFDisjunction {
	from  i : XML!Element (
			i.name = 'r2ml:qf.Disjunction'
		)
	to
		o : R2ML!QFDisjunction (
				formulas <- i.children->select(c | c.oclIsKindOf(XML!Element))->asSequence()
			)
}

-- Rule 'QFConjunction'
-- Creates QFConjunction from an XML!Element named 'r2ml:qf.Conjunction'.
rule QFConjunction {
	from  i : XML!Element (
			i.name = 'r2ml:qf.Conjuction'
		)
	to
		o : R2ML!QFConjunction (
			formulas <- i.children->select(c | c.oclIsKindOf(XML!Element))->asSequence()
			)
}

-- Rule 'QFNegationAsFailure'
-- Creates QFNegationAsFailure from an XML!Element named 'r2ml:qf.NegationAsFailure'.
rule QFNegationAsFailure {
	from i : XML!Element (
				i.name = 'r2ml:qf.NegationAsFailure'
			)
    to
		o : R2ML!QFNegationAsFailure (
				formula <- i.children->select(c | c.oclIsKindOf(XML!Element))->first()
		)
}

-- Rule 'QFStrongNegation'
-- Creates QFStrongNegation from an XML!Element named 'r2ml:qf.StrongNegation'.
rule QFStrongNegation {
	from i : XML!Element (
				i.name = 'r2ml:qf.StrongNegation'
			)
    to
		o : R2ML!QFStrongNegation (
				formula <- i.children->select(c | c.oclIsKindOf(XML!Element))->first()
		)
}

-- Rule 'DatatypePredicateAtom'
-- Creates DatatypePredicateAtom from an XML!Element named 'r2ml:DatatypePredicateAtom' or 'r2ml:DataPredicateAtom'.
rule DatatypePredicateAtom {
	from i : XML!Element (
		-- r2ml v0.1
		i.name = 'r2ml:DataPredicateAtom' or 
		-- r2ml v0.2
		i.name = 'r2ml:DatatypePredicateAtom'
		)
	to 
		o : R2ML!DatatypePredicateAtom (
			dataArguments <- Sequence{ i.getElementsByName('r2ml:dataArguments')->first().children->select(e | thisModule.getAllDataVariables()->includes(e))->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e)), 
				                       i.getElementsByName('r2ml:dataArguments')->first().children->select(e | not thisModule.getAllDataVariables()->includes(e))->asSequence()},
			predicate <- i.children->select(c | c.oclIsKindOf(XML!Attribute) and c.name = 'r2ml:dataPredicateID' or c.name = 'r2ml:datatypePredicateID')->collect(e | thisModule.DatatypePredicateRule(e))->first()
		)
}

-- Rule 'DatatypePredicateRule'
-- Creates DatatypePredicateRule from an XML!Attribute
-- This rule is unique lazy rule, which means that is called from other rules
unique lazy rule DatatypePredicateRule {
	from i : XML!Attribute
	to  
		dtp : R2ML!DatatypePredicate (
			predicateCategory <- #closed,
			name <- i.value
		)		
}

-- Rule 'DataOperationTerm'
-- Creates DataOperationTerm from an XML!Element named 'r2ml:DataOperationTerm'.
rule DataOperationTerm {
	from i : XML!Element (
			i.name = 'r2ml:DataOperationTerm'
		)
	to 
		o : R2ML!DataOperationTerm (
			dataOperationRef <- opr,
			arguments <- let args : Set(XML!Element) = i.getElementsByName('r2ml:arguments') in
							if args->isEmpty() then
							   Sequence {}
							-- ANNOTATION: First we get ObjectVariables, then DataVariables, and all elements which are not ObjectVariables or DataVariables
						    else Sequence { args->first().children->select(e | thisModule.getAllDataVariables()->includes(e))->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e)),
						    	            args->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
											args->first().children->select(e | not thisModule.getAllDataVariables()->includes(e) and not thisModule.getAllObjectVariables()->includes(e))->asSequence()
						         }
							endif,
			contextArgument <- let conArg : Set(XML!Element) = i.getElementsByName('r2ml:contextArgument') in
							       if conArg->isEmpty() then
							           OclUndefined	            
							       else Sequence { conArg->first().children->asSequence()->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first(),
							       				   conArg->first().children->asSequence()->select(e | thisModule.getAllObjectVariables()->excludes(e))
							       				 }->select(c | not c.oclIsUndefined())->asSequence()->first()
								   endif,
			typeCategory <- if i.hasAttr('r2ml:typeCategory') = true then
								if i.getAttrVal('r2ml:typeCategory') = 'individual' then
									#individual
								else if i.getAttrVal('r2ml:typeCategory') = 'set' then
										#set
									 else if i.getAttrVal('r2ml:typeCategory') = 'order' then
									 		#orderedSet
										  else if i.getAttrVal('r2ml:typeCategory') = 'bag' then
										  		#bag
											   else if i.getAttrVal('r2ml:typeCategory') = 'sequence' then
											   		 #sequence
													else OclUndefined
													endif
											   endif
										  endif
									 endif
								endif								
							else OclUndefined
							endif
			),
		opr : R2ML!DataOperation (
			name <- i.getAttrVal('r2ml:operationID')
			)
}

-- Rule 'TypedLiteral'
-- Creates TypedLiteral from an XML!Element named 'r2ml:TypedLiteral'.
rule TypedLiteral {
	from i : XML!Element (
			i.name = 'r2ml:TypedLiteral'
		)
	to 
		o : R2ML!TypedLiteral (
				lexicalValue <- i.getAttrVal('r2ml:lexicalValue'),
				type <- thisModule.Datatype(thisModule.getDefaultDataType(i.getAttr('r2ml:datatypeID'), i.getAttrVal('r2ml:datatypeID'))),
				typeCategory <- if i.hasAttr('r2ml:typeCategory') = true then
									if i.getAttrVal('r2ml:typeCategory') = 'individual' then
										#individual
									else if i.getAttrVal('r2ml:typeCategory') = 'set' then
											#set
										 else if i.getAttrVal('r2ml:typeCategory') = 'order' then
										 		#orderedSet
											  else if i.getAttrVal('r2ml:typeCategory') = 'bag' then
											  		#bag
												   else if i.getAttrVal('r2ml:typeCategory') = 'sequence' then
												   		 #sequence
														else OclUndefined
														endif
												   endif
											  endif
										 endif
									endif								
								else OclUndefined
								endif
			)
}

-- Rule 'PlainLiteral'
-- Creates PlainLiteral from an XML!Element named 'r2ml:PlainLiteral'.
rule PlainLiteral {
	from i : XML!Element (
			i.name = 'r2ml:PlainLiteral'
		)
	to 
		o : R2ML!PlainLiteral (
				lexicalValue <- i.getAttrVal('r2ml:lexicalValue'),
				languageTag <- i.getAttrVal('r2ml:languageTag'),
				typeCategory <- if i.hasAttr('r2ml:typeCategory') = true then
									if i.getAttrVal('r2ml:typeCategory') = 'individual' then
										#individual
									else if i.getAttrVal('r2ml:typeCategory') = 'set' then
											#set
										 else if i.getAttrVal('r2ml:typeCategory') = 'order' then
										 		#orderedSet
											  else if i.getAttrVal('r2ml:typeCategory') = 'bag' then
											  		#bag
												   else if i.getAttrVal('r2ml:typeCategory') = 'sequence' then
												   		 #sequence
														else OclUndefined
														endif
												   endif
											  endif
										 endif
									endif								
								else OclUndefined
								endif
			)
}

-- Rule 'AttributeFunctionTerm'
-- Creates AttributeFunctionTerm from an XML!Element named 'r2ml:AttributeFunctionTerm'.
rule AttributeFunctionTerm {
	from i : XML!Element (
			i.name = 'r2ml:AttributeFunctionTerm'
		)
	to 
		o : R2ML!AttributeFunctionTerm (
				contextArgument <- Sequence { i.getElementsByName('r2ml:contextArgument')->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first(),
						  					  i.getElementsByName('r2ml:contextArgument')->first().children->select(e | thisModule.getAllObjectVariables()->excludes(e))->asSequence()->first() -- other (non ObjectVariable) object terms
											}->select(c | not c.oclIsUndefined())->asSequence()->first(),
				attribute <- thisModule.Attribute(thisModule.getDefaultAttribute(i.getAttr('r2ml:attributeID'), i.getAttrVal('r2ml:attributeID'))),
				typeCategory <- if i.hasAttr('r2ml:typeCategory') = true then
									if i.getAttrVal('r2ml:typeCategory') = 'individual' then
										#individual
									else if i.getAttrVal('r2ml:typeCategory') = 'set' then
											#set
										 else if i.getAttrVal('r2ml:typeCategory') = 'order' then
										 		#orderedSet
											  else if i.getAttrVal('r2ml:typeCategory') = 'bag' then
											  		#bag
												   else if i.getAttrVal('r2ml:typeCategory') = 'sequence' then
												   		 #sequence
														else OclUndefined
														endif
												   endif
											  endif
										 endif
									endif								
								else OclUndefined
								endif
			)
}

-- Rule 'Attribute'
-- Creates Attribute from an XML!Attribute named 'r2ml:attributeID'.
unique lazy rule Attribute {
	from i : XML!Attribute 
	to o : R2ML!Attribute (	
			predicateCategory <- #closed,
			name <- i.value
		)
}

-- Rule 'AssociationAtom'
-- Creates AssociationAtom from an XML!Element named 'r2ml:AssociationAtom'
-- This rule is some complicated, because it is possible that object or data
-- arguments does not exists in input file, so this must be checked first (with let expression).
rule AssociationAtom {
	from i : XML!Element (
		i.name = 'r2ml:AssociationAtom'
		)
	to 
		o : R2ML!AssociationAtom (
			isNegated <- i.isNegated(),
			objectArguments <- let objArgs : Set(XML!Element) = i.getElementsByName('r2ml:objectArguments') in
							       if objArgs->isEmpty() then
								   	  Sequence{}
  						           else Sequence{ objArgs->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)), 
				                                  objArgs->first().children->select(e | thisModule.getAllObjectVariables()->excludes(e))->asSequence()}
								   endif,
			dataArguments <- let dataArgs : Set(XML!Element) = i.getElementsByName('r2ml:dataArguments') in
							     if dataArgs->isEmpty() then
							 	    Sequence{}
						         else Sequence { dataArgs->first().children->asSequence()->select(c | thisModule.getAllDataVariables()->includes(c))->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e)), 
						         				 dataArgs->first().children->asSequence()->select(c | thisModule.getAllDataVariables()->excludes(c))->asSequence()
										       }
						         endif,
			associationPredicate <- asp
			),
		asp : R2ML!AssociationPredicate (
				name <- i.getAttrVal('r2ml:associationPredicateID')
			)
}

-- Rule 'ReferencePropertyFunctionTerm'
-- Creates ReferencePropertyFunctionTerm from an XML!Element named 'r2ml:ReferencePropertyFunctionTerm'.
rule ReferencePropertyFunctionTerm {
	from i : XML!Element (
			i.name = 'r2ml:RoleFunctionTerm' -- v0.3
			or i.name = 'r2ml:ReferencePropertyFunctionTerm' -- v0.4
		)
	to 
		o : R2ML!ReferencePropertyFunctionTerm (
				referencePropertyRef <- thisModule.ReferenceProperty(i.getAttr('r2ml:referencePropertyID')),
				contextArgument <- Sequence { i.getElementsByName('r2ml:contextArgument')->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first(),
											  i.getElementsByName('r2ml:contextArgument')->first().children->select(e | thisModule.getAllObjectVariables()->excludes(e))->first()
											 }->select(c | not c.oclIsUndefined())->asSequence()->first(),
				typeCategory <- if i.hasAttr('r2ml:typeCategory') = true then
									if i.getAttrVal('r2ml:typeCategory') = 'individual' then
										#individual
									else if i.getAttrVal('r2ml:typeCategory') = 'set' then
											#set
										 else if i.getAttrVal('r2ml:typeCategory') = 'order' then
										 		#orderedSet
											  else if i.getAttrVal('r2ml:typeCategory') = 'bag' then
											  		#bag
												   else if i.getAttrVal('r2ml:typeCategory') = 'sequence' then
												   		 #sequence
														else OclUndefined
														endif
												   endif
											  endif
										 endif
									endif								
								else OclUndefined
								endif
			)
}

-- Rule 'AttributionAtom'
-- Creates AttributionAtom from an XML!Element named 'r2ml:AttributionAtom'.
rule AttributionAtom {
	from i : XML!Element (
			i.name = 'r2ml:AttributionAtom'
		)
	to 
		o : R2ML!AttributionAtom (
			isNegated <- i.isNegated(),
			dataValue <- let val : XML!Element = i.getElementsByName('r2ml:dataValue')->first().children->first() in
							if val.name = 'r2ml:DataVariable'			
								then i.getElementsByName('r2ml:dataValue')->first().children->select(e | thisModule.getAllDataVariables()->includes(e))->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e))->first()
								else i.getElementsByName('r2ml:dataValue')->first().children->select(e | not thisModule.getAllDataVariables()->includes(e))->first()
							endif,
			subject <- Sequence { i.getElementsByName('r2ml:subject')->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first(),
								  i.getElementsByName('r2ml:subject')->first().children->select(e | thisModule.getAllObjectVariables()->excludes(e))
							}->select(c | not c.oclIsUndefined())->asSequence()->first(),
			attribute <- thisModule.Attribute(thisModule.getDefaultAttribute(i.getAttr('r2ml:attributeID'), i.getAttrVal('r2ml:attributeID')))
			)
}

-- Rule 'ReferencePropertyAtom'
-- Creates ReferencePropertyAtom from an XML!Element named 'r2ml:ReferencePropertyAtom'.
rule ReferencePropertyAtom {
	from i : XML!Element (
			i.name = 'r2ml:ReferencePropertyAtom'
		)
	to 
		o : R2ML!ReferencePropertyAtom (
				isNegated <- i.isNegated(),
				referenceProperty <- thisModule.ReferenceProperty(i.getAttr('r2ml:referencePropertyID')),
				subject <- Sequence { i.getElementsByName('r2ml:subject')->first().children->select(c | thisModule.getAllObjectVariables()->includes(c))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first(),
							 		  i.getElementsByName('r2ml:subject')->first().children->select(c | thisModule.getAllObjectVariables()->excludes(c))
							 		}->select(c | not c.oclIsUndefined())->asSequence()->first(),
				object <- Sequence { i.getElementsByName('r2ml:object')->first().children->select(c | thisModule.getAllObjectVariables()->includes(c))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first(),
							 		 i.getElementsByName('r2ml:object')->first().children->select(c | thisModule.getAllObjectVariables()->excludes(c))
								   }->select(c | not c.oclIsUndefined())->asSequence()->first()
			)
}

-- Rule 'ReferenceProperty'
-- Creates ReferenceProperty element from an XML!Attribute
-- This rule is unique lazy rule, which means that is called from other rules
unique lazy rule ReferenceProperty {
	from i : XML!Attribute 
	to rfp: R2ML!ReferenceProperty (
				predicateCategory <- #closed,
	    		name <- i.value
	    	)
}

-- Rule 'GenericAtom'
-- Creates GenericAtom element from an XML!Element named 'r2ml:GenericAtom'
rule GenericAtom {
	from i : XML!Element (
			i.name = 'r2ml:GenericAtom'
		)
	to 
		o : R2ML!GenericAtom (
				arguments <- Sequence{ i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllVariables()->includes(e))->collect(e | thisModule.getDefaultGenericVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.GenericVariable(e)), 
					 				   i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllDataVariables()->includes(e))->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e)),
					 				   i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
					                   i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllVariables()->excludes(e) and thisModule.getAllDataVariables()->excludes(e) and thisModule.getAllObjectVariables()->excludes(e))->asSequence()},
				predicate <- thisModule.GenericPredicate(thisModule.getDefaultGenericPredicate(i.getAttr('r2ml:predicateID'), i.getAttrVal('r2ml:predicateID')))
		)
}

-- Rule 'GenericPredicate'
-- Creates Predicate element from an XML!Element named 'r2ml:GenericPredicate'
-- This rule is unique lazy rule, which means that is called from other rules
unique lazy rule GenericPredicate {
	from i : XML!Attribute
	to  
		pre : R2ML!GenericPredicate (
				name <- i.value,
				predicateTypeID <- let pt : String = i.parent.getAttrVal('r2ml:predicateType') in
										if pt <> OclUndefined then
											if pt = 'ObjectClassificationPredicate' then
												#ObjectClassificationPredicate
											else if pt = 'AttributionPredicate' then
													#AttributionPredicate
												 else if pt = 'AssociationPredicate' then
												 	  	#AssociationPredicate
													  else if pt = 'ReferencePropertyPredicate' then
													  	   #ReferencePropertyPredicate
														   else if pt = 'EqualityPredicate' then
														   		#EqualityPredicate
																else if pt = 'InequalityPredicate' then
																		#InequalityPredicate
																	 else if pt = 'DatatypePredicate' then
																	 		#DatatypePredicate
																		  else if pt = 'DataClassificationPredicate' then
																		  		#DataClassificationPredicate
																			   else OclUndefined
																			   endif
																		  endif
																	 endif
																endif 
														   endif
													  endif
												 endif 
											endif
										else OclUndefined
										endif
		)		
}

-- Rule 'GenericVariable'
-- Creates GenericVariable element from an XML!Element named 'r2ml:Variable' or 'r2ml:GenericVariable'
-- This rule is unique lazy rule, which means that it's called from other rules
unique lazy rule GenericVariable {
	from i : XML!Element 
	to 
		o : R2ML!GenericVariable (
				name <- i.getAttrVal('r2ml:name'),
				typeRef <- if i.hasAttr('r2ml:dataTypeID') then 
								thisModule.Datatype(thisModule.getDefaultDataType(i.getAttr('r2ml:dataTypeID'), i.getAttrVal('r2ml:dataTypeID')))
						   else OclUndefined
						   endif
			)
}

-- Rule 'GenericFunctionTerm'
-- Creates GenericFunctionTerm element from an XML!Element named 'r2ml:FunctionTerm' or 'r2ml:GenericFunctionTerm'
rule GenericFunctionTerm {
	from i : XML!Element (
			i.name = 'r2ml:FunctionTerm' -- v0.3
			or i.name = 'r2ml:GenericFunctionTerm' -- v0.4
		)
	to 
		o : R2ML!GenericFunctionTerm (
				arguments <- Sequence{ i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllVariables()->includes(e))->collect(e | thisModule.getDefaultGenericVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.GenericVariable(e)), 
				   		               i.getElementsByName('r2ml:arguments')->first().children->select(e | not thisModule.getAllVariables()->includes(e))->asSequence()},
				functor <- fun,
				typeCategory <- if i.hasAttr('r2ml:typeCategory') = true then
									if i.getAttrVal('r2ml:typeCategory') = 'individual' then
										#individual
									else if i.getAttrVal('r2ml:typeCategory') = 'set' then
											#set
										 else if i.getAttrVal('r2ml:typeCategory') = 'order' then
										 		#orderedSet
											  else if i.getAttrVal('r2ml:typeCategory') = 'bag' then
											  		#bag
												   else if i.getAttrVal('r2ml:typeCategory') = 'sequence' then
												   		 #sequence
														else OclUndefined
														endif
												   endif
											  endif
										 endif
									endif								
								else OclUndefined
								endif
		),
		fun : R2ML!GenericFunction (
				name <- i.getAttrVal('r2ml:genericFunctionID')
			)
}

-- Rule 'DatatypeFunctionTerm'
-- Creates DatatypeFunctionTerm element from an XML!Element named 'r2ml:DatatypeFunctionTerm'
rule DatatypeFunctionTerm {
	from i : XML!Element (
			i.name = 'r2ml:DatatypeFunctionTerm'
		)
	to o : R2ML!DatatypeFunctionTerm (
			dataArguments <- Sequence{ i.getElementsByName('r2ml:dataArguments')->first().children->select(e | thisModule.getAllDataVariables()->includes(e))->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e))->first(), 
				                       i.getElementsByName('r2ml:dataArguments')->first().children->select(e | not thisModule.getAllDataVariables()->includes(e))->asSequence()},
			function <- dtf,
			typeCategory <- if i.hasAttr('r2ml:typeCategory') = true then
								if i.getAttrVal('r2ml:typeCategory') = 'individual' then
									#individual
								else if i.getAttrVal('r2ml:typeCategory') = 'set' then
										#set
									 else if i.getAttrVal('r2ml:typeCategory') = 'order' then
									 		#orderedSet
										  else if i.getAttrVal('r2ml:typeCategory') = 'bag' then
										  		#bag
											   else if i.getAttrVal('r2ml:typeCategory') = 'sequence' then
											   		 #sequence
													else OclUndefined
													endif
											   endif
										  endif
									 endif
								endif								
							else OclUndefined
							endif
		),
	dtf : R2ML!DatatypeFunction (
			name <- i.getAttrVal('r2ml:datatypeFunctionID')
		)
}

-- Rule 'ObjectName'
-- Creates ObjectName element from an XML!Element named 'r2ml:ObjectName'
rule ObjectName {
	from i : XML!Element (
			i.name = 'r2ml:ObjectName'
		)
	to o : R2ML!ObjectName (
			name <- i.getAttrVal('r2ml:objectID'),
			classRef <- let classID : String = i.getAttrVal('r2ml:classID') in
							if not classID.oclIsUndefined() then
								thisModule.ClassRule(i.getAttr('r2ml:classID'))
							else OclUndefined
							endif,
			typeCategory <- if i.hasAttr('r2ml:typeCategory') = true then
								if i.getAttrVal('r2ml:typeCategory') = 'individual' then
									#individual
								else if i.getAttrVal('r2ml:typeCategory') = 'set' then
										#set
									 else if i.getAttrVal('r2ml:typeCategory') = 'order' then
									 		#orderedSet
										  else if i.getAttrVal('r2ml:typeCategory') = 'bag' then
										  		#bag
											   else if i.getAttrVal('r2ml:typeCategory') = 'sequence' then
											   		 #sequence
													else OclUndefined
													endif
											   endif
										  endif
									 endif
								endif								
							else OclUndefined
							endif
		)
}

-- Rule 'ObjectDescriptionAtom'
-- Creates ObjectDescriptionAtom element from an XML!Element named 'r2ml:ObjectDescriptionAtom'
rule ObjectDescriptionAtom {
	from i : XML!Element (
			i.name = 'r2ml:ObjectDescriptionAtom'
		)
	to o : R2ML!ObjectDescriptionAtom (
				isNegated <- i.isNegated(),
				type <- Sequence { thisModule.ClassRule(i.getAttr('r2ml:classID')) },
				slots <- Sequence{ i.getElementsByName('r2ml:DataSlot')->first().children->asSequence(),
								   i.getElementsByName('r2ml:ObjectSlot')->first().children->asSequence() },
				subject <- Sequence { i.getElementsByName('r2ml:subject')->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first(),
								      i.getElementsByName('r2ml:subject')->first().children->select(e | thisModule.getAllObjectVariables()->excludes(e))
							        }->select(c | not c.oclIsUndefined())->asSequence()->first(),
				objects <- i.getElementsByName('r2ml:objects')->first().children->asSequence(),
				baseType <- if i.hasAttr('r2ml:baseType') then
								thisModule.ClassRule(i.getAttr('r2ml:baseType'))
							else OclUndefined
							endif
			)
}

-- Rule 'ObjectSlot'
-- Creates ObjectSlot element from an XML!Element named 'r2ml:ObjectSlot'
rule ObjectSlot {
	from i : XML!Element (
			i.name = 'r2ml:ObjectSlot'
		)
	to 
		o : R2ML!ObjectSlot (
				object <- Sequence { i.getElementsByName('r2ml:object')->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first(),
								     i.getElementsByName('r2ml:object')->first().children->select(e | thisModule.getAllObjectVariables()->excludes(e))
							       }->select(c | not c.oclIsUndefined())->asSequence()->first(),
				referenceProperty <- thisModule.ReferenceProperty(i.getAttr('r2ml:referencePropertyID'))
			) 
}

-- Rule 'DataSlot'
-- Creates DataSlot element from an XML!Element named 'r2ml:DataSlot'
rule DataSlot {
	from i : XML!Element (
			i.name = 'r2ml:DataSlot'
		)
	to 
		o : R2ML!DataSlot (
				value <- Sequence { i.getElementsByName('r2ml:value')->first().children->select(e | thisModule.getAllDataVariables()->includes(e))->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e))->first(),
									i.getElementsByName('r2ml:value')->first().children->select(e | thisModule.getAllDataVariables()->excludes(e))->first()
								  }->select(c | not c.oclIsUndefined())->asSequence()->first(),
				attribute <- thisModule.Attribute(thisModule.getDefaultAttribute(i.getAttr('r2ml:attributeID'), i.getAttrVal('r2ml:attributeID')))
			) 
}

-- Rule 'AtLeastQuantifiedFormula'
-- Creates AtLeastQuantifiedFormula from an XML!Element named 'r2ml:AtLeastQuantifiedFormula'.
rule AtLeastQuantifiedFormula {
	from i : XML!Element (
				i.name = 'r2ml:AtLeastQuantifiedFormula'
			)
  to
		o : R2ML!AtLeastQuantifiedFormula (
				variables <- Sequence { i.getElementsByName('r2ml:ObjectVariable')->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
									    i.getElementsByName('r2ml:DataVariable')->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e)) },
				formula <- i.children->select(e | thisModule.getAllDataVariables()->excludes(e) and thisModule.getAllObjectVariables()->excludes(e) and e.oclIsTypeOf(XML!Element))->first(),
				minCardinality <- i.getAttrVal('r2ml:minCardinality').toInteger()
			)
}

-- Rule 'AtMostQuantifiedFormula'
-- Creates AtMostQuantifiedFormula from an XML!Element named 'r2ml:AtMostQuantifiedFormula'.
rule AtMostQuantifiedFormula {
	from i : XML!Element (
				i.name = 'r2ml:AtMostQuantifiedFormula'
			)
  to
		o : R2ML!AtMostQuantifiedFormula (
				variables <- Sequence { i.getElementsByName('r2ml:ObjectVariable')->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
									    i.getElementsByName('r2ml:DataVariable')->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e)) },
				formula <- i.children->select(e | thisModule.getAllDataVariables()->excludes(e) and thisModule.getAllObjectVariables()->excludes(e) and e.oclIsTypeOf(XML!Element))->first(),
				maxCardinality <- i.getAttrVal('r2ml:maxCardinality').toInteger()
			)
}

-- Rule 'AtLeastAndAtMostQuantifiedFormula'
-- Creates AtLeastAndAtMostQuantifiedFormula from an XML!Element named 'r2ml:AtLeastAndAtMostQuantifiedFormula'.
rule AtLeastAndAtMostQuantifiedFormula {
	from i : XML!Element (
				i.name = 'r2ml:AtLeastAndAtMostQuantifiedFormula'
			)
  to
		o : R2ML!AtLeastAndAtMostQuantifiedFormula (
				variables <- Sequence { i.getElementsByName('r2ml:ObjectVariable')->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
									    i.getElementsByName('r2ml:DataVariable')->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e)) },
				formula <- i.children->select(e | thisModule.getAllDataVariables()->excludes(e) and thisModule.getAllObjectVariables()->excludes(e) and e.oclIsTypeOf(XML!Element))->first(),
				maxCardinality <- i.getAttrVal('r2ml:maxCardinality').toInteger(),
				minCardinality <- i.getAttrVal('r2ml:minCardinality').toInteger()
			)
}

-- Rule 'ObjectOperationTerm'
-- Creates ObjectOperationTerm from an XML!Element named 'r2ml:ObjectOperationTerm'.
rule ObjectOperationTerm {
	from i : XML!Element (
			i.name = 'r2ml:ObjectOperationTerm'
		)
	to o : R2ML!ObjectOperationTerm (
			operation <- thisModule.ObjectOperation(i.getAttr('r2ml:operationID')),
			arguments <- Sequence { i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
									i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllDataVariables()->includes(e))->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e)),
								    i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllObjectVariables()->excludes(e) and thisModule.getAllDataVariables()->excludes(e))
 							      },
			contextArgument <- Sequence { i.getElementsByName('r2ml:contextArgument')->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first(),
										  i.getElementsByName('r2ml:contextArgument')->first().children->select(e | thisModule.getAllObjectVariables()->excludes(e))->first()
									    }->select(c | not c.oclIsUndefined())->asSequence()->first()
		)
}

-- Lazy Rule 'ObjectOperation'
-- Creates ObjectOperation from an XML!Element named attribute of 'r2ml:ObjectOperationTerm'.
unique lazy rule ObjectOperation {
	from i : XML!Attribute
	to o : R2ML!ObjectOperation (
			name <- i.value
		)
}

-- Rule 'DataOperationTerm'
-- Creates DataOperationTerm from an XML!Element named 'r2ml:DataOperationTerm'.
rule DataOperationTerm {
	from i : XML!Element (
			i.name = 'r2ml:DataOperationTerm'
		)
	to o : R2ML!DataOperationTerm (
			dataOperationRef <- thisModule.DataOperation(i.getAttr('r2ml:operationID')),
			arguments <- Sequence { i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
									i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllDataVariables()->includes(e))->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e)),
								    i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllObjectVariables()->excludes(e) and thisModule.getAllDataVariables()->excludes(e))
 							      },
			contextArgument <- Sequence { i.getElementsByName('r2ml:contextArgument')->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first(),
										  i.getElementsByName('r2ml:contextArgument')->first().children->select(e | thisModule.getAllObjectVariables()->excludes(e))->first()
									    }->select(c | not c.oclIsUndefined())->asSequence()->first()
		)
}

-- Lazy Rule 'DataOperation'
-- Creates DataOperation from an XML!Element named attribute of 'r2ml:DataOperationTerm'.
unique lazy rule DataOperation {
	from i : XML!Attribute
	to o : R2ML!DataOperation (
			name <- i.value
		)
}",transform xml metamodel r ml metamodel creat part m sc these good old ai laboratori author milan milanov milan milanov org work r ml xml schema metamodel v licenc gnu general public licens version modul xml r ml creat out r ml in xml use string use xmlhelper general xml metamodel helper helper xml r ml transform specif xml helper helper isneg return boolean statement xml element attribut xml attribut name r ml isneg true fals contextu xml element context xml element out boolean helper context xml element def isneg boolean let collect sequenc xml attribut self children select c c ocliskindof xml attribut c name r ml isneg collect isempti fals els empti let val string kolekcija first valu val true true els fals endif endif helper getallrul return sequenc xml element name integrityrul derivationrul context thismodul out sequenc xml element todo add type rule helper def getallrul sequenc xml element xml element allinst select e e name r ml alethicintegrityrul e name r ml deonticintegrityrul e name r ml derivationrul assequ helper allsubel return sequenc xml sub element xml element recursivelli element last element children annot base transform model atl freder jouault ivan kurtev context xml element out sequenc xml element helper context xml element def allsubel sequenc xml element let subelem sequenc xml element xml element allinst select c get element parent c parent self collect elem elem allsubel flatten everi element get subel subelem union subel apprehend everi element add topmost element child parent self children select ch ch oclistypeof xml element flatten helper allsubattribut return sequenc xml sub attribut xml element recursivelli attribut last attribut children context xml element out sequenc xml attribut helper context xml element def allsubattribut sequenc xml attribut let subattr sequenc xml attribut xml element allinst select c c parent self collect attr attr allsubattribut flatten subattr union self children select oclistypeof xml attribut flatten helper getruleforel return xml element rule integr deriv contain context ual xml element context xml element out xml element helper context xml element def getruleforel xml element thismodul getallrul select c c allsubel includ self assequ first helper getruleforattribut return xml element rule integr deriv contain context ual xml attribut context xml attribut out xml element helper context xml attribut def getruleforattribut xml element thismodul getallrul select c c allsubattribut includ self assequ first helper getdefaultobjectvari return alway first objectvari valu this necessari uniqu lazi rule creat one output objectvari multipl input valu context thismodul in string out xml element helper def getdefaultobjectvari elem xml element valu string xml element let objvar sequenc xml element elem getruleforel allsubel select e e name r ml objectvari select e e getattrv r ml name valu e hasattr r ml classid assequ objvar isempti elem getruleforel allsubel select e e name r ml objectvari select e e getattrv r ml name valu assequ first els objvar first endif helper getdefaultdatavari same previous data variabl context thismodul in string out xml element helper def getdefaultdatavari elem xml element valu string xml element elem getruleforel allsubel select e e name r ml datavari select e e getattrv r ml name valu assequ first helper getdefaultgenericvari same previous variabl context thismodul in string out xml element helper def getdefaultgenericvari elem xml element valu string xml element elem getruleforel allsubel select e e name r ml variabl e name r ml genericvari select e e getattrv r ml name valu assequ first helper getdefaultgenericpred alway return first predic associ genericatom context thismodul in string out xml attribut helper def getdefaultgenericpred attr xml attribut valu string xml attribut attr getruleforattribut allsubattribut select e e name r ml predicateid select e e valu valu assequ first helper getdefaultattribut alway return first attribut associ term context thismodul in string out xml attribut helper def getdefaultattribut attr xml attribut valu string xml attribut attr getruleforattribut allsubattribut select e e name r ml attributeid select e e valu valu assequ first helper getdefaultdatatyp alway return first data type context thismodul in string out xml attribut helper def getdefaultdatatyp attr xml attribut valu string xml attribut attr getruleforattribut allsubattribut select e e name r ml datatypeid e name r ml type select e e valu valu assequ first helper getallobjectvari return object variabl input file context thismodul out sequenc xml element helper def getallobjectvari sequenc xml element xml element allinst select e e name r ml objectvari helper getalldatavari return data variabl input file context thismodul out sequenc xml element helper def getalldatavari sequenc xml element xml element allinst select e e name r ml datavari helper getallvari return variabl input file context thismodul out sequenc xml element helper def getallvari sequenc xml element xml element allinst select e e name r ml variabl e name r ml genericvari rule rule rulebas creat rulebas root element rule rulebas xml element name r ml rulebas r ml rulebas rulebaseid getattrv xmlns r ml rule children select c c ocliskindof xml element assequ rule derivationruleset creat derivationruleset xml element name r ml derivationruleset rule derivationruleset xml element name r ml derivationruleset r ml derivationruleset rule children select c c ocliskindof xml element assequ rule integrityruleset creat integrityruleset xml element name r ml integrityruleset rule integrityruleset xml element name r ml integrityruleset r ml integrityruleset rule children select c c ocliskindof xml element assequ rule reactionruleset creat reactionruleset xml element name r ml reactionruleset rule reactionruleset xml element name r ml reactionruleset r ml reactionruleset rule children select c c ocliskindof xml element assequ rule productionruleset creat productionruleset xml element name r ml productionruleset rule productionruleset xml element name r ml productionruleset r ml productionruleset rule children select c c ocliskindof xml element assequ rule alethicintegrityrul creat alethicintegrityrul xml element name r ml alethicintegrityrul rule alethicintegrityrul xml element name r ml alethicintegrityrul r ml alethicintegrityrul constraint getelementsbynam r ml constraint first children select c c ocliskindof xml element first ruleid hasattr r ml ruleid true getattrv r ml ruleid els oclundefin endif rule deonticintegrityrul creat deonticintegrityrul xml element name r ml deonticintegrityrul rule deonticintegrityrul xml element name r ml deonticintegrityrul r ml deonticintegrityrul constraint getelementsbynam r ml constraint first children select c c ocliskindof xml element first ruleid hasattr r ml ruleid true getattrv r ml ruleid els oclundefin endif rule universallyquantifiedformula creat universallyquantifiedformula xml element name r ml universallyquantifiedformula rule universallyquantifiedformula xml element name r ml universallyquantifiedformula r ml universallyquantifiedformula annot remark first time generat variabl get objectvari element children helper getdefaultobjectvari get alway input element variabl name call uniqu lazi rule objectvari generat variabl variabl sequenc getelementsbynam r ml objectvari collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e getelementsbynam r ml datavari collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e formula children select e thismodul getalldatavari exclud e thismodul getallobjectvari exclud e e oclistypeof xml element first rule existentiallyquantifiedformula creat existentiallyquantifiedformula xml element name r ml existentiallyquantifiedformula rule existentiallyquantifiedformula xml element name r ml existentiallyquantifiedformula r ml existentiallyquantifiedformula variabl sequenc getelementsbynam r ml objectvari collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e getelementsbynam r ml datavari collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e formula children select e thismodul getalldatavari exclud e thismodul getallobjectvari exclud e e oclistypeof xml element first rule implic creat implic xml element name r ml implic rule implic xml element name r ml implic r ml implic anteced getelementsbynam r ml anteced first children select c c oclistypeof xml element assequ first consequ getelementsbynam r ml consequ first children select c c oclistypeof xml element assequ first rule conjuct creat conjuct xml element name r ml conjuct rule conjuct xml element name r ml conjunct r ml conjuct formula children select c c ocliskindof xml element asset rule disjunct creat disjunct xml element name r ml disjunct rule disjunct xml element name r ml disjunct r ml disjunct formula children select c c ocliskindof xml element asset rule negationasfailur creat negationasfailur xml element name r ml negationasfailur rule negationasfailur xml element name r ml negationasfailur r ml negationasfailur formula children select c c ocliskindof xml element first rule strongneg creat strongneg xml element name r ml strongneg rule strongneg xml element name r ml strongneg r ml strongneg formula children select c c ocliskindof xml element first rule equalityatom creat equalityatom xml element name r ml equalityatom rule equalityatom xml element name r ml equalityatom r ml equalityatom term sequenc children select c c ocliskindof xml element c name r ml objectvari collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e children select c c ocliskindof xml element c name r ml objectvari rule inequalityatom creat inequalityatom xml element name r ml inequalityatom rule inequalityatom xml element name r ml inequalityatom r ml inequalityatom term sequenc children select c c ocliskindof xml element c name r ml objectvari collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e children select c c ocliskindof xml element c name r ml objectvari rule derivationrul creat derivationrul xml element name r ml derivationrul rule derivationrul xml element name r ml derivationrul r ml derivationrul condit getelementsbynam r ml condit first children select c c ocliskindof xml element assequ conclus getelementsbynam r ml conclus first ruleid hasattr r ml ruleid true getattrv r ml ruleid els oclundefin endif rule literalconjuct creat atom xml element name r ml derivationrul conclus rule literalconjuct xml element name r ml conclus r ml literalconjunct atom children select c c ocliskindof xml element asset rule classrul creat class xml attribut this lazi rule call rule uniqu lazi rule classrul xml attribut cla r ml class name valu predicatecategori close rule objectclassificationatom creat objectclassificationatom xml element name r ml objectclassificationatom rule objectclassificationatom xml element name r ml objectclassificationatom obj r ml objectclassificationatom isneg isneg type children select c c ocliskindof xml attribut c name r ml classid collect e thismodul classrul e first term children select c c ocliskindof xml element c name r ml objectvari collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first rule dataclassificationatom creat dataclassificationatom xml element name r ml dataclassificationatom rule dataclassificationatom xml element name r ml dataclassificationatom obj r ml dataclassificationatom isneg isneg type thismodul datatyp thismodul getdefaultdatatyp getattr r ml datatypeid getattrv r ml datatypeid term children select c c ocliskindof xml element c name r ml datavari collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e first rule objectvari creat objectvari xml element name r ml objectvari this rule uniqu lazi rule mean call rule uniqu lazi rule objectvari xml element name r ml objectvari ov r ml objectvari classref children select c c ocliskindof xml attribut c name r ml classid collect e thismodul classrul e first name getattrv r ml name typecategori individu rule datavari creat datavari xml element name r ml datavari this rule uniqu lazi rule mean call rule uniqu lazi rule datavari xml element name r ml datavari odv r ml datavari datatyperef hasattr r ml datatypeid thismodul datatyp thismodul getdefaultdatatyp getattr r ml datatypeid getattrv r ml datatypeid els oclundefin endif name getattrv r ml name typecategori hasattr r ml typecategori true getattrv r ml typecategori individu individu els getattrv r ml typecategori set set els getattrv r ml typecategori order orderedset els getattrv r ml typecategori bag bag els getattrv r ml typecategori sequenc sequenc els individu endif endif endif endif endif els oclundefin endif rule datatyp creat datatyp xml attribut this rule uniqu lazi rule mean call rule uniqu lazi rule datatyp xml attribut r ml datatyp predicatecategori close name valu rule qfdisjunct creat qfdisjunct xml element name r ml qf disjunct rule qfdisjunct xml element name r ml qf disjunct r ml qfdisjunct formula children select c c ocliskindof xml element assequ rule qfconjunct creat qfconjunct xml element name r ml qf conjunct rule qfconjunct xml element name r ml qf conjuct r ml qfconjunct formula children select c c ocliskindof xml element assequ rule qfnegationasfailur creat qfnegationasfailur xml element name r ml qf negationasfailur rule qfnegationasfailur xml element name r ml qf negationasfailur r ml qfnegationasfailur formula children select c c ocliskindof xml element first rule qfstrongneg creat qfstrongneg xml element name r ml qf strongneg rule qfstrongneg xml element name r ml qf strongneg r ml qfstrongneg formula children select c c ocliskindof xml element first rule datatypepredicateatom creat datatypepredicateatom xml element name r ml datatypepredicateatom r ml datapredicateatom rule datatypepredicateatom xml element r ml v name r ml datapredicateatom r ml v name r ml datatypepredicateatom r ml datatypepredicateatom dataargu sequenc getelementsbynam r ml dataargu first children select e thismodul getalldatavari includ e collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e getelementsbynam r ml dataargu first children select e thismodul getalldatavari includ e assequ predic children select c c ocliskindof xml attribut c name r ml datapredicateid c name r ml datatypepredicateid collect e thismodul datatypepredicaterul e first rule datatypepredicaterul creat datatypepredicaterul xml attribut this rule uniqu lazi rule mean call rule uniqu lazi rule datatypepredicaterul xml attribut dtp r ml datatypepred predicatecategori close name valu rule dataoperationterm creat dataoperationterm xml element name r ml dataoperationterm rule dataoperationterm xml element name r ml dataoperationterm r ml dataoperationterm dataoperationref opr argument let arg set xml element getelementsbynam r ml argument arg isempti sequenc annot first get objectvari datavari element objectvari datavari els sequenc arg first children select e thismodul getalldatavari includ e collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e arg first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e arg first children select e thismodul getalldatavari includ e thismodul getallobjectvari includ e assequ endif contextargu let conarg set xml element getelementsbynam r ml contextargu conarg isempti oclundefin els sequenc conarg first children assequ select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first conarg first children assequ select e thismodul getallobjectvari exclud e select c c oclisundefin assequ first endif typecategori hasattr r ml typecategori true getattrv r ml typecategori individu individu els getattrv r ml typecategori set set els getattrv r ml typecategori order orderedset els getattrv r ml typecategori bag bag els getattrv r ml typecategori sequenc sequenc els oclundefin endif endif endif endif endif els oclundefin endif opr r ml dataoper name getattrv r ml operationid rule typedliter creat typedliter xml element name r ml typedliter rule typedliter xml element name r ml typedliter r ml typedliter lexicalvalu getattrv r ml lexicalvalu type thismodul datatyp thismodul getdefaultdatatyp getattr r ml datatypeid getattrv r ml datatypeid typecategori hasattr r ml typecategori true getattrv r ml typecategori individu individu els getattrv r ml typecategori set set els getattrv r ml typecategori order orderedset els getattrv r ml typecategori bag bag els getattrv r ml typecategori sequenc sequenc els oclundefin endif endif endif endif endif els oclundefin endif rule plainliter creat plainliter xml element name r ml plainliter rule plainliter xml element name r ml plainliter r ml plainliter lexicalvalu getattrv r ml lexicalvalu languagetag getattrv r ml languagetag typecategori hasattr r ml typecategori true getattrv r ml typecategori individu individu els getattrv r ml typecategori set set els getattrv r ml typecategori order orderedset els getattrv r ml typecategori bag bag els getattrv r ml typecategori sequenc sequenc els oclundefin endif endif endif endif endif els oclundefin endif rule attributefunctionterm creat attributefunctionterm xml element name r ml attributefunctionterm rule attributefunctionterm xml element name r ml attributefunctionterm r ml attributefunctionterm contextargu sequenc getelementsbynam r ml contextargu first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first getelementsbynam r ml contextargu first children select e thismodul getallobjectvari exclud e assequ first non objectvari object term select c c oclisundefin assequ first attribut thismodul attribut thismodul getdefaultattribut getattr r ml attributeid getattrv r ml attributeid typecategori hasattr r ml typecategori true getattrv r ml typecategori individu individu els getattrv r ml typecategori set set els getattrv r ml typecategori order orderedset els getattrv r ml typecategori bag bag els getattrv r ml typecategori sequenc sequenc els oclundefin endif endif endif endif endif els oclundefin endif rule attribut creat attribut xml attribut name r ml attributeid uniqu lazi rule attribut xml attribut r ml attribut predicatecategori close name valu rule associationatom creat associationatom xml element name r ml associationatom this rule complic possibl object data argument exist input file must check first let express rule associationatom xml element name r ml associationatom r ml associationatom isneg isneg objectargu let objarg set xml element getelementsbynam r ml objectargu objarg isempti sequenc els sequenc objarg first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e objarg first children select e thismodul getallobjectvari exclud e assequ endif dataargu let dataarg set xml element getelementsbynam r ml dataargu dataarg isempti sequenc els sequenc dataarg first children assequ select c thismodul getalldatavari includ c collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e dataarg first children assequ select c thismodul getalldatavari exclud c assequ endif associationpred asp asp r ml associationpred name getattrv r ml associationpredicateid rule referencepropertyfunctionterm creat referencepropertyfunctionterm xml element name r ml referencepropertyfunctionterm rule referencepropertyfunctionterm xml element name r ml rolefunctionterm v name r ml referencepropertyfunctionterm v r ml referencepropertyfunctionterm referencepropertyref thismodul referenceproperti getattr r ml referencepropertyid contextargu sequenc getelementsbynam r ml contextargu first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first getelementsbynam r ml contextargu first children select e thismodul getallobjectvari exclud e first select c c oclisundefin assequ first typecategori hasattr r ml typecategori true getattrv r ml typecategori individu individu els getattrv r ml typecategori set set els getattrv r ml typecategori order orderedset els getattrv r ml typecategori bag bag els getattrv r ml typecategori sequenc sequenc els oclundefin endif endif endif endif endif els oclundefin endif rule attributionatom creat attributionatom xml element name r ml attributionatom rule attributionatom xml element name r ml attributionatom r ml attributionatom isneg isneg datavalu let val xml element getelementsbynam r ml datavalu first children first val name r ml datavari getelementsbynam r ml datavalu first children select e thismodul getalldatavari includ e collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e first els getelementsbynam r ml datavalu first children select e thismodul getalldatavari includ e first endif subject sequenc getelementsbynam r ml subject first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first getelementsbynam r ml subject first children select e thismodul getallobjectvari exclud e select c c oclisundefin assequ first attribut thismodul attribut thismodul getdefaultattribut getattr r ml attributeid getattrv r ml attributeid rule referencepropertyatom creat referencepropertyatom xml element name r ml referencepropertyatom rule referencepropertyatom xml element name r ml referencepropertyatom r ml referencepropertyatom isneg isneg referenceproperti thismodul referenceproperti getattr r ml referencepropertyid subject sequenc getelementsbynam r ml subject first children select c thismodul getallobjectvari includ c collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first getelementsbynam r ml subject first children select c thismodul getallobjectvari exclud c select c c oclisundefin assequ first object sequenc getelementsbynam r ml object first children select c thismodul getallobjectvari includ c collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first getelementsbynam r ml object first children select c thismodul getallobjectvari exclud c select c c oclisundefin assequ first rule referenceproperti creat referenceproperti element xml attribut this rule uniqu lazi rule mean call rule uniqu lazi rule referenceproperti xml attribut rfp r ml referenceproperti predicatecategori close name valu rule genericatom creat genericatom element xml element name r ml genericatom rule genericatom xml element name r ml genericatom r ml genericatom argument sequenc getelementsbynam r ml argument first children select e thismodul getallvari includ e collect e thismodul getdefaultgenericvari e getattrv r ml name collect e thismodul genericvari e getelementsbynam r ml argument first children select e thismodul getalldatavari includ e collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e getelementsbynam r ml argument first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e getelementsbynam r ml argument first children select e thismodul getallvari exclud e thismodul getalldatavari exclud e thismodul getallobjectvari exclud e assequ predic thismodul genericpred thismodul getdefaultgenericpred getattr r ml predicateid getattrv r ml predicateid rule genericpred creat predic element xml element name r ml genericpred this rule uniqu lazi rule mean call rule uniqu lazi rule genericpred xml attribut pre r ml genericpred name valu predicatetypeid let pt string parent getattrv r ml predicatetyp pt oclundefin pt objectclassificationpred objectclassificationpred els pt attributionpred attributionpred els pt associationpred associationpred els pt referencepropertypred referencepropertypred els pt equalitypred equalitypred els pt inequalitypred inequalitypred els pt datatypepred datatypepred els pt dataclassificationpred dataclassificationpred els oclundefin endif endif endif endif endif endif endif endif els oclundefin endif rule genericvari creat genericvari element xml element name r ml variabl r ml genericvari this rule uniqu lazi rule mean call rule uniqu lazi rule genericvari xml element r ml genericvari name getattrv r ml name typeref hasattr r ml datatypeid thismodul datatyp thismodul getdefaultdatatyp getattr r ml datatypeid getattrv r ml datatypeid els oclundefin endif rule genericfunctionterm creat genericfunctionterm element xml element name r ml functionterm r ml genericfunctionterm rule genericfunctionterm xml element name r ml functionterm v name r ml genericfunctionterm v r ml genericfunctionterm argument sequenc getelementsbynam r ml argument first children select e thismodul getallvari includ e collect e thismodul getdefaultgenericvari e getattrv r ml name collect e thismodul genericvari e getelementsbynam r ml argument first children select e thismodul getallvari includ e assequ functor fun typecategori hasattr r ml typecategori true getattrv r ml typecategori individu individu els getattrv r ml typecategori set set els getattrv r ml typecategori order orderedset els getattrv r ml typecategori bag bag els getattrv r ml typecategori sequenc sequenc els oclundefin endif endif endif endif endif els oclundefin endif fun r ml genericfunct name getattrv r ml genericfunctionid rule datatypefunctionterm creat datatypefunctionterm element xml element name r ml datatypefunctionterm rule datatypefunctionterm xml element name r ml datatypefunctionterm r ml datatypefunctionterm dataargu sequenc getelementsbynam r ml dataargu first children select e thismodul getalldatavari includ e collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e first getelementsbynam r ml dataargu first children select e thismodul getalldatavari includ e assequ function dtf typecategori hasattr r ml typecategori true getattrv r ml typecategori individu individu els getattrv r ml typecategori set set els getattrv r ml typecategori order orderedset els getattrv r ml typecategori bag bag els getattrv r ml typecategori sequenc sequenc els oclundefin endif endif endif endif endif els oclundefin endif dtf r ml datatypefunct name getattrv r ml datatypefunctionid rule objectnam creat objectnam element xml element name r ml objectnam rule objectnam xml element name r ml objectnam r ml objectnam name getattrv r ml objectid classref let classid string getattrv r ml classid classid oclisundefin thismodul classrul getattr r ml classid els oclundefin endif typecategori hasattr r ml typecategori true getattrv r ml typecategori individu individu els getattrv r ml typecategori set set els getattrv r ml typecategori order orderedset els getattrv r ml typecategori bag bag els getattrv r ml typecategori sequenc sequenc els oclundefin endif endif endif endif endif els oclundefin endif rule objectdescriptionatom creat objectdescriptionatom element xml element name r ml objectdescriptionatom rule objectdescriptionatom xml element name r ml objectdescriptionatom r ml objectdescriptionatom isneg isneg type sequenc thismodul classrul getattr r ml classid slot sequenc getelementsbynam r ml dataslot first children assequ getelementsbynam r ml objectslot first children assequ subject sequenc getelementsbynam r ml subject first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first getelementsbynam r ml subject first children select e thismodul getallobjectvari exclud e select c c oclisundefin assequ first object getelementsbynam r ml object first children assequ basetyp hasattr r ml basetyp thismodul classrul getattr r ml basetyp els oclundefin endif rule objectslot creat objectslot element xml element name r ml objectslot rule objectslot xml element name r ml objectslot r ml objectslot object sequenc getelementsbynam r ml object first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first getelementsbynam r ml object first children select e thismodul getallobjectvari exclud e select c c oclisundefin assequ first referenceproperti thismodul referenceproperti getattr r ml referencepropertyid rule dataslot creat dataslot element xml element name r ml dataslot rule dataslot xml element name r ml dataslot r ml dataslot valu sequenc getelementsbynam r ml valu first children select e thismodul getalldatavari includ e collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e first getelementsbynam r ml valu first children select e thismodul getalldatavari exclud e first select c c oclisundefin assequ first attribut thismodul attribut thismodul getdefaultattribut getattr r ml attributeid getattrv r ml attributeid rule atleastquantifiedformula creat atleastquantifiedformula xml element name r ml atleastquantifiedformula rule atleastquantifiedformula xml element name r ml atleastquantifiedformula r ml atleastquantifiedformula variabl sequenc getelementsbynam r ml objectvari collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e getelementsbynam r ml datavari collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e formula children select e thismodul getalldatavari exclud e thismodul getallobjectvari exclud e e oclistypeof xml element first mincardin getattrv r ml mincardin tointeg rule atmostquantifiedformula creat atmostquantifiedformula xml element name r ml atmostquantifiedformula rule atmostquantifiedformula xml element name r ml atmostquantifiedformula r ml atmostquantifiedformula variabl sequenc getelementsbynam r ml objectvari collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e getelementsbynam r ml datavari collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e formula children select e thismodul getalldatavari exclud e thismodul getallobjectvari exclud e e oclistypeof xml element first maxcardin getattrv r ml maxcardin tointeg rule atleastandatmostquantifiedformula creat atleastandatmostquantifiedformula xml element name r ml atleastandatmostquantifiedformula rule atleastandatmostquantifiedformula xml element name r ml atleastandatmostquantifiedformula r ml atleastandatmostquantifiedformula variabl sequenc getelementsbynam r ml objectvari collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e getelementsbynam r ml datavari collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e formula children select e thismodul getalldatavari exclud e thismodul getallobjectvari exclud e e oclistypeof xml element first maxcardin getattrv r ml maxcardin tointeg mincardin getattrv r ml mincardin tointeg rule objectoperationterm creat objectoperationterm xml element name r ml objectoperationterm rule objectoperationterm xml element name r ml objectoperationterm r ml objectoperationterm oper thismodul objectoper getattr r ml operationid argument sequenc getelementsbynam r ml argument first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e getelementsbynam r ml argument first children select e thismodul getalldatavari includ e collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e getelementsbynam r ml argument first children select e thismodul getallobjectvari exclud e thismodul getalldatavari exclud e contextargu sequenc getelementsbynam r ml contextargu first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first getelementsbynam r ml contextargu first children select e thismodul getallobjectvari exclud e first select c c oclisundefin assequ first lazi rule objectoper creat objectoper xml element name attribut r ml objectoperationterm uniqu lazi rule objectoper xml attribut r ml objectoper name valu rule dataoperationterm creat dataoperationterm xml element name r ml dataoperationterm rule dataoperationterm xml element name r ml dataoperationterm r ml dataoperationterm dataoperationref thismodul dataoper getattr r ml operationid argument sequenc getelementsbynam r ml argument first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e getelementsbynam r ml argument first children select e thismodul getalldatavari includ e collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e getelementsbynam r ml argument first children select e thismodul getallobjectvari exclud e thismodul getalldatavari exclud e contextargu sequenc getelementsbynam r ml contextargu first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first getelementsbynam r ml contextargu first children select e thismodul getallobjectvari exclud e first select c c oclisundefin assequ first lazi rule dataoper creat dataoper xml element name attribut r ml dataoperationterm uniqu lazi rule dataoper xml attribut r ml dataoper name valu,6
150,150,P67-RaiseSupplier-context.atl,"-- @name		Raise supplier abstraction level
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		SIMON Eric(simon.eric3<at>gmail.com)
-- @date		2006/07/27
-- @description	This transformation strenghthens or weakens an assertion(respectively postcondition and precondition).
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 2.13, page 27
-- @see author of article : K. Lano

module RaiseSupplier; -- Module Template
create OUT : KM3 from IN : KM3;

-- @comment this helper returns the root SuperTypes of an element (it is a recursive helper)
helper context KM3!Class def: getRootSuperTypes : Sequence(KM3!Class) =
	if self.supertypes->isEmpty()
		then Sequence{}	
	else 		self.supertypes->select(c | c.supertypes->notEmpty())
					->iterate(a; acc : Sequence(KM3!Class)=Sequence{} |acc->including(a.getRootSuperTypes))
					->union(
					self.supertypes->select(c | c.supertypes->isEmpty())
					->iterate(a; acc : Sequence(KM3!Class)=Sequence{} | acc->including(a) )
			).flatten()
	endif;
	



--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
--@end rule Metamodel

--@begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
--@end rule Package

--@begin rule DataType
rule DataType {
	from
		inputData:KM3!DataType
	to
		outputData:KM3!DataType(
			name <- inputData.name,
			location <- inputData.location
		)
}
--@end rule DataType

--@begin rule EnumLiteral
rule EnumLiteral {
	from
		inputL:KM3!EnumLiteral
	to
		outputL:KM3!EnumLiteral (
			name <- inputL.name,
			location <- inputL.location,
			enum  <- inputL.enum,
			package <- inputL.package
		)
}
--@end rule EnumLiteral

--@begin rule Enumeration 
rule Enumeration {
	from
		inputEnum:KM3!Enumeration
	to
		outputEnum:KM3!Enumeration (
			name <- inputEnum.name,
			location <- inputEnum.location,
			package <- inputEnum.package,
			literals <- inputEnum.literals
		)
}
--@end rule Enumeration 

--@begin rule Class
rule Class {
	from
		inputC:KM3!Class
			to
		outputC:KM3!Class (
			isAbstract <- inputC.isAbstract,
			supertypes <- inputC.supertypes,
			name <- inputC.name,
			location <- inputC.location,
			package <- inputC.package,
			structuralFeatures <- inputC.structuralFeatures->
				select(r | r.oclIsTypeOf(KM3!Reference))->select(r | r.opposite.oclIsUndefined())->
				iterate(a;acc : Sequence(KM3!Reference) = Sequence{} | 
					if a.type.oclIsTypeOf(KM3!Class)
						then acc->append(a.type.getRootSuperTypes->iterate(b; acc1:Sequence(KM3!Reference) = Sequence{}|
							acc1->append(thisModule.InheritAndAssociation(b,a))))->flatten()
						else acc
						endif),
			structuralFeatures <- inputC.structuralFeatures
				->select(r | r.oclIsTypeOf(KM3!Reference))
				->select(r | not r.opposite.oclIsUndefined()),
			structuralFeatures <- inputC.structuralFeatures
				->select(r | not r.oclIsTypeOf(KM3!Reference))
		)
}
--@end rule Class



--@begin rule Attribute
rule Attribute {
	from
		inputAttr : KM3!Attribute
	to
		outputAttr : KM3!Attribute (
			package <- inputAttr.package,
			name <- inputAttr.name,
			lower <- inputAttr.lower,
			upper <- inputAttr.upper,
			isOrdered <- inputAttr.isOrdered,
			isUnique <- inputAttr.isUnique,
			owner <- inputAttr.owner,
			type <- inputAttr.type
		)
}
--@end rule Attribute

--@begin rule Reference
rule ReferenceWithOpposite {
	from
		inputRef : KM3!Reference
		(not inputRef.opposite.oclIsUndefined())
	to
		outputRef : KM3!Reference (
			package <- inputRef.package,
			name <- inputRef.name,
			lower <- inputRef.lower,
			upper <- inputRef.upper,
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			owner <- inputRef.owner,
			type <- inputRef.type,
			isContainer <- inputRef.isContainer,
			opposite <- inputRef.opposite
		)
}
--@end rule Reference

-- @comment this lazy rule creates a reference for a given supertypes end another reference
lazy rule InheritAndAssociation{
	from
		supertype:KM3!Class,
		reference:KM3!Reference
		
	to
		refChildren : KM3!Reference (
			package <- reference.package,
			name <- reference.name,
			lower <- reference.lower,
			upper <- reference.upper,
			isOrdered <- reference.isOrdered,
			isUnique <- reference.isUnique,
			owner <- reference.owner,
			type <- supertype,
			isContainer <- reference.isContainer
		)
}
",name rais supplier abstract level version domain catalogu model transform author simon eric simon eric gmail com date descript this transform strenghthen weaken assert respect postcondit precondit see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul raisesuppli modul templat creat out km in km comment helper return root supertyp element recurs helper helper context km class def getrootsupertyp sequenc km class self supertyp isempti sequenc els self supertyp select c c supertyp notempti iter acc sequenc km class sequenc acc includ getrootsupertyp union self supertyp select c c supertyp isempti iter acc sequenc km class sequenc acc includ flatten endif begin rule metamodel rule metamodel inputmm km metamodel outputmm km metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km packag name inputpkg name content inputpkg content end rule packag begin rule datatyp rule datatyp inputdata km datatyp outputdata km datatyp name inputdata name locat inputdata locat end rule datatyp begin rule enumliter rule enumliter inputl km enumliter outputl km enumliter name inputl name locat inputl locat enum inputl enum packag inputl packag end rule enumliter begin rule enumer rule enumer inputenum km enumer outputenum km enumer name inputenum name locat inputenum locat packag inputenum packag liter inputenum liter end rule enumer begin rule class rule class inputc km class outputc km class isabstract inputc isabstract supertyp inputc supertyp name inputc name locat inputc locat packag inputc packag structuralfeatur inputc structuralfeatur select r r oclistypeof km refer select r r opposit oclisundefin iter acc sequenc km refer sequenc type oclistypeof km class acc append type getrootsupertyp iter b acc sequenc km refer sequenc acc append thismodul inheritandassoci b flatten els acc endif structuralfeatur inputc structuralfeatur select r r oclistypeof km refer select r r opposit oclisundefin structuralfeatur inputc structuralfeatur select r r oclistypeof km refer end rule class begin rule attribut rule attribut inputattr km attribut outputattr km attribut packag inputattr packag name inputattr name lower inputattr lower upper inputattr upper isord inputattr isord isuniqu inputattr isuniqu owner inputattr owner type inputattr type end rule attribut begin rule refer rule referencewithopposit inputref km refer inputref opposit oclisundefin outputref km refer packag inputref packag name inputref name lower inputref lower upper inputref upper isord inputref isord isuniqu inputref isuniqu owner inputref owner type inputref type iscontain inputref iscontain opposit inputref opposit end rule refer comment lazi rule creat refer given supertyp end anoth refer lazi rule inheritandassoci supertyp km class refer km refer refchildren km refer packag refer packag name refer name lower refer lower upper refer upper isord refer isord isuniqu refer isuniqu owner refer owner type supertyp iscontain refer iscontain,8
151,151,P67-RaiseSupplier-without.atl,"-- @name		Raise supplier abstraction level
-- @version		1.1
-- @domains		Catalogue of Model Transformations
-- @authors		SIMON Eric(simon.eric3<at>gmail.com)
-- @date		2006/07/27
-- @description	This transformation strenghthens or weakens an assertion(respectively postcondition and precondition).
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 2.13, page 27
-- @see author of article : K. Lano-- @authors Eric Simon(simon.eric3<at>gmail.com)

module RaiseSupplier; -- Module Template
create OUT : KM3 from IN : KM3;

helper context KM3!Class def: getRootSuperTypes : Sequence(KM3!Class) =
	if self.supertypes->isEmpty()
		then Sequence{}	
	else 		self.supertypes->select(c | c.supertypes->notEmpty())
					->iterate(a; acc : Sequence(KM3!Class)=Sequence{} |acc->including(a.getRootSuperTypes))
					->union(
					self.supertypes->select(c | c.supertypes->isEmpty())
					->iterate(a; acc : Sequence(KM3!Class)=Sequence{} | acc->including(a) )
			).flatten()
	endif;
	



--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
--@end rule Metamodel

--@begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
--@end rule Package


--@begin rule Class
rule Class {
	from
		inputC:KM3!Class
			to
		outputC:KM3!Class (
			isAbstract <- inputC.isAbstract,
			supertypes <- inputC.supertypes,
			name <- inputC.name,
			location <- inputC.location,
			package <- inputC.package,
			structuralFeatures <- inputC.structuralFeatures->
				select(r | r.oclIsTypeOf(KM3!Reference))->select(r | r.opposite.oclIsUndefined())->
				iterate(a;acc : Sequence(KM3!Reference) = Sequence{} | 
					if a.type.oclIsTypeOf(KM3!Class)
						then acc->append(a.type.getRootSuperTypes->iterate(b; acc1:Sequence(KM3!Reference) = Sequence{}|
							acc1->append(thisModule.Inherit2Association(b,a))))->flatten()
						else acc
						endif),
			structuralFeatures <- inputC.structuralFeatures
				->select(r | r.oclIsTypeOf(KM3!Reference))
				->select(r | not r.opposite.oclIsUndefined()),
			structuralFeatures <- inputC.structuralFeatures
				->select(r | not r.oclIsTypeOf(KM3!Reference))
		)
}
--@end rule Class

--@begin rule Reference
rule ReferenceWithOpposite {
	from
		inputRef : KM3!Reference
		(not inputRef.opposite.oclIsUndefined())
	to
		outputRef : KM3!Reference (
			package <- inputRef.package,
			name <- inputRef.name,
			lower <- inputRef.lower,
			upper <- inputRef.upper,
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			owner <- inputRef.owner,
			type <- inputRef.type,
			isContainer <- inputRef.isContainer,
			opposite <- inputRef.opposite
		)
}
--@end rule Reference

lazy rule Inherit2Association{
	from
		supertype:KM3!Class,
		reference:KM3!Reference
		
	to
		refChildren : KM3!Reference (
			package <- reference.package,
			name <- reference.name,
			lower <- reference.lower,
			upper <- reference.upper,
			isOrdered <- reference.isOrdered,
			isUnique <- reference.isUnique,
			owner <- reference.owner,
			type <- supertype,
			isContainer <- reference.isContainer
		)
}
",name rais supplier abstract level version domain catalogu model transform author simon eric simon eric gmail com date descript this transform strenghthen weaken assert respect postcondit precondit see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano author eric simon simon eric gmail com modul raisesuppli modul templat creat out km in km helper context km class def getrootsupertyp sequenc km class self supertyp isempti sequenc els self supertyp select c c supertyp notempti iter acc sequenc km class sequenc acc includ getrootsupertyp union self supertyp select c c supertyp isempti iter acc sequenc km class sequenc acc includ flatten endif begin rule metamodel rule metamodel inputmm km metamodel outputmm km metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km packag name inputpkg name content inputpkg content end rule packag begin rule class rule class inputc km class outputc km class isabstract inputc isabstract supertyp inputc supertyp name inputc name locat inputc locat packag inputc packag structuralfeatur inputc structuralfeatur select r r oclistypeof km refer select r r opposit oclisundefin iter acc sequenc km refer sequenc type oclistypeof km class acc append type getrootsupertyp iter b acc sequenc km refer sequenc acc append thismodul inherit associ b flatten els acc endif structuralfeatur inputc structuralfeatur select r r oclistypeof km refer select r r opposit oclisundefin structuralfeatur inputc structuralfeatur select r r oclistypeof km refer end rule class begin rule refer rule referencewithopposit inputref km refer inputref opposit oclisundefin outputref km refer packag inputref packag name inputref name lower inputref lower upper inputref upper isord inputref isord isuniqu inputref isuniqu owner inputref owner type inputref type iscontain inputref iscontain opposit inputref opposit end rule refer lazi rule inherit associ supertyp km class refer km refer refchildren km refer packag refer packag name refer name lower refer lower upper refer upper isord refer isord isuniqu refer isuniqu owner refer owner type supertyp iscontain refer iscontain,8
152,152,P68-RedundantClassRemovable.atl,"-- @name		Remove redundant classes 
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		SIMON Eric(simon.eric3<at>gmail.com)
-- @date		2006/07/25
-- @description	Classes may be redundant because they are essentially duplicates of other classes in the model but with a different name (synonyms), or because they are not needed in the system being defined.
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 2.4, page 19
-- @see author of article : K. Lano

module RedundantClassRemovable; -- Module Template
create OUT : UML2Target from IN : UML2;


helper def: assoMap : Map(UML2!Class, Sequence(UML2!Class)) = Map{};
rule isAlreadyConsidered(ref1 : UML2!Class, ref2 : UML2!Class) {

	do {
		if (not thisModule.assoMap.get(ref2).oclIsUndefined()) {
			if (thisModule.assoMap.get(ref2)->includes(ref1)) {
				true;
			}
			else {
			    if (not thisModule.assoMap.get(ref1).oclIsUndefined()) {
					thisModule.assoMap <- thisModule.assoMap.including(ref1,thisModule.assoMap.get(ref1)->including(ref2));
					false;
			    }
				else {
					thisModule.assoMap <- thisModule.assoMap.including(ref1, Sequence{ref2});
					false;
				}
			}
		}
		else  {
				if (not thisModule.assoMap.get(ref1).oclIsUndefined()) {
					thisModule.assoMap <- thisModule.assoMap.including(ref1,thisModule.assoMap.get(ref1)->including(ref2));
					false;
			    }
				else {	
					thisModule.assoMap <- thisModule.assoMap.including(ref1, Sequence{ref2});
					false;
				}
		}
		
	}
}

-- @comment this helper returns a boolean, true if a class can be considered as redundant else false. The criterion to consider that a class is redundant is not optimal, so it must strengthen the criterions according to context.
helper def: isRedundantClass : Set(UML2!Class) =
	UML2!Class->allInstances()->select(c|c.oclIsTypeOf(UML2!Class))->
		iterate(inputC1; acc : Sequence(UML2!Class) = Sequence{} | acc->including(UML2!Class->allInstances()->
		select(c|c.oclIsTypeOf(UML2!Class))->
		iterate(inputC2; acc1 : Sequence(UML2!Class) = Sequence{} | 
		acc1->including(
		if
			(inputC1<> inputC2
			and inputC1.ownedAttribute->size() = inputC2.ownedAttribute->size()
			and inputC1.ownedRule->size() = inputC2.ownedRule->size()
			and inputC1.ownedAttribute->collect(a|a.type)->asSet() = inputC2.ownedAttribute->collect(a|a.type)->asSet()
			and (not thisModule.isAlreadyConsidered(inputC1, inputC2)))
		then
			inputC1
		else 
			Sequence{}
		endif
		)
	)
	)->flatten())->flatten()
	;


-- @begin Model
rule Model {
	from
		inputM : UML2!Model
	to
		outputM : UML2Target!Model (
			name <- inputM.name,
			ownedMember <- inputM.ownedMember->select(c|c.oclIsTypeOf(UML2!Class))->select(c| not thisModule.isRedundantClass->includes(c)),
			ownedMember <- inputM.ownedMember->select(c|not c.oclIsTypeOf(UML2!Class))
		)
}
-- @end Model

-- @begin DataType
rule DataType {
	from 
		inputC : UML2!DataType
	to
		outputC : UML2Target!DataType (
		name <- inputC.name
		)
}
-- @end DataType

-- @begin LiteralNull
rule LiteralNull {
	from 
		inputLN : UML2!LiteralNull
		(if inputLN.owner.oclIsTypeOf(UML2!Constraint)
			then
				not (thisModule.isRedundantClass->
					 includes(inputLN.owner.namespace))
			else
				not (if inputLN.owner.owningAssociation->oclIsUndefined()
						then true
						else inputLN.owner.owningAssociation.member->
							exists(p| thisModule.isRedundantClass->includes(p.type))
						endif)
			endif 
		)
	to
		outputLN : UML2Target!LiteralNull
}
-- @end LiteralNull

-- @begin LiteralInteger
rule LiteralInteger {
	from 
		inputLI : UML2!LiteralInteger
		(if inputLI.owner.oclIsTypeOf(UML2!Constraint)
			then
				not (thisModule.isRedundantClass->
					 includes(inputLI.owner.namespace))
			else
				not (if inputLI.owner.owningAssociation->oclIsUndefined()
						then true
						else inputLI.owner.owningAssociation.member->
							exists(p| thisModule.isRedundantClass->includes(p.type))
						endif)
			endif 
		)
	to
		outputLI : UML2Target!LiteralInteger (
			value <- inputLI.value	
		)
}
-- @end LiteralInteger

-- @begin LiteralUnlimitedNatural
rule LiteralUnlimitedNatural {
	from 
		inputLUN : UML2!LiteralUnlimitedNatural
		(if inputLUN.owner.oclIsTypeOf(UML2!Constraint)
			then
				not (thisModule.isRedundantClass->
					 includes(inputLUN.owner.namespace))
			else
				not (if inputLUN.owner.owningAssociation->oclIsUndefined()
						then true
						else inputLUN.owner.owningAssociation.member->
							exists(p| thisModule.isRedundantClass->includes(p.type))
						endif)
			endif 
		)
	to
		outputLUN : UML2Target!LiteralUnlimitedNatural (
			value <- inputLUN.value	
		)
}
-- @end LiteralUnlimitedNatural

-- @begin LiteralString
rule LiteralString {
	from 
		inputLS : UML2!LiteralString
		(if inputLS.owner.oclIsTypeOf(UML2!Constraint)
			then
				not (thisModule.isRedundantClass->
					 includes(inputLS.owner.namespace))
			else
				not (if inputLS.owner.owningAssociation->oclIsUndefined()
						then true
						else inputLS.owner.owningAssociation.member->
							exists(p| thisModule.isRedundantClass->includes(p.type))
						endif)
			endif 
		)
	to
		outputLS : UML2Target!LiteralString (
			value <- inputLS.value	
		)
}
-- @end LiteralString

-- @begin Association
rule Association {
	from 
		inputA : UML2!Association
		(not inputA.member->exists(p| thisModule.isRedundantClass->includes(p.type)))
	to 
		outputA : UML2Target!Association (
			name <- inputA.name,
			memberEnd <- inputA.memberEnd
	)
}
-- @end Association

-- @begin Property
rule Property {
	from 
		inputP : UML2!Property
		(not (thisModule.isRedundantClass->includes(inputP.class_) 
			or thisModule.isRedundantClass->includes(inputP.type)
			or (if inputP.owningAssociation->oclIsUndefined()
				then false
				else inputP.owningAssociation.member->
			exists(p| thisModule.isRedundantClass->includes(p.type))
			endif)
			))
	to
		outputP : UML2Target!Property (
			owningAssociation <- inputP.owningAssociation,
			name <- inputP.name,
			type <- inputP.type,
			upperValue <- inputP.upperValue,
			lowerValue <- inputP.lowerValue,
			defaultValue <-inputP.defaultValue
		)
}
-- @end Property

-- @begin Constraint
rule Constraint {
	from 
		inputC : UML2!Constraint
		(not thisModule.isRedundantClass->includes(inputC.namespace))
	to
		outputC : UML2Target!Constraint (
			name <-	inputC.name,
			namespace <- inputC.namespace,
			specification <- inputC.specification
		)
}
-- @end Constraint

-- @begin Class
rule Class {
	from 
		inputC : UML2!Class
		(not thisModule.isRedundantClass->includes(inputC))
	to 
		outputC : UML2Target!Class (
			name <- inputC.name,
			ownedOperation <- inputC.ownedOperation,
			nestedClassifier <-  inputC.nestedClassifier,
			isActive <-  inputC.isActive,
			ownedReception <-  inputC.ownedReception,
			ownedAttribute <- inputC.ownedAttribute
		)
}
-- @end Class
",name remov redund class version domain catalogu model transform author simon eric simon eric gmail com date descript class may redund essenti duplic class model differ name synonym need system defin see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul redundantclassremov modul templat creat out uml target in uml helper def assomap map uml class sequenc uml class map rule isalreadyconsid ref uml class ref uml class thismodul assomap get ref oclisundefin thismodul assomap get ref includ ref true els thismodul assomap get ref oclisundefin thismodul assomap thismodul assomap includ ref thismodul assomap get ref includ ref fals els thismodul assomap thismodul assomap includ ref sequenc ref fals els thismodul assomap get ref oclisundefin thismodul assomap thismodul assomap includ ref thismodul assomap get ref includ ref fals els thismodul assomap thismodul assomap includ ref sequenc ref fals comment helper return boolean true class consid redund els fals the criterion consid class redund optim must strengthen criterion accord context helper def isredundantclass set uml class uml class allinst select c c oclistypeof uml class iter inputc acc sequenc uml class sequenc acc includ uml class allinst select c c oclistypeof uml class iter inputc acc sequenc uml class sequenc acc includ inputc inputc inputc ownedattribut size inputc ownedattribut size inputc ownedrul size inputc ownedrul size inputc ownedattribut collect type asset inputc ownedattribut collect type asset thismodul isalreadyconsid inputc inputc inputc els sequenc endif flatten flatten begin model rule model inputm uml model outputm uml target model name inputm name ownedmemb inputm ownedmemb select c c oclistypeof uml class select c thismodul isredundantclass includ c ownedmemb inputm ownedmemb select c c oclistypeof uml class end model begin datatyp rule datatyp inputc uml datatyp outputc uml target datatyp name inputc name end datatyp begin literalnul rule literalnul inputln uml literalnul inputln owner oclistypeof uml constraint thismodul isredundantclass includ inputln owner namespac els inputln owner owningassoci oclisundefin true els inputln owner owningassoci member exist p thismodul isredundantclass includ p type endif endif outputln uml target literalnul end literalnul begin literalinteg rule literalinteg input uml literalinteg input owner oclistypeof uml constraint thismodul isredundantclass includ input owner namespac els input owner owningassoci oclisundefin true els input owner owningassoci member exist p thismodul isredundantclass includ p type endif endif output uml target literalinteg valu input valu end literalinteg begin literalunlimitednatur rule literalunlimitednatur inputlun uml literalunlimitednatur inputlun owner oclistypeof uml constraint thismodul isredundantclass includ inputlun owner namespac els inputlun owner owningassoci oclisundefin true els inputlun owner owningassoci member exist p thismodul isredundantclass includ p type endif endif outputlun uml target literalunlimitednatur valu inputlun valu end literalunlimitednatur begin literalstr rule literalstr inputl uml literalstr inputl owner oclistypeof uml constraint thismodul isredundantclass includ inputl owner namespac els inputl owner owningassoci oclisundefin true els inputl owner owningassoci member exist p thismodul isredundantclass includ p type endif endif outputl uml target literalstr valu inputl valu end literalstr begin associ rule associ inputa uml associ inputa member exist p thismodul isredundantclass includ p type outputa uml target associ name inputa name memberend inputa memberend end associ begin properti rule properti inputp uml properti thismodul isredundantclass includ inputp class thismodul isredundantclass includ inputp type inputp owningassoci oclisundefin fals els inputp owningassoci member exist p thismodul isredundantclass includ p type endif outputp uml target properti owningassoci inputp owningassoci name inputp name type inputp type uppervalu inputp uppervalu lowervalu inputp lowervalu defaultvalu inputp defaultvalu end properti begin constraint rule constraint inputc uml constraint thismodul isredundantclass includ inputc namespac outputc uml target constraint name inputc name namespac inputc namespac specif inputc specif end constraint begin class rule class inputc uml class thismodul isredundantclass includ inputc outputc uml target class name inputc name ownedoper inputc ownedoper nestedclassifi inputc nestedclassifi isact inputc isact ownedrecept inputc ownedrecept ownedattribut inputc ownedattribut end class,13
153,153,P69-RemovingAnAssociationClass.atl,"-- @name		Removal of association classes
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		SIMON Eric(simon.eric3<at>gmail.com)
-- @date		2006/08/02
-- @description	This transformation replaces an association class with a new class and two associations.
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 1.2, page 2
-- @see author of article : K. Lano

module RemovingAnAssociationClass; -- Module Template
create OUT : UML2 from IN : UML2;

-- @begin Model
rule Model {
	from
		inputM : UML2!Model
	to
		outputM : UML2!Model (
			name <- inputM.name,
			ownedMember <- inputM.ownedMember,
			ownedMember <- inputM.ownedMember ->
			select(a | a.oclIsTypeOf(UML2!AssociationClass))->
			collect(c|Sequence {thisModule.resolveTemp(c, 'outputAsso1')})->flatten(),
	  		ownedMember <- inputM.ownedMember ->
	  		select(a | a.oclIsTypeOf(UML2!AssociationClass))->
	  		collect(c|Sequence {thisModule.resolveTemp(c, 'outputAsso2')})->flatten()
		)
}
-- @end Model

-- @begin DataType
rule DataType {
	from 
		inputC : UML2!DataType
	to
		outputC : UML2!DataType (
		name <- inputC.name
		)
}
-- @end DataType

-- @begin LiteralNull
rule LiteralNull {
	from 
		inputLN : UML2!LiteralNull
	to
		outputLN : UML2!LiteralNull
}
-- @end LiteralNull

-- @begin LiteralInteger
rule LiteralInteger {
	from 
		inputLI : UML2!LiteralInteger
	to
		outputLI : UML2!LiteralInteger (
			value <- inputLI.value	
		)
}
-- @end LiteralInteger

-- @begin LiteralUnlimitedNatural
rule LiteralUnlimitedNatural {
	from 
		inputLUN : UML2!LiteralUnlimitedNatural
	to
		outputLUN : UML2!LiteralUnlimitedNatural (
			value <- inputLUN.value	
		)
}
-- @end LiteralUnlimitedNatural

-- @begin Property
rule Property {
	from 
		inputC : UML2!Property
		(
			not (
				inputC.class_.oclIsTypeOf(UML2!AssociationClass)
			and
				inputC.association.oclIsTypeOf(UML2!AssociationClass)
				)
		)
	to
		outputC : UML2!Property (
			name <- inputC.name,
			type <- inputC.type
		)
}
-- @end Property

-- @begin Class
rule Class {
	from 
		inputC : UML2!Class
		(not inputC.oclIsTypeOf(UML2!AssociationClass))
	to 
		outputC : UML2!Class (
			name <- inputC.name,
			ownedOperation <- inputC.ownedOperation,
			nestedClassifier <-  inputC.nestedClassifier,
			isActive <-  inputC.isActive,
			ownedReception <-  inputC.ownedReception,
			ownedAttribute <- inputC.ownedAttribute
		)
}
-- @end Class

-- @comment this rule replace a association class by a new class between two associations.
-- @begin AssociationClass2Class
rule AssociationClass2Class {
	from 
		inputA : UML2!AssociationClass
	to
		outputClass : UML2!Class (
			name <- inputA.name,
			ownedAttribute <- inputA.ownedAttribute->select(a|a.association->oclIsUndefined())
		),
		outputDef1 : UML2! LiteralInteger (
			value <- 1	
		),
		outputPro11 : UML2!Property (
			owningAssociation <- outputAsso1,
			name <- inputA.memberEnd->at(1).name,
			upperValue <- inputA.memberEnd->at(1).upperValue,
			lowerValue <- inputA.memberEnd->at(1).lowerValue,
			defaultValue <- inputA.memberEnd->at(1).defaultValue
		),
		outputPro12 : UML2!Property (
			owningAssociation <- outputAsso1,
			name <- inputA.memberEnd->at(2).type.name->toLower(),
			defaultValue <- outputDef1
		),
		outputAsso1 : UML2!Association(
			memberEnd <- outputPro11,
			memberEnd <- outputPro12
			
		),
		outputDef2 : UML2! LiteralInteger (
			value <- 1	
		),
		outputPro21 : UML2!Property (
			owningAssociation <- outputAsso2,
			name <- inputA.memberEnd->at(2).name,
			upperValue <- inputA.memberEnd->at(2).upperValue,
			lowerValue <- inputA.memberEnd->at(2).lowerValue,
			defaultValue <- inputA.memberEnd->at(2).defaultValue
		),
		outputPro22 : UML2!Property (
			owningAssociation <- outputAsso2,
			name <- inputA.memberEnd->at(1).type.name->toLower(),
			defaultValue <- outputDef2
		),
		outputAsso2 : UML2!Association(
			memberEnd <- outputPro21,
			memberEnd <- outputPro22
		)
}
-- @end	AssociationClass2Class
",name remov associ class version domain catalogu model transform author simon eric simon eric gmail com date descript this transform replac associ class new class two associ see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul removinganassociationclass modul templat creat out uml in uml begin model rule model inputm uml model outputm uml model name inputm name ownedmemb inputm ownedmemb ownedmemb inputm ownedmemb select oclistypeof uml associationclass collect c sequenc thismodul resolvetemp c outputasso flatten ownedmemb inputm ownedmemb select oclistypeof uml associationclass collect c sequenc thismodul resolvetemp c outputasso flatten end model begin datatyp rule datatyp inputc uml datatyp outputc uml datatyp name inputc name end datatyp begin literalnul rule literalnul inputln uml literalnul outputln uml literalnul end literalnul begin literalinteg rule literalinteg input uml literalinteg output uml literalinteg valu input valu end literalinteg begin literalunlimitednatur rule literalunlimitednatur inputlun uml literalunlimitednatur outputlun uml literalunlimitednatur valu inputlun valu end literalunlimitednatur begin properti rule properti inputc uml properti inputc class oclistypeof uml associationclass inputc associ oclistypeof uml associationclass outputc uml properti name inputc name type inputc type end properti begin class rule class inputc uml class inputc oclistypeof uml associationclass outputc uml class name inputc name ownedoper inputc ownedoper nestedclassifi inputc nestedclassifi isact inputc isact ownedrecept inputc ownedrecept ownedattribut inputc ownedattribut end class comment rule replac associ class new class two associ begin associationclass class rule associationclass class inputa uml associationclass outputclass uml class name inputa name ownedattribut inputa ownedattribut select associ oclisundefin outputdef uml literalinteg valu outputpro uml properti owningassoci outputasso name inputa memberend name uppervalu inputa memberend uppervalu lowervalu inputa memberend lowervalu defaultvalu inputa memberend defaultvalu outputpro uml properti owningassoci outputasso name inputa memberend type name tolow defaultvalu outputdef outputasso uml associ memberend outputpro memberend outputpro outputdef uml literalinteg valu outputpro uml properti owningassoci outputasso name inputa memberend name uppervalu inputa memberend uppervalu lowervalu inputa memberend lowervalu defaultvalu inputa memberend defaultvalu outputpro uml properti owningassoci outputasso name inputa memberend type name tolow defaultvalu outputdef outputasso uml associ memberend outputpro memberend outputpro end associationclass class,13
154,154,P7-Book2Publication.atl,"module Book2Publication;
create OUT : Publication from IN : Book;

-- getAuthors collects all Autors of a Book
-- the asSet operation removes all duplicates

helper context Book!Book def : getAuthors() : String =
       self.chapters->collect(e | e.author)->
	   					asSet()->
						iterate(authorName; acc : String = '' |
                   				acc + 
								if acc = '' 
									then authorName 
									else ' and ' + authorName 
								endif)
;

-- getNbPages collects all nbPages of all chapters
-- and calculates the sum

helper context Book!Book def : getNbPages() : Integer =
		self.chapters->collect(f|f.nbPages)->
						iterate(pages; acc : Integer = 0 |
                      	acc + pages)
;

-- getSumPages does the same as getNbPages,
-- but it uses the OCL sum operation

helper context Book!Book def : getSumPages() : Integer =
		self.chapters->collect(f|f.nbPages).sum()
;


rule Book2Publication {
	from 
		b : Book!Book (
			b.getSumPages() > 2
			-- only Books with more than 2 pages are publications
		) 
	to 
		out : Publication!Publication (
            title <- b.title,
			authors <- b.getAuthors(),
			nbPages <- b.getSumPages()
		)
}



",modul book public creat out public in book getauthor collect autor book asset oper remov duplic helper context book book def getauthor string self chapter collect e e author asset iter authornam acc string acc acc authornam els authornam endif getnbpag collect nbpage chapter calcul sum helper context book book def getnbpag integ self chapter collect f f nbpage iter page acc integ acc page getsumpag getnbpag use ocl sum oper helper context book book def getsumpag integ self chapter collect f f nbpage sum rule book public b book book b getsumpag book page public public public titl b titl author b getauthor nbpage b getsumpag,15
155,155,P7-XML2Book.atl,"module XML2Book;
create OUT : Book from IN : XML;

helper context XML!Element def: getAttrVal(name : String) : String =
	self.children->select(c | c.oclIsKindOf(XML!Attribute) and c.name = name)->first().value;

rule Book {
	from
		e : XML!Element (
			e.name = 'book'
		)
	to
		b : Book!Book (
			title <- e.getAttrVal('title'),
			chapters <- e.children->select(c | c.oclIsKindOf(XML!Element))->asSequence()
		)
}

rule Chapter {
	from
		e : XML!Element (
			e.name = 'chapter'
		)
	to
		c : Book!Chapter (
			title <- e.getAttrVal('title'),
			nbPages <- e.getAttrVal('nbPages').toInteger(),
			author <- e.getAttrVal('author')
		)
}",modul xml book creat out book in xml helper context xml element def getattrv name string string self children select c c ocliskindof xml attribut c name name first valu rule book e xml element e name book b book book titl e getattrv titl chapter e children select c c ocliskindof xml element assequ rule chapter e xml element e name chapter c book chapter titl e getattrv titl nbpage e getattrv nbpage tointeg author e getattrv author,5
156,156,P70-Removing-context.atl,"-- @name		Removal of many-many associations (with all context)
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		SIMON Eric(simon.eric3<at>gmail.com)
-- @date		2006/08/02
-- @description	The purpose of this transformation is to substitute a many-many association by an introduction of class with two many-one associations.
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 1.2, page 2
-- @see author of article : K. Lano

module Removing; -- Module Template
create OUT : KM3Target from IN : KM3;

-- @comment this helper allows to know if a reference oswn the properties necessary for the rule association  
helper context KM3!Reference def: isManyToManyNotContainer : Boolean =
	self.lower = 0 and self.upper < 0 and not self.isContainer
	;
-- @comment this helper create a Map which uses in the rule isAlreadyConsidered. 
helper def: assoMap : Map(KM3!Reference, Sequence(KM3!Reference)) = Map{};
-- @comment this rule allows to know if a pair of element is already considered. E.g.: {A,B} and {B,A} => {A,B}. 
rule isAlreadyConsidered(ref1 : KM3!Reference, ref2 : KM3!Reference) {

	do {
		if (not thisModule.assoMap.get(ref2).oclIsUndefined()) {
			if (thisModule.assoMap.get(ref2)->includes(ref1)) {
				true;
			}
			else {
			    if (not thisModule.assoMap.get(ref1).oclIsUndefined()) {
					thisModule.assoMap <- thisModule.assoMap.including(ref1,thisModule.assoMap.get(ref1)->including(ref2));
					false;
			    }
				else {
					thisModule.assoMap <- thisModule.assoMap.including(ref1, Sequence{ref2});
					false;
				}
			}
		}
		else  {
				if (not thisModule.assoMap.get(ref1).oclIsUndefined()) {
					thisModule.assoMap <- thisModule.assoMap.including(ref1,thisModule.assoMap.get(ref1)->including(ref2));
					false;
			    }
				else {	
					thisModule.assoMap <- thisModule.assoMap.including(ref1, Sequence{ref2});
					false;
				}
		}
		
	}
}

-- @begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3Target!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
-- @end rule Metamodel

-- @begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3Target!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
-- @end rule Package

-- @begin rule DataType
rule DataType {
	from
		inputData:KM3!DataType
	to
		outputData:KM3Target!DataType(
			name <- inputData.name,
			location <- inputData.location
		)
}
-- @end rule DataType

-- @begin rule EnumLiteral
rule EnumLiteral {
	from
		inputL:KM3!EnumLiteral
	to
		outputL:KM3Target!EnumLiteral (
			name <- inputL.name,
			location <- inputL.location,
			enum  <- inputL.enum,
			package <- inputL.package
		)
}
-- @end rule EnumLiteral

-- @begin rule Enumeration 
rule Enumeration {
	from
		inputEnum:KM3!Enumeration
	to
		outputEnum:KM3Target!Enumeration (
			name <- inputEnum.name,
			location <- inputEnum.location,
			package <- inputEnum.package,
			literals <- inputEnum.literals
		)
}
-- @end rule Enumeration 



-- @begin rule Class
rule Class {
	from
		inputC:KM3!Class
		(not inputC.structuralFeatures->select(a|a.oclIsTypeOf(KM3!Reference))->exists(r| r.isManyToManyNotContainer and r.opposite.isManyToManyNotContainer))
	to
		outputC:KM3Target!Class (
			isAbstract <- inputC.isAbstract,
			supertypes <- inputC.supertypes,
			name <- inputC.name,
			location <- inputC.location,
			package <- inputC.package,
			structuralFeatures <- inputC.structuralFeatures
		)
}
-- @end rule Class

-- @begin rule Attribute
rule Attribute {
	from
		inputAttr : KM3!Attribute
	to
		outputAttr : KM3Target!Attribute (
			package <- inputAttr.package,
			name <- inputAttr.name,
			lower <- inputAttr.lower,
			upper <- inputAttr.upper,
			isOrdered <- inputAttr.isOrdered,
			isUnique <- inputAttr.isUnique,
			owner <- inputAttr.owner,
			type <- inputAttr.type
		)
}
-- @end rule Attribute

-- @begin rule Reference
rule Reference {
	from
		inputRef : KM3!Reference
			( not (inputRef.isManyToManyNotContainer and inputRef.opposite.isManyToManyNotContainer))
	to
		outputRef : KM3Target!Reference (
			package <- inputRef.package,
			name <- inputRef.name,
			lower <- inputRef.lower,
			upper <- inputRef.upper,
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			owner <- inputRef.owner,
			type <- inputRef.type,
			isContainer <- inputRef.isContainer,
			opposite <- inputRef.opposite
		)
}
-- @end rule Reference

-- @comment This rule takes a pair of Reference and, if  these are not already considered, creates a class with two many-one association.
-- @begin rule Association
rule Association {
	from
		inputA : KM3!Reference,
		inputB : KM3!Reference
		(
			inputA.opposite = inputB
			and inputA.isManyToManyNotContainer
			and inputB.isManyToManyNotContainer
			--	and inputA <> inputB
			and not thisModule.isAlreadyConsidered(inputA, inputB)
		)


	to
		outputA : KM3Target!Class (
			package <- inputA.owner.package,
			name <- inputA.owner.name,
			isAbstract <- inputA.owner.isAbstract,
			structuralFeatures <- inputA.owner.structuralFeatures->select(b|b.oclIsTypeOf(KM3!Reference))->select(a| not a.isManyToManyNotContainer),
			structuralFeatures <- inputA.owner.structuralFeatures->select(b|b.oclIsTypeOf(KM3!Attribute)),
			structuralFeatures <- referenceAC
		),
		outputB : KM3Target!Class (
			package <- inputB.owner.package,
			name <- inputB.owner.name,
			isAbstract <- inputB.owner.isAbstract,
			structuralFeatures <- inputB.owner.structuralFeatures->select(b|b.oclIsTypeOf(KM3!Reference))->select(a| not a.isManyToManyNotContainer),
			structuralFeatures <- inputB.owner.structuralFeatures->select(b|b.oclIsTypeOf(KM3!Attribute)),
			structuralFeatures <- referenceBC
		),
		outputC : KM3Target!Class (
			package <- inputA.owner.package,
			name <- inputA.owner.name->concat(inputB.owner.name),
			isAbstract <- false,
			structuralFeatures <- referenceCA,
			structuralFeatures <- referenceCB
      		
		),
		referenceAC : KM3Target!Reference (
			name <- inputA.name,
			lower <- 1,
			upper <- 1,
			isOrdered <- false,
			isUnique <- false,
			owner <- outputA,
			isContainer <- false,
			opposite <- referenceCA
		),
		referenceCA : KM3Target!Reference (
			name <- outputC.name->concat('1'),
			lower <- 0,
			upper <- 0-1,
			isOrdered <- false,
			isUnique <- false,
			owner <- outputC,
			isContainer <- false,
			opposite <- referenceAC
		),
		referenceBC : KM3Target!Reference (
			name <- inputB.name,
			lower <- 1,
			upper <- 1,
			isOrdered <- false,
			isUnique <- false,
			owner <- outputB,
			isContainer <- false,
			opposite <- referenceCB
		),
		referenceCB : KM3Target!Reference (
			name <- outputC.name->concat('2'),
			lower <- 0,
			upper <- 0-1,
			isOrdered <- false,
			isUnique <- false,
			owner <- outputC,
			isContainer <- false,
			opposite <- referenceBC
		)

}
--@end rule Association


",name remov mani mani associ context version domain catalogu model transform author simon eric simon eric gmail com date descript the purpos transform substitut mani mani associ introduct class two mani one associ see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul remov modul templat creat out km target in km comment helper allow know refer oswn properti necessari rule associ helper context km refer def ismanytomanynotcontain boolean self lower self upper self iscontain comment helper creat map use rule isalreadyconsid helper def assomap map km refer sequenc km refer map comment rule allow know pair element alreadi consid e g a b b a a b rule isalreadyconsid ref km refer ref km refer thismodul assomap get ref oclisundefin thismodul assomap get ref includ ref true els thismodul assomap get ref oclisundefin thismodul assomap thismodul assomap includ ref thismodul assomap get ref includ ref fals els thismodul assomap thismodul assomap includ ref sequenc ref fals els thismodul assomap get ref oclisundefin thismodul assomap thismodul assomap includ ref thismodul assomap get ref includ ref fals els thismodul assomap thismodul assomap includ ref sequenc ref fals begin rule metamodel rule metamodel inputmm km metamodel outputmm km target metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km target packag name inputpkg name content inputpkg content end rule packag begin rule datatyp rule datatyp inputdata km datatyp outputdata km target datatyp name inputdata name locat inputdata locat end rule datatyp begin rule enumliter rule enumliter inputl km enumliter outputl km target enumliter name inputl name locat inputl locat enum inputl enum packag inputl packag end rule enumliter begin rule enumer rule enumer inputenum km enumer outputenum km target enumer name inputenum name locat inputenum locat packag inputenum packag liter inputenum liter end rule enumer begin rule class rule class inputc km class inputc structuralfeatur select oclistypeof km refer exist r r ismanytomanynotcontain r opposit ismanytomanynotcontain outputc km target class isabstract inputc isabstract supertyp inputc supertyp name inputc name locat inputc locat packag inputc packag structuralfeatur inputc structuralfeatur end rule class begin rule attribut rule attribut inputattr km attribut outputattr km target attribut packag inputattr packag name inputattr name lower inputattr lower upper inputattr upper isord inputattr isord isuniqu inputattr isuniqu owner inputattr owner type inputattr type end rule attribut begin rule refer rule refer inputref km refer inputref ismanytomanynotcontain inputref opposit ismanytomanynotcontain outputref km target refer packag inputref packag name inputref name lower inputref lower upper inputref upper isord inputref isord isuniqu inputref isuniqu owner inputref owner type inputref type iscontain inputref iscontain opposit inputref opposit end rule refer comment this rule take pair refer alreadi consid creat class two mani one associ begin rule associ rule associ inputa km refer inputb km refer inputa opposit inputb inputa ismanytomanynotcontain inputb ismanytomanynotcontain inputa inputb thismodul isalreadyconsid inputa inputb outputa km target class packag inputa owner packag name inputa owner name isabstract inputa owner isabstract structuralfeatur inputa owner structuralfeatur select b b oclistypeof km refer select ismanytomanynotcontain structuralfeatur inputa owner structuralfeatur select b b oclistypeof km attribut structuralfeatur referenceac outputb km target class packag inputb owner packag name inputb owner name isabstract inputb owner isabstract structuralfeatur inputb owner structuralfeatur select b b oclistypeof km refer select ismanytomanynotcontain structuralfeatur inputb owner structuralfeatur select b b oclistypeof km attribut structuralfeatur referencebc outputc km target class packag inputa owner packag name inputa owner name concat inputb owner name isabstract fals structuralfeatur referenceca structuralfeatur referencecb referenceac km target refer name inputa name lower upper isord fals isuniqu fals owner outputa iscontain fals opposit referenceca referenceca km target refer name outputc name concat lower upper isord fals isuniqu fals owner outputc iscontain fals opposit referenceac referencebc km target refer name inputb name lower upper isord fals isuniqu fals owner outputb iscontain fals opposit referencecb referencecb km target refer name outputc name concat lower upper isord fals isuniqu fals owner outputc iscontain fals opposit referencebc end rule associ,19
157,157,P70-Removing-without.atl,"-- @name		Removal of many-many associations (with only the  elements necessary for the example context)
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		SIMON Eric(simon.eric3<at>gmail.com)
-- @date		2006/08/02
-- @description	The purpose of this transformation is to substitute a many-many association by an introduction of class with two many-one associations.
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 1.2, page 2
-- @see author of article : K. Lano

module Removing; -- Module Template
create OUT : KM3Target from IN : KM3;

-- @comment this helper allows to know if a reference oswn the properties necessary for the rule association  
helper context KM3!Reference def: isManyToManyNotContainer : Boolean =
	self.lower = 0 and self.upper < 0 and not self.isContainer
	;
-- @comment this helper create a Map which uses in the rule isAlreadyConsidered. 
helper def: assoMap : Map(KM3!Reference, Sequence(KM3!Reference)) = Map{};
-- @comment this rule allows to know if a pair of element is already considered. E.g.: {A,B} and {B,A} => {A,B}. 
rule isAlreadyConsidered(ref1 : KM3!Reference, ref2 : KM3!Reference) {

	do {
		if (not thisModule.assoMap.get(ref2).oclIsUndefined()) {
			if (thisModule.assoMap.get(ref2)->includes(ref1)) {
				true;
			}
			else {
			    if (not thisModule.assoMap.get(ref1).oclIsUndefined()) {
					thisModule.assoMap <- thisModule.assoMap.including(ref1,thisModule.assoMap.get(ref1)->including(ref2));
					false;
			    }
				else {
					thisModule.assoMap <- thisModule.assoMap.including(ref1, Sequence{ref2});
					false;
				}
			}
		}
		else  {
				if (not thisModule.assoMap.get(ref1).oclIsUndefined()) {
					thisModule.assoMap <- thisModule.assoMap.including(ref1,thisModule.assoMap.get(ref1)->including(ref2));
					false;
			    }
				else {	
					thisModule.assoMap <- thisModule.assoMap.including(ref1, Sequence{ref2});
					false;
				}
		}
		
	}
}

-- @begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3Target!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
-- @end rule Metamodel

-- @begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3Target!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
-- @end rule Package

-- @begin rule Class
rule Class {
	from
		inputC:KM3!Class
		(not inputC.structuralFeatures->select(a|a.oclIsTypeOf(KM3!Reference))->exists(r| r.isManyToManyNotContainer and r.opposite.isManyToManyNotContainer))
	to
		outputC:KM3Target!Class (
			isAbstract <- inputC.isAbstract,
			supertypes <- inputC.supertypes,
			name <- inputC.name,
			location <- inputC.location,
			package <- inputC.package,
			structuralFeatures <- inputC.structuralFeatures
		)
}
-- @end rule Class



-- @begin rule Reference
rule Reference {
	from
		inputRef : KM3!Reference
			( not (inputRef.isManyToManyNotContainer and inputRef.opposite.isManyToManyNotContainer))
	to
		outputRef : KM3Target!Reference (
			package <- inputRef.package,
			name <- inputRef.name,
			lower <- inputRef.lower,
			upper <- inputRef.upper,
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			owner <- inputRef.owner,
			type <- inputRef.type,
			isContainer <- inputRef.isContainer,
			opposite <- inputRef.opposite
		)
}
-- @end rule Reference

-- @comment This rule takes a pair of Reference and, if  these are not already considered, creates a class with two many-one association.
-- @begin rule Association
rule Association {
	from
		inputA : KM3!Reference,
		inputB : KM3!Reference
		(
			inputA.opposite = inputB
			and inputA.isManyToManyNotContainer
			and inputB.isManyToManyNotContainer
			--	and inputA <> inputB
			and not thisModule.isAlreadyConsidered(inputA, inputB)
		)


	to
		outputA : KM3Target!Class (
			package <- inputA.owner.package,
			name <- inputA.owner.name,
			isAbstract <- inputA.owner.isAbstract,
			structuralFeatures <- inputA.owner.structuralFeatures->select(b|b.oclIsTypeOf(KM3!Reference))->select(a| not a.isManyToManyNotContainer),
			structuralFeatures <- inputA.owner.structuralFeatures->select(b|b.oclIsTypeOf(KM3!Attribute)),
			structuralFeatures <- referenceAC
		),
		outputB : KM3Target!Class (
			package <- inputB.owner.package,
			name <- inputB.owner.name,
			isAbstract <- inputB.owner.isAbstract,
			structuralFeatures <- inputB.owner.structuralFeatures->select(b|b.oclIsTypeOf(KM3!Reference))->select(a| not a.isManyToManyNotContainer),
			structuralFeatures <- inputB.owner.structuralFeatures->select(b|b.oclIsTypeOf(KM3!Attribute)),
			structuralFeatures <- referenceBC
		),
		outputC : KM3Target!Class (
			package <- inputA.owner.package,
			name <- inputA.owner.name->concat(inputB.owner.name),
			isAbstract <- false,
			structuralFeatures <- referenceCA,
			structuralFeatures <- referenceCB
      		
		),
		referenceAC : KM3Target!Reference (
			name <- inputA.name,
			lower <- 1,
			upper <- 1,
			isOrdered <- false,
			isUnique <- false,
			owner <- outputA,
			isContainer <- false,
			opposite <- referenceCA
		),
		referenceCA : KM3Target!Reference (
			name <- outputC.name->concat('1'),
			lower <- 0,
			upper <- 0-1,
			isOrdered <- false,
			isUnique <- false,
			owner <- outputC,
			isContainer <- false,
			opposite <- referenceAC
		),
		referenceBC : KM3Target!Reference (
			name <- inputB.name,
			lower <- 1,
			upper <- 1,
			isOrdered <- false,
			isUnique <- false,
			owner <- outputB,
			isContainer <- false,
			opposite <- referenceCB
		),
		referenceCB : KM3Target!Reference (
			name <- outputC.name->concat('2'),
			lower <- 0,
			upper <- 0-1,
			isOrdered <- false,
			isUnique <- false,
			owner <- outputC,
			isContainer <- false,
			opposite <- referenceBC
		)

}
--@end rule Association


",name remov mani mani associ element necessari exampl context version domain catalogu model transform author simon eric simon eric gmail com date descript the purpos transform substitut mani mani associ introduct class two mani one associ see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul remov modul templat creat out km target in km comment helper allow know refer oswn properti necessari rule associ helper context km refer def ismanytomanynotcontain boolean self lower self upper self iscontain comment helper creat map use rule isalreadyconsid helper def assomap map km refer sequenc km refer map comment rule allow know pair element alreadi consid e g a b b a a b rule isalreadyconsid ref km refer ref km refer thismodul assomap get ref oclisundefin thismodul assomap get ref includ ref true els thismodul assomap get ref oclisundefin thismodul assomap thismodul assomap includ ref thismodul assomap get ref includ ref fals els thismodul assomap thismodul assomap includ ref sequenc ref fals els thismodul assomap get ref oclisundefin thismodul assomap thismodul assomap includ ref thismodul assomap get ref includ ref fals els thismodul assomap thismodul assomap includ ref sequenc ref fals begin rule metamodel rule metamodel inputmm km metamodel outputmm km target metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km target packag name inputpkg name content inputpkg content end rule packag begin rule class rule class inputc km class inputc structuralfeatur select oclistypeof km refer exist r r ismanytomanynotcontain r opposit ismanytomanynotcontain outputc km target class isabstract inputc isabstract supertyp inputc supertyp name inputc name locat inputc locat packag inputc packag structuralfeatur inputc structuralfeatur end rule class begin rule refer rule refer inputref km refer inputref ismanytomanynotcontain inputref opposit ismanytomanynotcontain outputref km target refer packag inputref packag name inputref name lower inputref lower upper inputref upper isord inputref isord isuniqu inputref isuniqu owner inputref owner type inputref type iscontain inputref iscontain opposit inputref opposit end rule refer comment this rule take pair refer alreadi consid creat class two mani one associ begin rule associ rule associ inputa km refer inputb km refer inputa opposit inputb inputa ismanytomanynotcontain inputb ismanytomanynotcontain inputa inputb thismodul isalreadyconsid inputa inputb outputa km target class packag inputa owner packag name inputa owner name isabstract inputa owner isabstract structuralfeatur inputa owner structuralfeatur select b b oclistypeof km refer select ismanytomanynotcontain structuralfeatur inputa owner structuralfeatur select b b oclistypeof km attribut structuralfeatur referenceac outputb km target class packag inputb owner packag name inputb owner name isabstract inputb owner isabstract structuralfeatur inputb owner structuralfeatur select b b oclistypeof km refer select ismanytomanynotcontain structuralfeatur inputb owner structuralfeatur select b b oclistypeof km attribut structuralfeatur referencebc outputc km target class packag inputa owner packag name inputa owner name concat inputb owner name isabstract fals structuralfeatur referenceca structuralfeatur referencecb referenceac km target refer name inputa name lower upper isord fals isuniqu fals owner outputa iscontain fals opposit referenceca referenceca km target refer name outputc name concat lower upper isord fals isuniqu fals owner outputc iscontain fals opposit referenceac referencebc km target refer name inputb name lower upper isord fals isuniqu fals owner outputb iscontain fals opposit referencecb referencecb km target refer name outputc name concat lower upper isord fals isuniqu fals owner outputc iscontain fals opposit referencebc end rule associ,19
158,158,P71-ForeignKey-context.atl,"-- @name		Replacing association by foreign key
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		Baudry Julien (jul.baudry<at>gmail.com)
-- @date		2006/08/02
-- @description	The purpose of this transformation is to replace an association by a foreign key
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 1.6, page 7
-- @see author of article : K. Lano

module ForeignKey; -- Module Template
create OUT : KM3target from IN : KM3;

----@begin rule Metamodel
--entrypoint rule Metamodel() {
--	do {
--		KM3!Metamodel.allInstances().debug('metamodels');
--		KM3!Package.allInstances().debug('packages');
--		KM3!Class.allInstances().debug('classes');
--		KM3!DataType.allInstances().debug('datatypes');
--	}
--}
----@end rule Metamodel

--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3target!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
--@end rule Metamodel

--@begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3target!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
--@end rule Package

--@begin rule Class
rule Class {
	from
		inputA:KM3!Class
	to
		outputA:KM3target!Class (
			name <- inputA.name,
			isAbstract <- inputA.isAbstract,
			structuralFeatures <- inputA.structuralFeatures
		),
		
		key:KM3target!Attribute (
			name <- inputA.name.toLower()+'Key',
			isOrdered <- false,
			isUnique <- false,
			location <- '',
			lower <- 1,
			upper <- 1,
			type <- KM3!DataType.allInstances()->select(a|a.name = 'Integer')->first(),
			owner <- inputA
		)
}
--@end rule Class

--@begin rule attribute 
rule attribute {
	from
		inputAtt:KM3!Attribute 
	to
		outputAtt:KM3target!Attribute(
			name <- inputAtt.name,
			isOrdered <- inputAtt.isOrdered,
			isUnique <- inputAtt.isUnique,
			location <- inputAtt.location,
			lower <- inputAtt.lower,
			upper <- inputAtt.upper,
			type <- inputAtt.type,
			owner <- inputAtt.owner
			
		)
}
--@end rule attribute

--@begin rule datatype
rule DataType {
from
		inputData:KM3!DataType
	to
		outputData:KM3target!DataType(
			name <- inputData.name,
			location <- inputData.location
		)
}
--@end rule datatype

--@begin foreignkey
rule reference2Key {
	from 
		r:KM3!Reference (
			r.upper = 1	
		)
	to
		key:KM3target!Attribute (
			name <- r.type.name.toLower()+'ForeignKey',
			isOrdered <- false,
			isUnique <- false,
			location <- '',
			lower <- 1,
			upper <- 1,
			type <- KM3!DataType.allInstances()->select(a|a.name = 'Integer')->first(),
			owner <- r.owner
		)
}
--@end foreignkey

--@begin enumeration
rule enumeration {
	from
		inputEnum:KM3!Enumeration 
	to
		outputEnum:KM3target!Enumeration (
			location <- inputEnum.location,
			name  <- inputEnum.name,
			package  <- inputEnum.package
		)

}
--@end enumeration

--@begin literal
rule literal {
	from
		inputEnum:KM3!EnumLiteral
	to
		outputEnum:KM3target!EnumLiteral (
			location <- inputEnum.location,
			name  <- inputEnum.name,
			enum  <- inputEnum.enum
		)

}
--@end literal
",name replac associ foreign key version domain catalogu model transform author baudri julien jul baudri gmail com date descript the purpos transform replac associ foreign key see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul foreignkey modul templat creat out km target in km begin rule metamodel entrypoint rule metamodel km metamodel allinst debug metamodel km packag allinst debug packag km class allinst debug class km datatyp allinst debug datatyp end rule metamodel begin rule metamodel rule metamodel inputmm km metamodel outputmm km target metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km target packag name inputpkg name content inputpkg content end rule packag begin rule class rule class inputa km class outputa km target class name inputa name isabstract inputa isabstract structuralfeatur inputa structuralfeatur key km target attribut name inputa name tolow key isord fals isuniqu fals locat lower upper type km datatyp allinst select name integ first owner inputa end rule class begin rule attribut rule attribut inputatt km attribut outputatt km target attribut name inputatt name isord inputatt isord isuniqu inputatt isuniqu locat inputatt locat lower inputatt lower upper inputatt upper type inputatt type owner inputatt owner end rule attribut begin rule datatyp rule datatyp inputdata km datatyp outputdata km target datatyp name inputdata name locat inputdata locat end rule datatyp begin foreignkey rule refer key r km refer r upper key km target attribut name r type name tolow foreignkey isord fals isuniqu fals locat lower upper type km datatyp allinst select name integ first owner r owner end foreignkey begin enumer rule enumer inputenum km enumer outputenum km target enumer locat inputenum locat name inputenum name packag inputenum packag end enumer begin liter rule liter inputenum km enumliter outputenum km target enumliter locat inputenum locat name inputenum name enum inputenum enum end liter,1
159,159,P71-ForeignKey-without.atl,"-- @name		Replacing association by foreign key
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		Baudry Julien (jul.baudry<at>gmail.com)
-- @date		2006/08/02
-- @description	The purpose of this transformation is to replace an association by a foreign key
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 1.6, page 7
-- @see author of article : K. Lano

module ForeignKey; -- Module Template
create OUT : KM3target from IN : KM3;

--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3target!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
--@end rule Metamodel

--@begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3target!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
--@end rule Package

--@begin rule Class
rule Class {
	from
		inputA:KM3!Class
	to
		outputA:KM3target!Class (
			name <- inputA.name,
			isAbstract <- inputA.isAbstract,
			structuralFeatures <- inputA.structuralFeatures
		)
}
--@end rule Class

--@begin rule datatype
rule DataType {
from
		inputData:KM3!DataType
	to
		outputData:KM3target!DataType(
			name <- inputData.name,
			location <- inputData.location
		)
}
--@end rule datatype

--@begin foreignkey
rule reference2Key {
	from 
		r:KM3!Reference (
			r.upper = 1	
		)
	to
		key:KM3target!Attribute (
			name <- r.type.name.toLower()+'ForeignKey',
			isOrdered <- false,
			isUnique <- false,
			location <- '',
			lower <- 1,
			upper <- 1,
			type <- KM3!DataType.allInstances()->select(a|a.name = 'Integer')->first(),
			owner <- r.owner
		)
}
--@end foreignkey

--@begin rule attribute 
rule attribute {
	from
		inputAtt:KM3!Attribute 
	to
		outputAtt:KM3target!Attribute(
			name <- inputAtt.name,
			isOrdered <- inputAtt.isOrdered,
			isUnique <- inputAtt.isUnique,
			location <- inputAtt.location,
			lower <- inputAtt.lower,
			upper <- inputAtt.upper,
			type <- inputAtt.type,
			owner <- inputAtt.owner
			
		)
}
--@end rule attribute",name replac associ foreign key version domain catalogu model transform author baudri julien jul baudri gmail com date descript the purpos transform replac associ foreign key see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul foreignkey modul templat creat out km target in km begin rule metamodel rule metamodel inputmm km metamodel outputmm km target metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km target packag name inputpkg name content inputpkg content end rule packag begin rule class rule class inputa km class outputa km target class name inputa name isabstract inputa isabstract structuralfeatur inputa structuralfeatur end rule class begin rule datatyp rule datatyp inputdata km datatyp outputdata km target datatyp name inputdata name locat inputdata locat end rule datatyp begin foreignkey rule refer key r km refer r upper key km target attribut name r type name tolow foreignkey isord fals isuniqu fals locat lower upper type km datatyp allinst select name integ first owner r owner end foreignkey begin rule attribut rule attribut inputatt km attribut outputatt km target attribut name inputatt name isord inputatt isord isuniqu inputatt isuniqu locat inputatt locat lower inputatt lower upper inputatt upper type inputatt type owner inputatt owner end rule attribut,1
160,160,P72-Replace-context.atl,"-- @name		Replacing inheritance by association
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		Baudry Julien (jul.baudry<at>gmail.com)
-- @date		2006/08/02
-- @description	The purpose of this transformation is to replace inheritances by associations
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 1.1, page 2
-- @see author of article : K. Lano

module Replace; -- Module Template
create OUT : KM3target from IN : KM3;

--@begin rule Metamodel
--entrypoint rule Metamodel() {
--	do {
--		KM3!Metamodel.allInstances().debug('metamodels');
--		KM3!Package.allInstances().debug('packages');
--		KM3!Class.allInstances().debug('classes');
--	}
--}
--@end rule Metamodel

--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3target!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
--@end rule Metamodel

--@begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3target!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
--@end rule Package

--@begin rule ClassA
rule ClassA {
	from
		inputA:KM3!Class (
			inputA.supertypes.isEmpty()
		)
	to
		outputA:KM3target!Class (
			name <- inputA.name,
			isAbstract <- inputA.isAbstract
		)
}
--@end rule ClassA

--@begin rule ClassB
rule ClassB {
	from
		inputB:KM3!Class (
			not(inputB.supertypes.isEmpty())
		)
	to
		outputB:KM3target!Class (
			name <- inputB.name,
			isAbstract <- inputB.isAbstract,
			structuralFeatures <- inputB.supertypes->iterate(a;acc : Sequence(KM3!StructuralFeature) = Sequence{}|
																acc->including(thisModule.Inherit2Association(a,inputB))
															)
		)
}
--@end rule ClassB

--@begin Inherit2Association
lazy rule Inherit2Association {
	from
		supertype:KM3!Class,
		children:KM3!Class
	to
		refChildren : KM3target!Reference (
			name <- 'inherit'+supertype.name,
			opposite <- refSupertype,
			owner <- children,
			type <- supertype,
			lower <- 1,
			upper <- 1
		),

		refSupertype : KM3target!Reference( 
			name <- 'children'+children.name,
			opposite <- refChildren,
			owner <- supertype,
			type <- children,
			lower <- 1,
			upper <- 1
		)	
}
--@end Inherit2Association

--@begin rule attribute 
rule attribute {
	from
		inputAtt:KM3!Attribute 
	to
		outputAtt:KM3target!Attribute(
			name <- inputAtt.name,
			isOrdered <- inputAtt.isOrdered,
			isUnique <- inputAtt.isUnique,
			location <- inputAtt.location,
			lower <- inputAtt.lower,
			upper <- inputAtt.upper,
			type <- inputAtt.type,
			owner <- inputAtt.owner
			
		)
}
--@end rule attribute

--@begin rule DataType
rule DataType {
from
		inputData:KM3!DataType
	to
		outputData:KM3target!DataType(
			name <- inputData.name,
			location <- inputData.location
		)
}
--@end rule DataType

--@begin reference
rule reference {
	from
		inputRef:KM3!Reference 
	to
		outputRef:KM3target!Reference (
			name <- inputRef.name,
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			location <- inputRef.location,
			lower <- inputRef.lower,
			upper <- inputRef.upper,
			type <- inputRef.type,
			owner <- inputRef.owner,
			opposite <- inputRef.opposite
		)
}
--@end reference

--@begin enumeration
rule enumeration {
	from
		inputEnum:KM3!Enumeration 
	to
		outputEnum:KM3target!Enumeration (
			location <- inputEnum.location,
			name  <- inputEnum.name,
			package  <- inputEnum.package
		)

}
--@end enumeration

--@begin literal
rule literal {
	from
		inputEnum:KM3!EnumLiteral
	to
		outputEnum:KM3target!EnumLiteral (
			location <- inputEnum.location,
			name  <- inputEnum.name,
			enum  <- inputEnum.enum
		)

}
--@end literal",name replac inherit associ version domain catalogu model transform author baudri julien jul baudri gmail com date descript the purpos transform replac inherit associ see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul replac modul templat creat out km target in km begin rule metamodel entrypoint rule metamodel km metamodel allinst debug metamodel km packag allinst debug packag km class allinst debug class end rule metamodel begin rule metamodel rule metamodel inputmm km metamodel outputmm km target metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km target packag name inputpkg name content inputpkg content end rule packag begin rule classa rule classa inputa km class inputa supertyp isempti outputa km target class name inputa name isabstract inputa isabstract end rule classa begin rule classb rule classb inputb km class inputb supertyp isempti outputb km target class name inputb name isabstract inputb isabstract structuralfeatur inputb supertyp iter acc sequenc km structuralfeatur sequenc acc includ thismodul inherit associ inputb end rule classb begin inherit associ lazi rule inherit associ supertyp km class children km class refchildren km target refer name inherit supertyp name opposit refsupertyp owner children type supertyp lower upper refsupertyp km target refer name children children name opposit refchildren owner supertyp type children lower upper end inherit associ begin rule attribut rule attribut inputatt km attribut outputatt km target attribut name inputatt name isord inputatt isord isuniqu inputatt isuniqu locat inputatt locat lower inputatt lower upper inputatt upper type inputatt type owner inputatt owner end rule attribut begin rule datatyp rule datatyp inputdata km datatyp outputdata km target datatyp name inputdata name locat inputdata locat end rule datatyp begin refer rule refer inputref km refer outputref km target refer name inputref name isord inputref isord isuniqu inputref isuniqu locat inputref locat lower inputref lower upper inputref upper type inputref type owner inputref owner opposit inputref opposit end refer begin enumer rule enumer inputenum km enumer outputenum km target enumer locat inputenum locat name inputenum name packag inputenum packag end enumer begin liter rule liter inputenum km enumliter outputenum km target enumliter locat inputenum locat name inputenum name enum inputenum enum end liter,1
161,161,P72-Replace-without.atl,"-- @name		Replacing inheritance by association
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		Baudry Julien (jul.baudry<at>gmail.com)
-- @date		2006/08/02
-- @description	The purpose of this transformation is to replace inheritances by associations
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 1.1, page 2
-- @see author of article : K. Lano

module Replace; -- Module Template
create OUT : KM3 from IN : KM3;

--@begin rule Metamodel
--	For a Metamodel element, another Metamodel element is created :
--			with the same name and location,
--			Linked to the same contents.
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
--@end rule Metamodel

--@begin rule Package
--	For a Package element, another Package element is created :
--			with the same name, 
--			Linked to the same contents.
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
--@end rule Package

--@begin rule Class without supertype
--	This class has no supertypes :
--			We create another class with the same name,
--			Abstract if the source class is abstract. 	
rule ClassA {
	from
		inputA:KM3!Class (
			inputA.supertypes.isEmpty()
		)
	to
		outputA:KM3!Class (
			name <- inputA.name,
			isAbstract <- inputA.isAbstract
		)
}
--@end rule without supertype

--@begin rule Class with supertype
rule ClassB {
	from
		inputB:KM3!Class (
			not(inputB.supertypes.isEmpty())
		)
	to
		outputB:KM3!Class (
			name <- inputB.name,
			isAbstract <- inputB.isAbstract,
			structuralFeatures <- inputB.supertypes->iterate(a;acc : Sequence(KM3!StructuralFeature) = Sequence{}|
																acc->including(thisModule.Inherit2Association(a,inputB))
															)
		)
}
--@end rule Class  with supertype


lazy rule Inherit2Association {
	from
		supertype:KM3!Class,
		children:KM3!Class
	to
		refChildren : KM3!Reference (
			name <- 'inherit'+supertype.name,
			opposite <- refSupertype,
			owner <- children,
			type <- supertype,
			lower <- 1,
			upper <- 1
		),

		refSupertype : KM3!Reference( 
			name <- 'children'+children.name,
			opposite <- refChildren,
			owner <- supertype,
			type <- children,
			lower <- 1,
			upper <- 1
		)	
}",name replac inherit associ version domain catalogu model transform author baudri julien jul baudri gmail com date descript the purpos transform replac inherit associ see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul replac modul templat creat out km in km begin rule metamodel for metamodel element anoth metamodel element creat name locat link content rule metamodel inputmm km metamodel outputmm km metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag for packag element anoth packag element creat name link content rule packag inputpkg km packag outputpkg km packag name inputpkg name content inputpkg content end rule packag begin rule class without supertyp this class supertyp we creat anoth class name abstract sourc class abstract rule classa inputa km class inputa supertyp isempti outputa km class name inputa name isabstract inputa isabstract end rule without supertyp begin rule class supertyp rule classb inputb km class inputb supertyp isempti outputb km class name inputb name isabstract inputb isabstract structuralfeatur inputb supertyp iter acc sequenc km structuralfeatur sequenc acc includ thismodul inherit associ inputb end rule class supertyp lazi rule inherit associ supertyp km class children km class refchildren km refer name inherit supertyp name opposit refsupertyp owner children type supertyp lower upper refsupertyp km refer name children children name opposit refchildren owner supertyp type children lower upper,1
162,162,P73-ATOM2RSS.atl,"-- ============================================================
-- ATOM2RSS
-- Created by : Youssef Srour (srour.youssef@gmail.com)
-- Date: 23/06/2006
-- Version: 1
-- ============================================================


module ATOM2RSS;
create OUT : RSS from IN : ATOM;
	
--Rule ATOM to Channel
--Creates a Channel from the input ATOM Element
rule ATOM2Channel {
	from 
    	At : ATOM!ATOM
	to
   		out : RSS!Channel (
   			
	    	title <- At.title,
	    	description <- At.subtitle,
	    	copyright <- At.rights,
	    	managingEditor <- At.authors.first().name,
	    	generator <- At.generator,
	    	lastBuildDate <- At.lastUpdate,
	    	category <- At.categories -> first(),-- A ATOM have one or zero category 
			webmaster <- At.authors.first().email,
			pubDate <- At.entrie.first().published,
			link <- At.links.first().hrefl.toString(),		
			items <- At.entrie -> asSequence() ,-- A item have a sequence of entrie
			image <- imag
		),
		
		imag : RSS!Image(
			
			url <- At.logo
		)
}

--Rule Entry to Item
--Creates a Item from the Entry Element

rule Entry2Item {
	from 
    	it : ATOM!Entry
	to
   		out : RSS!Item (
   			
	    	title <- it.title,
	    	guid <- it.id,
	    	pubDate <- it.published,
	    	description <- it.content,
	    	comments <- it.summary,
			link <- it.links.first().hrefl    	
	)
}

--Rule Category to Category
--Creates a Category from the input Category Element

rule Category2Category {
	from 
    	it : ATOM!Category
	to
   		out : RSS!Category(
   			
	    	domain <- it.scheme,
			value <- it.label    	
	)
}

",atom rss creat youssef srour srour youssef gmail com date version modul atom rss creat out rss in atom rule atom channel creat channel input atom element rule atom channel at atom atom rss channel titl at titl descript at subtitl copyright at right managingeditor at author first name generat at generat lastbuildd at lastupd categori at categori first a atom one zero categori webmast at author first email pubdat at entri first publish link at link first hrefl tostr item at entri assequ a item sequenc entri imag imag imag rss imag url at logo rule entri item creat item entri element rule entri item atom entri rss item titl titl guid id pubdat publish descript content comment summari link link first hrefl rule categori categori creat categori input categori element rule categori categori atom categori rss categori domain scheme valu label,9
163,163,P73-ATOM2XML.atl,"module ATOM2XML;
create OUT : XML from IN : ATOM;


 --Begin rule ATOM to Root
 
 rule ATOM2Root{
	 from i : ATOM!ATOM
	 
	 to 
	 
		 o : XML!Root(
		 	
			 name <- 'ATOM',
			 children <- Sequence {title,id,subtitle,rights,lastUpdate,links,icon,logo,authors,entrie,generator,categories,contributors}--,contributors}
		 ),
	 
		 title : XML!Element(
		 	
				 name <- 'title',
				 children <- the_title
		 ), 
		 
		 the_title : XML!Text(
		 	
			 name <- 'the_title',
			 value <- i.title
		 ),
		 
		 id : XML!Element(
		 	
			 name <- 'id',
			 children <- the_id
		 ),
		 
		 the_id : XML!Text(
		 	
			 name <- 'the_id',
			 value <- if i.id.oclIsUndefined() then '' else i.id endif
		 ),
		 
		 subtitle : XML!Element(
		 	
			 name <- 'subtitle',
			 children <- the_subtitle
		 ),
		 
		 the_subtitle : XML!Text(
		 	
			 name <- 'the_subtitle',
			 value <- if i.subtitle.oclIsUndefined() then '' else i.subtitle endif
		 ),
		 
		 rights : XML!Element(
		 	
			 name <- 'rights',
			 children <- therights
		 ),
		 
		 
		 therights : XML!Text(
		 	
			 name <- 'therights',
			 value <- if i.rights.oclIsUndefined() then '' else i.rights endif
		 
		 ),
		 
		 
		 lastUpdate : XML!Element(
		 	
			 name <- 'lastUpdate',
			 children <- thelastUpdate
		 ),
		 
		 thelastUpdate : XML!Text(
		 	
			 name <- 'thelastUpdate',
			 value <- if i.lastUpdate.oclIsUndefined() then '' else i.lastUpdate endif
		 ),
		 
		 icon : XML!Element(
		 	
			 name <- 'icon',
			 children <- theicon
		 ),
		 
		 theicon : XML!Text(
		 	
			 name <- 'theicon',
			 value <- if i.icon.oclIsUndefined() then '' else i.icon endif
		 ),
		 
		 logo : XML!Element(
		 	
			 name <- 'logo',
			 children <- thelogo
		 ),
		 
		 
		 thelogo : XML!Text(
		 	
			 name <- 'thelogo',
			 value <- if i.logo.oclIsUndefined() then '' else i.logo endif
		 ),
		 
		 links : XML!Element(
		 	
			 name <- 'links',
			 children <- i.links->asSequence()
		 ),
		 
		 generator : XML!Element(
		 	
			 name <- 'generator',
			 children <- i.generator->asSequence()
		 ),
		 
		 authors : XML!Element(
		 	
			 name <- 'authors',
			 children <- i.authors->asSequence()
		 ),
		 
		 categories : XML!Element(
		 	
			 name <- 'categories',
			 children <- i.categories->asSequence()
		 ),
		 
		 contributors : XML!Element(
		 	
			 name <- 'contributors',
			 children <- i.contributors->asSequence()
		 ),
		 
		 entrie : XML!Element(
		 	
			 name <- 'entrie',
			 children <- i.entrie->asSequence()
		 )
 
 }-- End rule ATOM to Root
 
-- Begin rule Category to Element
 rule Category2Element{
 	
	 from i : ATOM!Category
	 
	 to 
	 
	 o : XML!Element(
	 	
		 name <- 'category',
		 children <- Sequence {term,scheme,label}
	 ),
	 
	 term : XML!Element(
	 	
		 name <- 'term',
		 children <- theterm
	 ),
	 
	 theterm : XML!Text(
	 	
		 name <- 'theterm',
		 value <-  i.term
	 ),
	 
	 scheme : XML!Element(
	 	
		 name <- 'scheme',
		 children <- thescheme
	 ),
	 
	 thescheme : XML!Text(
	 	
		 name <- 'thescheme',
		 value <- if i.scheme.oclIsUndefined() then '' else i.scheme endif
	 ),
	 
	 label : XML!Element(
	 	
		 name <- 'label',
		 children <- thelabel
	 ),
	 
	 thelabel : XML!Text(
	 	
		 name <- 'thelabel',
		 value <- if i.label.oclIsUndefined() then '' else i.label endif
	 )
 } --End rule Category to Element
 
  --Begin rule Author to Element  
 rule Author2Element{
	 from i : ATOM!Author
	 
	 to 
	 
	 o : XML!Element(
	 	
		 name <- 'Author',
		 children <- Sequence {name,uri,email}
	 ),
	 
	 name : XML!Element(
	 	
		 name <- 'name',
		 children <- thename
	 ),
	 
	 thename : XML!Text(
	 	
		 name <- 'thename',
		 value <-  i.name
	 ),
	 
	 uri : XML!Element(
	 	
		 name <- 'uri',
		 children <- theuri
	 ),
	 
	 theuri : XML!Text(
	 	
		 name <- 'theuri',
		 value <- if i.uri.oclIsUndefined() then '' else i.uri endif
	 ),
	 
	 email : XML!Element(
	 	
		 name <- 'email',
		 children <- theemail
	 ),
	 
	 theemail : XML!Text(
	 	
		 name <- 'theemail',
		 value <- if i.email.oclIsUndefined() then '' else i.email endif
	 )
 }--End rule Author to Element
 
 --Begin rule Contributor to Element
 rule Contributor2Element{
 	
	 from i : ATOM!Contributor
	 
	 to 
	 
	 o : XML!Element(
	 	
		 name <- 'Contributor',
		 children <- Sequence {name,uri,email}
	 ),
	 
	 name : XML!Element(
	 	
		 name <- 'name',
		 children <- thename
	 ),
	 
	 thename : XML!Text(
	 	
		 name <- 'thename',
		 value <-  i.name
	 ),
	 
	 uri : XML!Element(
	 	
		 name <- 'uri',
		 children <- theuri
	 ),
	 
	 theuri : XML!Text(
	 	
		 name <- 'theuri',
		 value <- if i.uri.oclIsUndefined() then '' else i.uri endif
	 ),
	 
	 email : XML!Element(
	 	
		 name <- 'email',
		 children <- theemail
	 ),
	 
	 theemail : XML!Text(
	 	
		 name <- 'theemail',
		 value <- if i.email.oclIsUndefined() then '' else i.email endif
	 )
 }--End rule Contributor to Element
 
 --Begin rule Link to Element
 rule Link2Element{
 	
	 from i : ATOM!Link
	 
	 to 
	 
	 o : XML!Element(
	 	
		 name <- 'Link',
		 children <- Sequence {rel,hrefl,type,hreflang,title,lenght}
	 ),
	 rel : XML!Element(
	 	
		 name <- 'rel',
		 children <- therel
	 ),
	 
	 therel : XML!Text(
	 	
		 name <- 'therel',
		 value <-  if i.rel.oclIsUndefined() then '' else i.rel endif
	 ),
	 
	 hrefl : XML!Element(
	 	
		 name <- 'hrefl',
		 children <- thehrefl
	 ),
	 
	 thehrefl : XML!Text(
	 	
		 name <- 'thehrefl',
		 value <- if i.hrefl.oclIsUndefined() then '' else i.hrefl endif
	 ),
	 
	 type : XML!Element(
	 	
		 name <- 'type',
		 children <- thetype
	 ),
	 
	 thetype : XML!Text(
	 	
		 name <- 'thetype',
		 value <- if i.type.oclIsUndefined() then '' else i.type endif
	 ),
	 
	 hreflang : XML!Element(
	 	
		 name <- 'hreflang',
		 children <- thehreflang
	 ),
	 
	 thehreflang : XML!Text(
	 	
		 name <- 'thehreflang',
		 value <-  if i.hreflang.oclIsUndefined() then '' else i.hreflang endif
	 ),
	 
	 title : XML!Element(
	 	
		 name <- 'title',
		 children <- thetitle
	 ),
	 
	 thetitle : XML!Text(
	 	
		 name <- 'thetitle',
		 value <-  if i.title.oclIsUndefined() then '' else i.title endif
	 ),
	 
	 lenght : XML!Element(
	 	
		 name <- 'lenght',
		 children <- thelenght
	 ),
	 
	 thelenght : XML!Text(
	 	
		 name <- 'thelenght',
		 value <-  if i.lenght.oclIsUndefined() then '' else i.lenght endif
	 ) 
 }--End rule Link to Element
 
 --Begin rule Entry to Element
 rule Entry2Element{
	 from i : ATOM!Entry
	 
	 to 
	 
	 o : XML!Element(
	 	
		 name <- 'Entry',
		 children <- Sequence {title,id,rights,summary,published,lastUpdate,links,categories,content,contributors}
	 ),
	 
	 title : XML!Element(
	 	
		 name <- 'title',
		 children <- thetitle
	 ),
	 
	 thetitle : XML!Text(
	 	
		 name <- 'thetitle',
		 value <-  if i.title.oclIsUndefined() then '' else i.title endif
	 ),
	 
	 id : XML!Element(
	 	
		 name <- 'id',
		 children <- theid
	 ),
	 
	 theid : XML!Text(
	 	
		 name <- 'theid',
		 value <- if i.id.oclIsUndefined() then '' else i.id endif
	 ),
	 
	 rights : XML!Element(
	 	
		 name <- 'rights',
		 children <- therights
	 ),
	 
	 therights : XML!Text(
	 	
		 name <- 'therights',
		 value <- if i.rights.oclIsUndefined() then '' else i.rights endif
	 ),
	 
	 summary : XML!Element(
	 	
		 name <- 'summary',
		 children <- thesummary
	 ),
	 
	 thesummary : XML!Text(
	 	
		 name <- 'thesummary',
		 value <-  if i.summary.oclIsUndefined() then '' else i.summary endif
	 ),
	 
	 published : XML!Element(
	 	
		 name <- 'published',
		 children <- thepublished
	 ),
	 
	 thepublished : XML!Text(
	 	
		 name <- 'thepublished',
		 value <-  if i.published.oclIsUndefined() then '' else i.published endif
	 ),
	 
	 lastUpdate : XML!Element(
	 	
		 name <- 'lastUpdate',
		 children <- thelastUpdate
	 ),
	 
	 thelastUpdate : XML!Text(
	 	
		 name <- 'thelastUpdate',
		 value <-  if i.lastUpdate.oclIsUndefined() then '' else i.lastUpdate endif
	 ),
	 
	 links : XML!Element(
	 	
		 name <- 'links',
		 children <- i.links->asSequence()
	 ),
	 
	 categories : XML!Element(
	 	
		 name <- 'categories',
		 children <- i.categories->asSequence()
	 ),
	 
	 contributors : XML!Element(
	 	
		 name <- 'contributors',
		 children <- i.contributors->asSequence()
	 ),
	 
	 content : XML!Element(
	 	
		 name <- 'content',
		 children <- i.content->asSequence()
	 )
 }--End rule Entry to Element
 
 --Begin rule Content to Element
 rule Content2Element{
	 from i : ATOM!Content
	 
	 to o : XML!Element(
	 	
		 name <- 'Content',
		 children <- Sequence {type,mode,text}
	 ),
	 
	 type : XML!Element(
	 	
		 name <- 'type',
		 children <- thetype
	 ),
	 
	 thetype : XML!Text(
	 	
		 name <- 'thetype',
		 value <- if i.type.oclIsUndefined() then '' else i.type endif
	 ),
	 
	 mode : XML!Element(
	 	
		 name <- 'mode',
		 children <- themode
	 ),
	 
	 themode : XML!Text(
	 	
		 name <- 'themode',
		 value <-  if i.mode.oclIsUndefined() then '' else i.mode endif
	 ),
	 
	 text : XML!Element(
	 	
		 name <- 'text',
		 children <- thepublished
	 ),
	 
	 thepublished : XML!Text(
	 	
		 name <- 'thepublished',
		 value <-  if i.text.oclIsUndefined() then '' else i.text endif
	 )
 }--End rule Content to Element
 
 --Begin rule Source to Element
 rule Source2Element{
	 from i : ATOM!Source
	 
	 to o : XML!Element(
	 	
		 name <- 'ATOM',
		 children <- Sequence {id,subtitle,rights
		 ,lastUpdate,links,author,icon,logo,generator,categories,contributors}--,contributors}
	 ),
	 
	 id : XML!Element(
	 	
		 name <- 'id',
		 children <- theid
	 ),
	 
	 theid : XML!Text(
	 	
		 name <- 'theid',
		 value <- if i.id.oclIsUndefined() then '' else i.id endif
	 ),
	 
	 subtitle : XML!Element(
	 	
		 name <- 'subtitle',
		 children <- thesubtitle
	 ),
	 
	 thesubtitle : XML!Text(
	 	
		 name <- 'thesubtitle',
		 value <- if i.subtitle.oclIsUndefined() then '' else i.subtitle endif
	 ),
	 
	 rights : XML!Element(
	 	
		 name <- 'rights',
		 children <- therights
	 ),
	 
	 
	 therights : XML!Text(
	 	
		 name <- 'therights',
		 value <- if i.rights.oclIsUndefined() then '' else i.rights endif
	 ),
	 
	 
	 lastUpdate : XML!Element(
	 	
		 name <- 'lastUpdate',
		 children <- thelastUpdate
	 ),
	 
	 thelastUpdate : XML!Text(
	 	
		 name <- 'thelastUpdate',
		 value <- if i.lastUpdate.oclIsUndefined() then '' else i.lastUpdate endif
	 ),
	 
	 icon : XML!Element(
	 	
		 name <- 'icon',
		 children <- theicon
	 ),
	 
	 theicon : XML!Text(
	 	
		 name <- 'theicon',
		 value <- if i.icon.oclIsUndefined() then '' else i.icon endif
	 ),
	 
	 logo : XML!Element(
	 	
		 name <- 'logo',
		 children <- thelogo
	 ),
	 
	 
	 thelogo : XML!Text(
	 	
		 name <- 'thelogo',
		 value <- if i.logo.oclIsUndefined() then '' else i.logo endif
	 ),
	 
	 links : XML!Element(
	 	
		 name <- 'links',
		 children <- i.links->asSequence()
	 ),
	 
	 generator : XML!Element(
	 	
		 name <- 'generator',
		 children <- i.generator->asSequence()
	 ),
	 
	 author : XML!Element(
	 	
		 name <- 'author',
		 children <- i.author->asSequence()
	 ),
	 
	 categories : XML!Element(
	 	
		 name <- 'categories',
		 children <- i.categories->asSequence()
	 ),
	 
	 contributors : XML!Element(
	 	
		 name <- 'contributors',
		 children <- i.contributors->asSequence()
	 )
 
 }--End rule Source to Element
 ",modul atom xml creat out xml in atom begin rule atom root rule atom root atom atom xml root name atom children sequenc titl id subtitl right lastupd link icon logo author entri generat categori contributor contributor titl xml element name titl children titl titl xml text name titl valu titl id xml element name id children id id xml text name id valu id oclisundefin els id endif subtitl xml element name subtitl children subtitl subtitl xml text name subtitl valu subtitl oclisundefin els subtitl endif right xml element name right children theright theright xml text name theright valu right oclisundefin els right endif lastupd xml element name lastupd children thelastupd thelastupd xml text name thelastupd valu lastupd oclisundefin els lastupd endif icon xml element name icon children theicon theicon xml text name theicon valu icon oclisundefin els icon endif logo xml element name logo children thelogo thelogo xml text name thelogo valu logo oclisundefin els logo endif link xml element name link children link assequ generat xml element name generat children generat assequ author xml element name author children author assequ categori xml element name categori children categori assequ contributor xml element name contributor children contributor assequ entri xml element name entri children entri assequ end rule atom root begin rule categori element rule categori element atom categori xml element name categori children sequenc term scheme label term xml element name term children theterm theterm xml text name theterm valu term scheme xml element name scheme children theschem theschem xml text name theschem valu scheme oclisundefin els scheme endif label xml element name label children thelabel thelabel xml text name thelabel valu label oclisundefin els label endif end rule categori element begin rule author element rule author element atom author xml element name author children sequenc name uri email name xml element name name children thenam thenam xml text name thenam valu name uri xml element name uri children theuri theuri xml text name theuri valu uri oclisundefin els uri endif email xml element name email children theemail theemail xml text name theemail valu email oclisundefin els email endif end rule author element begin rule contributor element rule contributor element atom contributor xml element name contributor children sequenc name uri email name xml element name name children thenam thenam xml text name thenam valu name uri xml element name uri children theuri theuri xml text name theuri valu uri oclisundefin els uri endif email xml element name email children theemail theemail xml text name theemail valu email oclisundefin els email endif end rule contributor element begin rule link element rule link element atom link xml element name link children sequenc rel hrefl type hreflang titl lenght rel xml element name rel children therel therel xml text name therel valu rel oclisundefin els rel endif hrefl xml element name hrefl children thehrefl thehrefl xml text name thehrefl valu hrefl oclisundefin els hrefl endif type xml element name type children thetyp thetyp xml text name thetyp valu type oclisundefin els type endif hreflang xml element name hreflang children thehreflang thehreflang xml text name thehreflang valu hreflang oclisundefin els hreflang endif titl xml element name titl children thetitl thetitl xml text name thetitl valu titl oclisundefin els titl endif lenght xml element name lenght children thelenght thelenght xml text name thelenght valu lenght oclisundefin els lenght endif end rule link element begin rule entri element rule entri element atom entri xml element name entri children sequenc titl id right summari publish lastupd link categori content contributor titl xml element name titl children thetitl thetitl xml text name thetitl valu titl oclisundefin els titl endif id xml element name id children theid theid xml text name theid valu id oclisundefin els id endif right xml element name right children theright theright xml text name theright valu right oclisundefin els right endif summari xml element name summari children thesummari thesummari xml text name thesummari valu summari oclisundefin els summari endif publish xml element name publish children thepublish thepublish xml text name thepublish valu publish oclisundefin els publish endif lastupd xml element name lastupd children thelastupd thelastupd xml text name thelastupd valu lastupd oclisundefin els lastupd endif link xml element name link children link assequ categori xml element name categori children categori assequ contributor xml element name contributor children contributor assequ content xml element name content children content assequ end rule entri element begin rule content element rule content element atom content xml element name content children sequenc type mode text type xml element name type children thetyp thetyp xml text name thetyp valu type oclisundefin els type endif mode xml element name mode children themod themod xml text name themod valu mode oclisundefin els mode endif text xml element name text children thepublish thepublish xml text name thepublish valu text oclisundefin els text endif end rule content element begin rule sourc element rule sourc element atom sourc xml element name atom children sequenc id subtitl right lastupd link author icon logo generat categori contributor contributor id xml element name id children theid theid xml text name theid valu id oclisundefin els id endif subtitl xml element name subtitl children thesubtitl thesubtitl xml text name thesubtitl valu subtitl oclisundefin els subtitl endif right xml element name right children theright theright xml text name theright valu right oclisundefin els right endif lastupd xml element name lastupd children thelastupd thelastupd xml text name thelastupd valu lastupd oclisundefin els lastupd endif icon xml element name icon children theicon theicon xml text name theicon valu icon oclisundefin els icon endif logo xml element name logo children thelogo thelogo xml text name thelogo valu logo oclisundefin els logo endif link xml element name link children link assequ generat xml element name generat children generat assequ author xml element name author children author assequ categori xml element name categori children categori assequ contributor xml element name contributor children contributor assequ end rule sourc element,9
164,164,P73-RSS2ATOM.atl,"module RSS2ATOM;
create OUT : ATOM from IN : RSS;

-- ============================================================
-- RSS2ATOM
-- Created by : Youssef Srour (srour.youssef@gmail.com)
-- Date: 23/06/2006
-- Version: 1
-- ============================================================

	
--Rule Channel to ATOM
--Create a ATOM from the input Channel Element
rule Channel2ATOM {
	from 
    	At : RSS!Channel
	to
   		out : ATOM!ATOM (
   			
    	title <- At.title,
    	subtitle <- At.description,
    	rights <- At.copyright,    	
    	generator <- At.generator,
    	lastUpdate <- At.lastBuildDate,
    	categories <- At.category->asSet(),
		links <- Sequence{link}.first(),
		authors <- Sequence{auth}.first(),
		entrie <- At.items->asSequence()		
	),
	
	link : ATOM!Link(
		
		hrefl<-At.link	
	),
	auth : ATOM!Author(
		
		email<-At.webmaster,
		name<-At.managingEditor
	)
}

--Rule Item to Entry
--Create a Entry from the input Item Element
rule Item2Entry {
	from 
    	it : RSS!Item
	to
   		out : ATOM!Entry (
   			
    	title <- it.title,
    	id <- it.guid,
    	published <- it.pubDate,
    	content <- it.description,
    	summary <- it.comments,
		links <- Sequence{link}.first()
    	),
	
		link : ATOM!Link(
			
			hrefl<-it.link	
		)
}

--Rule Category to Category
--Create a category from  the input Category Element
rule Category2Category {
	from 
    	it : RSS!Category
	to
   		out : ATOM!Category (
	    	scheme<-it.domain,
			label<-it.value
    	
	)
}",modul rss atom creat out atom in rss rss atom creat youssef srour srour youssef gmail com date version rule channel atom creat atom input channel element rule channel atom at rss channel atom atom titl at titl subtitl at descript right at copyright generat at generat lastupd at lastbuildd categori at categori asset link sequenc link first author sequenc auth first entri at item assequ link atom link hrefl at link auth atom author email at webmast name at managingeditor rule item entri creat entri input item element rule item entri rss item atom entri titl titl id guid publish pubdat content descript summari comment link sequenc link first link atom link hrefl link rule categori categori creat categori input categori element rule categori categori rss categori atom categori scheme domain label valu,9
165,165,P73-RSS2XML.atl,"module RSS2XML;
create OUT : XML from IN : RSS;

-- concatene a list of String
-- the elements are separated by a comma
helper def: concat(list : Sequence(String)) : String =
	list -> asSet() -> iterate(element ;acc : String = '' |
	acc +
		if acc = ''
 			then element
 		else ',' + element
 		endif);

 -- rule for a project having a description
 rule Channel2Element{
	 from i : RSS!Channel
	 
	 to o : XML!Root(
	 	
		 name <- 'Channel',
		 children <- Sequence {title,link,description,language
		 ,copyright,managingEditor,webmaster,generator,pubDate,lastBuildDate
		 ,items,category,docs,ttl,rating}
	 ),
	 
	 title : XML!Element(
	 	
		 name <- 'title',
		 children <- letitle
	 ),
	 
	 letitle : XML!Text(
	 	
		 name <- 'letitle',
		 value <- i.title
	 ),
	 
	 link : XML!Element(
	 	
		 name <- 'link',
		 children <- thelink
	 ),
	 
	 thelink : XML!Text(
	 	
		 name <- 'thelink',
		 value <- i.link
	 ),	 
	 
	 description : XML!Element(
	 	
		 name <- 'description',
		 children <- ladescription
	 ),
	 
	 ladescription : XML!Text(
	 	
		 name <- 'ladescription',
		 value <- i.description
	 ),
	 
	 language : XML!Element(
	 	
		 name <- 'language',
		 children <- lelangage
	 ),
	 
	 
	 lelangage : XML!Text(
	 	
		 name <- 'lelangage',
		 value <- if i.language.oclIsUndefined() then '' else i.language endif
	 ),
	 
	 copyright : XML!Element(
	 	
		 name <- 'copyright',
		 children <- thecopyright
	 ),
	 
	 thecopyright : XML!Text(
	 	
		 name <- 'thecopyright',
		 value <- if i.copyright.oclIsUndefined() then '' else i.copyright endif
	 ),
	 
	 
	 managingEditor : XML!Element(
	 	
		 name <- 'managingEditor',
		 children <- themanagingEditor
	 ),
	  
	 themanagingEditor : XML!Text(
	 	
		 name <- 'themanagingEditor',
		 value <- if i.managingEditor.oclIsUndefined() then '' else i.managingEditor endif
	 ),
	 
	 webmaster : XML!Element(
	 	
		 name <- 'webmaster',
		 children <- thewebmaster
	 ),
	 
	 thewebmaster : XML!Text(
	 	
		 name <- 'thewebmaster',
		 value <- if i.webmaster.oclIsUndefined() then '' else i.webmaster endif
	 ),
	 
	 
	 generator : XML!Element(
	 	
		 name <- 'generator',
		 children <- thegenerator
	 ),
	 
	 docs : XML!Element(
	 	
		 name <- 'docs',
		 children <- thedocs
	 ),
	 
	 
	 thedocs : XML!Text(
	 	
		 name <- 'thedocs',
		 value <- if i.docs.oclIsUndefined() then '' else i.docs endif
	 ),
	 
	 ttl : XML!Element(
	 	
		 name <- 'ttl',
		 children <- thettl
	 ),
	 
	 thettl : XML!Text(
	 	
		 name <- 'thettl',
		 value <- if i.ttl.oclIsUndefined() then '' else i.ttl endif
	 ),
	 
	 
	 rating : XML!Element(
	 	
		 name <- 'rating',
		 children <- therating
	 ),
	  
	 therating : XML!Text(
	 	
		 name <- 'therating',
		 value <- if i.rating.oclIsUndefined() then '' else i.rating endif
	 ),
	 
	 thegenerator : XML!Text(
	 	
		 name <- 'thegenerator',
		 value <- if i.generator.oclIsUndefined() then '' else i.generator endif
	 ),
	 
	 pubDate : XML!Element(
	 	
		 name <- 'pubDate',
		 children <- thepubDate
	 ),
	 
	 thepubDate : XML!Text(
	 	
		 name <- 'thepubDate',
		 value <- if i.pubDate.oclIsUndefined() then '' else i.pubDate endif
	 ),
	 	 
	 lastBuildDate : XML!Element(
	 	
		 name <- 'lastBuildDate',
		 children <- thelastBuildDate
	 ),
	 
	 thelastBuildDate : XML!Text(
	 	
		 name <- 'thelastBuildDate',
		 value <- if i.lastBuildDate.oclIsUndefined() then '' else i.lastBuildDate endif
	 ),
	 
	 
	 items : XML!Element(
	 	
		 name <- 'items',
		 children <- i.items->asSequence()
	 ),
	 
	 category : XML!Element(
	 	
		 name <- 'category',
		 children <- i.category->asSequence()
	 )
 }

 rule Item2Element{
 	
	 from i : RSS!Item
	 
	 to 
	 
	 o : XML!Element(
	 	
		 name <- 'Item',
		 children <- Sequence {title,link,comments,description,author,guid,category}
	 ),
	 title : XML!Element(
	 	
		 name <- 'title',
		 children <- letitle
	 ),
	 letitle : XML!Text(
	 	
		 name <- 'letitle',
		 value <- i.title
	 ),
	 
	 guid : XML!Element(
	 	
		 name <- 'guid',
		 children <- theguid
	 ),
	 
	 theguid : XML!Text(
	 	
		 name <- 'theguid',
		 value <- if i.guid.oclIsUndefined() then '' else i.guid endif
	 ),
	 	  
	 author : XML!Element(
	 	
		 name <- 'author',
		 children <- theauthor
	 ),
	 
	 theauthor : XML!Text(
	 	
		 name <- 'theauthor',
		 value <- if i.author.oclIsUndefined() then '' else i.author endif
	 ),
	 
	 
	 link : XML!Element(
	 	
		 name <- 'link',
		 children <- thelink
	 ),
	 
	 thelink : XML!Text(
	 	
		 name <- 'thelink',
		 value <- if i.link.oclIsUndefined() then '' else i.link endif
	 ),
	 
	 description : XML!Element(
	 	
		 name <- 'description',
		 children <- thedescription
	 ),
	 
	 thedescription : XML!Text(
	 	
		 name <- 'thedescription',
		 value <- if i.description.oclIsUndefined() then '' else i.description endif
	 ),	 
	 
	 comments : XML!Element(
	 	
		 name <- 'comments',
		 children <- thecomments
	 ),
	 
	 thecomments : XML!Text(
	 	
		 name <- 'thecomments',
		 value <- if i.comments.oclIsUndefined() then '' else i.comments endif
	 ),
	 
	 category : XML!Element(
	 	
		 name <- 'category',
		 children <- i.category
	 )
 }
 
 rule Category2Element{
 	
	 from i : RSS!Category
	 
	 to 
	 
	 o : XML!Element(
	 	
		 name <- 'category',
		 children <- Sequence {domain,value}
	 ),
	 domain : XML!Element(
	 	
		 name <- 'domain',
		 children <- thedomain
	 ),
	 
	 thedomain : XML!Text(
	 	
		 name <- 'thedomain',
		 value <- if i.domain.oclIsUndefined() then '' else i.domain endif
	 ),
	 
	 value : XML!Element(
	 	
		 name <- 'value',
		 children <- thevalue
	 ),
	 
	 thevalue : XML!Text(
	 	
		 name <- 'thevalue',
		 value <- if i.value.oclIsUndefined() then '' else i.value endif
	 )
 }
 
 rule Image2Element{
 	
	 from i : RSS!Image
	 
	 to 
	 
	 o : XML!Element(
	 	
		 name <- 'Image',
		 children <- Sequence {url,title,link,description,width,height}
	 ),
	 
	 url : XML!Text(
	 	
		 name <- 'url',
		 value <- the_url
	 ),
	 
	 the_url : XML!Text(
		 	
			 name <- 'the_url',
			 value <- if i.subtitle.oclIsUndefined() then '' else i.subtitle endif
	 ),
	 
	 title : XML!Text(
	 	
		 name <- 'title',
		 value <- the_title
	 ),
		 
	 the_title : XML!Text(
		 	
			 name <- 'the_title',
			 value <- if i.subtitle.oclIsUndefined() then '' else i.subtitle endif
	 ),
	 
	 link : XML!Text(
	 	
		 name <- 'link',
		 value <- the_link
	 ),
	 
	 the_link : XML!Text(
		 	
			 name <- 'the_link',
			 value <- if i.subtitle.oclIsUndefined() then '' else i.subtitle endif
	 ),
	 
	 description : XML!Text(
	 	
		 name <- 'description',
		 value <- the_description
	 ),
	 
	 the_description : XML!Text(
		 	
			 name <- 'the_description',
			 value <- if i.subtitle.oclIsUndefined() then '' else i.subtitle endif
	 ),
	 
	 width : XML!Text(
	 	
		 name <- 'width',
		 value <- the_width
	 ),
	 
	 the_width : XML!Text(
		 	
			 name <- 'the_width',
			 value <- if i.subtitle.oclIsUndefined() then '' else i.subtitle endif
	 ),
	 
	 height : XML!Text(
	 	
		 name <- 'height',
		 value <- the_height
	 ),
	 
	 the_height : XML!Text(
		 	
			 name <- 'the_height',
			 value <- if i.subtitle.oclIsUndefined() then '' else i.subtitle endif
	 )
 }
	 ",modul rss xml creat out xml in rss concaten list string element separ comma helper def concat list sequenc string string list asset iter element acc string acc acc element els element endif rule project descript rule channel element rss channel xml root name channel children sequenc titl link descript languag copyright managingeditor webmast generat pubdat lastbuildd item categori doc ttl rate titl xml element name titl children letitl letitl xml text name letitl valu titl link xml element name link children thelink thelink xml text name thelink valu link descript xml element name descript children ladescript ladescript xml text name ladescript valu descript languag xml element name languag children lelangag lelangag xml text name lelangag valu languag oclisundefin els languag endif copyright xml element name copyright children thecopyright thecopyright xml text name thecopyright valu copyright oclisundefin els copyright endif managingeditor xml element name managingeditor children themanagingeditor themanagingeditor xml text name themanagingeditor valu managingeditor oclisundefin els managingeditor endif webmast xml element name webmast children thewebmast thewebmast xml text name thewebmast valu webmast oclisundefin els webmast endif generat xml element name generat children thegener doc xml element name doc children thedoc thedoc xml text name thedoc valu doc oclisundefin els doc endif ttl xml element name ttl children thettl thettl xml text name thettl valu ttl oclisundefin els ttl endif rate xml element name rate children therat therat xml text name therat valu rate oclisundefin els rate endif thegener xml text name thegener valu generat oclisundefin els generat endif pubdat xml element name pubdat children thepubd thepubd xml text name thepubd valu pubdat oclisundefin els pubdat endif lastbuildd xml element name lastbuildd children thelastbuildd thelastbuildd xml text name thelastbuildd valu lastbuildd oclisundefin els lastbuildd endif item xml element name item children item assequ categori xml element name categori children categori assequ rule item element rss item xml element name item children sequenc titl link comment descript author guid categori titl xml element name titl children letitl letitl xml text name letitl valu titl guid xml element name guid children theguid theguid xml text name theguid valu guid oclisundefin els guid endif author xml element name author children theauthor theauthor xml text name theauthor valu author oclisundefin els author endif link xml element name link children thelink thelink xml text name thelink valu link oclisundefin els link endif descript xml element name descript children thedescript thedescript xml text name thedescript valu descript oclisundefin els descript endif comment xml element name comment children thecom thecom xml text name thecom valu comment oclisundefin els comment endif categori xml element name categori children categori rule categori element rss categori xml element name categori children sequenc domain valu domain xml element name domain children thedomain thedomain xml text name thedomain valu domain oclisundefin els domain endif valu xml element name valu children thevalu thevalu xml text name thevalu valu valu oclisundefin els valu endif rule imag element rss imag xml element name imag children sequenc url titl link descript width height url xml text name url valu url url xml text name url valu subtitl oclisundefin els subtitl endif titl xml text name titl valu titl titl xml text name titl valu subtitl oclisundefin els subtitl endif link xml text name link valu link link xml text name link valu subtitl oclisundefin els subtitl endif descript xml text name descript valu descript descript xml text name descript valu subtitl oclisundefin els subtitl endif width xml text name width valu width width xml text name width valu subtitl oclisundefin els subtitl endif height xml text name height valu height height xml text name height valu subtitl oclisundefin els subtitl endif,9
166,166,P73-XML2ATOM.atl,"module XML2ATOM; -- Module Template
create OUT : ATOM from IN : XML;

-- ============================================================
-- XML2ATOM
-- Created by : Guillaume Hillairet (g.hillairet@gmail.com)
-- Date: 16/06/2006
-- Version: 1
-- modified by : Youssef Srour (srour.youssef@gmail.com)
-- ============================================================
	
-- ============================================================
-- HELPERS
-- ============================================================

-- This helper gets the Attribute who has value name = name and return it to a Boolean
-- CONTEXT: XML!Element
-- RETURN:  Boolean
helper context XML!Element def: getAttrBool(name : String) : Boolean =
	let a : String = 
    self.children->select(c | c.oclIsTypeOf(XML!Attribute) and c.name = name)->first().value
	in if a ='true' then true else false endif;

-- This helper gets the Attribute who has value name = name
-- CONTEXT: XML!Element
-- RETURN:  String
helper context XML!Element def: getAttrVal(name : String) : String =
	let e : XML!Attribute =
    self.children->any(c | c.oclIsTypeOf(XML!Attribute) and c.name = name)
	in if e.oclIsUndefined() then '' else e.value endif;

-- This helper gets Text from an XML!Element who has a child with a name value = name 
-- and with a child XML!Text.
-- CONTEXT: XML!Element
-- RETURN:  String
helper context XML!Element def: getText(name : String) : String =
	let e :Sequence(XML!Element) =
	self.children-> select(m | m.oclIsTypeOf(XML!Element) )
	in
	(if e.isEmpty() then '' else
		let r:Sequence(XML!Element) =
	    e->select (f|f.name=name)
		in
		if r.isEmpty() then '' else
			r-> collect(d | d.children )->flatten()
			->select(f | f.oclIsTypeOf(XML!Text) )
			->select ( g | g.name = '#text' )->first().value
		endif
	endif).toString();



-- This helper gets a Sequence of XML!Element from an XML!Element who has a child with a name value = name 
-- CONTEXT: XML!Element
-- RETURN:  Sequence(XML!Element)
helper context XML!Element def: getSequence(name : String) : Sequence(XML!Element) =
	let e :Sequence(XML!Element) = self.children-> select(m | m.oclIsTypeOf(XML!Element) )
	in if e.isEmpty() 
		then Sequence{} 
		else 
			let r : Sequence(XML!Element) = e->select (f|f.name = name)
		in r
	endif;
	
-- This helper say if an XML!Element has a child with value name = name
-- CONTEXT: XML!Element
-- RETURN:  Boolean
helper context XML!Element def: hasChildren(name : String) : Boolean =
	let a : XML!Element =
	self.children-> select(m | m.oclIsTypeOf(XML!Element) and m.name = name )->first()
	in if (a.oclIsTypeOf(XML!Element) and a.name = name) 
		then true else false 
	endif;

-- This helper stores an integer value used to assign an ID to each generated
-- CONTEXT: XML!Element
-- RETURN:  Boolean
--teste si l'element possede un certain XMLattribut
helper context XML!Element def: hasAttribute(name : String) : Boolean =
	let a : XML!Attribute =
	self.children-> select(m | m.oclIsTypeOf(XML!Attribute) and m.name = name )->first()
	in if not a.oclIsUndefined()
		then (a.name = name) else false
	endif;

-- This helper stores adds All Text value contains in an XML element in a single String
-- CONTEXT: XML!Element
-- RETURN:  String
helper context XML!Element def: getAllText() : String = 
	let s :String =
		self.children->select( e | e.oclIsTypeOf(XML!Text))->iterate(acc; res : String = '' | res + acc.value )
	in s;

helper context XML!Element def: getUpdate() : String = 
	let s :String =
		(if self.getText('updated').oclIsUndefined() then self.getText('modified') else self.getText('updated') endif).toString()
	in s;




--(if e.getText('updated').oclIsUndefined() then e.getText('modified') else e.getText('updated') endif).toString(),
-- ============================================================
-- Rules
-- ============================================================

-- this rule 
rule Atom {
	from
		r : XML!Root (
			r.name = 'feed'
		)
	to
		a : ATOM!ATOM (
			title <- r.getText('title'),
			id <- r.getText('id'),
			subtitle <- r.getText('subtitle'),
			rights <- r.getText('rights'),
			authors <- r.getSequence('author'),
			icon <- r.getText('icon'),
			logo <- r.getText('logo'),
			links <- r.getSequence('link'),
			entrie <- r.getSequence('entry'),
			lastUpdate <- (if r.getText('updated').oclIsUndefined() then r.getText('modified') else r.getText('updated') endif).toString(),
			generator <- r.children->any( e | e.oclIsTypeOf(XML!Element) and e.name = 'generator'),
			categories <- r.getSequence('category'),
			
			contributors <- r.getSequence('contributor')
		)
}

rule Category {
	from
		e : XML!Element (
			e.name = 'category'
		)
	to 
		a : ATOM!Category (
			term <- e.getAttrVal('term'),
			scheme <- e.getAttrVal('scheme'),
			label <- e.getAttrVal('label')
		)
}

rule Generator {
	from
		e : XML!Element (
			e.name = 'generator'
		)
	to
		a : ATOM!Generator (
			name <- e.children->any(e | e.oclIsTypeOf(XML!Text)).value,
			uri <- e.getAttrVal('uri').toString(),
			version <-e.getAttrVal('version')
		)
}



rule Entry {
	from
		e : XML!Element (
			e.name = 'entry'
		)
	to
		a : ATOM!Entry (
			title <- e.getText('title'),
			id <- e.getText('id'),
			rights <- e.getText('rights'),
			summary <- e.getText('summary'),
			links <- e.getSequence('link'),
			lastUpdate <-e.getUpdate(),
			content <- e.children->select( e | e.oclIsTypeOf(XML!Element) and e.name = 'content'),
			authors <- e.getSequence('author'),
			contributors <- e.getSequence('contributor')
		)
}

rule TextContent {
	from
		e : XML!Element (
			e.name = 'content' and e.getAttrVal('type') = 'text'
		)
	to
		a : ATOM!InLineTextContent (
			type <- e.getAttrVal('type'),
			mode <- e.getAttrVal('mode'),
			text <- e.getAllText()
			
		)
}

rule XHtmlContent {
	from
		e : XML!Element (
			e.name = 'content' and  (( e.getAttrVal('type') = 'html' or
				e.getAttrVal('type') = 'xhtml'  ) or 
				e.getAttrVal('type') = 'text/html' )
		)
	to
		a : ATOM!InLineXHTMLContent (
			type <- e.getAttrVal('type'),
			mode <- e.getAttrVal('mode'),
			text <- e.getAllText()
		)
}
rule Link {
	from 
		e : XML!Element (
			e.name = 'link'
			and (e.parent.value = 'feed' or e.parent.value = 'entry') 
		)
	to 
		out : ATOM!Link (
			
			rel <- e.getAttrVal('rel'),
			hrefl <- e.getAttrVal('href'),
			type <- e.getAttrVal('type'),			
			hreflang <- e.getAttrVal('hreflang'),
			title <- e.getAttrVal('title'),
			lenght <- e.getAttrVal('lenght').toInteger()
		)
}
rule Author {
	from
		e : XML!Element (
			e.name = 'author'
		)
	to
		a : ATOM!Author (
			name <- e.getText('name'),
			email <- e.getText('email'),
			uri <- e.getText('uri')
		)
}

rule Contributor {
	from
		e : XML!Element (
			e.name = 'contributor'
		)
	to
		a : ATOM!Contributor (
			name <- e.getText('name'),
			email <- e.getText('email'),
			uri <- e.getText('uri')
		)
}



rule LinkNotLenght {
	from
		e : XML!Element (
			e.name = 'link' and not e.hasAttribute('lenght')
		)
	to 
		a : ATOM!Link (
			rel <- e.getAttrVal('rel'),
			type <- e.getAttrVal('type'),
			hrefl <- e.getAttrVal('href'),
			hreflang <- e.getAttrVal('hreflang'),
			title <- e.getAttrVal('title')
		)
}
",modul xml atom modul templat creat out atom in xml xml atom creat guillaum hillairet g hillairet gmail com date version modifi youssef srour srour youssef gmail com helper this helper get attribut valu name name return boolean context xml element return boolean helper context xml element def getattrbool name string boolean let string self children select c c oclistypeof xml attribut c name name first valu true true els fals endif this helper get attribut valu name name context xml element return string helper context xml element def getattrv name string string let e xml attribut self children c c oclistypeof xml attribut c name name e oclisundefin els e valu endif this helper get text xml element child name valu name child xml text context xml element return string helper context xml element def gettext name string string let e sequenc xml element self children select oclistypeof xml element e isempti els let r sequenc xml element e select f f name name r isempti els r collect children flatten select f f oclistypeof xml text select g g name text first valu endif endif tostr this helper get sequenc xml element xml element child name valu name context xml element return sequenc xml element helper context xml element def getsequ name string sequenc xml element let e sequenc xml element self children select oclistypeof xml element e isempti sequenc els let r sequenc xml element e select f f name name r endif this helper say xml element child valu name name context xml element return boolean helper context xml element def haschildren name string boolean let xml element self children select oclistypeof xml element name name first oclistypeof xml element name name true els fals endif this helper store integ valu use assign id generat context xml element return boolean test si l element possed un certain xmlattribut helper context xml element def hasattribut name string boolean let xml attribut self children select oclistypeof xml attribut name name first oclisundefin name name els fals endif this helper store add all text valu contain xml element singl string context xml element return string helper context xml element def getalltext string let string self children select e e oclistypeof xml text iter acc res string res acc valu helper context xml element def getupd string let string self gettext updat oclisundefin self gettext modifi els self gettext updat endif tostr e gettext updat oclisundefin e gettext modifi els e gettext updat endif tostr rule rule rule atom r xml root r name feed atom atom titl r gettext titl id r gettext id subtitl r gettext subtitl right r gettext right author r getsequ author icon r gettext icon logo r gettext logo link r getsequ link entri r getsequ entri lastupd r gettext updat oclisundefin r gettext modifi els r gettext updat endif tostr generat r children e e oclistypeof xml element e name generat categori r getsequ categori contributor r getsequ contributor rule categori e xml element e name categori atom categori term e getattrv term scheme e getattrv scheme label e getattrv label rule generat e xml element e name generat atom generat name e children e e oclistypeof xml text valu uri e getattrv uri tostr version e getattrv version rule entri e xml element e name entri atom entri titl e gettext titl id e gettext id right e gettext right summari e gettext summari link e getsequ link lastupd e getupd content e children select e e oclistypeof xml element e name content author e getsequ author contributor e getsequ contributor rule textcont e xml element e name content e getattrv type text atom inlinetextcont type e getattrv type mode e getattrv mode text e getalltext rule xhtmlcontent e xml element e name content e getattrv type html e getattrv type xhtml e getattrv type text html atom inlinexhtmlcont type e getattrv type mode e getattrv mode text e getalltext rule link e xml element e name link e parent valu feed e parent valu entri atom link rel e getattrv rel hrefl e getattrv href type e getattrv type hreflang e getattrv hreflang titl e getattrv titl lenght e getattrv lenght tointeg rule author e xml element e name author atom author name e gettext name email e gettext email uri e gettext uri rule contributor e xml element e name contributor atom contributor name e gettext name email e gettext email uri e gettext uri rule linknotlenght e xml element e name link e hasattribut lenght atom link rel e getattrv rel type e getattrv type hrefl e getattrv href hreflang e getattrv hreflang titl e getattrv titl,7
167,167,P73-XML2RSS.atl,"module XML2RSS; -- Module Template
create OUT : RSS from IN : XML;

-- ============================================================
-- XML2RSS
-- Created by: Guillaume Hillairet (g.hillairet@gmail.com)
-- Date: 16/06/2006
-- Version: 1
-- ============================================================
	
-- ============================================================
-- HELPERS
-- ============================================================

-- This helper gets the Attribute who has value name = name and return it to a Boolean
-- CONTEXT: XML!Element
-- RETURN:  Boolean
helper context XML!Element def: getAttrBool(name : String) : Boolean =
	let a : String = 
    self.children->select(c | c.oclIsTypeOf(XML!Attribute) and c.name = name)->first().value
	in if a ='true' then true else false endif;

-- This helper gets the Attribute who has value name = name
-- CONTEXT: XML!Element
-- RETURN:  String
helper context XML!Element def: getAttrVal(name : String) : String =
    self.children->select(c | c.oclIsTypeOf(XML!Attribute) and c.name = name)->first().value;

-- This helper gets Text from an XML!Element who has a child with a name value = name 
-- and with a child XML!Text.
-- CONTEXT: XML!Element
-- RETURN:  String
helper context XML!Element def: getText(name : String) : String =
	let e :Sequence(XML!Element) =
	self.children-> select(m | m.oclIsTypeOf(XML!Element) )
	in
	if e.isEmpty() then '' else
		let r:Sequence(XML!Element) =
	    e->select (f|f.name=name)
		in
		if r.isEmpty() then '' else
			r-> collect(d | d.children )->flatten()
			->select(f | f.oclIsTypeOf(XML!Text) )
			->select ( g | g.name = '#text' )->first().value
		endif
	endif;
	
	
-- This helper gets a Sequence of XML!Element from an XML!Element who has a child with a name value = name 
-- CONTEXT: XML!Element
-- RETURN:  Sequence(XML!Element)
helper context XML!Element def: getSequence(name : String) : Sequence(XML!Element) =
	let e :Sequence(XML!Element) = self.children-> select(m | m.oclIsTypeOf(XML!Element) )
	in if e.isEmpty() 
		then Sequence{} 
		else 
			let r : Sequence(XML!Element) = e->select (f|f.name = name)
		in r
	endif;
	
-- This helper say if an XML!Element has a child with value name = name
-- CONTEXT: XML!Element
-- RETURN:  Boolean
helper context XML!Element def: hasChildren(name : String) : Boolean =
	let a : XML!Element =
	self.children-> select(m | m.oclIsTypeOf(XML!Element) and m.name = name )->first()
	in if (a.oclIsTypeOf(XML!Element) and a.name = name) 
		then true else false 
	endif;

-- This helper stores an integer value used to assign an ID to each generated
-- CONTEXT: XML!Element
-- RETURN:  Boolean
--teste si l'element possede un certain XMLattribut
helper context XML!Element def: hasAttribute(name : String) : Boolean =
	let a : XML!Attribute =
	self.children-> select(m | m.oclIsTypeOf(XML!Attribute) and m.name = name )->first()
	in if not a.oclIsUndefined()
		then (a.name = name) else false
	endif;

--
-- Map for month
--
helper def: monthMap : Map(String, Integer) =
	let m : Map(String, Integer) = 
		Map{('January',1),('February',2),('March',3),('April',4),
			('May',5),('June',6),('July',7),('August',8),
			('September',9),('October',10),('November',11),('December',12)}
	in m ;

--
-- Map for day
--
helper def: eDayMap : Map(String, RSS!DayKind) =
	let m : Map(String, RSS!DayKind) = 
		Map{('Mon',#Monday),('Tue',#Tuesday),('Wed',#Wednesday),('Thu',#Thursday),
			('Fri',#Friday),('Sat',#Saturday),('Sun',#Sunday)}
	in m ;
	
-- ============================================================
-- RULES
-- ============================================================

rule RSS {
	from
		r : XML!Root
	to
		rss : RSS!RSS (
			version <- r.getAttrVal('version'),
			channel <- r.children->select( e | e.oclIsTypeOf(XML!Element) and e.name = 'channel')->first()
		)
}

rule Channel {
	from
		e : XML!Element (
			e.name = 'channel'
		)
	to
		c : RSS!Channel (
			title <- e.getText('title'),
			link <- e.getText('link'),
			description <- e.getText('description'),
			language <- e.getText('language'),
			copyright <- e.getText('copyright'),
			managingEditor <- e.getText('managingEditor'),
			webmaster <- e.getText('webMaster'),
			pubDate <- e.getText('pubDate'),
			generator <- e.getText('generator'),
			docs <- e.getText('docs'),
--			ttl <-  e.getText('ttl')->toInteger(),
			rating <- e.getText('rating'),
			textInput <- e.children->select( e | e.oclIsTypeOf(XML!Element) and e.name = 'textInput')->first(),
			cloud <- e.children->select( e | e.oclIsTypeOf(XML!Element) and e.name = 'cloud')->first(),
			image <- e.children->select( e | e.oclIsTypeOf(XML!Element) and e.name = 'image')->first(),
			
			lastBuildDate <- e.getText('lastBuildDate'),
			category <- e.children->select( e | e.oclIsTypeOf(XML!Element) and e.name = 'category')->first(),
			items <- e.children->select( e | e.oclIsTypeOf(XML!Element) and e.name = 'item')->asSequence()
		)
}


rule Image {
	from
		e : XML!Element (
			e.name = 'image'
		)
	to
		i : RSS!Image (
			url <- e.getText('url'),
			title <- e.getText('title'),
			link <- e.getText('link'),
			description <- e.getText('description')
		)
}

rule Cloud {
	from
		e : XML!Element (
			e.name = 'cloud'
		)
	to
		c : RSS!Cloud (
			domain <- e.getAttrVal('domain'),
			port <- e.getAttrVal('port').toInteger(),
			path <- e.getAttrVal('path'),
			registerProcedure <- e.getAttrVal('registerProcedure'),
			protocol <- e.getAttrVal('protocol')
		)
}

rule TextInput {
	from
		e : XML!Element (
			e.name = 'textInput'
		)
	to
		t : RSS!TextInput (
			title <- e.getText('url'),
			description <- e.getText('description'),
			name <- e.getText('name'),
			link <- e.getText('link')
		)
}

rule Item {
	from
		e : XML!Element (
			e.name = 'item'
		)
	to
		i : RSS!Item (
			title <- e.getText('title'),
			link <- e.getText('link'),
			description <- e.getText('description'),
			author <- e.getText('author'),
			comments <- e.getText('comments'),
			guid <- e.getText('guid'),
			source <- e.children->select( e | e.oclIsTypeOf(XML!Element) and e.name = 'source')->first(),
			pubDate <- e.children->select(e | e.oclIsTypeOf(XML!Element) and e.name = 'pubDate')->first(),
			enclosure <- e.children->select(e | e.oclIsTypeOf(XML!Element) and e.name = 'enclosure')->first(),
			category <- e.children->select( e | e.oclIsTypeOf(XML!Element) and e.name = 'category')->first()
		)
}

rule Category {
	from
		e : XML!Element (
			e.name = 'category'
		)
	to
		c : RSS!Category (
			domain <- if e.hasAttribute('domain') 
						then e.getAttrVal('domain')
						else ''
					   endif,
			value <- e.children->select( t | t.oclIsTypeOf(XML!Text))->first().value
		)
}

rule Source {
	from
		e : XML!Element (
			e.name = 'source'
		)
	to
		c : RSS!Source (
			url <- e.getAttrVal('url'),
			value <- e.children->select( t | t.oclIsTypeOf(XML!Text))->first().value
		)
}

rule Enclosure {
	from
		e : XML!Element (
			e.name = 'source'
		)
	to
		c : RSS!Enclosure (
			url <- e.getAttrVal('url'),
			lenght <- e.getAttrVal('lenght').toInteger(),
			type <- e.getAttrVal('type')
		)
}
",modul xml rss modul templat creat out rss in xml xml rss creat guillaum hillairet g hillairet gmail com date version helper this helper get attribut valu name name return boolean context xml element return boolean helper context xml element def getattrbool name string boolean let string self children select c c oclistypeof xml attribut c name name first valu true true els fals endif this helper get attribut valu name name context xml element return string helper context xml element def getattrv name string string self children select c c oclistypeof xml attribut c name name first valu this helper get text xml element child name valu name child xml text context xml element return string helper context xml element def gettext name string string let e sequenc xml element self children select oclistypeof xml element e isempti els let r sequenc xml element e select f f name name r isempti els r collect children flatten select f f oclistypeof xml text select g g name text first valu endif endif this helper get sequenc xml element xml element child name valu name context xml element return sequenc xml element helper context xml element def getsequ name string sequenc xml element let e sequenc xml element self children select oclistypeof xml element e isempti sequenc els let r sequenc xml element e select f f name name r endif this helper say xml element child valu name name context xml element return boolean helper context xml element def haschildren name string boolean let xml element self children select oclistypeof xml element name name first oclistypeof xml element name name true els fals endif this helper store integ valu use assign id generat context xml element return boolean test si l element possed un certain xmlattribut helper context xml element def hasattribut name string boolean let xml attribut self children select oclistypeof xml attribut name name first oclisundefin name name els fals endif map month helper def monthmap map string integ let map string integ map januari februari march april may june juli august septemb octob novemb decemb map day helper def edaymap map string rss daykind let map string rss daykind map mon monday tue tuesday wed wednesday thu thursday fri friday sat saturday sun sunday rule rule rss r xml root rss rss rss version r getattrv version channel r children select e e oclistypeof xml element e name channel first rule channel e xml element e name channel c rss channel titl e gettext titl link e gettext link descript e gettext descript languag e gettext languag copyright e gettext copyright managingeditor e gettext managingeditor webmast e gettext webmast pubdat e gettext pubdat generat e gettext generat doc e gettext doc ttl e gettext ttl tointeg rate e gettext rate textinput e children select e e oclistypeof xml element e name textinput first cloud e children select e e oclistypeof xml element e name cloud first imag e children select e e oclistypeof xml element e name imag first lastbuildd e gettext lastbuildd categori e children select e e oclistypeof xml element e name categori first item e children select e e oclistypeof xml element e name item assequ rule imag e xml element e name imag rss imag url e gettext url titl e gettext titl link e gettext link descript e gettext descript rule cloud e xml element e name cloud c rss cloud domain e getattrv domain port e getattrv port tointeg path e getattrv path registerprocedur e getattrv registerprocedur protocol e getattrv protocol rule textinput e xml element e name textinput rss textinput titl e gettext url descript e gettext descript name e gettext name link e gettext link rule item e xml element e name item rss item titl e gettext titl link e gettext link descript e gettext descript author e gettext author comment e gettext comment guid e gettext guid sourc e children select e e oclistypeof xml element e name sourc first pubdat e children select e e oclistypeof xml element e name pubdat first enclosur e children select e e oclistypeof xml element e name enclosur first categori e children select e e oclistypeof xml element e name categori first rule categori e xml element e name categori c rss categori domain e hasattribut domain e getattrv domain els endif valu e children select oclistypeof xml text first valu rule sourc e xml element e name sourc c rss sourc url e getattrv url valu e children select oclistypeof xml text first valu rule enclosur e xml element e name sourc c rss enclosur url e getattrv url lenght e getattrv lenght tointeg type e getattrv type,7
168,168,P74-TypeA2TypeB_v1.atl,"-- @path TypeA=/SideEffect/Metamodels/TypeA.ecore
-- @path TypeB=/SideEffect/Metamodels/TypeB.ecore

module TypeA2TypeB;
create b : TypeB from a : TypeA;

-- This helper retrieves all names and removes all duplicates
helper context TypeA!RootA def : getDefNameSet() : Set(String) =
	self.elms->collect(e|e.name).asSet();

rule RootA2RootB {
	from 
		rtA : TypeA!RootA
	to
		-- this rule is dangerous as we suppose the ATL engine executes...
		rtB : TypeB!RootB (
			-- this line before...
			defs <- defBLst,
			-- this one.
			elms <- elmBLst
		),
		defBLst : distinct TypeB!DefinitionB foreach(defName in rtA.getDefNameSet ())(
			name <- defName
		),
		elmBLst : distinct TypeB!ElementB foreach (elmA in rtA.elms) (
				-- here the target model is browsed
				definition <- rtB.defs->select (d | d.name = elmA.name )->first()
		)
}",path typea sideeffect metamodel typea ecor path typeb sideeffect metamodel typeb ecor modul typea typeb creat b typeb typea this helper retriev name remov duplic helper context typea roota def getdefnameset set string self elm collect e e name asset rule roota rootb rta typea roota rule danger suppos atl engin execut rtb typeb rootb line def defblst one elm elmblst defblst distinct typeb definitionb foreach defnam rta getdefnameset name defnam elmblst distinct typeb elementb foreach elma rta elm target model brows definit rtb def select name elma name first,4
169,169,P74-TypeA2TypeB_v2.atl,"-- @path TypeA=/SideEffect/Metamodels/TypeA.ecore
-- @path TypeB=/SideEffect/Metamodels/TypeB.ecore

module TypeA2TypeB;
create b : TypeB from a : TypeA;

rule RootA2RootB {
	from
		rtA : TypeA!RootA
	to
		rtB : TypeB!RootB (
			defs <- rtA.elms->iterate(e; res : Set(TypeA!ElementA) = Set {} |
				if (res->collect(f | f.name)->includes(e.name)) then
					res
				else
					res->including(e)
				endif
				)-- here we keep only one element of each name value
				->collect(e | thisModule.Definition(e))
				-- then we create a DefinitionB from each selected element
			, elms <- rtA.elms
		)
}

lazy rule Definition {
	from
		s : TypeA!ElementA
	to
		t : TypeB!DefinitionB(
			name <- s.name
		)
}

helper def: nameToAssignHistory : Sequence(TupleType(e : TypeB!ElementB, s : String)) =
	Sequence {};
	
rule NameToAssign (e : TypeB!ElementB, s : String) {
	do {
		thisModule.nameToAssignHistory <- thisModule.nameToAssignHistory->append(Tuple {e = e, s = s});
	}
}

rule Element {
	from
		s : TypeA!ElementA
	to
		t : TypeB!ElementB(
		)
	do {
		-- The corresponding name for the current ElementB is added in the map.
		-- This map will be used at the end of the transformation to create a link between ElementB and DefinitionB
		thisModule.NameToAssign(t, s.name);
	}
}

-- execute delayed actions
endpoint rule EndRule() {
	do {
		for(dta in thisModule.nameToAssignHistory) {
			-- We create a link between an ElementB and the corresponding DefinitionB
			dta.e.definition <- TypeB!DefinitionB.allInstancesFrom('b')->any(e | e.name = dta.s);
		}
	}
}",path typea sideeffect metamodel typea ecor path typeb sideeffect metamodel typeb ecor modul typea typeb creat b typeb typea rule roota rootb rta typea roota rtb typeb rootb def rta elm iter e res set typea elementa set res collect f f name includ e name res els res includ e endif keep one element name valu collect e thismodul definit e creat definitionb select element elm rta elm lazi rule definit typea elementa typeb definitionb name name helper def nametoassignhistori sequenc tupletyp e typeb elementb string sequenc rule nametoassign e typeb elementb string thismodul nametoassignhistori thismodul nametoassignhistori append tupl e e rule element typea elementa typeb elementb the correspond name current elementb ad map this map use end transform creat link elementb definitionb thismodul nametoassign name execut delay action endpoint rule endrul dta thismodul nametoassignhistori we creat link elementb correspond definitionb dta e definit typeb definitionb allinstancesfrom b e e name dta,0
170,170,P74-TypeA2TypeB_v3_firstStep.atl,"-- @path TypeA=/SideEffect/Metamodels/TypeA.ecore
-- @path TypeB=/SideEffect/Metamodels/TypeB.ecore

module TypeA2TypeB;
create b : TypeB from a : TypeA;

rule RootA2RootB {
	from
		rtA : TypeA!RootA
	to
		rtB : TypeB!RootB (
			defs <- rtA.elms->iterate(e; res : Set(TypeA!ElementA) = Set {} |
				if (res->collect(f | f.name)->includes(e.name)) then
					res
				else
					res->including(e)
				endif
				)->collect(e | thisModule.Definition(e))
		)
}

lazy rule Definition {
	from
		s : TypeA!ElementA
	to
		t : TypeB!DefinitionB(
			name <- s.name
		)
}",path typea sideeffect metamodel typea ecor path typeb sideeffect metamodel typeb ecor modul typea typeb creat b typeb typea rule roota rootb rta typea roota rtb typeb rootb def rta elm iter e res set typea elementa set res collect f f name includ e name res els res includ e endif collect e thismodul definit e lazi rule definit typea elementa typeb definitionb name name,4
171,171,P74-TypeA2TypeB_v3_secondStep.atl,"-- @path TypeA=/SideEffect/Metamodels/TypeA.ecore
-- @path TypeB=/SideEffect/Metamodels/TypeB.ecore

module TypeA2TypeB; 
create b : TypeB from a : TypeA, bIn : TypeB;

rule RootA2RootB {
	from
		rtA : TypeA!RootA, rtBIN : TypeB!RootB
	to
		rtB : TypeB!RootB (
			defs <- rtBIN.defs,
			elms <- rtA.elms
		)
}

rule Definition {
	from
		s : TypeB!DefinitionB
	to
		t : TypeB!DefinitionB(
			name <- s.name
		)
}

rule Element {
	from
		s : TypeA!ElementA
	to
		t : TypeB!ElementB(
			definition <- TypeB!DefinitionB.allInstancesFrom('bIn')->any(e | e.name = s.name)
		)
}",path typea sideeffect metamodel typea ecor path typeb sideeffect metamodel typeb ecor modul typea typeb creat b typeb typea bin typeb rule roota rootb rta typea roota rtbin typeb rootb rtb typeb rootb def rtbin def elm rta elm rule definit typeb definitionb typeb definitionb name name rule element typea elementa typeb elementb definit typeb definitionb allinstancesfrom bin e e name name,4
172,172,P75-KM32SimpleClass.atl,"module KM32SimpleClass; -- Module Template

create OUT : SimpleClass from IN : KM3;

rule Class {
	from
		s : KM3!Class
	to
		t : SimpleClass!Class (
			name <- s.name,
			attrs <- s.structuralFeatures->select(sf | 
				         sf.oclIsKindOf(KM3!Attribute) and
						 sf.name <> 'persistent'
					 ),
			parent <- s.supertypes->first(),
			is_persistent<-s.structuralFeatures->exists(sf | sf.name='persistent')
		)
}

rule Attribute {
    from
	   s : KM3!Attribute (
	   	s.name <> 'persistent'
	   )
	using {
		is_primary : Boolean = if s.name->size() > 8 
		           		then s.name->substring(s.name->size()-7,
		           	       		               s.name->size())='_primary'
				   		else false
				   		endif;

		name : String = if is_primary 
		         then s.name->substring(1, s.name->size()-8)
				 else s.name
				 endif;
	}

	to
	   t : SimpleClass!Attribute(
	       name<-name,
		   type<-s.type,
		   is_primary<-is_primary
	   )
}

rule PrimitiveTypes {
	 from
	 	s : KM3!DataType
	 to 
	      t : SimpleClass!PrimitiveDataType (
	        name<-s.name	
	      )
}

rule Reference {
	from ref : KM3!Reference
	to
	     assoc : SimpleClass!Association(
	     	        name<-ref.name,
					src<-ref.owner,
					dest<-ref.type
	             )
}

",modul km simpleclass modul templat creat out simpleclass in km rule class km class simpleclass class name name attr structuralfeatur select sf sf ocliskindof km attribut sf name persist parent supertyp first persist structuralfeatur exist sf sf name persist rule attribut km attribut name persist use primari boolean name size name substr name size name size primari els fals endif name string primari name substr name size els name endif simpleclass attribut name name type type primari primari rule primitivetyp km datatyp simpleclass primitivedatatyp name name rule refer ref km refer assoc simpleclass associ name ref name src ref owner dest ref type,18
173,173,P75-SimpleClass2SimpleRDBMS.atl,"module SimpleClass2SimpleRDBMS;
create OUT : SimpleRDBMS from IN : SimpleClass;

-- Transforms all persistent classes that are a root of an inheritance tree

rule PersistentClass2Table{
	from
		c : SimpleClass!Class (
			  c.is_persistent and c.parent->oclIsUndefined() 
			)
			
	using {
		primary_attributes : Sequence(TupleType(name : String,
			                            		type : SimpleClass!Classifier,
										        isPrimary : Boolean)
					 		 ) =
					c.flattenedFeatures->select(f | f.isPrimary);

		--	this variable holds all the features of a persistent class
		--	and for each feature it keeps the number of the primary attributes
		--	of the persistent class plus the total number of the primary attributes of the 
		--	preceding attributes

		persistent_features : Sequence(TupleType(
											name : String,
											class : SimpleClass!Class,
											offcet : Integer,
											nofAttrs : Integer
										)
			                    ) =
			c.flattenedFeatures->iterate(tuple; acc : Sequence(TupleType(name : String,
			             									  class : SimpleClass!Class,
															  offcet : Integer,
															  nofAttrs : Integer))=Sequence{} |
			          if tuple.type->oclIsKindOf(SimpleClass!Class)
					  then -- a persistent feature is found
					  	 acc->append(
								Tuple{
									name=tuple.name,
									class = tuple.type,
									offcet=if acc->size()=0 then 1
										   else acc->last().offcet + acc->last().nofAttrs
										   endif,
									nofAttrs=tuple.type.topParent.flattenedFeatures->select(t | t.isPrimary)->size()
								}
							  )
						else
							acc
						endif
			);

		foreign_key_attributes : Sequence(TupleType(name : String,
			                            			type : SimpleClass!Classifier)
					 		     ) =
					persistent_features->collect(tuple | 
						                   	  tuple.class.topParent.flattenedFeatures->select(t | t.isPrimary)->collect(a |
						                   	     Tuple {
						                   	  	 	name=tuple.name + '_' + a.name,
													type=a.type
						                   	  	 }
						                   	  )
					                      )->flatten();
		
		rest_of_attributes : Sequence(TupleType(name : String,
			                            		type : SimpleClass!Classifier
							 )) =
			c.flattenedFeatures->select(tuple | 
					 		 	not tuple.isPrimary and 
								not tuple.type->oclIsKindOf(SimpleClass!Class)
					 		 );
	}
	
	to
		t : SimpleRDBMS!Table (
		    	name<-c.name,
				cols<-primary_key_columns->union(foreign_key_columns)->union(rest),
				pkey<-primary_key_columns,
				fkeys<-foreign_keys
			),
		
		primary_key_columns : distinct SimpleRDBMS!Column foreach (primAttr in primary_attributes)
			    (
		 		    name<-primAttr.name,
				    type<-primAttr.type.name
		         ),
		
		foreign_keys : distinct SimpleRDBMS!FKey foreach (persAttr in persistent_features)
		 		(
		 			references<-persAttr.class.topParent, 
					cols<-persistent_features->iterate(tuple;
													   acc : Sequence(Sequence(SimpleRDBMS!Column))=Sequence{} |
					      	acc->append(foreign_key_columns.subSequence(
					      					tuple.offcet,
					      					tuple.offcet + tuple.nofAttrs-1)
										)
						         )
											 			
		 		),
				
		foreign_key_columns : distinct SimpleRDBMS!Column foreach (attr in foreign_key_attributes)
		 		(
		 			name<-attr.name,
				    type<-attr.type.name
		 		),
		
		rest : distinct SimpleRDBMS!Column foreach (attr in rest_of_attributes)
		 		(
		 			name<-attr.name,
				    type<-attr.type.name
		 		)
}

-- This helper determines all the attributes of a given class
-- as an union of the attributes defined in the class and
-- the attributes inherited from the parent class. 
-- Attributes in a sub-class overrides inherited
-- attributes with the same name.

helper context SimpleClass!Class def :
	allAttributes : Sequence(SimpleClass!Attribute) =

	self.attrs->union(
		if not self.parent.oclIsUndefined() then -- there is a parent class
			self.parent.allAttributes->select(attr |
			   not self.attrs->exists(at | at.name = attr.name)
			)
		else  -- no parent class
			Sequence {} 
		endif
	)->flatten();
	
	   
-- This helper determines all the associations
-- for a given class as an union of the defined
-- and inherited associations.
-- We assume that name clashes in association ends are not allowed.
	   
helper context SimpleClass!Class def :
	allAssociations : Sequence(SimpleClass!Association) =

	let defAssoc : Sequence(SimpleClass!Association) = 
		SimpleClass!Association.allInstances()->select(assoc |
			assoc.src = self) in
   	defAssoc->union(
		if not self.parent.oclIsUndefined() then 
		   self.parent.allAssociations
		else 
		   Sequence {} 
        endif
	)->flatten();

-- This helper returns a sequence of attributes collected from the 
-- specialized classes of the context class.
-- In this way a flattening of inheritance hierarchy
-- is achieved.

helper context SimpleClass!Class def :
	attributesOfSubclasses : Sequence(SimpleClass!Attribute) =
	
	let attrsInSubclasses : Sequence(SimpleClass!Attribute) =
		SimpleClass!Class.allInstances()->select(c |
			c.parent=self
		)->collect(directSubclass |
			directSubclass.attributesOfSubclasses
		)->flatten() in
	attrsInSubclasses->union(
		self.attrs->select(attr | 
			not attrsInSubclasses->exists(a |
				a.name = attr.name)
	))->flatten();

--Helper similar to the previous one that flattens associations.

helper context SimpleClass!Class def :
	associationsOfSubclasses : Sequence(SimpleClass!Association) =

	SimpleClass!Association.allInstances()->select(assoc |
			assoc.src = self)->union(
	   		SimpleClass!Class.allInstances()->select(c |
	   			c.parent = self)->collect(subclass |
	   		subclass.associationsOfSubclasses)->flatten()
	)->flatten();

-- This helper locates the top parent class
-- for a given context class. The helper is used
-- when an attribute/association refers to a
-- persistent class that is not a root of
-- an inheritance hierarchy. In that case
-- the root must be located in order to obtain
-- the target table derived from the root class. 

helper context SimpleClass!Class def :
	topParent : SimpleClass!Class =

	if self.parent.oclIsUndefined() then 
		self 
	else
		self.parent.topParent
	endif;

-- Helper that performs flattening of non-simple attributes
-- and associations pointing to non-persistent classes.

helper context SimpleClass!Class def :
	flattenedFeatures : Sequence(TupleType(
		                                   name : String,
										   type : SimpleClass!Classifier,
										   isPrimary : Boolean
										  )) =

    if self.topParent.is_persistent then
		self.topParent.attributesOfSubclasses->union(
			self.topParent.associationsOfSubclasses)
	else
		self.allAttributes->union(self.allAssociations)
	endif->collect(f | 
		let feature : TupleType(
			             name : String,
			             type : SimpleClass!Classifier,
					     isPrimary : Boolean
				      ) = 
		if f.oclIsKindOf(SimpleClass!Attribute) then
			Tuple{name = f.name, type = f.type, isPrimary = f.is_primary}
	 	else
			Tuple{name = f.name, type = f.dest, isPrimary = false}
	 	endif in
	if feature.type.oclIsKindOf(SimpleClass!PrimitiveDataType) then
		feature
	else if not feature.type.topParent.is_persistent then 	 
		feature.type.flattenedFeatures->collect (f | Tuple{name=feature.name+ '_' + f.name, type=f.type, isPrimary=f.isPrimary})
	else feature
	endif endif
	)->flatten();
",modul simpleclass simplerdbm creat out simplerdbm in simpleclass transform persist class root inherit tree rule persistentclass tabl c simpleclass class c persist c parent oclisundefin use primari attribut sequenc tupletyp name string type simpleclass classifi isprimari boolean c flattenedfeatur select f f isprimari variabl hold featur persist class featur keep number primari attribut persist class plus total number primari attribut preced attribut persist featur sequenc tupletyp name string class simpleclass class offcet integ nofattr integ c flattenedfeatur iter tupl acc sequenc tupletyp name string class simpleclass class offcet integ nofattr integ sequenc tupl type ocliskindof simpleclass class persist featur found acc append tupl name tupl name class tupl type offcet acc size els acc last offcet acc last nofattr endif nofattr tupl type toppar flattenedfeatur select isprimari size els acc endif foreign key attribut sequenc tupletyp name string type simpleclass classifi persist featur collect tupl tupl class toppar flattenedfeatur select isprimari collect tupl name tupl name name type type flatten rest attribut sequenc tupletyp name string type simpleclass classifi c flattenedfeatur select tupl tupl isprimari tupl type ocliskindof simpleclass class simplerdbm tabl name c name col primari key column union foreign key column union rest pkey primari key column fkey foreign key primari key column distinct simplerdbm column foreach primattr primari attribut name primattr name type primattr type name foreign key distinct simplerdbm fkey foreach persattr persist featur refer persattr class toppar col persist featur iter tupl acc sequenc sequenc simplerdbm column sequenc acc append foreign key column subsequ tupl offcet tupl offcet tupl nofattr foreign key column distinct simplerdbm column foreach attr foreign key attribut name attr name type attr type name rest distinct simplerdbm column foreach attr rest attribut name attr name type attr type name this helper determin attribut given class union attribut defin class attribut inherit parent class attribut sub class overrid inherit attribut name helper context simpleclass class def allattribut sequenc simpleclass attribut self attr union self parent oclisundefin parent class self parent allattribut select attr self attr exist name attr name els parent class sequenc endif flatten this helper determin associ given class union defin inherit associ we assum name clash associ end allow helper context simpleclass class def allassoci sequenc simpleclass associ let defassoc sequenc simpleclass associ simpleclass associ allinst select assoc assoc src self defassoc union self parent oclisundefin self parent allassoci els sequenc endif flatten this helper return sequenc attribut collect special class context class in way flatten inherit hierarchi achiev helper context simpleclass class def attributesofsubclass sequenc simpleclass attribut let attrsinsubclass sequenc simpleclass attribut simpleclass class allinst select c c parent self collect directsubclass directsubclass attributesofsubclass flatten attrsinsubclass union self attr select attr attrsinsubclass exist name attr name flatten helper similar previous one flatten associ helper context simpleclass class def associationsofsubclass sequenc simpleclass associ simpleclass associ allinst select assoc assoc src self union simpleclass class allinst select c c parent self collect subclass subclass associationsofsubclass flatten flatten this helper locat top parent class given context class the helper use attribut associ refer persist class root inherit hierarchi in case root must locat order obtain target tabl deriv root class helper context simpleclass class def toppar simpleclass class self parent oclisundefin self els self parent toppar endif helper perform flatten non simpl attribut associ point non persist class helper context simpleclass class def flattenedfeatur sequenc tupletyp name string type simpleclass classifi isprimari boolean self toppar persist self toppar attributesofsubclass union self toppar associationsofsubclass els self allattribut union self allassoci endif collect f let featur tupletyp name string type simpleclass classifi isprimari boolean f ocliskindof simpleclass attribut tupl name f name type f type isprimari f primari els tupl name f name type f dest isprimari fals endif featur type ocliskindof simpleclass primitivedatatyp featur els featur type toppar persist featur type flattenedfeatur collect f tupl name featur name f name type f type isprimari f isprimari els featur endif endif flatten,0
174,174,P76-Bugzilla2XML.atl,"module Bugzilla2XML; -- Module Template
create OUT : XML from IN : Bugzilla;


-- This helper permits to obtain the string associated
-- to an ErrorType value.
-- CONTEXT: n/a
-- RETURN: String
helper def: getStringErrorValue(ev : Bugzilla!ErrorType) :  String =
	let sev : String = ev.toString()
	in
		sev.substring(4,sev.size());

-- This helper permits to obtain the string associated
-- to a StatusType value for a bug.
-- CONTEXT: n/a
-- RETURN: String
helper def: getStringBugStatusValue(sv : Bugzilla!StatusType) :  String =
	let ssv : String = sv.toString()
	in
		ssv.substring(4,ssv.size());
	
-- This helper permits to obtain the string associated
-- to a ResolutionType value for a bug.
-- CONTEXT: n/a
-- RETURN: String
helper def: getStringResolutionValue(rv : Bugzilla!ResolutionType) :  String =
	let srv : String = rv.toString()
	in
		srv.substring(4,srv.size());

-- This helper permits to obtain the string associated
-- to a PriorityType value for a bug.
-- CONTEXT: n/a
-- RETURN: String
helper def: getStringPriorityValue(pv : Bugzilla!PriorityType) :  String =
	let spv : String = pv.toString()
	in
		spv.substring(4,spv.size());

-- This helper permits to obtain the string associated
-- to a ReportedPlatformType value for a bug.
-- CONTEXT: n/a
-- RETURN: String
helper def: getStringRepPlatformValue(rp : Bugzilla!ReportedPlatformType) :  String =
	let srp : String = rp.toString()
	in
		srp.substring(5,srp.size());

-- This helper permits to obtain the string associated
-- to a SeverityType value for a bug.
-- CONTEXT: n/a
-- RETURN: String
helper def: getStringSeverityValue(sv : Bugzilla!SeverityType) :  String =
	let ssv : String = sv.toString()
	in
		ssv.substring(4,ssv.size());

-- This helper permits to obtain the string associated
-- to an OperatingSystemType value for a bug.
-- CONTEXT: n/a
-- RETURN: String
helper def: getStringOperatingSystemValue(osv : Bugzilla!OperatingSystemType) :  String =
	let sosv : String = osv.toString()
	in
		sosv.substring(5,sosv.size());



-- Rule 'BugzillaRoot2Root'
-- This rule generates the root of the XML model
-- from the ""BugzillaRoot"" element
rule  BugzillaRoot2Root {
	from
		br : Bugzilla!BugzillaRoot
	using {
		exporterOrNot : Sequence(String) =
			let exp : String = br.exporter
			in
				if exp.oclIsUndefined()
				then
					Sequence{}
				else
					Sequence{exp}
				endif;
	}
	to
		xr : XML!Root (
			name <- 'bugzilla',
			children <- Sequence{v,u,m,e,
								br.bugs->collect(e | thisModule.resolveTemp(e, 'xb'))
								}
		),
		v : XML!Attribute (
			name <- 'version',
			value <- br.version
		),
		u : XML!Attribute (
			name <- 'urlbase',
			value <- br.urlbase
		),
		m : XML!Attribute (
			name <- 'maintainer',
			value <- br.maintainer
		),
		e : distinct XML!Attribute foreach(exporterVal in exporterOrNot) (
			name <- 'exporter',
			value <- exporterVal
		)
}


-- Rule 'Bug2Bug'
-- This rule generates the XML bugs' tags 
-- from the ""Bug""s element
rule  Bug2Bug {
	from
		b : Bugzilla!Bug
	using {
		errorOrNot : Sequence(Bugzilla!ErrorType) =
			let err : Bugzilla!ErrorType = b.error
			in
				if err = #et_null
				then
					Sequence{}
				else
					Sequence{err}
				endif;
		resolutionOrNot : Sequence(Bugzilla!ResolutionType) =
			let resol : Bugzilla!ResolutionType = b.resolution
			in
				if resol = #rt_null
				then
					Sequence{}
				else
					Sequence{resol}
				endif;
		targetMilestoneOrNot : Sequence(String) =
			let tm : String = b.target_milestone
			in
				if tm.oclIsUndefined()
				then
					Sequence{}
				else
					Sequence{tm}
				endif;
		qaContactOrNot : Sequence(String) =
			let qac : String = b.qa_contact
			in
				if qac.oclIsUndefined()
				then
					Sequence{}
				else
					Sequence{qac}
				endif;
		statusWhiteboardOrNot : Sequence(String) =
			let sw : String = b.status_whiteboard
			in
				if sw.oclIsUndefined()
				then
					Sequence{}
				else
					Sequence{sw}
				endif;
		bugFileLocOrNot : Sequence(String) =
			let bfl : String = b.bug_file_loc
			in
				if bfl.oclIsUndefined()
				then
					Sequence{}
				else
					Sequence{bfl}
				endif;
		shortDescOrNot : Sequence(String) =
			let sd : String = b.short_desc
			in
				if sd.oclIsUndefined()
				then
					Sequence{}
				else
					Sequence{sd}
				endif;
	}
	to
		xb : XML!Element (
			name <- 'bug',
			children <- Sequence{er,bi,ex,ub,bs,res,p,pri,v,rp,at,dts,c,rep,tarMl,bsvy,cts,qac,sw,os,bfl,sd,
								b.keywords->collect(e | thisModule.resolveTemp(e, 'k')),
								b.dependson->collect(e | thisModule.resolveTemp(e, 'd')),
								b.blocks->collect(e | thisModule.resolveTemp(e, 'b')),
								b.cc->collect(e | thisModule.resolveTemp(e, 'c')),
								Sequence{b.long_desc}->collect(e | thisModule.resolveTemp(e, 'ld'))->first(),
								b.attachment->collect(e | thisModule.resolveTemp(e, 'a'))
								}
		),
		er : distinct XML!Attribute foreach(errorVal in errorOrNot) (
			name <- 'error',
			value <- thisModule.getStringErrorValue(errorVal)
		),
		bi : XML!Element (
			name <- 'bug_id',
			children <- Sequence{biv}
		),
		biv : XML!Text (
			value <- b.bug_id
		),
		ex : XML!Element (
			name <- 'exporter',
			children <- Sequence{exv}
		),
		exv : XML!Text (
			value <- b.exporter
		),
		ub : XML!Element (
			name <- 'urlbase',
			children <- Sequence{ubv}
		),
		ubv : XML!Text (
			value <- b.urlbase
		),
		bs : XML!Element (
			name <- 'bug_status',
			children <- Sequence{bsv}
		),
		bsv : XML!Text (
			value <- thisModule.getStringBugStatusValue(b.bug_status)
		),
		res : distinct XML!Element foreach(resolutionVal in resolutionOrNot) (
			name <- 'resolution',
			children <- Sequence{resv}
		),
		resv : distinct XML!Text foreach(resolutionVal in resolutionOrNot) (
			value <- thisModule.getStringResolutionValue(resolutionVal)
		),
		p : XML!Element (
			name <- 'product',
			children <- Sequence{pv}
		),
		pv : XML!Text (
			value <- b.product
		),
		pri : XML!Element (
			name <- 'priority',
			children <- Sequence{priv}
		),
		priv : XML!Text (
			value <- thisModule.getStringPriorityValue(b.priority)
		),
		v : XML!Element (
			name <- 'version',
			children <- Sequence{vv}
		),
		vv : XML!Text (
			value <- b.version	
		),
		rp : XML!Element (
			name <- 'rep_platform',
			children <- Sequence{rpv}
		),
		rpv : XML!Text (
			value <- thisModule.getStringRepPlatformValue(b.rep_platform)	
		),
		at : XML!Element (
			name <- 'assigned_to',
			children <- Sequence{atv}
		),
		atv : XML!Text (
			value <- b.assigned_to	
		),
		dts : XML!Element (
			name <- 'delta_ts',
			children <- Sequence{dtsv}
		),
		dtsv : XML!Text (
			value <- b.delta_ts	
		),
		c : XML!Element (
			name <- 'component',
			children <- Sequence{cv}
		),
		cv : XML!Text (
			value <- b.component	
		),
		rep : XML!Element (
			name <- 'reporter',
			children <- Sequence{repv}
		),
		repv : XML!Text (
			value <- b.reporter	
		),
		tarMl : distinct XML!Element foreach(targetMilestoneVal in targetMilestoneOrNot) (
			name <- 'target_milestone',
			children <- Sequence{tarMlv}
		),
		tarMlv : distinct XML!Text foreach(targetMilestoneVal in targetMilestoneOrNot) (
			value <- targetMilestoneVal
		),
		bsvy : XML!Element (
			name <- 'bug_severity',
			children <- Sequence{bsvv}
		),
		bsvv : XML!Text (
			value <- thisModule.getStringSeverityValue(b.bug_severity)
		),
		cts : XML!Element (
			name <- 'creation_ts',
			children <- Sequence{ctsv}
		),
		ctsv : XML!Text (
			value <- b.creation_ts	
		),
		qac : distinct XML!Element foreach(qaContactVal in qaContactOrNot) (
			name <- 'qa_contact',
			children <- Sequence{qacv}
		),
		qacv : distinct XML!Text foreach(qaContactVal in qaContactOrNot) (
			value <- qaContactVal
		),
		sw : distinct XML!Element foreach(statusWhiteboardVal in statusWhiteboardOrNot) (
			name <- 'status_whiteboard',
			children <- Sequence{swv}
		),
		swv : distinct XML!Text foreach(statusWhiteboardVal in statusWhiteboardOrNot) (
			value <- statusWhiteboardVal
		),
		os : XML!Element (
			name <- 'op_sys',
			children <- Sequence{osv}  
		),
		osv : XML!Text (
			value <- thisModule.getStringOperatingSystemValue(b.op_sys)	
		),
		bfl : distinct XML!Element foreach(bugFileLocVal in bugFileLocOrNot) (
			name <- 'bug_file_loc',
			children <- Sequence{bflv}  
		),
		bflv : distinct XML!Text foreach(bugFileLocVal in bugFileLocOrNot) (
			value <- bugFileLocVal	
		),
		sd : distinct XML!Element foreach(shortDescVal in shortDescOrNot) (
			name <- 'short_desc',
			children <- Sequence{sdv} 
		),
		sdv : distinct XML!Text foreach(shortDescVal in shortDescOrNot) (
			value <- shortDescVal	
		)
}


-- Rule 'Keywords2Keywords'
-- This rule generates the ""keywords"" XML element
-- from the ""Keywords"" element
rule  Keywords2Keywords {
	from
		bk : Bugzilla!Keywords
	
	to
		k : XML!Element (
			name <- 'keywords',
			children <- Sequence{kv}	
		),
		kv : XML!Text (
			value <- bk.value	
		)
}


-- Rule 'Dependson2Dependson'
-- This rule generates the ""dependson"" XML element
-- from the ""Dependson"" element
rule  Dependson2Dependson {
	from
		bdo : Bugzilla!Dependson
	
	to
		d : XML!Element (
			name <- 'dependson',
			children <- Sequence{dv}	
		),
		dv : XML!Text (
			value <- bdo.value
		)
}


-- Rule 'Blocks2Blocks'
-- This rule generates the ""blocks"" XML element
-- from the ""Blocks"" element
rule  Blocks2Blocks {
	from
		bb : Bugzilla!Blocks
	
	to
		b : XML!Element (
			name <- 'blocks',
			children <- Sequence{bv}
		),
		bv : XML!Text (
			value <- bb.value
		)
}


-- Rule 'Cc2Cc'
-- This rule generates the ""cc"" XML element
-- from the ""Cc"" element
rule  Cc2Cc {
	from
		bc : Bugzilla!Cc
	
	to
		c : XML!Element (
			name <- 'cc',
			children <- Sequence{cv}	
		),
		cv : XML!Text (
			value <- bc.value
		)
}


-- Rule 'LongDesc2LongDesc'
-- This rule generates the ""long_desc"" XML element
-- from the ""LongDesc"" element
rule  LongDesc2LongDesc {
	from
		bld : Bugzilla!LongDesc
	
	to
		ld : XML!Element (
			name <- 'long_desc',
			children <- Sequence{w,bw,t}	
		),
		w : XML!Element (
			name <- 'who',
			children <- Sequence{wv}
		),
		wv : XML!Text (
			value <- bld.who
		),
		bw : XML!Element (
			name <- 'bug_when',
			children <- Sequence{bwv} 
		),
		bwv : XML!Text (
			value <- bld.bug_when
		),
		t : XML!Element (
			name <- 'thetext',
			children <- Sequence{tv} 
		),
		tv : XML!Text (
			value <- bld.thetext
		)
}


-- Rule 'Attachment2Attachment'
-- This rule generates the ""attachment"" XML element
-- from the ""Attachment"" element
rule Attachment2Attachment {
	from
		ba : Bugzilla!Attachment
	
	to
		a : XML!Element (
			name <- 'attachment',
			children <- Sequence{i,de,dc,t,da}	
		),
		i : XML!Element (
			name <- 'id',
			children <- Sequence{iv}
		),
		iv : XML!Text (
			value <- ba.id
		),
		de : XML!Element (
			name <- 'date',
			children <- Sequence{dev} 
		),
		dev : XML!Text (
			value <- ba.date
		),
		dc : XML!Element (
			name <- 'desc',
			children <- Sequence{dcv} 
		),
		dcv : XML!Text (
			value <- ba.desc
		),
		t : XML!Element (
			name <- 'type',
			children <- Sequence{tv} 
		),
		tv : XML!Text (
			value <- ba.type
		),
		da : XML!Element (
			name <- 'data',
			children <- Sequence{dav}
		),
		dav : XML!Text (
			value <- ba.data
		)
}",modul bugzilla xml modul templat creat out xml in bugzilla this helper permit obtain string associ errortyp valu context n return string helper def getstringerrorvalu ev bugzilla errortyp string let sev string ev tostr sev substr sev size this helper permit obtain string associ statustyp valu bug context n return string helper def getstringbugstatusvalu sv bugzilla statustyp string let ssv string sv tostr ssv substr ssv size this helper permit obtain string associ resolutiontyp valu bug context n return string helper def getstringresolutionvalu rv bugzilla resolutiontyp string let srv string rv tostr srv substr srv size this helper permit obtain string associ prioritytyp valu bug context n return string helper def getstringpriorityvalu pv bugzilla prioritytyp string let spv string pv tostr spv substr spv size this helper permit obtain string associ reportedplatformtyp valu bug context n return string helper def getstringrepplatformvalu rp bugzilla reportedplatformtyp string let srp string rp tostr srp substr srp size this helper permit obtain string associ severitytyp valu bug context n return string helper def getstringseverityvalu sv bugzilla severitytyp string let ssv string sv tostr ssv substr ssv size this helper permit obtain string associ operatingsystemtyp valu bug context n return string helper def getstringoperatingsystemvalu osv bugzilla operatingsystemtyp string let sosv string osv tostr sosv substr sosv size rule bugzillaroot root this rule generat root xml model bugzillaroot element rule bugzillaroot root br bugzilla bugzillaroot use exporterornot sequenc string let exp string br export exp oclisundefin sequenc els sequenc exp endif xr xml root name bugzilla children sequenc v u e br bug collect e thismodul resolvetemp e xb v xml attribut name version valu br version u xml attribut name urlbas valu br urlbas xml attribut name maintain valu br maintain e distinct xml attribut foreach exporterv exporterornot name export valu exporterv rule bug bug this rule generat xml bug tag bug element rule bug bug b bugzilla bug use errorornot sequenc bugzilla errortyp let err bugzilla errortyp b error err et null sequenc els sequenc err endif resolutionornot sequenc bugzilla resolutiontyp let resol bugzilla resolutiontyp b resolut resol rt null sequenc els sequenc resol endif targetmilestoneornot sequenc string let tm string b target mileston tm oclisundefin sequenc els sequenc tm endif qacontactornot sequenc string let qac string b qa contact qac oclisundefin sequenc els sequenc qac endif statuswhiteboardornot sequenc string let sw string b status whiteboard sw oclisundefin sequenc els sequenc sw endif bugfilelocornot sequenc string let bfl string b bug file loc bfl oclisundefin sequenc els sequenc bfl endif shortdescornot sequenc string let sd string b short desc sd oclisundefin sequenc els sequenc sd endif xb xml element name bug children sequenc er bi ex ub bs res p pri v rp dts c rep tarml bsvi cts qac sw os bfl sd b keyword collect e thismodul resolvetemp e k b dependson collect e thismodul resolvetemp e b block collect e thismodul resolvetemp e b b cc collect e thismodul resolvetemp e c sequenc b long desc collect e thismodul resolvetemp e ld first b attach collect e thismodul resolvetemp e er distinct xml attribut foreach errorv errorornot name error valu thismodul getstringerrorvalu errorv bi xml element name bug id children sequenc biv biv xml text valu b bug id ex xml element name export children sequenc exv exv xml text valu b export ub xml element name urlbas children sequenc ubv ubv xml text valu b urlbas bs xml element name bug status children sequenc bsv bsv xml text valu thismodul getstringbugstatusvalu b bug status res distinct xml element foreach resolutionv resolutionornot name resolut children sequenc resv resv distinct xml text foreach resolutionv resolutionornot valu thismodul getstringresolutionvalu resolutionv p xml element name product children sequenc pv pv xml text valu b product pri xml element name prioriti children sequenc priv priv xml text valu thismodul getstringpriorityvalu b prioriti v xml element name version children sequenc vv vv xml text valu b version rp xml element name rep platform children sequenc rpv rpv xml text valu thismodul getstringrepplatformvalu b rep platform xml element name assign children sequenc atv atv xml text valu b assign dts xml element name delta ts children sequenc dtsv dtsv xml text valu b delta ts c xml element name compon children sequenc cv cv xml text valu b compon rep xml element name report children sequenc repv repv xml text valu b report tarml distinct xml element foreach targetmilestonev targetmilestoneornot name target mileston children sequenc tarmlv tarmlv distinct xml text foreach targetmilestonev targetmilestoneornot valu targetmilestonev bsvi xml element name bug sever children sequenc bsvv bsvv xml text valu thismodul getstringseverityvalu b bug sever cts xml element name creation ts children sequenc ctsv ctsv xml text valu b creation ts qac distinct xml element foreach qacontactv qacontactornot name qa contact children sequenc qacv qacv distinct xml text foreach qacontactv qacontactornot valu qacontactv sw distinct xml element foreach statuswhiteboardv statuswhiteboardornot name status whiteboard children sequenc swv swv distinct xml text foreach statuswhiteboardv statuswhiteboardornot valu statuswhiteboardv os xml element name op sys children sequenc osv osv xml text valu thismodul getstringoperatingsystemvalu b op sys bfl distinct xml element foreach bugfilelocv bugfilelocornot name bug file loc children sequenc bflv bflv distinct xml text foreach bugfilelocv bugfilelocornot valu bugfilelocv sd distinct xml element foreach shortdescv shortdescornot name short desc children sequenc sdv sdv distinct xml text foreach shortdescv shortdescornot valu shortdescv rule keyword keyword this rule generat keyword xml element keyword element rule keyword keyword bk bugzilla keyword k xml element name keyword children sequenc kv kv xml text valu bk valu rule dependson dependson this rule generat dependson xml element dependson element rule dependson dependson bdo bugzilla dependson xml element name dependson children sequenc dv dv xml text valu bdo valu rule block block this rule generat block xml element block element rule block block bb bugzilla block b xml element name block children sequenc bv bv xml text valu bb valu rule cc cc this rule generat cc xml element cc element rule cc cc bc bugzilla cc c xml element name cc children sequenc cv cv xml text valu bc valu rule longdesc longdesc this rule generat long desc xml element longdesc element rule longdesc longdesc bld bugzilla longdesc ld xml element name long desc children sequenc w bw w xml element name children sequenc wv wv xml text valu bld bw xml element name bug children sequenc bwv bwv xml text valu bld bug xml element name thetext children sequenc tv tv xml text valu bld thetext rule attach attach this rule generat attach xml element attach element rule attach attach ba bugzilla attach xml element name attach children sequenc de dc da xml element name id children sequenc iv iv xml text valu ba id de xml element name date children sequenc dev dev xml text valu ba date dc xml element name desc children sequenc dcv dcv xml text valu ba desc xml element name type children sequenc tv tv xml text valu ba type da xml element name data children sequenc dav dav xml text valu ba data,11
175,175,P76-SoftwareQualityControl2Bugzilla.atl,"module SoftwareQualityControl2Bugzilla; -- Module Template
create OUT : Bugzilla from IN : SoftwareQualityControl;


-- This helper permits to convert the status value of a bug 
-- in a right Bugzilla status type value. 
-- CONTEXT: n/a
-- RETURN: Bugzilla!StatusType
helper def: convertStatus(bs : SoftwareQualityControl!BugStatusType) :  Bugzilla!StatusType =
	if bs = #bst_open
	then
		#st_new
	else
		if bs = #bst_closed
		then
			#st_closed
		else
			if bs = #bst_skipped
			then
				#st_unconfirmed
			else
				#st_new
			endif
		endif
	endif;



-- Rule 'BugTracking2BugzillaRoot'
-- This rule generates the root of the Bugzilla output model
-- if a BugTracking element exists in the input model
rule  BugTracking2BugzillaRoot {
	from
		bt : SoftwareQualityControl!BugTracking
	
	to
		br : Bugzilla!BugzillaRoot (
			version <- '',
			urlbase <- '',
			maintainer <- '',
			--exporter <- '',
			bugs <- bt.bugs->collect(e | thisModule.resolveTemp(e, 'bb'))
		)
}


-- Rule 'Bug2Bug'
-- This rule generates a bug in Bugzilla for each
-- bug reported in the BugTracking element.
rule  Bug2Bug {
	from
		bbt : SoftwareQualityControl!Bug
	
	to
		bb : Bugzilla!Bug (
			--error <- Bugzilla!ErrorType,
			bug_id <- bbt.number.toString(),
			exporter <- '',
			urlbase <- '',
			bug_status <- thisModule.convertStatus(bbt.status),
			--resolution <- Bugzilla!ResolutionType,
			product <- '',
			priority <- #pt_P1,
			version <- bbt.componentVersion,
			rep_platform <- #rpt_all,
			assigned_to <- let v : String = bbt.responsible in
							if v.oclIsUndefined()
							then	bbt.b_bugTracking.ct_control.responsible
							else	v
							endif,
			delta_ts <- let v : String = bbt.closeDate in
							if v.oclIsUndefined()
							then	''
							else	v
							endif,
			component<- bbt.b_bugTracking.ct_control.component,
			reporter <- bbt.originator,
			target_milestone <- String,
			bug_severity <- #st_normal,
			creation_ts <- bbt.openDate,
			qa_contact <- bbt.b_bugTracking.ct_control.responsible,
			--status_whiteboard <- '',
			op_sys <- #ost_all, -- #""ost_Windows XP""
			bug_file_loc <- String,
			short_desc <- bbt.description,
			keywords <- Sequence{},
			dependson <- Sequence{},
			blocks <- Sequence{},
			cc <- Sequence{},
			long_desc <- commentsAndAnswers,
			attachment <- Sequence{} 
		),
		commentsAndAnswers : Bugzilla!LongDesc (
			who <- bbt.originator,
			bug_when <- bbt.openDate,
			thetext <- let v : String = bbt.commentsAnswers in
						if v.oclIsUndefined()
						then	''
						else	v
						endif
		)
}





",modul softwarequalitycontrol bugzilla modul templat creat out bugzilla in softwarequalitycontrol this helper permit convert status valu bug right bugzilla status type valu context n return bugzilla statustyp helper def convertstatus bs softwarequalitycontrol bugstatustyp bugzilla statustyp bs bst open st new els bs bst close st close els bs bst skip st unconfirm els st new endif endif endif rule bugtrack bugzillaroot this rule generat root bugzilla output model bugtrack element exist input model rule bugtrack bugzillaroot bt softwarequalitycontrol bugtrack br bugzilla bugzillaroot version urlbas maintain export bug bt bug collect e thismodul resolvetemp e bb rule bug bug this rule generat bug bugzilla bug report bugtrack element rule bug bug bbt softwarequalitycontrol bug bb bugzilla bug error bugzilla errortyp bug id bbt number tostr export urlbas bug status thismodul convertstatus bbt status resolut bugzilla resolutiontyp product prioriti pt p version bbt componentvers rep platform rpt assign let v string bbt respons v oclisundefin bbt b bugtrack ct control respons els v endif delta ts let v string bbt closed v oclisundefin els v endif compon bbt b bugtrack ct control compon report bbt origin target mileston string bug sever st normal creation ts bbt opend qa contact bbt b bugtrack ct control respons status whiteboard op sys ost ost window xp bug file loc string short desc bbt descript keyword sequenc dependson sequenc block sequenc cc sequenc long desc commentsandansw attach sequenc commentsandansw bugzilla longdesc bbt origin bug bbt opend thetext let v string bbt commentsansw v oclisundefin els v endif,11
176,176,P76-XML2BugzillaText.atl,"query XML2Text = XML!Root.allInstances()
		->asSequence()
		->first().BugzillaFile().writeTo('C:\\ ... the path has to be completed ... \\SoftwareQualityControl2BugzillaFile\\BugzillaXMLfileExample.xml');

helper context XML!Root def: BugzillaFile() : String =
	'<?xml version=""1.0""?>'+'\n'+ self.toString2('');

helper context XML!Element def: toString2(indent : String) : String =
	let na : Sequence(XML!Node) =
		self.children->select(e | not e.oclIsKindOf(XML!Attribute)) in
	let a : Sequence(XML!Node) =
		self.children->select(e | e.oclIsKindOf(XML!Attribute)) in
	indent + '<' + self.name + 
	a->iterate(e; acc : String = '' |
		acc + ' ' + e.toString2()
	) +
	if na->size() > 0 then
		'>'
		+ na->iterate(e; acc : String = '' |
			acc + 
			if e.oclIsKindOf(XML!Text) then
				''
			else
				'\r\n'
			endif
			+ e.toString2(indent + '  ')
		) +
		if na->first().oclIsKindOf(XML!Text) then
			'</' + self.name + '>'
			else
				'\r\n' + indent + '</' + self.name + '>'
		endif
	else
		'/>'
	endif;

	
helper context XML!Attribute def: toString2() : String =
	self.name + '=\""' + self.value + '\""';


helper context XML!Text def: toString2() : String =
	self.value;
",queri xml text xml root allinst assequ first bugzillafil writeto c path complet softwarequalitycontrol bugzillafil bugzillaxmlfileexampl xml helper context xml root def bugzillafil string xml version n self tostr helper context xml element def tostr indent string string let na sequenc xml node self children select e e ocliskindof xml attribut let sequenc xml node self children select e e ocliskindof xml attribut indent self name iter e acc string acc e tostr na size na iter e acc string acc e ocliskindof xml text els r n endif e tostr indent na first ocliskindof xml text self name els r n indent self name endif els endif helper context xml attribut def tostr string self name self valu helper context xml text def tostr string self valu,5
177,177,P77-Mantis2XML.atl,"module Mantis2XML; -- Module Template
create OUT : XML from IN : Mantis;


-- This helper permits to obtain the string associated
-- to an RelationshipType value.
-- CONTEXT: n/a
-- RETURN: String
helper def: getRelationshipTypeStringValue(rt : Mantis!RelationshipType) : String =
	let rv : String = rt.toString()
	in
		rv.substring(4,rv.size());



-- Rule 'MantisRoot2Root'
-- This rule generates the root of the XML model
-- from the ""MantisRoot"" element
rule  MantisRoot2Root {
	from
		mr : Mantis!MantisRoot
	
	to
		xr : XML!Root (
			name <- 'mantis',
			children <- Sequence{att1,att2,att3,
								mr.issues->collect(e | thisModule.resolveTemp(e, 'xi'))
								}
		),
		att1 : XML!Attribute (
			name <- 'xmlns',
			value <- 'http://www.mantisbt.org'
		),
		att2 : XML!Attribute (
			name <- 'xmlns:xsi',
			value <- 'http://www.w3.org/2001/XMLSchema-instance'
		),
		att3 : XML!Attribute (
			name <- 'xsi:schemaLocation',
			value <- 'http://www.mantisbt.org mantis.xsd'
		)
}


-- Rule 'Issue2Issue'
-- This rule generates the XML issue's tags
-- from the ""Issue"" element
rule  Issue2Issue {
	from
		mi : Mantis!Issue
	using {
		privateOrNot : Sequence(String) =
			let priv : Boolean = mi.private
			in
				if priv.oclIsUndefined()
				then
					Sequence{}
				else
					Sequence{priv.toString()}
				endif;
		versionOrNot : Sequence(String) =
			let vv : String = mi.version
			in
				if vv.oclIsUndefined()
				then
					Sequence{}
				else
					Sequence{vv}
				endif;
		buildOrNot : Sequence(String) =
			let bv : String = mi.build
			in
				if bv.oclIsUndefined()
				then
					Sequence{}
				else
					Sequence{bv}
				endif;
		platformOrNot : Sequence(String) =
			let pv : String = mi.platform
			in
				if pv.oclIsUndefined()
				then
					Sequence{}
				else
					Sequence{pv}
				endif;
		osOrNot : Sequence(String) =
			let ov : String = mi.os
			in
				if ov.oclIsUndefined()
				then
					Sequence{}
				else
					Sequence{ov}
				endif;
		osVersionOrNot : Sequence(String) =
			let ovv : String = mi.osVersion
			in
				if ovv.oclIsUndefined()
				then
					Sequence{}
				else
					Sequence{ovv}
				endif;
		stepsToReproduceOrNot : Sequence(String) =
			let strv : String = mi.stepsToReproduce
			in
				if strv.oclIsUndefined()
				then
					Sequence{}
				else
					Sequence{strv}
				endif;
		additionalInfoOrNot : Sequence(String) =
			let aiv : String = mi.additionalInfo
			in
				if aiv.oclIsUndefined()
				then
					Sequence{}
				else
					Sequence{aiv}
				endif;
		fixedInVersionOrNot : Sequence(String) =
			let fivv : String = mi.fixedInVersion
			in
				if fivv.oclIsUndefined()
				then
					Sequence{}
				else
					Sequence{fivv}
				endif;
		assignedToOrNot : Sequence(Mantis!Person) =
			let atv : Mantis!Person = mi.assignedTo
			in
				if atv.oclIsUndefined()
				then
					Sequence{}
				else
					Sequence{atv}
				endif;	
		projectionOrNot : Sequence(Mantis!ValueWithId) =
			let projv : Mantis!ValueWithId = mi.projection
			in
				if projv.oclIsUndefined()
				then
					Sequence{}
				else
					Sequence{projv}
				endif;
		etaOrNot : Sequence(Mantis!ValueWithId) =
			let ev : Mantis!ValueWithId = mi.eta
			in
				if ev.oclIsUndefined()
				then
					Sequence{}
				else
					Sequence{ev}
				endif;
		resolutionOrNot : Sequence(Mantis!ValueWithId) =
			let resv : Mantis!ValueWithId = mi.resolution
			in
				if resv.oclIsUndefined()
				then
					Sequence{}
				else
					Sequence{resv}
				endif;
	}
	to
		xi : XML!Element (
			name <- 'issue',
			children <- Sequence{	idAtt,privAtt,proj,cat,prior,sev,stat,rep,sum,desc,
									vers,buil,plat,o,overs,repro,sTr,addInfo,dateSub,
									assi,proje,e,res,fiv,
									mi.attachments->collect(e | thisModule.resolveTemp(e, 'xa')),
									mi.relationships->collect(e | thisModule.resolveTemp(e, 'xrs')),
									mi.notes->collect(e | thisModule.resolveTemp(e, 'xn')),
									lastUp }
		),
		idAtt : XML!Attribute (
			name <- 'id',
			value <- mi.id.toString()
		),
		privAtt : distinct XML!Attribute foreach(privateVal in privateOrNot)(
			name <- 'private',
			value <- privateVal
		),
		proj : XML!Element (
			name <- 'project',
			children <- Sequence{projIdAtt,projVal}
		),
		projIdAtt : XML!Attribute (
			name <- 'id',
			value <- mi.project.id.toString()
		),
		projVal : XML!Text (
			value <- mi.project.value
		),
		cat : XML!Element (
			name <- 'category',
			children <- Sequence{catVal}
		),
		catVal : XML!Text (
			value <- mi.category
		),
		prior : XML!Element (
			name <- 'priority',
			children <- Sequence{priorIdAtt,priorVal}
		),
		priorIdAtt : XML!Attribute (
			name <- 'id',
			value <- mi.priority.id.toString()
		),
		priorVal : XML!Text (
			value <- mi.priority.value
		),
		sev : XML!Element (
			name <- 'severity',
			children <- Sequence{sevIdAtt,sevVal}
		),
		sevIdAtt : XML!Attribute (
			name <- 'id',
			value <- mi.severity.id.toString()
		),
		sevVal : XML!Text (
			value <- mi.severity.value
		),
		stat : XML!Element (
			name <- 'status',
			children <- Sequence{statIdAtt,statVal}
		),
		statIdAtt : XML!Attribute (
			name <- 'id',
			value <- mi.status.id.toString()
		),
		statVal : XML!Text (
			value <- mi.status.value
		),
		rep : XML!Element (
			name <- 'reporter',
			children <- Sequence{repIdAtt,repLogAtt,repVal}
		),
		repIdAtt : XML!Attribute (
			name <- 'id',
			value <- mi.reporter.id.toString()
		),
		repLogAtt : XML!Attribute (
			name <- 'login',
			value <- mi.reporter.login
		),
		repVal : XML!Text (
			value <- mi.reporter.value
		),
		sum : XML!Element (
			name <- 'summary',
			children <- Sequence{sumVal}
		),
		sumVal : XML!Text (
			value <- mi.summary
		),
		desc : XML!Element (
			name <- 'description',
			children <- Sequence{descVal}
		),
		descVal : XML!Text (
			value <- mi.description
		),
		vers : distinct XML!Element foreach(versionVal in versionOrNot)(
			name <- 'version',
			children <- Sequence{versVal}
		),
		versVal : distinct XML!Text foreach(versionVal in versionOrNot)(
			value <- versionVal
		),
		buil : distinct XML!Element foreach(buildVal in buildOrNot)(
			name <- 'build',
			children <- Sequence{builVal}
		),
		builVal : distinct XML!Text foreach(buildVal in buildOrNot)(
			value <- buildVal
		),
		plat : distinct XML!Element foreach(platformVal in platformOrNot)(
			name <- 'platform',
			children <- Sequence{platVal}
		),
		platVal : distinct XML!Text foreach(platformVal in platformOrNot)(
			value <- platformVal
		),
		o : distinct XML!Element foreach(osVal in osOrNot)(
			name <- 'os',
			children <- Sequence{oVal}
		),
		oVal : distinct XML!Text foreach(osVal in osOrNot)(
			value <- osVal
		),
		overs : distinct XML!Element foreach(osVersionVal in osVersionOrNot)(
			name <- 'osVersion',
			children <- Sequence{oversVal}
		),
		oversVal : distinct XML!Text foreach(osVersionVal in osVersionOrNot)(
			value <- osVersionVal
		),
		repro : XML!Element (
			name <- 'reproducibility',
			children <- Sequence{reproIdAtt,reproVal}
		),
		reproIdAtt : XML!Attribute (
			name <- 'id',
			value <- mi.reproducibility.id.toString()
		),
		reproVal : XML!Text (
			value <- mi.reproducibility.value
		),
		sTr : distinct XML!Element foreach(stepsToReproduceVal in stepsToReproduceOrNot)(
			name <- 'stepsToReproduce',
			children <- Sequence{sTrVal}
		),
		sTrVal : distinct XML!Text foreach(stepsToReproduceVal in stepsToReproduceOrNot)(
			value <- stepsToReproduceVal
		),
		addInfo : distinct XML!Element foreach(additionalInfoVal in additionalInfoOrNot)(
			name <- 'additionalInfo',
			children <- Sequence{addInfoVal}
		),
		addInfoVal : distinct XML!Text foreach(additionalInfoVal in additionalInfoOrNot)(
			value <- additionalInfoVal
		),
		dateSub : XML!Element (
			name <- 'dateSubmitted',
			children <- Sequence{dateSubVal}
		),
		dateSubVal : XML!Text (
			value <- mi.dateSubmitted.toString()
		),
		assi : distinct XML!Element foreach(assignedToVal in assignedToOrNot) (
			name <- 'assignedTo',
			children <- Sequence{assiIdAtt,assiLogAtt,assiVal}
		),
		assiIdAtt : distinct XML!Attribute foreach(assignedToVal in assignedToOrNot)(
			name <- 'id',
			value <- assignedToVal.id.toString()
		),
		assiLogAtt : distinct XML!Attribute foreach(assignedToVal in assignedToOrNot) (
			parent <- assi,
			name <- 'login',
			value <- assignedToVal.login
		),
		assiVal : distinct XML!Text foreach(assignedToVal in assignedToOrNot) (
			parent <- assi,
			value <- assignedToVal.value
		),
		proje : distinct XML!Element foreach(projectionVal in projectionOrNot) (
			name <- 'projection',
			children <- Sequence{projeIdAtt,projeVal}
		),
		projeIdAtt : distinct XML!Attribute foreach(projectionVal in projectionOrNot) (
			name <- 'id',
			value <- projectionVal.id.toString()
		),
		projeVal : distinct XML!Text foreach(projectionVal in projectionOrNot) (
			parent <- proje,
			value <- projectionVal.value
		),
		e : distinct XML!Element foreach(etaVal in etaOrNot) (
			name <- 'eta',
			children <- Sequence{eIdAtt,eVal}
		),
		eIdAtt : distinct XML!Attribute foreach(etaVal in etaOrNot) (
			name <- 'id',
			value <- etaVal.id.toString()
		),
		eVal : distinct XML!Text foreach(etaVal in etaOrNot) (
			parent <- e,
			value <- etaVal.value
		),
		res : distinct XML!Element foreach(resolutionVal in resolutionOrNot) (
			name <- 'resolution',
			children <- Sequence{resIdAtt,resVal}
		),
		resIdAtt : distinct XML!Attribute foreach(resolutionVal in resolutionOrNot) (
			name <- 'id',
			value <- resolutionVal.id.toString()
		),
		resVal : distinct XML!Text foreach(resolutionVal in resolutionOrNot) (
			parent <- res,
			value <- resolutionVal.value
		),
		fiv : distinct XML!Element foreach(fixedInVersionVal in fixedInVersionOrNot)(
			name <- 'fixedInVersion',
			children <- Sequence{fivVal}
		),
		fivVal : distinct XML!Text foreach(fixedInVersionVal in fixedInVersionOrNot)(
			value <- fixedInVersionVal
		),
		lastUp : XML!Element (
			name <- 'lastUpdate',
			children <- Sequence{lastUpVal}
		),
		lastUpVal : XML!Text (
			value <- mi.lastUpdate.toString()
		) 
} 


-- Rule 'Attachment2Attachment'
-- This rule generates the attachment's XML tags
-- from the ""Attachment"" element
rule  Attachment2Attachment {
	from
		ma : Mantis!Attachment
	
	to
		xa : XML!Element (
			name <- 'attachment',
			children <- Sequence{fileN,si,cType,ts,dlU}
		),
		fileN : XML!Element (
			name <- 'filename',
			children <- Sequence{fileNVal}
		),
		fileNVal : XML!Text (
			value <- ma.filename
		),
		si : XML!Element (
			name <- 'size',
			children <- Sequence{siVal}
		),
		siVal : XML!Text (
			value <- ma.size.toString()
		),
		cType : XML!Element (
			name <- 'contentType',
			children <- Sequence{cTypeVal}
		),
		cTypeVal : XML!Text (
			value <- ma.contentType
		),
		ts : XML!Element (
			name <- 'timestamp',
			children <- Sequence{tsVal}
		),
		tsVal : XML!Text (
			value <- ma.timestamp
		),
		dlU : XML!Element (
			name <- 'downloadUrl',
			children <- Sequence{dlUVal}
		),
		dlUVal : XML!Text (
			value <- ma.downloadUrl
		)
}


-- Rule 'Relationship2Relationship'
-- This rule generates the relationship's XML tags
-- from the ""Relationship"" element
rule  Relationship2Relationship {
	from
		mr : Mantis!Relationship
	
	to
		xrs : XML!Element (
			name <- 'relationship',
			children <- Sequence{typ,rid}
		),
		typ : XML!Element (
			name <- 'type',
			children <- Sequence{typVal}
		),
		typVal : XML!Text (
			value <- thisModule.getRelationshipTypeStringValue(mr.type)
		),
		rid : XML!Element (
			name <- 'id',
			children <- Sequence{ridVal}
		),
		ridVal : XML!Text (
			value <- mr.id
		)
}


-- Rule 'Note2Note'
-- This rule generates the note's XML tags
-- from the ""Note"" element
rule  Note2Note {
	from
		mn : Mantis!Note
	using {
		privateOrNot : Sequence(String) =
			let priv : Boolean = mn.private
			in
				if priv.oclIsUndefined()
				then
					Sequence{}
				else
					Sequence{priv.toString()}
				endif;
	}
	to
		xn : XML!Element (
			name <- 'note',
			children <- Sequence{privAtt,auth,ts,tex}
		),
		privAtt : distinct XML!Attribute foreach(privateVal in privateOrNot)(
			name <- 'private',
			value <- privateVal
		),
		auth : XML!Element (
			name <- 'author',
			children <- Sequence{authId,authLog,authVal}
		),
		authId : XML!Attribute (
			name <- 'id',
			value <- mn.author.id.toString()
		),
		authLog : XML!Attribute (
			name <- 'login',
			value <- mn.author.login
		),
		authVal : XML!Text (
			value <- mn.author.value
		),
		ts : XML!Element (
			name <- 'timestamp',
			children <- Sequence{tsVal}
		),
		tsVal : XML!Text (
			value <- mn.timestamp.toString()
		),
		tex : XML!Element (
			name <- 'text',
			children <- Sequence{texVal}
		),
		texVal : XML!Text (
			value <- mn.text
		)	
}",modul manti xml modul templat creat out xml in manti this helper permit obtain string associ relationshiptyp valu context n return string helper def getrelationshiptypestringvalu rt manti relationshiptyp string let rv string rt tostr rv substr rv size rule mantisroot root this rule generat root xml model mantisroot element rule mantisroot root mr manti mantisroot xr xml root name manti children sequenc att att att mr issu collect e thismodul resolvetemp e xi att xml attribut name xmlns valu http www mantisbt org att xml attribut name xmlns xsi valu http www w org xmlschema instanc att xml attribut name xsi schemaloc valu http www mantisbt org manti xsd rule issu issu this rule generat xml issu tag issu element rule issu issu mi manti issu use privateornot sequenc string let priv boolean mi privat priv oclisundefin sequenc els sequenc priv tostr endif versionornot sequenc string let vv string mi version vv oclisundefin sequenc els sequenc vv endif buildornot sequenc string let bv string mi build bv oclisundefin sequenc els sequenc bv endif platformornot sequenc string let pv string mi platform pv oclisundefin sequenc els sequenc pv endif osornot sequenc string let ov string mi os ov oclisundefin sequenc els sequenc ov endif osversionornot sequenc string let ovv string mi osvers ovv oclisundefin sequenc els sequenc ovv endif stepstoreproduceornot sequenc string let strv string mi stepstoreproduc strv oclisundefin sequenc els sequenc strv endif additionalinfoornot sequenc string let aiv string mi additionalinfo aiv oclisundefin sequenc els sequenc aiv endif fixedinversionornot sequenc string let fivv string mi fixedinvers fivv oclisundefin sequenc els sequenc fivv endif assignedtoornot sequenc manti person let atv manti person mi assignedto atv oclisundefin sequenc els sequenc atv endif projectionornot sequenc manti valuewithid let projv manti valuewithid mi project projv oclisundefin sequenc els sequenc projv endif etaornot sequenc manti valuewithid let ev manti valuewithid mi eta ev oclisundefin sequenc els sequenc ev endif resolutionornot sequenc manti valuewithid let resv manti valuewithid mi resolut resv oclisundefin sequenc els sequenc resv endif xi xml element name issu children sequenc idatt privatt proj cat prior sev stat rep sum desc ver buil plat over repro str addinfo datesub assi proje e res fiv mi attach collect e thismodul resolvetemp e xa mi relationship collect e thismodul resolvetemp e xrs mi note collect e thismodul resolvetemp e xn lastup idatt xml attribut name id valu mi id tostr privatt distinct xml attribut foreach privatev privateornot name privat valu privatev proj xml element name project children sequenc projidatt projval projidatt xml attribut name id valu mi project id tostr projval xml text valu mi project valu cat xml element name categori children sequenc catval catval xml text valu mi categori prior xml element name prioriti children sequenc prioridatt priorval prioridatt xml attribut name id valu mi prioriti id tostr priorval xml text valu mi prioriti valu sev xml element name sever children sequenc sevidatt sevval sevidatt xml attribut name id valu mi sever id tostr sevval xml text valu mi sever valu stat xml element name status children sequenc statidatt statval statidatt xml attribut name id valu mi status id tostr statval xml text valu mi status valu rep xml element name report children sequenc repidatt replogatt repval repidatt xml attribut name id valu mi report id tostr replogatt xml attribut name login valu mi report login repval xml text valu mi report valu sum xml element name summari children sequenc sumval sumval xml text valu mi summari desc xml element name descript children sequenc descval descval xml text valu mi descript ver distinct xml element foreach versionv versionornot name version children sequenc versval versval distinct xml text foreach versionv versionornot valu versionv buil distinct xml element foreach buildval buildornot name build children sequenc builval builval distinct xml text foreach buildval buildornot valu buildval plat distinct xml element foreach platformv platformornot name platform children sequenc platval platval distinct xml text foreach platformv platformornot valu platformv distinct xml element foreach osval osornot name os children sequenc oval oval distinct xml text foreach osval osornot valu osval over distinct xml element foreach osversionv osversionornot name osvers children sequenc oversv oversv distinct xml text foreach osversionv osversionornot valu osversionv repro xml element name reproduc children sequenc reproidatt reprov reproidatt xml attribut name id valu mi reproduc id tostr reprov xml text valu mi reproduc valu str distinct xml element foreach stepstoreproducev stepstoreproduceornot name stepstoreproduc children sequenc strval strval distinct xml text foreach stepstoreproducev stepstoreproduceornot valu stepstoreproducev addinfo distinct xml element foreach additionalinfov additionalinfoornot name additionalinfo children sequenc addinfov addinfov distinct xml text foreach additionalinfov additionalinfoornot valu additionalinfov datesub xml element name datesubmit children sequenc datesubv datesubv xml text valu mi datesubmit tostr assi distinct xml element foreach assignedtov assignedtoornot name assignedto children sequenc assiidatt assilogatt assiv assiidatt distinct xml attribut foreach assignedtov assignedtoornot name id valu assignedtov id tostr assilogatt distinct xml attribut foreach assignedtov assignedtoornot parent assi name login valu assignedtov login assiv distinct xml text foreach assignedtov assignedtoornot parent assi valu assignedtov valu proje distinct xml element foreach projectionv projectionornot name project children sequenc projeidatt projev projeidatt distinct xml attribut foreach projectionv projectionornot name id valu projectionv id tostr projev distinct xml text foreach projectionv projectionornot parent proje valu projectionv valu e distinct xml element foreach etav etaornot name eta children sequenc eidatt eval eidatt distinct xml attribut foreach etav etaornot name id valu etav id tostr eval distinct xml text foreach etav etaornot parent e valu etav valu res distinct xml element foreach resolutionv resolutionornot name resolut children sequenc residatt resval residatt distinct xml attribut foreach resolutionv resolutionornot name id valu resolutionv id tostr resval distinct xml text foreach resolutionv resolutionornot parent res valu resolutionv valu fiv distinct xml element foreach fixedinversionv fixedinversionornot name fixedinvers children sequenc fivval fivval distinct xml text foreach fixedinversionv fixedinversionornot valu fixedinversionv lastup xml element name lastupd children sequenc lastupv lastupv xml text valu mi lastupd tostr rule attach attach this rule generat attach xml tag attach element rule attach attach manti attach xa xml element name attach children sequenc filen si ctype ts dlu filen xml element name filenam children sequenc filenv filenv xml text valu filenam si xml element name size children sequenc sival sival xml text valu size tostr ctype xml element name contenttyp children sequenc ctypev ctypev xml text valu contenttyp ts xml element name timestamp children sequenc tsval tsval xml text valu timestamp dlu xml element name downloadurl children sequenc dluval dluval xml text valu downloadurl rule relationship relationship this rule generat relationship xml tag relationship element rule relationship relationship mr manti relationship xrs xml element name relationship children sequenc typ rid typ xml element name type children sequenc typval typval xml text valu thismodul getrelationshiptypestringvalu mr type rid xml element name id children sequenc ridval ridval xml text valu mr id rule note note this rule generat note xml tag note element rule note note mn manti note use privateornot sequenc string let priv boolean mn privat priv oclisundefin sequenc els sequenc priv tostr endif xn xml element name note children sequenc privatt auth ts tex privatt distinct xml attribut foreach privatev privateornot name privat valu privatev auth xml element name author children sequenc authid authlog authval authid xml attribut name id valu mn author id tostr authlog xml attribut name login valu mn author login authval xml text valu mn author valu ts xml element name timestamp children sequenc tsval tsval xml text valu mn timestamp tostr tex xml element name text children sequenc texval texval xml text valu mn text,11
178,178,P77-SoftwareQualityControl2Mantis.atl,"module SoftwareQualityControl2Mantis; -- Module Template
create OUT : Mantis from IN : SoftwareQualityControl;


-- This helper permits to convert the status value of a bug in string 
-- CONTEXT: n/a
-- RETURN: String
helper def: convertStatus(bs : SoftwareQualityControl!BugStatusType) :  String =
	let sv : String = bs.toString()
	in
		sv.substring(5,sv.size()); 

-- This helper permits to get the name of the person who is responsible for the bug.
-- If the ""responsible"" field is not valued, the responsible of this bug is the
-- control responsible.
-- CONTEXT: n/a
-- RETURN: String
helper context SoftwareQualityControl!Bug def: getResponsibleName() :  String =
	let rv : String = self.responsible
	in
		if rv.oclIsUndefined()
		then
			self.b_bugTracking.ct_control.responsible
		else
			rv
		endif;



-- Rule 'BugTracking2MantisRoot'
-- This rule generates the root of the Mantis output model
-- if a BugTracking element exists in the input model
rule  BugTracking2MantisRoot {
	from
		bt : SoftwareQualityControl!BugTracking
	
	to
		mr : Mantis!MantisRoot (
			issues <- bt.bugs->collect(e | thisModule.resolveTemp(e, 'mi'))
		)
}


-- Rule 'Bug2Issue'
-- This rule generates a issue in Mantis for each
-- bug reported in the BugTracking element.
rule  Bug2Issue {
	from
		bbt : SoftwareQualityControl!Bug
	using {
		commentsAnswersOrNot : Sequence(String) =
			let ca : String = bbt.commentsAnswers
			in
				if ca.oclIsUndefined()
				then
					Sequence{}
				else
					Sequence{ca}
				endif;
	}
	to
		mi : Mantis!Issue (
			id <- bbt.number,
			project <- proj,
			category <- '',
			priority <- prior,
			severity <- sev,
			status <- stat,
			reporter <- rep,
			summary <- '',
			description <- bbt.description,
			version <- bbt.componentVersion,
--			build <-,
--			platform <-,
--			os <-,
--			osVersion <-
			reproducibility <- reprod,
--			stepsToReproduce <-,
--			additionalInfo <-,
			dateSubmitted <- 0, -- the date is an integer value in a specific format : how to convert?
			assignedTo <- at,
--			projection <-,
--			eta <-,
--			resolution <-,
--			fixedInVersion <-,
			attachments <- Sequence{},
			relationships <- Sequence{},
			notes <- Sequence{note},
			lastUpdate <- 0 -- this date is not mentionned in any field in the Software Quality Control metamodel
		),
		proj : Mantis!ValueWithId (
			id <- 0,
			value <- bbt.b_bugTracking.ct_control.component
		),
		prior : Mantis!ValueWithId (
			id <- 0,
			value <- ''
		),
		sev : Mantis!ValueWithId (
			id <- 0,
			value <- ''
		),
		stat : Mantis!ValueWithId (
			id <- 0,
			value <- thisModule.convertStatus(bbt.status)
		),
		rep : Mantis!Person (
			id <- 0,
			value <- bbt.originator,
			login <-''
		),
		reprod : Mantis!ValueWithId (
			id <- 0,
			value <- ''
		),
		at : Mantis!Person (
			id <- 0,
			value <- bbt.getResponsibleName(),
			login <-''
		), 
		note : distinct Mantis!Note foreach(commentsAnswersVal in commentsAnswersOrNot)(
			timestamp <- 0,
			author <- aut,
			text <- commentsAnswersVal
		),
		aut : distinct Mantis!Person foreach(commentsAnswersVal in commentsAnswersOrNot)(
			id <- 0,
			value <- bbt.originator,
			login <-''
		)
}",modul softwarequalitycontrol manti modul templat creat out manti in softwarequalitycontrol this helper permit convert status valu bug string context n return string helper def convertstatus bs softwarequalitycontrol bugstatustyp string let sv string bs tostr sv substr sv size this helper permit get name person respons bug if respons field valu respons bug control respons context n return string helper context softwarequalitycontrol bug def getresponsiblenam string let rv string self respons rv oclisundefin self b bugtrack ct control respons els rv endif rule bugtrack mantisroot this rule generat root manti output model bugtrack element exist input model rule bugtrack mantisroot bt softwarequalitycontrol bugtrack mr manti mantisroot issu bt bug collect e thismodul resolvetemp e mi rule bug issu this rule generat issu manti bug report bugtrack element rule bug issu bbt softwarequalitycontrol bug use commentsanswersornot sequenc string let ca string bbt commentsansw ca oclisundefin sequenc els sequenc ca endif mi manti issu id bbt number project proj categori prioriti prior sever sev status stat report rep summari descript bbt descript version bbt componentvers build platform os osvers reproduc reprod stepstoreproduc additionalinfo datesubmit date integ valu specif format convert assignedto project eta resolut fixedinvers attach sequenc relationship sequenc note sequenc note lastupd date mention field softwar qualiti control metamodel proj manti valuewithid id valu bbt b bugtrack ct control compon prior manti valuewithid id valu sev manti valuewithid id valu stat manti valuewithid id valu thismodul convertstatus bbt status rep manti person id valu bbt origin login reprod manti valuewithid id valu manti person id valu bbt getresponsiblenam login note distinct manti note foreach commentsanswersv commentsanswersornot timestamp author aut text commentsanswersv aut distinct manti person foreach commentsanswersv commentsanswersornot id valu bbt origin login,11
179,179,P77-XML2MantisText.atl,"query XML2Text = XML!Root.allInstances()
		->asSequence()
		->first().MantisFile().writeTo('C:\\ ... the path has to be completed ... \\SoftwareQualityControl2MantisBTFile\\MantisXMLfileExample.xml');

helper context XML!Root def: MantisFile() : String =
	'<?xml version=""1.0"" encoding=""ISO-8859-1""?>'+'\n'+ self.toString2('');

helper context XML!Element def: toString2(indent : String) : String =
	let na : Sequence(XML!Node) =
		self.children->select(e | not e.oclIsKindOf(XML!Attribute)) in
	let a : Sequence(XML!Node) =
		self.children->select(e | e.oclIsKindOf(XML!Attribute)) in
	indent + '<' + self.name + 
	a->iterate(e; acc : String = '' |
		acc + ' ' + e.toString2()
	) +
	if na->size() > 0 then
		'>'
		+ na->iterate(e; acc : String = '' |
			acc + 
			if e.oclIsKindOf(XML!Text) then
				''
			else
				'\r\n'
			endif
			+ e.toString2(indent + '  ')
		) +
		if na->first().oclIsKindOf(XML!Text) then
			'</' + self.name + '>'
			else
				'\r\n' + indent + '</' + self.name + '>'
		endif
	else
		'/>'
	endif;

	
helper context XML!Attribute def: toString2() : String =
	self.name + '=\""' + self.value + '\""';


helper context XML!Text def: toString2() : String =
	self.value;
",queri xml text xml root allinst assequ first mantisfil writeto c path complet softwarequalitycontrol mantisbtfil mantisxmlfileexampl xml helper context xml root def mantisfil string xml version encod iso n self tostr helper context xml element def tostr indent string string let na sequenc xml node self children select e e ocliskindof xml attribut let sequenc xml node self children select e e ocliskindof xml attribut indent self name iter e acc string acc e tostr na size na iter e acc string acc e ocliskindof xml text els r n endif e tostr indent na first ocliskindof xml text self name els r n indent self name endif els endif helper context xml attribut def tostr string self name self valu helper context xml text def tostr string self valu,5
180,180,P78-SSL2SDLTransformation.atl,"module SSL2SDL;
create OUT : SDL from IN : SSL, IN2 : ODM;

-- A SSL!OntologyClassURI element has a lexicalForm attribute with
-- the following structure: <ontologyID>#<ontologyClassID>.
-- This helper takes this value and returns the <ontologyClassID> part.
helper def : getOntologyIDName(e : String) : String = 
	e.substring(e.indexOf('#') + 2, e.size())
;

-- A SSL!DataTypeURI element has a lexicalForm attribute that 
-- contains the URI that points to a XMLSchema and to the desired type,
-- in the form: <baseURI>#<typeName>
-- This helper takes this value and returns the <typeName> part.
helper def : getSchemaTypeName(e : String) : String = 
	e.substring(e.indexOf('#') + 2, e.size())
;

-- Taking a String value, this helper returns a sequence containing all the
-- ODM!DatatypeProperty elements that apply to the ODM!Class that has the id attribute
-- equal with that value. The returned sequence includes the ODM!DatatypeProperty-es 
-- that apply to any of its superclasses (the inherited ODM!DatatypeProperty-es).
helper def: getDataTypePropertiesForId(inputId : String) : Sequence(ODM!DatatypeProperty) = 
	ODM!Class.allInstances() -> select (d | d.id = inputId) -> 
		collect (d | thisModule.getAllDataTypeProperties(d)) -> flatten()
;

-- Taking a ODM!Class, returns a sequence containing all the ODM!DatatypeProperty 
-- elements that have in their theDomain property a reference to that class or to
-- one of its superclasses (recursion on all the defined super classes)
helper def: getAllDataTypeProperties(c : ODM!Class) : Sequence(ODM!DatatypeProperty) = 
	Sequence{}
	-> append (thisModule.getOwnDataTypeProperties(c))
	-> append ( c.theSuperClass ->
				iterate(e; result : Sequence(ODM!DatatypeProperty) = Sequence{} 
				| result -> append(thisModule.getAllDataTypeProperties(e)) -> flatten())
	   ) -> flatten()
;

-- Taking a ODM!Class, returns a sequence containing all the ODM!DatatypeProperty 
-- elements that have in their theDomain property a reference to that class.
helper def: getOwnDataTypeProperties(c : ODM!Class) : Sequence(ODM!DatatypeProperty) = 
	ODM!DatatypeProperty.allInstances() -> select(e | e.theDomain -> includes (c))     
;
	
-- This helper returns a sequence containing all the SSL!ServiceInput 
-- elements that belong to a SSL!ServiceFunctionality that has 
-- multiple inputs
helper def: getMultipleInputs() : Sequence(SSL!ServiceInput) = 
	SSL!ServiceFunctionality.allInstances() -> select(e | e.Input.size() > 1) 
	-> collect(e | e.Input) -> flatten()
;

-- Similar with getMultipleInputs(), but referring to SSL!ServiceOutput.
helper def: getMultipleOutputs() : Sequence(SSL!ServiceOutput) = 
	SSL!ServiceFunctionality.allInstances() -> select(e | e.Output.size() > 1) 
	-> collect(e | e.Output) -> flatten()
;

-- This helper returns the name of the SSL!ServiceInput that has as 
-- Type the specified SSL!OntologyClassURI.
helper def: inputMessageName(searchedType: SSL!OntologyClassURI) : String =
     SSL!ServiceInput.allInstances() -> select(e | e.Type = searchedType) -> collect(e | e.name) 
	 -> asSequence() -> first()
;

-- Similar with inputMessageName(), but referring to SSL!ServiceOutput.
helper def: outputMessageName(searchedType: SSL!OntologyClassURI) : String =
     SSL!ServiceOutput.allInstances() -> select(e | e.Type = searchedType) -> collect(e | e.name) 
	 -> asSequence() -> first()
;

-- Returns the root element of the input SSL model, as it is the one 
-- that generates the SDL types.
helper def: getTypeGenerator() : SSL!ServiceProfile = 
		SSL!ServiceProfile.allInstances()->asSequence()->first()
;

-- Returns the name of the target pattern (in rule Definitions) that 
-- generates the SDL type that corresponds to the specified ODM!DataRange.
-- For the types that do not have direct mapping to an SDL type, the 
-- returned target pattern name is the one returned by the helper
-- getSDLTypeForODM_Default.
helper def: getSDLTypeForODM(p : ODM!DataRange) : String = 
	if p.oclIsKindOf(ODM!PrimitiveType) then
		thisModule.getSDLTypeForSchemaType(
			thisModule.getSchemaTypeName(p.TypeDefinitionURI.lexicalForm))
	else thisModule.getSDLTypeForODM_Default()
	endif
;	

-- Returns the name of the target pattern (in rule Definitions) that is
-- assigned by default to elements from the ontology whose type is not mapped
-- directly to a SDL type (the pattern that generates SDL!SdlString).
helper def: getSDLTypeForODM_Default() : String = 
	'type4'
;

-- Returns the name of the target pattern (in rule Definitions) that 
-- generates the SDL type that corresponds to the schema type with the 
-- specified name. (The mapping realized for the schema: 
-- http://www.w3.org/2001/XMLSchema.)
-- For the types that do not have direct mapping to an SDL type, the 
-- retured target pattern name is the one corresponding to SDL!String. 
helper def: getSDLTypeForSchemaType(name : String) : String = 
	if  name = 'integer' or name = 'positiveInteger' or name = 'nonPositiveInteger' or
        name = 'negativeInteger' or name = 'nonNegativeInteger' or name = 'long' or
        name = 'int' or name = 'short' or name = 'byte' or name = 'unsignedLong' or
        name = 'unsignedInt' or name = 'unsignedShort' or name = 'unsignedByte'
	then 'type1'	-- SDL!SdlInteger
	else if name = 'boolean'
		 then 'type2'	-- SDL!SdlBoolean
		 else if name = 'decimal' or name = 'float' or name = 'double'
		 		then 'type3'	-- SDL!SdlReal
		 		else if name = 'dateTime' or name = 'date' or name = 'time' or 
						name = 'gYearMonth' or name = 'gMonthDay' or 
						name = 'gYear' or name = 'gMonth' or name = 'gDay'
					 then 'type5'	-- SDL!SdlDateTime
					 else 	if name = 'string' or name = 'normalizedString' or 
					 			name = 'token' or name = 'language' or name = 'NMTOKEN' or 
								name = 'Name' or name = 'NCName' or 
								name = 'hexBinary' or name = 'base64Binary'
					 		then 'type4' 	--  SDL!SdlString
							else 'type4' 	-- default for unsupported types: SDL!SdlString
							endif						
					 endif
		 		endif
		 endif
	endif
;	

-- Returns a sequence with a 'fake' element if the size of the 
-- provided sequence is 0, otherwise it returns an empty sequence.
helper def: getFakeDatatypeSequence(m : Sequence(ODM!DatatypeProperty)) : Sequence(String) = 
	if m.size() = 0
		then Sequence{''}
		else Sequence{}
	endif
;		

-- Returns a sequence of all the SSL!ServiceInput and SSL!ServiceOutput 
-- that have the Type attribute equal to the specified SSL!DataTypeURI.
helper def: getInputOutputHavingURIType(t : SSL!DataTypeURI) : Sequence(SSL!FunctionalityParameter) = 
	Sequence{SSL!ServiceInput.allInstances() -> asSequence(), SSL!ServiceOutput.allInstances() -> asSequence()} -> flatten() -> select(e | e.Type = t)
;

-- An SSL!OntologyClassURI element contains the id of an element in the 
-- associated ontology.
-- For every SSL!OntologyClassURI element that is the Type attribute of a 
-- SSL!ServiceInput, this rule creates:
-- 1) a SDL!ComplexType that has a SDL!Part for each ODM!DatatypeProperty 
-- in which this class is reffered (by id). If there is no such 
-- ODM!DatatypeProperty, by default a SDL!Part with the type SDL!String 
-- is created
-- 2) if this element is the Type of a SSL!ServiceInput that belongs 
-- to a SSL!ServiceFunctionality with multiple inputs, then a SDL!Part 
-- that has a reference to the generated SDL!ComplexType is created
-- (and it will be included in the element obtained from the transformation 
-- of that SSL!ServiceFunctionality)
rule TypeFromOntology_Input {
	from inp : SSL!OntologyClassURI (
				SSL!ServiceInput.allInstances() -> select(e | e.Type = inp) -> size() > 0 
			)
	using{
		properties : Sequence(ODM!DatatypeProperty) = 
			thisModule.getDataTypePropertiesForId(thisModule.getOntologyIDName(inp.lexicalform));
		service_name : SSL!ServiceInput = thisModule.inputMessageName(inp);
	}
	to complex : SDL!ComplexType(
		ElName <- service_name + 'Parameters',
		cmpPart <- Sequence{part_a, part_b}
	),
	part_a : distinct SDL!Part foreach(a in properties)(
		ElName <- a.name,
		refPart <- thisModule.resolveTemp(thisModule.getTypeGenerator(), 
			thisModule.getSDLTypeForODM(a.theDataRange)
		)			
	),
	part_b : distinct SDL!Part foreach(c in thisModule.getFakeDatatypeSequence(properties) )	(
		ElName <- thisModule.getOntologyIDName(inp.lexicalform),
		refPart <- thisModule.resolveTemp(thisModule.getTypeGenerator(), 
			thisModule.getSDLTypeForODM_Default()
		)			
	),
	
	part_c : distinct  SDL!Part foreach(b in SSL!ServiceFunctionality.allInstances() ->
									   select(c | c.Input.size() > 1) -> select(v | v.Input -> select(u | u.Type = inp).size() > 0))(
		ElName <- service_name,
		refPart <- complex
	)
	
}

-- The same transformation as TypeFromOntology_Input, but for types 
-- that belong to a ServiceOutput.
rule TypeFromOntology_Output {
	from inp : SSL!OntologyClassURI (
				SSL!ServiceOutput.allInstances() -> select(e | e.Type = inp) -> size() > 0
			)
	using{
		properties : Sequence(ODM!DatatypeProperty) = 
			thisModule.getDataTypePropertiesForId(thisModule.getOntologyIDName(inp.lexicalform));
		service_name : SSL!ServiceOutput = thisModule.outputMessageName(inp);
	}
	to complex : SDL!ComplexType(
		ElName <- service_name + 'Parameters',
		cmpPart <- Sequence{part_a, part_b}
	),
	part_a : distinct SDL!Part foreach(a in properties)(
		ElName <- a.name,
		refPart <- thisModule.resolveTemp(thisModule.getTypeGenerator(), 
			thisModule.getSDLTypeForODM(a.theDataRange)
			)			
	),
	part_b : distinct SDL!Part foreach (c in thisModule.getFakeDatatypeSequence(properties)	)(
		ElName <- thisModule.getOntologyIDName(inp.lexicalform),
		refPart <- thisModule.resolveTemp(thisModule.getTypeGenerator(), 
			thisModule.getSDLTypeForODM_Default()
		)			
	),
	
	part_c : distinct  SDL!Part foreach(b in SSL!ServiceFunctionality.allInstances() ->
									   select(c | c.Output.size() > 1) -> select(v | v.Output -> select(u | u.Type = inp).size() > 0))(
		ElName <- service_name,
		refPart <- complex
	)
}

-- A SSL!DataTypeURI element refers to a type defined in a specified XMLSchema.
-- For every SSL!DataTypeURI element that is the Type attribute of a 
-- SSL!ServiceInput or a SSL!ServiceOutput, this rule creates a 
-- SDL!Part that refers to the corresponding SDL type 
-- (see the helper getSDLTypeForSchemaType).
rule TypeFromSchema {
	from inp : SSL!DataTypeURI (
		thisModule.getInputOutputHavingURIType(inp) -> size() > 0 
	)
	to part_c : SDL!Part (
		ElName <- thisModule.getInputOutputHavingURIType(inp) -> first().name,
		refPart <- thisModule.resolveTemp(thisModule.getTypeGenerator(), 	
			thisModule.getSDLTypeForSchemaType(thisModule.getSchemaTypeName(inp.lexicalform)) )
	)
}

-- For every SSL!ServiceInput that is the only input of a 
-- SSL!ServiceFunctionality and whose type is not SSL!OntologyClassURI, 
-- this rules construct a SDL!SimpleMessage that describes it (the type 
-- of the input is transformed according to the rule TypeFromSchema)
rule SingleInput_NonOntology {
	from e : SSL!ServiceInput (not thisModule.getMultipleInputs()->includes(e)
		and not e.Type.oclIsKindOf(SSL!OntologyClassURI ))
	to inm : SDL!SimpleMessage(
		  ElName <- e.name,
		  cmpPart <- e.Type
    )	
}

-- The same transformation as SingleInput_NonOntology, but for 
-- SSL!ServiceOutput.
rule SingleOutput_NonOntology {
	from e : SSL!ServiceOutput (not thisModule.getMultipleOutputs()->includes(e)
		and not e.Type.oclIsKindOf(SSL!OntologyClassURI ))
	to outm : SDL!SimpleMessage (
   	  ElName <- e.name,
      cmpPart <- e.Type
    )
}

-- For every SSL!ServiceInput that is the only input of a 
-- SSL!ServiceFunctionality and whose type is SSL!OntologyClassURI (it 
-- is described in the ontology), this rules construct a SDL!SimpleMessage 
-- that describes it (the message contains a single SDL!Part that refers 
-- to the complex type generated from the input's type - see rule 
-- TypeFromOntology_Input: part_c)
rule SingleInput_Ontology {
	from e : SSL!ServiceInput ( not thisModule.getMultipleInputs()->includes(e) and 
		e.Type.oclIsKindOf(SSL!OntologyClassURI ))
	to inm : SDL!SimpleMessage(
		ElName <- e.name,
		cmpPart <- part
	),
	part : SDL!Part(
		ElName <- e.name + 'ComplexType',
		refPart <- e.Type
	)
}

-- The same transformation as SingleInput_Ontology, but for 
-- SSL!ServiceOutput.
rule SingleOutput_Ontology {
	from e : SSL!ServiceOutput ( not thisModule.getMultipleOutputs()->includes(e) and 
		e.Type.oclIsKindOf(SSL!OntologyClassURI ))
	to outm : SDL!SimpleMessage(
		ElName <- e.name,
		cmpPart <- part
	),
	part : SDL!Part(
		ElName <- e.name + 'ComplexType',
		refPart <- e.Type
	)
}



-- For every SSL!ServiceFunctionality that has a single input and a 
-- single output, this rule constructs a SDL!Operation that contains 
-- the results of the input's and output's transformation (see rules
-- SingleInput_Ontology, SingleInput_NonOntology and their 
-- correspondents for output messages)
rule ServiceFunctionality11 {
	from e : SSL!ServiceFunctionality (e.Input.size() <= 1 and e.Output.size() <= 1 )
	to outOper : SDL!Operation(
		ElName <- e.name,
		refInputMessage <- e.Input,
		refOutputMessage <- e.Output
	)
}

-- For every SSL!ServiceFunctionality that has multiple inputs and a 
-- single output, this rule constructs a SDL!Operation that contains 
-- the results of the output's transformation (see rules 
-- SingleOutput_Ontology, SingleOutput_NonOntology) and that constructs 
-- a SDL!Message in which it ""compacts"" the inputs by placing, as parts, 
-- the results of the transformation of each input's type (see rules 
-- TypeFromOntology_Input: part_c and TypeFromSchema: part_c)
rule ServiceFunctionalityN1 {
	from e : SSL!ServiceFunctionality (e.Input.size() > 1 and e.Output.size() = 1)
	to inp : SDL!SimpleMessage(
		ElName <- e.name + 'Request',
		cmpPart <- Sequence{e.Input -> collect(k | thisModule.resolveTemp(k.Type, 'part_c'))}
	),
	outOper : SDL!Operation(
		ElName <- e.name,
		refInputMessage <- inp,
		refOutputMessage <- e.Output
	)
}


-- For every SSL!ServiceFunctionality that has a single input and
-- multiple outputs, this rule constructs a SDL!Operation that contains 
-- the results of the input's transformation (see rules 
-- SingleInput_Ontology, SingleInput_NonOntology) and that constructs 
-- a SDL!Message in which it ""compacts"" the outputs by placing, as parts, 
-- the results of the transformation of each output's type (see rules 
-- TypeFromOntology_Output: part_c and TypeFromSchema: part_c)
rule ServiceFunctionality1N {
	from e : SSL!ServiceFunctionality (e.Input.size() = 1 and e.Output.size() > 1)
	to out : SDL!SimpleMessage(
		ElName <- e.name + 'Response',
		cmpPart <- Sequence{
			e.Output -> collect(k | thisModule.resolveTemp(k.Type, 'part_c'))	
		}
	),
	outOper : SDL!Operation(
		ElName <- e.name,
		refInputMessage <- e.Input,
		refOutputMessage <- out		
	)
}

-- For every SSL!ServiceFunctionality that has multiple inputs and
-- multiple outputs, this rule constructs a SDL!Operation that contains: 
-- - a SDL!Message in which it ""compacts"" the inputs by placing, as parts, 
-- the results of the transformation of each input's type (see rules 
-- TypeFromOntology_Input: part_c and TypeFromSchema: part_c)
-- - a SDL!Message in which it ""compacts"" the outputs by placing, as parts, 
-- the results of the transformation of each output's type (see rules 
-- TypeFromOntology_Output: part_c and TypeFromSchema: part_c)
rule ServiceFunctionalityNN {
	from e : SSL!ServiceFunctionality (e.Input.size() > 1 and e.Output.size() > 1)
	to inp : SDL!SimpleMessage(
		ElName <- e.name + 'Request',
		cmpPart <- Sequence{
			e.Input -> collect(k | thisModule.resolveTemp(k.Type, 'part_c'))	
		}		
	),
	out : SDL!SimpleMessage(
		ElName <- e.name + 'Response',
		cmpPart <- Sequence{
			e.Output -> collect(k | thisModule.resolveTemp(k.Type, 'part_c'))	
		}	
	),
	outOper : SDL!Operation(
		ElName <- e.name,
		refInputMessage <- inp,
		refOutputMessage <- out		
	)
}

-- The main rule of the transformation. It constructs the skeleton of the SDL model, and uses the 
-- results of the other rules in order to fill it.
-- It creates the SDL types definitions, generates the definitions of the interfaces (containing the
-- generated operations) and groups the generated messages.
rule Definitions {
	from e : SSL!ServiceProfile 
	to out : SDL!Definitions ( 
		ElName <- e.name,
		cmpType <- Sequence{type1, type2, type3, type4, type5, type6, SSL!OntologyClassURI.allInstances()},
		cmpInterface <- interfaces,
		cmpMessage <- Sequence{
			SSL!ServiceInput.allInstances() -> select(e | not thisModule.getMultipleInputs() -> includes(e)) -> collect (e | thisModule.resolveTemp(e, 'inm') ),
			SSL!ServiceOutput.allInstances() -> select(e | not thisModule.getMultipleOutputs() -> includes(e)) -> collect (e | thisModule.resolveTemp(e, 'outm') ),
			SSL!ServiceFunctionality.allInstances() -> select (e | e.Input.size() > 1) -> collect (e | thisModule.resolveTemp(e, 'inp') ),
			SSL!ServiceFunctionality.allInstances() -> select (e | e.Output.size() > 1) -> collect (e | thisModule.resolveTemp(e, 'out') )
		}
	),
	interfaces : SDL!Interface (
		ElName <- e.name + 'Service', 
		cmpOperation <- e.Functionality -> collect(e | thisModule.resolveTemp(e, 'outOper') )
	),
	type1 : SDL!SdlInteger(
	   ElName <- 'Integer'
	),
	type2 : SDL!SdlBoolean(
	   ElName <- 'Boolean'
	),
	type3 : SDL!SdlReal(
	   ElName <- 'Real'
	),
	type4 : SDL!SdlString(
	   ElName <- 'String'
	),
	type5 : SDL!SdlDateTime(
	   ElName <- 'DateTime'
	),
	type6 : SDL!SdlUri(
	   ElName <- 'Uri'
	)
}
",modul ssl sdl creat out sdl in ssl in odm a ssl ontologyclassuri element lexicalform attribut follow structur ontologyid ontologyclassid this helper take valu return ontologyclassid part helper def getontologyidnam e string string e substr e indexof e size a ssl datatypeuri element lexicalform attribut contain uri point xmlschema desir type form baseuri typenam this helper take valu return typenam part helper def getschematypenam e string string e substr e indexof e size take string valu helper return sequenc contain odm datatypeproperti element appli odm class id attribut equal valu the return sequenc includ odm datatypeproperti es appli superclass inherit odm datatypeproperti es helper def getdatatypepropertiesforid inputid string sequenc odm datatypeproperti odm class allinst select id inputid collect thismodul getalldatatypeproperti flatten take odm class return sequenc contain odm datatypeproperti element thedomain properti refer class one superclass recurs defin super class helper def getalldatatypeproperti c odm class sequenc odm datatypeproperti sequenc append thismodul getowndatatypeproperti c append c thesuperclass iter e result sequenc odm datatypeproperti sequenc result append thismodul getalldatatypeproperti e flatten flatten take odm class return sequenc contain odm datatypeproperti element thedomain properti refer class helper def getowndatatypeproperti c odm class sequenc odm datatypeproperti odm datatypeproperti allinst select e e thedomain includ c this helper return sequenc contain ssl serviceinput element belong ssl servicefunct multipl input helper def getmultipleinput sequenc ssl serviceinput ssl servicefunct allinst select e e input size collect e e input flatten similar getmultipleinput refer ssl serviceoutput helper def getmultipleoutput sequenc ssl serviceoutput ssl servicefunct allinst select e e output size collect e e output flatten this helper return name ssl serviceinput type specifi ssl ontologyclassuri helper def inputmessagenam searchedtyp ssl ontologyclassuri string ssl serviceinput allinst select e e type searchedtyp collect e e name assequ first similar inputmessagenam refer ssl serviceoutput helper def outputmessagenam searchedtyp ssl ontologyclassuri string ssl serviceoutput allinst select e e type searchedtyp collect e e name assequ first return root element input ssl model one generat sdl type helper def gettypegener ssl serviceprofil ssl serviceprofil allinst assequ first return name target pattern rule definit generat sdl type correspond specifi odm datarang for type direct map sdl type return target pattern name one return helper getsdltypeforodm default helper def getsdltypeforodm p odm datarang string p ocliskindof odm primitivetyp thismodul getsdltypeforschematyp thismodul getschematypenam p typedefinitionuri lexicalform els thismodul getsdltypeforodm default endif return name target pattern rule definit assign default element ontolog whose type map direct sdl type pattern generat sdl sdlstring helper def getsdltypeforodm default string type return name target pattern rule definit generat sdl type correspond schema type specifi name the map realiz schema http www w org xmlschema for type direct map sdl type retur target pattern name one correspond sdl string helper def getsdltypeforschematyp name string string name integ name positiveinteg name nonpositiveinteg name negativeinteg name nonnegativeinteg name long name int name short name byte name unsignedlong name unsignedint name unsignedshort name unsignedbyt type sdl sdlinteg els name boolean type sdl sdlboolean els name decim name float name doubl type sdl sdlreal els name datetim name date name time name gyearmonth name gmonthday name gyear name gmonth name gday type sdl sdldatetim els name string name normalizedstr name token name languag name nmtoken name name name ncname name hexbinari name base binari type sdl sdlstring els type default unsupport type sdl sdlstring endif endif endif endif endif return sequenc fake element size provid sequenc otherwis return empti sequenc helper def getfakedatatypesequ sequenc odm datatypeproperti sequenc string size sequenc els sequenc endif return sequenc ssl serviceinput ssl serviceoutput type attribut equal specifi ssl datatypeuri helper def getinputoutputhavingurityp ssl datatypeuri sequenc ssl functionalityparamet sequenc ssl serviceinput allinst assequ ssl serviceoutput allinst assequ flatten select e e type an ssl ontologyclassuri element contain id element associ ontolog for everi ssl ontologyclassuri element type attribut ssl serviceinput rule creat sdl complextyp sdl part odm datatypeproperti class reffer id if odm datatypeproperti default sdl part type sdl string creat element type ssl serviceinput belong ssl servicefunct multipl input sdl part refer generat sdl complextyp creat includ element obtain transform ssl servicefunct rule typefromontolog input inp ssl ontologyclassuri ssl serviceinput allinst select e e type inp size use properti sequenc odm datatypeproperti thismodul getdatatypepropertiesforid thismodul getontologyidnam inp lexicalform servic name ssl serviceinput thismodul inputmessagenam inp complex sdl complextyp elnam servic name paramet cmppart sequenc part part b part distinct sdl part foreach properti elnam name refpart thismodul resolvetemp thismodul gettypegener thismodul getsdltypeforodm thedatarang part b distinct sdl part foreach c thismodul getfakedatatypesequ properti elnam thismodul getontologyidnam inp lexicalform refpart thismodul resolvetemp thismodul gettypegener thismodul getsdltypeforodm default part c distinct sdl part foreach b ssl servicefunct allinst select c c input size select v v input select u u type inp size elnam servic name refpart complex the transform typefromontolog input type belong serviceoutput rule typefromontolog output inp ssl ontologyclassuri ssl serviceoutput allinst select e e type inp size use properti sequenc odm datatypeproperti thismodul getdatatypepropertiesforid thismodul getontologyidnam inp lexicalform servic name ssl serviceoutput thismodul outputmessagenam inp complex sdl complextyp elnam servic name paramet cmppart sequenc part part b part distinct sdl part foreach properti elnam name refpart thismodul resolvetemp thismodul gettypegener thismodul getsdltypeforodm thedatarang part b distinct sdl part foreach c thismodul getfakedatatypesequ properti elnam thismodul getontologyidnam inp lexicalform refpart thismodul resolvetemp thismodul gettypegener thismodul getsdltypeforodm default part c distinct sdl part foreach b ssl servicefunct allinst select c c output size select v v output select u u type inp size elnam servic name refpart complex a ssl datatypeuri element refer type defin specifi xmlschema for everi ssl datatypeuri element type attribut ssl serviceinput ssl serviceoutput rule creat sdl part refer correspond sdl type see helper getsdltypeforschematyp rule typefromschema inp ssl datatypeuri thismodul getinputoutputhavingurityp inp size part c sdl part elnam thismodul getinputoutputhavingurityp inp first name refpart thismodul resolvetemp thismodul gettypegener thismodul getsdltypeforschematyp thismodul getschematypenam inp lexicalform for everi ssl serviceinput input ssl servicefunct whose type ssl ontologyclassuri rule construct sdl simplemessag describ type input transform accord rule typefromschema rule singleinput nonontolog e ssl serviceinput thismodul getmultipleinput includ e e type ocliskindof ssl ontologyclassuri inm sdl simplemessag elnam e name cmppart e type the transform singleinput nonontolog ssl serviceoutput rule singleoutput nonontolog e ssl serviceoutput thismodul getmultipleoutput includ e e type ocliskindof ssl ontologyclassuri outm sdl simplemessag elnam e name cmppart e type for everi ssl serviceinput input ssl servicefunct whose type ssl ontologyclassuri describ ontolog rule construct sdl simplemessag describ messag contain singl sdl part refer complex type generat input type see rule typefromontolog input part c rule singleinput ontolog e ssl serviceinput thismodul getmultipleinput includ e e type ocliskindof ssl ontologyclassuri inm sdl simplemessag elnam e name cmppart part part sdl part elnam e name complextyp refpart e type the transform singleinput ontolog ssl serviceoutput rule singleoutput ontolog e ssl serviceoutput thismodul getmultipleoutput includ e e type ocliskindof ssl ontologyclassuri outm sdl simplemessag elnam e name cmppart part part sdl part elnam e name complextyp refpart e type for everi ssl servicefunct singl input singl output rule construct sdl oper contain result input output transform see rule singleinput ontolog singleinput nonontolog correspond output messag rule servicefunct e ssl servicefunct e input size e output size outop sdl oper elnam e name refinputmessag e input refoutputmessag e output for everi ssl servicefunct multipl input singl output rule construct sdl oper contain result output transform see rule singleoutput ontolog singleoutput nonontolog construct sdl messag compact input place part result transform input type see rule typefromontolog input part c typefromschema part c rule servicefunctionalityn e ssl servicefunct e input size e output size inp sdl simplemessag elnam e name request cmppart sequenc e input collect k thismodul resolvetemp k type part c outop sdl oper elnam e name refinputmessag inp refoutputmessag e output for everi ssl servicefunct singl input multipl output rule construct sdl oper contain result input transform see rule singleinput ontolog singleinput nonontolog construct sdl messag compact output place part result transform output type see rule typefromontolog output part c typefromschema part c rule servicefunct n e ssl servicefunct e input size e output size sdl simplemessag elnam e name respons cmppart sequenc e output collect k thismodul resolvetemp k type part c outop sdl oper elnam e name refinputmessag e input refoutputmessag for everi ssl servicefunct multipl input multipl output rule construct sdl oper contain sdl messag compact input place part result transform input type see rule typefromontolog input part c typefromschema part c sdl messag compact output place part result transform output type see rule typefromontolog output part c typefromschema part c rule servicefunctionalitynn e ssl servicefunct e input size e output size inp sdl simplemessag elnam e name request cmppart sequenc e input collect k thismodul resolvetemp k type part c sdl simplemessag elnam e name respons cmppart sequenc e output collect k thismodul resolvetemp k type part c outop sdl oper elnam e name refinputmessag inp refoutputmessag the main rule transform it construct skeleton sdl model use result rule order fill it creat sdl type definit generat definit interfac contain generat oper group generat messag rule definit e ssl serviceprofil sdl definit elnam e name cmptype sequenc type type type type type type ssl ontologyclassuri allinst cmpinterfac interfac cmpmessag sequenc ssl serviceinput allinst select e thismodul getmultipleinput includ e collect e thismodul resolvetemp e inm ssl serviceoutput allinst select e thismodul getmultipleoutput includ e collect e thismodul resolvetemp e outm ssl servicefunct allinst select e e input size collect e thismodul resolvetemp e inp ssl servicefunct allinst select e e output size collect e thismodul resolvetemp e interfac sdl interfac elnam e name servic cmpoper e function collect e thismodul resolvetemp e outop type sdl sdlinteg elnam integ type sdl sdlboolean elnam boolean type sdl sdlreal elnam real type sdl sdlstring elnam string type sdl sdldatetim elnam datetim type sdl sdluri elnam uri,0
181,181,P79-R2ML2XML.atl,"-- ============================================================
-- Transforms an R2ML metamodel to XML metamodel.
-- Created as part of M.Sc. theses at GOOD OLD AI Laboratory
-- Author: Milan Milanovic (milan at milanovic.org)
-- Works for R2ML v0.4
-- Licence: GNU General Public License, version 2
-- ============================================================

module R2ML2XML; -- Module Template
create OUT : XML from IN : R2ML;

uses strings;

-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- HELPER: isNegated
-- Checks if Atom is negated. If property is not defined then it is false.
-- CONTEXT:	R2ML!Atom
-- OUT:		Boolean
helper context R2ML!Atom def: isNegated() : Boolean = 
	if self.isNegated.oclIsUndefined() then
		false
	else self.isNegated
	endif;

-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'RuleBase'
-- Create XML Root element (r2ml:RuleBase) from the R2ML RuleBase element 
rule RuleBase {
	from i : R2ML!RuleBase (
		i.oclIsTypeOf(R2ML!RuleBase)
		)
	to o : XML!Root (
			name <- 'r2ml:RuleBase',
			children <- Sequence { dc, schema, r2ml, xsi, i.rules }
		),
	dc : XML!Attribute (
			name <- 'xmlns:dc',
			value <- 'http://purl.org/dc/elements/1.1/'
		),
	schema : XML!Attribute (
			name <- 'xsi:schemaLocation',
			value <- 'http://www.rewerse.net/I1/2006/R2ML http://oxygen.informatik.tu-cottbus.de/R2ML/0.4/R2ML.xsd'
		),
	r2ml : XML!Attribute (
			name <- 'xmlns:r2ml',
			value <- 'http://www.rewerse.net/I1/2006/R2ML'
		),
	xsi : XML!Attribute (
			name <- 'xmlns:xsi',
			value <- 'http://www.w3.org/2001/XMLSchema-instance'
		)
}

-- Rule 'DerivationRuleSet'
-- Create XML element (r2ml:DerivationRuleSet) from the R2ML DerivationRuleSet element 
rule DerivationRuleSet {
	from i : R2ML!DerivationRuleSet (
			i.oclIsTypeOf(R2ML!DerivationRuleSet)
		)
	to o : XML!Element (
			name <- 'r2ml:DerivationRuleSet',
			children <- i.rules
		)
}

-- Rule 'IntegrityRuleSet'
-- Create XML element (r2ml:IntegrityRuleSet) from the R2ML IntegrityRuleSet element 
rule IntegrityRuleSet {
	from i : R2ML!IntegrityRuleSet (
			i.oclIsTypeOf(R2ML!IntegrityRuleSet)
		)
	to o : XML!Element (
			name <- 'r2ml:IntegrityRuleSet',
			children <- i.rules
		)
}

-- Rule 'ReactionRuleSet'
-- Create XML element (r2ml:ReactionRuleSet) from the R2ML ReactionRuleSet element 
rule ReactionRuleSet {
	from i : R2ML!ReactionRuleSet (
			i.oclIsTypeOf(R2ML!ReactionRuleSet)
		)
	to o : XML!Element (
			name <- 'r2ml:ReactionRuleSet',
			children <- i.rules
		)
}

-- Rule 'ProductionRuleSet'
-- Create XML element (r2ml:ProductionRuleSet) from the R2ML ProductionRuleSet element 
rule ProductionRuleSet {
	from i : R2ML!ProductionRuleSet (
			i.oclIsTypeOf(R2ML!ProductionRuleSet)
		)
	to o : XML!Element (
			name <- 'r2ml:ProductionRuleSet',
			children <- i.rules
		)
}

-- Rule 'AlethicIntegrityRule'
-- Create XML element (r2ml:AlethicIntegrityRule) from the R2ML AlethicIntegrityRule element 
rule AlethicIntegrityRule { 
	from i : R2ML!AlethicIntegrityRule (
			i.oclIsTypeOf(R2ML!AlethicIntegrityRule)
		)
	to o : XML!Element (
			name <- 'r2ml:AlethicIntegrityRule',
			children <- Sequence { if not i.ruleID.oclIsUndefined() then
									thisModule.RuleId(i)
									else OclUndefined
									endif,
									constraint
								}
		),
	constraint : XML!Element (
			name <- 'r2ml:constraint',
			children <- Sequence { i.constraint }
		)
}

-- Rule 'RuleId'
-- Create XML attribute (r2ml:ruleID) from the R2ML Rule element 
lazy rule RuleId {
	from i : R2ML!Rule
	to o : XML!Attribute (
			name <- 'r2ml:ruleID',
			value <- i.ruleID
		)
}

-- Rule 'DeonticIntegrityRule'
-- Create XML element (r2ml:DeonticIntegrityRule) from the R2ML DeonticIntegrityRule element 
rule DeonticIntegrityRule { 
	from i : R2ML!DeonticIntegrityRule (
			i.oclIsTypeOf(R2ML!DeonticIntegrityRule)
		)
	to o : XML!Element (
			name <- 'r2ml:DeonticIntegrityRule',
			children <- Sequence { if not i.ruleID.oclIsUndefined() then
									thisModule.RuleId(i)
									else OclUndefined
									endif,
									constraint 
								 }
		),
	constraint : XML!Element (
			name <- 'r2ml:constraint',
			children <- Sequence { i.constraint }
		)
}

-- Rule 'UniversallyQuantifiedFormula'
-- Create XML element (r2ml:UniversallyQuantifiedFormula) from the R2ML UniversallyQuantifiedFormula element 
rule UniversallyQuantifiedFormula {
	from i : R2ML!UniversallyQuantifiedFormula (
			i.oclIsTypeOf(R2ML!UniversallyQuantifiedFormula)
		)
	to o : XML!Element (
			name <- 'r2ml:UniversallyQuantifiedFormula',
			children <- Sequence {
							i.variables->asSequence()->select(c | c.oclIsTypeOf(R2ML!ObjectVariable))->collect(e | thisModule.ObjectVariable(e)),
							i.variables->asSequence()->select(c | c.oclIsTypeOf(R2ML!DataVariable))->collect(e | thisModule.DataVariable(e)),
							i.formula
						}
		)
}

-- Rule 'ExistentiallyQuantifiedFormula'
-- Create XML element (r2ml:ExistentiallyQuantifiedFormula) from the R2ML ExistentiallyQuantifiedFormula element 
rule ExistentiallyQuantifiedFormula {
	from i : R2ML!ExistentiallyQuantifiedFormula (
			i.oclIsTypeOf(R2ML!ExistentiallyQuantifiedFormula)
		)
	to o : XML!Element (
			name <- 'r2ml:ExistentiallyQuantifiedFormula',
			children <- Sequence {
							i.variables->asSequence()->select(c | c.oclIsTypeOf(R2ML!ObjectVariable))->collect(e | thisModule.ObjectVariable(e)),
							i.variables->asSequence()->select(c | c.oclIsTypeOf(R2ML!DataVariable))->collect(e | thisModule.DataVariable(e)),
							i.formula
						}
		)
}

-- Lazy rule 'ClassRule'
-- Create XML attribute (r2ml:classID) from the R2ML Class element 
lazy rule ClassRule {
	from i : R2ML!Class 
	to o : XML!Attribute (
			name <- 'r2ml:classID',
			value <- i.name
		)
}

-- Lazy rule 'ObjectVariable'
-- Create XML element (r2ml:ObjectVariable) from the R2ML ObjectVariable element 
lazy rule ObjectVariable {
	from i : R2ML!ObjectVariable
	to o : XML!Element (
		name <- 'r2ml:ObjectVariable',
		children <- Sequence { attrName, if not i.classRef.oclIsUndefined() then
											thisModule.ClassRule(i.classRef)
										 else OclUndefined
										 endif
							 }
		),
	attrName : XML!Attribute (
			name <- 'r2ml:name',
			value <- i.name
		)
}

-- Lazy rule 'DataVariable'
-- Create XML element (r2ml:DataVariable) from the R2ML DataVariable element 
lazy rule DataVariable {
	from i : R2ML!DataVariable
	to o : XML!Element (
		name <- 'r2ml:DataVariable',
		children <- Sequence { attrName, if not i.datatypeRef.oclIsUndefined() then
											thisModule.Datatype(i.datatypeRef)
										 else OclUndefined
										 endif,
										 if not i.typeCategory.oclIsUndefined() then
										 	thisModule.TypeCategory(i)
										 else OclUndefined
										 endif
							 }
		),
	attrName : XML!Attribute (
			name <- 'r2ml:name',
			value <- i.name
		)
}

-- Lazy rule 'GenericVariable'
-- Create XML element (r2ml:GenericVariable) from the R2ML GenericVariable element 
lazy rule GenericVariable {
	from i : R2ML!GenericVariable
	to o : XML!Element (
			name <- 'r2ml:GenericVariable',
			children <- Sequence { attrName, if not i.typeRef.oclIsUndefined() then
												thisModule.Datatype(i.typeRef)
										 	 else OclUndefined
										 	 endif 
								 }
		),
	attrName : XML!Attribute (
			name <- 'r2ml:name',
			value <- i.name
		)
}

-- Lazy rule 'Datatype'
-- Create XML attribute (r2ml:datatypeID) from the R2ML Datatype element 
lazy rule Datatype {
	from i : R2ML!Datatype
	to o : XML!Attribute (
			name <- 'r2ml:datatypeID',
			value <- i.name
		)
}

-- Rule 'Implication'
-- Create XML element (r2ml:Implication) from the R2ML Implication element 
rule Implication {
	from i : R2ML!Implication (
			i.oclIsTypeOf(R2ML!Implication)
		)
	to o : XML!Element (
			name <- 'r2ml:Implication',
			children <- Sequence { ant, con }
		),
		ant : XML!Element (
			name <- 'r2ml:antecedent',
			children <- i.antecedent
		),
		con : XML!Element (
			name <- 'r2ml:consequent',
			children <- i.consequent
		)
}

-- Rule 'Conjuction'
-- Create XML element (r2ml:Conjuction) from the R2ML Conjuction element 
rule Conjuction {
	from i : R2ML!Conjuction (
			i.oclIsTypeOf(R2ML!Conjuction)
		)
	to o : XML!Element (
			name <- 'r2ml:Conjunction',
			children <- i.formulas
		)
}

-- Rule 'Disjunction'
-- Create XML element (r2ml:Disjunction) from the R2ML Disjunction element 
rule Disjunction {
	from i : R2ML!Disjunction (
			i.oclIsTypeOf(R2ML!Disjunction)
		)
	to o : XML!Element (
			name <- 'r2ml:Disjunction',
			children <- i.formulas
		)
}

-- Rule 'NegationAsFailure'
-- Create XML element (r2ml:NegationAsFailure) from the R2ML NegationAsFailure element 
rule NegationAsFailure {
	from i : R2ML!NegationAsFailure (
			i.oclIsTypeOf(R2ML!NegationAsFailure)
		)
	to o : XML!Element (
			name <- 'r2ml:NegationAsFailure',
			children <- Sequence { i.formula }
		)
}

-- Rule 'StrongNegation'
-- Create XML element (r2ml:StrongNegation) from the R2ML StrongNegation element 
rule StrongNegation {
	from i : R2ML!StrongNegation (
			i.oclIsTypeOf(R2ML!StrongNegation)
		)
	to o : XML!Element (
			name <- 'r2ml:StrongNegation',
			children <- Sequence { i.formula }
		)
}

-- Rule 'EqualityAtom'
-- Create XML element (r2ml:EqualityAtom) from the R2ML EqualityAtom element 
rule EqualityAtom {
	from i : R2ML!EqualityAtom (
			i.oclIsTypeOf(R2ML!EqualityAtom)
		)
	to o : XML!Element (
			name <- 'r2ml:EqualityAtom',
			children <- Sequence { i.terms->select(c | c.oclIsTypeOf(R2ML!ObjectVariable))->collect(e | thisModule.ObjectVariable(e)),
								   i.terms->select(c | not c.oclIsTypeOf(R2ML!ObjectVariable))
								 }
		)
}

-- Rule 'InequalityAtom'
-- Create XML element (r2ml:InequalityAtom) from the R2ML InequalityAtom element 
rule InequalityAtom {
	from i : R2ML!InequalityAtom (
			i.oclIsTypeOf(R2ML!InequalityAtom)
		)
	to o : XML!Element (
			name <- 'r2ml:InequalityAtom',
			children <- Sequence { i.terms->select(c | c.oclIsTypeOf(R2ML!ObjectVariable))->collect(e | thisModule.ObjectVariable(e)),
								   i.terms->select(c | not c.oclIsTypeOf(R2ML!ObjectVariable))
								 }
		)
}

-- Rule 'DerivationRule'
-- Create XML element (r2ml:DerivationRule) from the R2ML DerivationRule element 
rule DerivationRule { 
	from i : R2ML!DerivationRule (
			i.oclIsTypeOf(R2ML!DerivationRule)
		)
	to o : XML!Element (
			name <- 'r2ml:DerivationRule',
			children <- Sequence { if not i.ruleID.oclIsUndefined() then
									thisModule.RuleId(i)
									else OclUndefined
									endif,
									conditions, 
									conclusions 
								 }
		),
		conditions : XML!Element (
				name <- 'r2ml:conditions',
				children <- i.conditions
			),
		conclusions : XML!Element (
				name <- 'r2ml:conclusion',
				children <- i.conclusions->asSequence()->collect(c | c.atoms)->flatten()->asSequence() -- collect LiteralConjuctions
			)
}

-- Rule 'ObjectClassificationAtom'
-- Create XML element (r2ml:ObjectClassificationAtom) from the R2ML ObjectClassificationAtom element 
rule ObjectClassificationAtom {
	from i : R2ML!ObjectClassificationAtom (
			i.oclIsTypeOf(R2ML!ObjectClassificationAtom)
		)
	to o : XML!Element (
			name <- 'r2ml:ObjectClassificationAtom',
			children <- Sequence { if i.isNegated() then    	  -- for isNegated attribute
									 thisModule.AtomIsNegated(i)
								   else OclUndefined
								   endif,
								   thisModule.ClassRule(i.type),      -- for classID attribute
								   thisModule.ObjectVariable(i.term)  -- for term 
								}
		)
}

-- Rule 'AtomIsNegated'
-- Create XML attribute (r2ml:isNegated) from the R2ML Atom element 
lazy rule AtomIsNegated {
	from i : R2ML!Atom
	to o : XML!Attribute ( 
			name <- 'r2ml:isNegated',
			value <- 'true'
		)
}

-- Rule 'DataClassificationAtom'
-- Create XML element (r2ml:DataClassificationAtom) from the R2ML DataClassificationAtom element 
rule DataClassificationAtom {
	from i : R2ML!DataClassificationAtom (
			i.oclIsTypeOf(R2ML!DataClassificationAtom)
		)
	to o : XML!Element (
			name <- 'r2ml:DataClassificationAtom',
			children <- Sequence { if i.isNegated() then    	  -- for isNegated attribute
									 thisModule.AtomIsNegated(i)
								   else OclUndefined
								   endif,
								   thisModule.Datatype(i.type),      -- for classID attribute
								   thisModule.DataVariable(i.term)  -- for term 
								}
		)
}

-- Rule 'QFConjunction'
-- Create XML element (r2ml:qf.Conjuction) from the R2ML QFConjunction element 
rule QFConjunction {
	from i : R2ML!QFConjunction (
			i.oclIsTypeOf(R2ML!QFConjunction)
		)
	to o : XML!Element (
			name <- 'r2ml:qf.Conjuction',
			children <- i.formulas
		)
}

-- Rule 'QFDisjunction'
-- Create XML element (r2ml:qf.Disjunction) from the R2ML QFDisjunction element 
rule QFDisjunction {
	from i : R2ML!QFDisjunction (
			i.oclIsTypeOf(R2ML!QFDisjunction)
		)
	to o : XML!Element (
			name <- 'r2ml:qf.Disjunction',
			children <- i.formulas
		)
}

-- Rule 'QFNegationAsFailure'
-- Create XML element (r2ml:qf.NegationAsFailure) from the R2ML QFNegationAsFailure element 
rule QFNegationAsFailure {
	from i : R2ML!QFNegationAsFailure (
			i.oclIsTypeOf(R2ML!QFNegationAsFailure)
		)
	to o : XML!Element (
			name <- 'r2ml:qf.NegationAsFailure',
			children <- Sequence { i.formula }
		)
}

-- Rule 'QFStrongNegation'
-- Create XML element (r2ml:qf.StrongNegation) from the R2ML QFStrongNegation element 
rule QFStrongNegation {
	from i : R2ML!QFStrongNegation (
			i.oclIsTypeOf(R2ML!QFStrongNegation)
		)
	to o : XML!Element (
			name <- 'r2ml:qf.StrongNegation',
			children <- Sequence { i.formula }
		)
}

-- Rule 'DatatypePredicateAtom'
-- Create XML element (r2ml:DatatypePredicateAtom) from the R2ML DatatypePredicateAtom element 
rule DatatypePredicateAtom {
	from i : R2ML!DatatypePredicateAtom (
			i.oclIsTypeOf(R2ML!DatatypePredicateAtom)
		)
	to o : XML!Element (
			name <- 'r2ml:DatatypePredicateAtom',
			children <- Sequence { if i.isNegated() then    	  -- for isNegated attribute
									 thisModule.AtomIsNegated(i)
								   else OclUndefined
								   endif,
								   attr, 
								   dataArgs }
		),
		attr : XML!Attribute (
				name <- 'r2ml:datatypePredicateID',
				value <- i.predicate.name
			),
		dataArgs : XML!Element (
				name <- 'r2ml:dataArguments',
				children <- Sequence { i.dataArguments->asSequence()->select(c | c.oclIsTypeOf(R2ML!DataVariable))->collect(c | thisModule.DataVariable(c)),
									   i.dataArguments->asSequence()->select(c | not c.oclIsTypeOf(R2ML!DataVariable))
									 }
			)
}

-- Rule 'TypeCategory'
-- Create XML attribute (r2ml:typeCategory) for R2ML Term element 
lazy rule TypeCategory {
	from i : R2ML!Term
	to o : XML!Attribute (
		name <- 'r2ml:typeCategory',
		value <- if i.typeCategory = #individual then
					 'individual'
				 else if i.typeCategory = #set then
						  'set'
					  else if i.typeCategory = #orderedSet then
								 'order'
						   else if i.typeCategory = #bag then
									'bag'
							    else if i.typeCategory = #sequence then
										  'sequence'
									 else OclUndefined
								     endif
								endif
						   endif
					  endif
				 endif			
		)
}
			
-- Rule 'DataOperationTermArgs'
-- Create XML element (r2ml:arguments) for R2ML DataOperationTerm element 
lazy rule DataOperationTermArgs {
	from i : R2ML!DataOperationTerm
	to o : XML!Element (
			name <- 'r2ml:arguments',
			children <- Sequence { i.arguments->asSequence()->select(c | c.oclIsTypeOf(R2ML!ObjectVariable))->collect(c | thisModule.ObjectVariable(c)),
								   i.arguments->asSequence()->select(c | c.oclIsTypeOf(R2ML!DataVariable))->collect(c | thisModule.DataVariable(c)),
								   i.arguments->asSequence()->select(c | not c.oclIsTypeOf(R2ML!ObjectVariable) and not c.oclIsTypeOf(R2ML!DataVariable))
								 }
		)
}

-- Rule 'TypedLiteral'
-- Create XML element (r2ml:TypedLiteral) from the R2ML TypedLiteral element 
rule TypedLiteral {
	from i : R2ML!TypedLiteral (
			i.oclIsTypeOf(R2ML!TypedLiteral)
		)
	to o : XML!Element (
			name <- 'r2ml:TypedLiteral',
			children <- Sequence { type, value }
		),
	type : XML!Attribute (
			name <- 'r2ml:datatypeID',
			value <- i.type.name
		),
	value : XML!Attribute (
			name <- 'r2ml:lexicalValue',
			value <- i.lexicalValue
		)
}

-- Rule 'PlainLiteral'
-- Create XML element (r2ml:PlainLiteral) from the R2ML PlainLiteral element
rule PlainLiteral {
	from i : R2ML!PlainLiteral (
			i.oclIsTypeOf(R2ML!PlainLiteral)
		)
	to o : XML!Element (
			name <- Sequence { if not i.languageTag.oclIsUndefined() then 
								thisModule.PlainLiteralLanguageTag(i)
							   else OclUndefined
							   endif, 
							   value
							}
		),
	value : XML!Attribute (
			name <- 'r2ml:lexicalValue',
			value <- i.lexicalValue
		)
}
		
-- Rule 'PlainLiteralLanguageTag'
-- Create XML attribute (r2ml:languageTag) for R2ML PlainLiteral element
lazy rule PlainLiteralLanguageTag {
	from i : R2ML!PlainLiteral
	to o : XML!Attribute (
			name <- 'r2ml:languageTag',
			value <- i.languageTag
		)
}

-- Rule 'AttributeFunctionTerm'
-- Create XML element (r2ml:AttributeFunctionTerm) from the R2ML AttributeFunctionTerm element
rule AttributeFunctionTerm {
	from i : R2ML!AttributeFunctionTerm (
			i.oclIsTypeOf(R2ML!AttributeFunctionTerm)
		)
	to o : XML!Element (
			name <- 'r2ml:AttributeFunctionTerm',
			children <- Sequence { attr,  contextArg, 
								   if not i.typeCategory.oclIsUndefined() then
										thisModule.TypeCategory(i)
								   else OclUndefined
								   endif 
								  }
		),
	attr : XML!Attribute (
			name <- 'r2ml:attributeID',
			value <- i.attribute.name
		),
	contextArg : XML!Element (
			name <- 'r2ml:contextArgument',
			children <- Sequence { if i.contextArgument.oclIsTypeOf(R2ML!ObjectVariable) then 
									thisModule.ObjectVariable(i.contextArgument)
								   else i.contextArgument
								   endif
								 }
		)
}

-- Rule 'AssociationAtom'
-- Create XML element (r2ml:AssociationAtom) from the R2ML AssociationAtom element
rule AssociationAtom {
	from i : R2ML!AssociationAtom (
			i.oclIsTypeOf(R2ML!AssociationAtom)
		)
	to o : XML!Element (
			name <- 'r2ml:AssociationAtom',
			children <- Sequence { if i.isNegated() then    	  -- for isNegated attribute
										thisModule.AtomIsNegated(i)
								   else OclUndefined
								   endif,
								   assocPred,
								   objArgs,
								   if i.dataArguments->size() > 0 then
								   		thisModule.AssociationAtomDataArgs(i)
								   else OclUndefined
								   endif
								   }
		),
	assocPred : XML!Attribute (
			name <- 'r2ml:associationPredicateID',
			value <- i.associationPredicate.name
		),
	objArgs : XML!Element (
			name <- 'r2ml:objectArguments',
			children <- Sequence { i.objectArguments->asSequence()->select(c | c.oclIsTypeOf(R2ML!ObjectVariable))->collect(c | thisModule.ObjectVariable(c)),
								   i.objectArguments->asSequence()->select(c | not c.oclIsTypeOf(R2ML!ObjectVariable))
								 }
		)
}

-- Rule 'AssociationAtomDataArgs'
-- Create XML element (r2ml:dataArguments) for R2ML AssociationAtom element
lazy rule AssociationAtomDataArgs {
	from i : R2ML!AssociationAtom
	to o : XML!Element (
			name <- 'r2ml:dataArguments',
			children <- Sequence { i.dataArguments->asSequence()->select(c | c.oclIsTypeOf(R2ML!DataVariable))->collect(c | thisModule.DataVariable(c)),
								   i.dataArguments->asSequence()->select(c | not c.oclIsTypeOf(R2ML!DataVariable))
								 }
		)
}

-- Rule 'ReferencePropertyFunctionTerm'
-- Create XML element (r2ml:ReferencePropertyFunctionTerm) from the R2ML ReferencePropertyFunctionTerm element
rule ReferencePropertyFunctionTerm {
	from i : R2ML!ReferencePropertyFunctionTerm (
			i.oclIsTypeOf(R2ML!ReferencePropertyFunctionTerm)
		)
	to o : XML!Element (
			name <- 'r2ml:ReferencePropertyFunctionTerm',
			children <- Sequence { refProp, contextArg, 
								   if not i.typeCategory.oclIsUndefined() then
									thisModule.TypeCategory(i)
								   else OclUndefined
								   endif 
								  }
		),
	refProp : XML!Attribute (
			name <- 'r2ml:referencePropertyID',
			value <- i.referencePropertyRef.name
		),
	contextArg : XML!Element (
			name <- 'r2ml:contextArgument',
			children <- Sequence { if i.contextArgument.oclIsTypeOf(R2ML!ObjectVariable) then
									thisModule.ObjectVariable(i.contextArgument)
								   else i.contextArgument
								   endif
								 }
		)
}

-- Rule 'AttributionAtom'
-- Create XML element (r2ml:AttributionAtom) from the R2ML AttributionAtom element
rule AttributionAtom {
	from i : R2ML!AttributionAtom (
			i.oclIsTypeOf(R2ML!AttributionAtom)
		)
	to o : XML!Element (
			name <- 'r2ml:AttributionAtom',
			children <- Sequence { attr, if i.isNegated() then    	  -- for isNegated attribute
									       thisModule.AtomIsNegated(i)
								   		 else OclUndefined
								         endif,
								   subject,
								   dataValue
								 }
		),
	attr : XML!Attribute (
			name <- 'r2ml:attributeID',
			value <- i.attribute.name
		),
	subject : XML!Element (
			name <- 'r2ml:subject',
			children <- Sequence { if i.subject.oclIsTypeOf(R2ML!ObjectVariable) then
										thisModule.ObjectVariable(i.subject)
								   else i.subject
								   endif
								 }
		),
	dataValue : XML!Element (
			name <- 'r2ml:dataValue',
			children <- Sequence { if i.dataValue.oclIsTypeOf(R2ML!DataVariable) then
										thisModule.DataVariable(i.dataValue)
								   else i.dataValue
					 			   endif
								 }
		)
}

-- Rule 'ReferencePropertyAtom'
-- Create XML element (r2ml:ReferencePropertyAtom) from the R2ML ReferencePropertyAtom element
rule ReferencePropertyAtom {
	from i : R2ML!ReferencePropertyAtom (
			i.oclIsTypeOf(R2ML!ReferencePropertyAtom)
		)
	to o : XML!Element (
			name <- 'r2ml:ReferencePropertyAtom',
			children <- Sequence { if i.isNegated() then    	  -- for isNegated attribute
								   	thisModule.AtomIsNegated(i)
								   else OclUndefined
								   endif,
								   refProp,
								   subject,
								   object
								  }
		),
	refProp : XML!Attribute (
			name <- 'r2ml:referencePropertyID',
			value <- i.referenceProperty.name
		),
	subject : XML!Element (
			name <- 'r2ml:subject',
			children <- Sequence { if i.subject.oclIsTypeOf(R2ML!ObjectVariable) then
									thisModule.ObjectVariable(i.subject)
								   else i.subject
								   endif
								}
		),
	object : XML!Element (
			name <- 'r2ml:object',
			children <- Sequence { if i.object.oclIsTypeOf(R2ML!ObjectVariable) then
									thisModule.ObjectVariable(i.object)
								   else i.object
								   endif
								}
		)
}

-- Rule 'GenericAtom'
-- Create XML element (r2ml:GenericAtom) from the R2ML GenericAtom element
rule GenericAtom {
	from i : R2ML!GenericAtom (
			i.oclIsTypeOf(R2ML!GenericAtom)
		)
	to o : XML!Element (
			name <- 'r2ml:GenericAtom',
			children <- Sequence { predicate, args }
		),
	predicate : XML!Attribute (
			name <- 'r2ml:predicateID',
			value <- i.predicate.name
		),
	args : XML!Element (
			name <- 'r2ml:arguments',
			children <- Sequence { i.arguments->asSequence()->select(c | c.oclIsTypeOf(R2ML!GenericVariable))->collect(c | thisModule.GenericVariable(c)),
								   i.arguments->asSequence()->select(c | c.oclIsTypeOf(R2ML!ObjectVariable))->collect(c | thisModule.ObjectVariable(c)),
								   i.arguments->asSequence()->select(c | c.oclIsTypeOf(R2ML!DataVariable))->collect(c | thisModule.DataVariable(c)),
								   i.arguments->asSequence()->select(c | not c.oclIsKindOf(R2ML!Variable))
								 }
		)
}

-- Rule 'PredicateType'
-- Create XML attribute (r2ml:predicateType) for R2ML GenericAtom element
lazy rule PredicateType {
	from i : R2ML!GenericPredicate
	to o : XML!Attribute (
			name <- 'r2ml:predicateType',
			value <- if i.predicateTypeID = #ObjectClassificationPredicate then
						'ObjectClassificationPredicate'
						else if i.predicateTypeID = #AttributionPredicate then
							  'AttributionPredicate'
							 else if i.predicateTypeID = #AssociationPredicate then
								   'AssociationPredicate'
								  else if i.predicateTypeID = #ReferencePropertyPredicate then
									    'ReferencePropertyPredicate'
									   else if i.predicateTypeID = #EqualityPredicate then
										     'EqualityPredicate'
										    else if i.predicateTypeID = #InequalityPredicate then
											      'InequalityPredicate'
											     else if i.predicateTypeID = #DatatypePredicate then
												       'DatatypePredicate'
												      else if i.predicateTypeID = #DataClassificationPredicate then
														    'DataClassificationPredicate'
													       else OclUndefined
													       endif
												      endif
												 endif
											endif 
										endif
								   endif
							 endif 
						endif
		)
}

-- Rule 'GenericFunctionTerm'
-- Create XML element (r2ml:GenericFunctionTerm) from the R2ML GenericFunctionTerm element
rule GenericFunctionTerm {
	from i : R2ML!GenericFunctionTerm (
			i.oclIsTypeOf(R2ML!GenericFunctionTerm)
		)
	to o : XML!Element (
			name <- 'r2ml:GenericFunctionTerm',
			children <- Sequence { attr, args }
		),
	attr : XML!Attribute (
			name <- 'r2ml:genericFunctionID',
			value <- i.functor.name
		),
	args : XML!Element ( 
			name <- 'r2ml:arguments',
			children <- Sequence { i.arguments->asSequence()->select(c | c.oclIsTypeOf(R2ML!GenericVariable))->collect(c | thisModule.GenericVariable(c)),
								   i.arguments->asSequence()->select(c | not c.oclIsTypeOf(R2ML!GenericVariable)),
								   if not i.typeCategory.oclIsUndefined() then
									thisModule.TypeCategory(i)
								   else OclUndefined
								   endif 
								 }
		)
}

-- Rule 'DatatypeFunctionTerm'
-- Create XML element (r2ml:DatatypeFunctionTerm) from the R2ML DatatypeFunctionTerm element
rule DatatypeFunctionTerm {
	from i : R2ML!DatatypeFunctionTerm (
			i.oclIsTypeOf(R2ML!DatatypeFunctionTerm)
		)
	to o : XML!Element (
			name <- 'r2ml:DatatypeFunctionTerm',
			children <- Sequence { attr, args }
		),
	attr : XML!Attribute (
			name <- 'datatypeFunctionID',
			value <- i.function.name
		),
	args : XML!Element (
			name <- 'r2ml:dataArguments',
			children <- Sequence { i.dataArguments->asSequence()->select(c | c.oclIsTypeOf(R2ML!DataVariable))->collect(c | thisModule.DataVariable(c)),
								   i.dataArguments->asSequence()->select(c | not c.oclIsTypeOf(R2ML!DataVariable)),
								   if not i.typeCategory.oclIsUndefined() then
									thisModule.TypeCategory(i)
								   else OclUndefined
								   endif 
								 }						
		)
}

-- Rule 'ObjectName'
-- Create XML element (r2ml:ObjectName) from the R2ML ObjectName element
rule ObjectName {
	from i : R2ML!ObjectName (
			i.oclIsTypeOf(R2ML!ObjectName)
		)
	to o : XML!Element (
			name <- 'r2ml:ObjectName',
			children <- Sequence { attr, if not i.classRef.oclIsUndefined() then 
											thisModule.ClassRule(i.classRef)
										 else OclUndefined
										 endif,
										 if not i.typeCategory.oclIsUndefined() then
											thisModule.TypeCategory(i)
								  		 else OclUndefined
								   		 endif
								 }
		),
	attr : XML!Attribute (
			name <- 'r2ml:objectID',
			value <- i.name
		)
}

-- Rule 'ObjectDescriptionAtom'
-- Create XML element (r2ml:ObjectDescriptionAtom) from the R2ML ObjectDescriptionAtom element
rule ObjectDescriptionAtom {
	from i : R2ML!ObjectDescriptionAtom (
			i.oclIsTypeOf(R2ML!ObjectDescriptionAtom)
		)
	to o : XML!Element (
			name <- 'r2ml:ObjectDescriptionAtom',
			children <- Sequence { class, if not i.baseType.oclIsUndefined then 
											thisModule.ClassRule(i.baseType)
										  else OclUndefined 
										  endif,
								   subject,
								   i.slots,
								   objects
			}
		),
	class : XML!Attribute (
			name <- 'r2ml:classID',
			value <- i.type.name
		),
	subject : XML!Element (
			name <- 'r2ml:subject',
			children <- Sequence { if i.subject.oclIsTypeOf(R2ML!ObjectVariable) then 
									thisModule.ObjectVariable(i.subject)
								   else i.subject
								   endif
								 }
		),
	objects : XML!Element (
			name <- 'r2ml:objects',
			children <- i.objects
		)
}

-- Rule 'ObjectSlot'
-- Create XML element (r2ml:ObjectSlot) from the R2ML ObjectSlot element
rule ObjectSlot {
	from i : R2ML!ObjectSlot (
			i.oclIsTypeOf(R2ML!ObjectSlot)
		)
	to o : XML!Element (
			name <- 'r2ml:ObjectSlot',
			children <- Sequence { attr, object }
		),
	attr : XML!Attribute (
			name <- 'r2ml:referencePropertyID',
			value <- i.referenceProperty.name
		),
	object : XML!Element (
			name <- 'r2ml:object',
			children <- Sequence { if i.object.oclIsTypeOf(R2ML!ObjectVariable) then 
									thisModule.ObjectVariable(i.object)
								   else i.object
								   endif
								 }
		)
}

-- Rule 'DataSlot'
-- Create XML element (r2ml:DataSlot) from the R2ML DataSlot element
rule DataSlot {
	from i : R2ML!DataSlot (
			i.oclIsTypeOf(R2ML!DataSlot)
		)
	to o : XML!Element (
			name <- 'r2ml:DataSlot',
			children <- Sequence { attr, value }
		),
	attr : XML!Attribute (
			name <- 'r2ml:attributeID',
			value <- i.attribute.name
		),
	value : XML!Element (
			name <- 'r2ml:value',
			children <- Sequence { if i.value.oclIsTypeOf(R2ML!DataVariable) then 
									thisModule.DataVariable(i.value)
								   else i.value
								   endif
								 }
		)
}

-- Rule 'AtLeastQuantifiedFormula'
-- Create XML element (r2ml:AtLeastQuantifiedFormula) from the R2ML AtLeastQuantifiedFormula element 
rule AtLeastQuantifiedFormula {
	from i : R2ML!AtLeastQuantifiedFormula (
			i.oclIsTypeOf(R2ML!AtLeastQuantifiedFormula)
		)
	to o : XML!Element (
			name <- 'r2ml:AtLeastQuantifiedFormula',
			children <- Sequence {
							attr,
							i.variables->asSequence()->select(c | c.oclIsTypeOf(R2ML!ObjectVariable))->collect(e | thisModule.ObjectVariable(e)),
							i.variables->asSequence()->select(c | c.oclIsTypeOf(R2ML!DataVariable))->collect(e | thisModule.DataVariable(e)),
							i.formula
						}
  		  ),
		attr : XML!Attribute (
			name <- 'r2ml:minCardinality',
			value <- i.minCardinality.toString()
		)
}

-- Rule 'AtMostQuantifiedFormula'
-- Create XML element (r2ml:AtMostQuantifiedFormula) from the R2ML AtMostQuantifiedFormula element 
rule AtMostQuantifiedFormula {
	from i : R2ML!AtMostQuantifiedFormula (
			i.oclIsTypeOf(R2ML!AtMostQuantifiedFormula)
		)
	to o : XML!Element (
			name <- 'r2ml:AtMostQuantifiedFormula',
			children <- Sequence {
							attr,
							i.variables->asSequence()->select(c | c.oclIsTypeOf(R2ML!ObjectVariable))->collect(e | thisModule.ObjectVariable(e)),
							i.variables->asSequence()->select(c | c.oclIsTypeOf(R2ML!DataVariable))->collect(e | thisModule.DataVariable(e)),
							i.formula
						}
  		  ),
		attr : XML!Attribute (
			name <- 'r2ml:maxCardinality',
			value <- i.maxCardinality.toString()
		)
}

-- Rule 'AtLeastAndAtMostQuantifiedFormula'
-- Create XML element (r2ml:AtLeastAndAtMostQuantifiedFormula) from the R2ML AtLeastAndAtMostQuantifiedFormula element.
rule AtLeastAndAtMostQuantifiedFormula {
	from i : R2ML!AtLeastAndAtMostQuantifiedFormula (
			i.oclIsTypeOf(R2ML!AtLeastAndAtMostQuantifiedFormula)
		)
	to o : XML!Element (
			name <- 'r2ml:AtLeastAndAtMostQuantifiedFormula',
			children <- Sequence {
							attrMax, attrMin,
							i.variables->asSequence()->select(c | c.oclIsTypeOf(R2ML!ObjectVariable))->collect(e | thisModule.ObjectVariable(e)),
							i.variables->asSequence()->select(c | c.oclIsTypeOf(R2ML!DataVariable))->collect(e | thisModule.DataVariable(e)),
							i.formula
						}
  		  ),
		attrMax : XML!Attribute (
			name <- 'r2ml:maxCardinality',
			value <- i.maxCardinality.toString()
		),
		attrMin : XML!Attribute (
			name <- 'r2ml:minCardinality',
			value <- i.minCardinality.toString()
		)
}

-- Rule 'ObjectOperationTerm'
-- Create XML element (r2ml:ObjectOperationTerm) from the R2ML ObjectOperationTerm element.
rule ObjectOperationTerm {
	from i : R2ML!ObjectOperationTerm (
			i.oclIsTypeOf(R2ML!ObjectOperationTerm)
		)
	to o : XML!Element (
			name <- 'r2ml:ObjectOperationTerm',
			children <- Sequence { operation, contextArg, 
					
													-- TODO: ObjectOperationTermArgs ?
													if i.arguments->size() > 0 then
															i.arguments
														  else OclUndefined
														  endif
								  }
		),
	operation : XML!Attribute (
			name <- 'r2ml:operationID',
			value <- i.operation.name
		),
	contextArg : XML!Element (
			name <- 'r2ml:contextArgument',
			children <- Sequence { if i.contextArgument.oclIsTypeOf(R2ML!ObjectVariable) then
									thisModule.ObjectVariable(i.contextArgument)
								   else i.contextArgument
								   endif
								 }
		)
}


-- Rule 'DataOperationTerm'
-- Create XML element (r2ml:DataOperationTerm) from the R2ML DataOperationTerm element 
rule DataOperationTerm {
	from i : R2ML!DataOperationTerm (
			i.oclIsTypeOf(R2ML!DataOperationTerm)
		)
	to o : XML!Element (
			name <- 'r2ml:DataOperationTerm',
			children <- Sequence { attr, if i.arguments->size() > 0 then
											thisModule.DataOperationTermArgs(i)
											else OclUndefined
											endif, 
											contArg,
										 if not i.typeCategory.oclIsUndefined() then
										 	thisModule.TypeCategory(i)
										 else OclUndefined
										 endif
								 }
		),
	attr : XML!Attribute (
			name <- 'r2ml:operationID',
			value <- i.dataOperationRef.name
		),
	contArg : XML!Element (
			name <- 'r2ml:contextArgument',
			children <- Sequence { if i.contextArgument.oclIsTypeOf(R2ML!ObjectVariable) then
									thisModule.ObjectVariable(i.contextArgument)
								   else i.contextArgument	
								   endif
								 }
		)
}
",transform r ml metamodel xml metamodel creat part m sc these good old ai laboratori author milan milanov milan milanov org work r ml v licenc gnu general public licens version modul r ml xml modul templat creat out xml in r ml use string helper helper isneg check atom negat if properti defin fals context r ml atom out boolean helper context r ml atom def isneg boolean self isneg oclisundefin fals els self isneg endif rule rule rulebas creat xml root element r ml rulebas r ml rulebas element rule rulebas r ml rulebas oclistypeof r ml rulebas xml root name r ml rulebas children sequenc dc schema r ml xsi rule dc xml attribut name xmlns dc valu http purl org dc element schema xml attribut name xsi schemaloc valu http www rewers net i r ml http oxygen informatik tu cottbus de r ml r ml xsd r ml xml attribut name xmlns r ml valu http www rewers net i r ml xsi xml attribut name xmlns xsi valu http www w org xmlschema instanc rule derivationruleset creat xml element r ml derivationruleset r ml derivationruleset element rule derivationruleset r ml derivationruleset oclistypeof r ml derivationruleset xml element name r ml derivationruleset children rule rule integrityruleset creat xml element r ml integrityruleset r ml integrityruleset element rule integrityruleset r ml integrityruleset oclistypeof r ml integrityruleset xml element name r ml integrityruleset children rule rule reactionruleset creat xml element r ml reactionruleset r ml reactionruleset element rule reactionruleset r ml reactionruleset oclistypeof r ml reactionruleset xml element name r ml reactionruleset children rule rule productionruleset creat xml element r ml productionruleset r ml productionruleset element rule productionruleset r ml productionruleset oclistypeof r ml productionruleset xml element name r ml productionruleset children rule rule alethicintegrityrul creat xml element r ml alethicintegrityrul r ml alethicintegrityrul element rule alethicintegrityrul r ml alethicintegrityrul oclistypeof r ml alethicintegrityrul xml element name r ml alethicintegrityrul children sequenc ruleid oclisundefin thismodul ruleid els oclundefin endif constraint constraint xml element name r ml constraint children sequenc constraint rule ruleid creat xml attribut r ml ruleid r ml rule element lazi rule ruleid r ml rule xml attribut name r ml ruleid valu ruleid rule deonticintegrityrul creat xml element r ml deonticintegrityrul r ml deonticintegrityrul element rule deonticintegrityrul r ml deonticintegrityrul oclistypeof r ml deonticintegrityrul xml element name r ml deonticintegrityrul children sequenc ruleid oclisundefin thismodul ruleid els oclundefin endif constraint constraint xml element name r ml constraint children sequenc constraint rule universallyquantifiedformula creat xml element r ml universallyquantifiedformula r ml universallyquantifiedformula element rule universallyquantifiedformula r ml universallyquantifiedformula oclistypeof r ml universallyquantifiedformula xml element name r ml universallyquantifiedformula children sequenc variabl assequ select c c oclistypeof r ml objectvari collect e thismodul objectvari e variabl assequ select c c oclistypeof r ml datavari collect e thismodul datavari e formula rule existentiallyquantifiedformula creat xml element r ml existentiallyquantifiedformula r ml existentiallyquantifiedformula element rule existentiallyquantifiedformula r ml existentiallyquantifiedformula oclistypeof r ml existentiallyquantifiedformula xml element name r ml existentiallyquantifiedformula children sequenc variabl assequ select c c oclistypeof r ml objectvari collect e thismodul objectvari e variabl assequ select c c oclistypeof r ml datavari collect e thismodul datavari e formula lazi rule classrul creat xml attribut r ml classid r ml class element lazi rule classrul r ml class xml attribut name r ml classid valu name lazi rule objectvari creat xml element r ml objectvari r ml objectvari element lazi rule objectvari r ml objectvari xml element name r ml objectvari children sequenc attrnam classref oclisundefin thismodul classrul classref els oclundefin endif attrnam xml attribut name r ml name valu name lazi rule datavari creat xml element r ml datavari r ml datavari element lazi rule datavari r ml datavari xml element name r ml datavari children sequenc attrnam datatyperef oclisundefin thismodul datatyp datatyperef els oclundefin endif typecategori oclisundefin thismodul typecategori els oclundefin endif attrnam xml attribut name r ml name valu name lazi rule genericvari creat xml element r ml genericvari r ml genericvari element lazi rule genericvari r ml genericvari xml element name r ml genericvari children sequenc attrnam typeref oclisundefin thismodul datatyp typeref els oclundefin endif attrnam xml attribut name r ml name valu name lazi rule datatyp creat xml attribut r ml datatypeid r ml datatyp element lazi rule datatyp r ml datatyp xml attribut name r ml datatypeid valu name rule implic creat xml element r ml implic r ml implic element rule implic r ml implic oclistypeof r ml implic xml element name r ml implic children sequenc ant con ant xml element name r ml anteced children anteced con xml element name r ml consequ children consequ rule conjuct creat xml element r ml conjuct r ml conjuct element rule conjuct r ml conjuct oclistypeof r ml conjuct xml element name r ml conjunct children formula rule disjunct creat xml element r ml disjunct r ml disjunct element rule disjunct r ml disjunct oclistypeof r ml disjunct xml element name r ml disjunct children formula rule negationasfailur creat xml element r ml negationasfailur r ml negationasfailur element rule negationasfailur r ml negationasfailur oclistypeof r ml negationasfailur xml element name r ml negationasfailur children sequenc formula rule strongneg creat xml element r ml strongneg r ml strongneg element rule strongneg r ml strongneg oclistypeof r ml strongneg xml element name r ml strongneg children sequenc formula rule equalityatom creat xml element r ml equalityatom r ml equalityatom element rule equalityatom r ml equalityatom oclistypeof r ml equalityatom xml element name r ml equalityatom children sequenc term select c c oclistypeof r ml objectvari collect e thismodul objectvari e term select c c oclistypeof r ml objectvari rule inequalityatom creat xml element r ml inequalityatom r ml inequalityatom element rule inequalityatom r ml inequalityatom oclistypeof r ml inequalityatom xml element name r ml inequalityatom children sequenc term select c c oclistypeof r ml objectvari collect e thismodul objectvari e term select c c oclistypeof r ml objectvari rule derivationrul creat xml element r ml derivationrul r ml derivationrul element rule derivationrul r ml derivationrul oclistypeof r ml derivationrul xml element name r ml derivationrul children sequenc ruleid oclisundefin thismodul ruleid els oclundefin endif condit conclus condit xml element name r ml condit children condit conclus xml element name r ml conclus children conclus assequ collect c c atom flatten assequ collect literalconjuct rule objectclassificationatom creat xml element r ml objectclassificationatom r ml objectclassificationatom element rule objectclassificationatom r ml objectclassificationatom oclistypeof r ml objectclassificationatom xml element name r ml objectclassificationatom children sequenc isneg isneg attribut thismodul atomisneg els oclundefin endif thismodul classrul type classid attribut thismodul objectvari term term rule atomisneg creat xml attribut r ml isneg r ml atom element lazi rule atomisneg r ml atom xml attribut name r ml isneg valu true rule dataclassificationatom creat xml element r ml dataclassificationatom r ml dataclassificationatom element rule dataclassificationatom r ml dataclassificationatom oclistypeof r ml dataclassificationatom xml element name r ml dataclassificationatom children sequenc isneg isneg attribut thismodul atomisneg els oclundefin endif thismodul datatyp type classid attribut thismodul datavari term term rule qfconjunct creat xml element r ml qf conjuct r ml qfconjunct element rule qfconjunct r ml qfconjunct oclistypeof r ml qfconjunct xml element name r ml qf conjuct children formula rule qfdisjunct creat xml element r ml qf disjunct r ml qfdisjunct element rule qfdisjunct r ml qfdisjunct oclistypeof r ml qfdisjunct xml element name r ml qf disjunct children formula rule qfnegationasfailur creat xml element r ml qf negationasfailur r ml qfnegationasfailur element rule qfnegationasfailur r ml qfnegationasfailur oclistypeof r ml qfnegationasfailur xml element name r ml qf negationasfailur children sequenc formula rule qfstrongneg creat xml element r ml qf strongneg r ml qfstrongneg element rule qfstrongneg r ml qfstrongneg oclistypeof r ml qfstrongneg xml element name r ml qf strongneg children sequenc formula rule datatypepredicateatom creat xml element r ml datatypepredicateatom r ml datatypepredicateatom element rule datatypepredicateatom r ml datatypepredicateatom oclistypeof r ml datatypepredicateatom xml element name r ml datatypepredicateatom children sequenc isneg isneg attribut thismodul atomisneg els oclundefin endif attr dataarg attr xml attribut name r ml datatypepredicateid valu predic name dataarg xml element name r ml dataargu children sequenc dataargu assequ select c c oclistypeof r ml datavari collect c thismodul datavari c dataargu assequ select c c oclistypeof r ml datavari rule typecategori creat xml attribut r ml typecategori r ml term element lazi rule typecategori r ml term xml attribut name r ml typecategori valu typecategori individu individu els typecategori set set els typecategori orderedset order els typecategori bag bag els typecategori sequenc sequenc els oclundefin endif endif endif endif endif rule dataoperationtermarg creat xml element r ml argument r ml dataoperationterm element lazi rule dataoperationtermarg r ml dataoperationterm xml element name r ml argument children sequenc argument assequ select c c oclistypeof r ml objectvari collect c thismodul objectvari c argument assequ select c c oclistypeof r ml datavari collect c thismodul datavari c argument assequ select c c oclistypeof r ml objectvari c oclistypeof r ml datavari rule typedliter creat xml element r ml typedliter r ml typedliter element rule typedliter r ml typedliter oclistypeof r ml typedliter xml element name r ml typedliter children sequenc type valu type xml attribut name r ml datatypeid valu type name valu xml attribut name r ml lexicalvalu valu lexicalvalu rule plainliter creat xml element r ml plainliter r ml plainliter element rule plainliter r ml plainliter oclistypeof r ml plainliter xml element name sequenc languagetag oclisundefin thismodul plainliterallanguagetag els oclundefin endif valu valu xml attribut name r ml lexicalvalu valu lexicalvalu rule plainliterallanguagetag creat xml attribut r ml languagetag r ml plainliter element lazi rule plainliterallanguagetag r ml plainliter xml attribut name r ml languagetag valu languagetag rule attributefunctionterm creat xml element r ml attributefunctionterm r ml attributefunctionterm element rule attributefunctionterm r ml attributefunctionterm oclistypeof r ml attributefunctionterm xml element name r ml attributefunctionterm children sequenc attr contextarg typecategori oclisundefin thismodul typecategori els oclundefin endif attr xml attribut name r ml attributeid valu attribut name contextarg xml element name r ml contextargu children sequenc contextargu oclistypeof r ml objectvari thismodul objectvari contextargu els contextargu endif rule associationatom creat xml element r ml associationatom r ml associationatom element rule associationatom r ml associationatom oclistypeof r ml associationatom xml element name r ml associationatom children sequenc isneg isneg attribut thismodul atomisneg els oclundefin endif assocpr objarg dataargu size thismodul associationatomdataarg els oclundefin endif assocpr xml attribut name r ml associationpredicateid valu associationpred name objarg xml element name r ml objectargu children sequenc objectargu assequ select c c oclistypeof r ml objectvari collect c thismodul objectvari c objectargu assequ select c c oclistypeof r ml objectvari rule associationatomdataarg creat xml element r ml dataargu r ml associationatom element lazi rule associationatomdataarg r ml associationatom xml element name r ml dataargu children sequenc dataargu assequ select c c oclistypeof r ml datavari collect c thismodul datavari c dataargu assequ select c c oclistypeof r ml datavari rule referencepropertyfunctionterm creat xml element r ml referencepropertyfunctionterm r ml referencepropertyfunctionterm element rule referencepropertyfunctionterm r ml referencepropertyfunctionterm oclistypeof r ml referencepropertyfunctionterm xml element name r ml referencepropertyfunctionterm children sequenc refprop contextarg typecategori oclisundefin thismodul typecategori els oclundefin endif refprop xml attribut name r ml referencepropertyid valu referencepropertyref name contextarg xml element name r ml contextargu children sequenc contextargu oclistypeof r ml objectvari thismodul objectvari contextargu els contextargu endif rule attributionatom creat xml element r ml attributionatom r ml attributionatom element rule attributionatom r ml attributionatom oclistypeof r ml attributionatom xml element name r ml attributionatom children sequenc attr isneg isneg attribut thismodul atomisneg els oclundefin endif subject datavalu attr xml attribut name r ml attributeid valu attribut name subject xml element name r ml subject children sequenc subject oclistypeof r ml objectvari thismodul objectvari subject els subject endif datavalu xml element name r ml datavalu children sequenc datavalu oclistypeof r ml datavari thismodul datavari datavalu els datavalu endif rule referencepropertyatom creat xml element r ml referencepropertyatom r ml referencepropertyatom element rule referencepropertyatom r ml referencepropertyatom oclistypeof r ml referencepropertyatom xml element name r ml referencepropertyatom children sequenc isneg isneg attribut thismodul atomisneg els oclundefin endif refprop subject object refprop xml attribut name r ml referencepropertyid valu referenceproperti name subject xml element name r ml subject children sequenc subject oclistypeof r ml objectvari thismodul objectvari subject els subject endif object xml element name r ml object children sequenc object oclistypeof r ml objectvari thismodul objectvari object els object endif rule genericatom creat xml element r ml genericatom r ml genericatom element rule genericatom r ml genericatom oclistypeof r ml genericatom xml element name r ml genericatom children sequenc predic arg predic xml attribut name r ml predicateid valu predic name arg xml element name r ml argument children sequenc argument assequ select c c oclistypeof r ml genericvari collect c thismodul genericvari c argument assequ select c c oclistypeof r ml objectvari collect c thismodul objectvari c argument assequ select c c oclistypeof r ml datavari collect c thismodul datavari c argument assequ select c c ocliskindof r ml variabl rule predicatetyp creat xml attribut r ml predicatetyp r ml genericatom element lazi rule predicatetyp r ml genericpred xml attribut name r ml predicatetyp valu predicatetypeid objectclassificationpred objectclassificationpred els predicatetypeid attributionpred attributionpred els predicatetypeid associationpred associationpred els predicatetypeid referencepropertypred referencepropertypred els predicatetypeid equalitypred equalitypred els predicatetypeid inequalitypred inequalitypred els predicatetypeid datatypepred datatypepred els predicatetypeid dataclassificationpred dataclassificationpred els oclundefin endif endif endif endif endif endif endif endif rule genericfunctionterm creat xml element r ml genericfunctionterm r ml genericfunctionterm element rule genericfunctionterm r ml genericfunctionterm oclistypeof r ml genericfunctionterm xml element name r ml genericfunctionterm children sequenc attr arg attr xml attribut name r ml genericfunctionid valu functor name arg xml element name r ml argument children sequenc argument assequ select c c oclistypeof r ml genericvari collect c thismodul genericvari c argument assequ select c c oclistypeof r ml genericvari typecategori oclisundefin thismodul typecategori els oclundefin endif rule datatypefunctionterm creat xml element r ml datatypefunctionterm r ml datatypefunctionterm element rule datatypefunctionterm r ml datatypefunctionterm oclistypeof r ml datatypefunctionterm xml element name r ml datatypefunctionterm children sequenc attr arg attr xml attribut name datatypefunctionid valu function name arg xml element name r ml dataargu children sequenc dataargu assequ select c c oclistypeof r ml datavari collect c thismodul datavari c dataargu assequ select c c oclistypeof r ml datavari typecategori oclisundefin thismodul typecategori els oclundefin endif rule objectnam creat xml element r ml objectnam r ml objectnam element rule objectnam r ml objectnam oclistypeof r ml objectnam xml element name r ml objectnam children sequenc attr classref oclisundefin thismodul classrul classref els oclundefin endif typecategori oclisundefin thismodul typecategori els oclundefin endif attr xml attribut name r ml objectid valu name rule objectdescriptionatom creat xml element r ml objectdescriptionatom r ml objectdescriptionatom element rule objectdescriptionatom r ml objectdescriptionatom oclistypeof r ml objectdescriptionatom xml element name r ml objectdescriptionatom children sequenc class basetyp oclisundefin thismodul classrul basetyp els oclundefin endif subject slot object class xml attribut name r ml classid valu type name subject xml element name r ml subject children sequenc subject oclistypeof r ml objectvari thismodul objectvari subject els subject endif object xml element name r ml object children object rule objectslot creat xml element r ml objectslot r ml objectslot element rule objectslot r ml objectslot oclistypeof r ml objectslot xml element name r ml objectslot children sequenc attr object attr xml attribut name r ml referencepropertyid valu referenceproperti name object xml element name r ml object children sequenc object oclistypeof r ml objectvari thismodul objectvari object els object endif rule dataslot creat xml element r ml dataslot r ml dataslot element rule dataslot r ml dataslot oclistypeof r ml dataslot xml element name r ml dataslot children sequenc attr valu attr xml attribut name r ml attributeid valu attribut name valu xml element name r ml valu children sequenc valu oclistypeof r ml datavari thismodul datavari valu els valu endif rule atleastquantifiedformula creat xml element r ml atleastquantifiedformula r ml atleastquantifiedformula element rule atleastquantifiedformula r ml atleastquantifiedformula oclistypeof r ml atleastquantifiedformula xml element name r ml atleastquantifiedformula children sequenc attr variabl assequ select c c oclistypeof r ml objectvari collect e thismodul objectvari e variabl assequ select c c oclistypeof r ml datavari collect e thismodul datavari e formula attr xml attribut name r ml mincardin valu mincardin tostr rule atmostquantifiedformula creat xml element r ml atmostquantifiedformula r ml atmostquantifiedformula element rule atmostquantifiedformula r ml atmostquantifiedformula oclistypeof r ml atmostquantifiedformula xml element name r ml atmostquantifiedformula children sequenc attr variabl assequ select c c oclistypeof r ml objectvari collect e thismodul objectvari e variabl assequ select c c oclistypeof r ml datavari collect e thismodul datavari e formula attr xml attribut name r ml maxcardin valu maxcardin tostr rule atleastandatmostquantifiedformula creat xml element r ml atleastandatmostquantifiedformula r ml atleastandatmostquantifiedformula element rule atleastandatmostquantifiedformula r ml atleastandatmostquantifiedformula oclistypeof r ml atleastandatmostquantifiedformula xml element name r ml atleastandatmostquantifiedformula children sequenc attrmax attrmin variabl assequ select c c oclistypeof r ml objectvari collect e thismodul objectvari e variabl assequ select c c oclistypeof r ml datavari collect e thismodul datavari e formula attrmax xml attribut name r ml maxcardin valu maxcardin tostr attrmin xml attribut name r ml mincardin valu mincardin tostr rule objectoperationterm creat xml element r ml objectoperationterm r ml objectoperationterm element rule objectoperationterm r ml objectoperationterm oclistypeof r ml objectoperationterm xml element name r ml objectoperationterm children sequenc oper contextarg todo objectoperationtermarg argument size argument els oclundefin endif oper xml attribut name r ml operationid valu oper name contextarg xml element name r ml contextargu children sequenc contextargu oclistypeof r ml objectvari thismodul objectvari contextargu els contextargu endif rule dataoperationterm creat xml element r ml dataoperationterm r ml dataoperationterm element rule dataoperationterm r ml dataoperationterm oclistypeof r ml dataoperationterm xml element name r ml dataoperationterm children sequenc attr argument size thismodul dataoperationtermarg els oclundefin endif contarg typecategori oclisundefin thismodul typecategori els oclundefin endif attr xml attribut name r ml operationid valu dataoperationref name contarg xml element name r ml contextargu children sequenc contextargu oclistypeof r ml objectvari thismodul objectvari contextargu els contextargu endif,6
182,182,P79-RDM2R2ML.atl,"-- ============================================================
-- Transforms an RDM metamodel into R2ML metamodel.
-- Created as part of M.Sc. theses at GOOD OLD AI Laboratory
-- Author: Milan Milanovic (milan at milanovic.org)
-- Works for R2ML v0.4 (Integrity and Derivation rules)
-- Licence: GNU General Public License, version 2
-- ============================================================

module RDM2R2ML; -- Module Template
create OUT : R2ML from IN : RDM;

uses strings;

-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

---------------------------------------------------------------------
-- Helpers for searching on Class elements for Atoms Predicate Symbol
---------------------------------------------------------------------

-- HELPER: getAtomForClassElement
-- Returns atom which contains cla Class element in hasPredicateSymbol, or
-- in childrens of predicate symbol.
-- This helper is needed because we want to find (for some element) in which
-- Atom it's containted, for getting terms of that Atom.
-- IN:		RDM!Class
-- OUT:		RDM!Atom
helper def: getAtomForClassElement(cla : RDM!Class) : RDM!Atom = 
	let allAtoms : Sequence(RDM!Atom) = RDM!Atom.allInstancesFrom('IN')->asSequence()->select(c | c.hasPredicateSymbol.oclIsKindOf(RDM!Class)) in
		allAtoms->iterate(p; res : RDM!Atom = allAtoms->first() |
			if(p.childrenClasses(cla)->includes(cla))
				then p
				else res
				endif
		);

-- HELPER: childrenClasses
-- Returns all children classes for predicate symbol of Atom.
-- It's returns not only Class, but all elements which inherit Class. 
-- CONTEXT:	RDM!Atom
-- IN:		RDM!Class
-- OUT:		Sequence(RDM!Class)
helper context RDM!Atom def: childrenClasses(cla : RDM!Class) : Sequence(RDM!Class) = 
	if self.hasPredicateSymbol.oclIsTypeOf(RDM!Class)
		then Sequence{self.hasPredicateSymbol}
		else Sequence{self.hasPredicateSymbol.childrenClasses(cla)}->flatten()
	endif;
	
-- HELPER: childrenClasses
-- Returns all children classes for IntersectionClass. If this class contains 
-- some other elements, then this helper is called for that elements.
-- CONTEXT:	RDM!IntersectionClass
-- IN:		RDM!Class
-- OUT:		Sequence(RDM!Class)
helper context RDM!IntersectionClass def: childrenClasses(cla : RDM!Class) : Sequence(RDM!Class) = 
	let allClasses : Sequence(RDM!Class) = self.intersectionOf->select(e | e.oclIsTypeOf(RDM!Class)) in
		allClasses.union(self.intersectionOf->select(e | not e.oclIsTypeOf(RDM!Class))->collect(c | c.childrenClasses(cla))->flatten())->append(self);

-- HELPER: childrenClasses
-- Returns all children classes for UnionClass. If this class contains 
-- some other elements, then this helper is called for that elements.
-- CONTEXT:	RDM!UnionClass
-- IN:		RDM!Class
-- OUT:		Sequence(RDM!Class)
helper context RDM!UnionClass def: childrenClasses(cla : RDM!Class) : Sequence(RDM!Class) = 
	let allClasses : Sequence(RDM!Class) = self.unionOf->select(e | e.oclIsTypeOf(RDM!Class)) in
		allClasses.union(self.unionOf->select(e | not e.oclIsTypeOf(RDM!Class))->collect(c | c.childrenClasses(cla))->flatten())->append(self);

-- HELPER: childrenClasses
-- Returns all children classes for ComplementClass. If this class contains 
-- some other elements, then this helper is called for that elements.
-- CONTEXT:	RDM!ComplementClass
-- IN:		RDM!Class
-- OUT:		Sequence(RDM!Class)
helper context RDM!ComplementClass def: childrenClasses(cla : RDM!Class) : Sequence(RDM!Class) = 
	if(self.complementOf.oclIsTypeOf(RDM!Class)) then
		Sequence{self.complementOf}->append(self)
	else self.complementOf.childrenClasses(cla)->append(self)
	endif;

-- HELPER: childrenClasses
-- Returns all children classes for EnumeratedClass. 
-- This class doesn't have any children classes.
-- CONTEXT:	RDM!EnumeratedClass
-- IN:		RDM!Class
-- OUT:		Sequence(RDM!Class)
helper context RDM!EnumeratedClass def: childrenClasses(cla : RDM!Class) : Sequence(RDM!Class) = 
	self.oneOf->asSequence();

-- HELPER: childrenClasses
-- Returns all children classes for HasValueRestriction. 
-- This class doesn't have any children classes.
-- CONTEXT:	RDM!HasValueRestriction
-- IN:		RDM!Class
-- OUT:		Sequence(RDM!Class)
helper context RDM!HasValueRestriction def: childrenClasses(cla : RDM!Class) : Sequence(RDM!Class) = 
	Sequence{self};
	
-- HELPER: childrenClasses
-- Returns all children classes for MinCardinalityRestriction. 
-- This class doesn't have any children classes.
-- CONTEXT:	RDM!MinCardinalityRestriction
-- IN:		RDM!Class
-- OUT:		Sequence(RDM!Class)
helper context RDM!MinCardinalityRestriction def: childrenClasses(cla : RDM!Class) : Sequence(RDM!Class) = 
	Sequence{self};

-- HELPER: childrenClasses
-- Returns all children classes for MaxCardinalityRestriction. 
-- This class doesn't have any children classes.
-- CONTEXT:	RDM!MaxCardinalityRestriction
-- IN:		RDM!Class
-- OUT:		Sequence(RDM!Class)
helper context RDM!MaxCardinalityRestriction def: childrenClasses(cla : RDM!Class) : Sequence(RDM!Class) = 
	Sequence{self};
	
-- HELPER: childrenClasses
-- Returns all children classes for CardinalityRestriction. 
-- This class doesn't have any children classes.
-- CONTEXT:	RDM!CardinalityRestriction
-- IN:		RDM!Class
-- OUT:		Sequence(RDM!Class)
helper context RDM!CardinalityRestriction def: childrenClasses(cla : RDM!Class) : Sequence(RDM!Class) = 
	Sequence{self};	

-- HELPER: childrenClasses
-- Returns all children classes for SomeValuesFromRestriction. If this class contains 
-- some other elements, then this helper is called for that elements.
-- CONTEXT:	RDM!SomeValuesFromRestriction
-- IN:		RDM!Class
-- OUT:		Sequence(RDM!Class)
helper context RDM!SomeValuesFromRestriction def: childrenClasses(cla : RDM!Class) : Sequence(RDM!Class) =
	if(not self.someValuesFromClass.oclIsUndefined()) then
		Sequence{self.someValuesFromClass}->append(self)
	else Sequence {self}
	endif;	

-- HELPER: childrenClasses
-- Returns all children classes for AllValuesFromRestriction. If this class contains 
-- some other elements, then this helper is called for that elements.
-- CONTEXT:	RDM!AllValuesFromRestriction
-- IN:		RDM!Class
-- OUT:		Sequence(RDM!Class)
helper context RDM!AllValuesFromRestriction def: childrenClasses(cla : RDM!Class) : Sequence(RDM!Class) =
	if(not self.allValuesFromClass.oclIsUndefined()) then
		Sequence{self.allValuesFromClass}->append(self)
	else Sequence {self}
	endif;	
	
-- HELPER: childrenClasses
-- Returns all children classes for ObjectProperty. 
-- This class doesn't have any children classes.
-- CONTEXT:	RDM!ObjectProperty
-- IN:		RDM!Class
-- OUT:		Sequence(RDM!Class)
helper context RDM!ObjectProperty def: childrenClasses(cla : RDM!Class) : Sequence(RDM!Class) = 
	Sequence{};	

---------------------------------------------------------------------
-- Helpers for searching on Data elements for Atoms Predicate Symbol
---------------------------------------------------------------------

-- HELPER: getAtomForDataElement
-- Returns atom which contains dtp OntologyElement element in hasPredicateSymbol, or
-- in childrens of predicate symbol.
-- This helper is needed because we want to find (for some element) in which
-- Atom it's containted, for getting terms of that Atom.
-- Annotation: we use OntologyElement, instead of Datatype becase we want to
--             include DataRange element, which is not Datatype (but Class).
-- IN:		RDM!OntologyElement
-- OUT:		RDM!Atom
helper def: getAtomForDataElement(dtp : RDM!OntologyElement) : RDM!Atom = 
	let allAtoms : Sequence(RDM!Atom) = RDM!Atom.allInstancesFrom('IN')->asSequence()->select(c | c.hasPredicateSymbol.oclIsKindOf(RDM!OntologyElement)) in
		allAtoms->iterate(p; res : RDM!Atom = allAtoms->first() |
			if(p.childrenElems(dtp)->includes(dtp))
				then p
				else res
				endif
		);

-- HELPER: childrenElems
-- Returns all children data elements for predicate symbol of Atom.
-- It's returns not only Datatypes, but also DataRange. 
-- CONTEXT:	RDM!Atom
-- IN:		RDM!OntologyElement
-- OUT:		Sequence(RDM!OntologyElement)
helper context RDM!Atom def: childrenElems(ont : RDM!OntologyElement) : Sequence(RDM!OntologyElement) = 
	if self.hasPredicateSymbol.oclIsKindOf(RDM!Datatype) or self.hasPredicateSymbol.oclIsTypeOf(RDM!DataRange)
		then Sequence{self.hasPredicateSymbol.childrenElems(ont)}->flatten()
		else Sequence{self.hasPredicateSymbol}
	endif;

-- HELPER: childrenElems
-- Returns all children data elements for DataRange.
-- CONTEXT:	RDM!DataRange
-- IN:		RDM!OntologyElement
-- OUT:		Sequence(RDM!OntologyElement)
helper context RDM!DataRange def: childrenElems(dtp : RDM!OntologyElement) : Sequence(RDM!OntologyElement) = 
	if self.oneOf.oclIsUndefined()
		then Sequence {self.datatype}->append(self)
		else self.oneOf->select(e | e.oclIsKindOf(RDM!OntologyElement))->append(self)
		endif;

-- HELPER: childrenElems
-- Returns all children data elements for AllValuesFromRestriction.
-- CONTEXT:	RDM!AllValuesFromRestriction
-- IN:		RDM!OntologyElement
-- OUT:		Sequence(RDM!OntologyElement)
helper context RDM!AllValuesFromRestriction def: childrenElems(dtp : RDM!OntologyElement) : Sequence(RDM!OntologyElement) = 
	self.allValuesFromRange.oneOf->select(e | e.oclIsKindOf(RDM!OntologyElement))->append(self);

-- HELPER: childrenElems
-- Returns all children data elements for SomeValuesFromRestriction.
-- CONTEXT:	RDM!SomeValuesFromRestriction
-- IN:		RDM!OntologyElement
-- OUT:		Sequence(RDM!OntologyElement)
helper context RDM!SomeValuesFromRestriction def: childrenElems(dtp : RDM!OntologyElement) : Sequence(RDM!OntologyElement) = 
	self.someValuesFromRange.oneOf->select(e | e.oclIsKindOf(RDM!OntologyElement))->append(self);

-- HELPER: childrenElems
-- Returns all children data elements for HasValueRestriction.
-- CONTEXT:	RDM!HasValueRestriction
-- IN:		RDM!OntologyElement
-- OUT:		Sequence(RDM!OntologyElement)
helper context RDM!HasValueRestriction def: childrenElems(dtp : RDM!OntologyElement) : Sequence(RDM!OntologyElement) = 
	Sequence{self.hasLiteralValue}->append(self);
	
-- HELPER: childrenElems
-- Returns all children data elements for MinCardinalityRestriction.
-- CONTEXT:	RDM!MinCardinalityRestriction
-- IN:		RDM!OntologyElement
-- OUT:		Sequence(RDM!OntologyElement)
helper context RDM!MinCardinalityRestriction def: childrenElems(dtp : RDM!OntologyElement) : Sequence(RDM!OntologyElement) = 
	Sequence{self};

-- HELPER: childrenElems
-- Returns all children data elements for MaxCardinalityRestriction.
-- CONTEXT:	RDM!MaxCardinalityRestriction
-- IN:		RDM!OntologyElement
-- OUT:		Sequence(RDM!OntologyElement)
helper context RDM!MaxCardinalityRestriction def: childrenElems(dtp : RDM!OntologyElement) : Sequence(RDM!OntologyElement) = 
	Sequence{self};

-- HELPER: childrenElems
-- Returns all children data elements for CardinalityRestriction.
-- CONTEXT:	RDM!CardinalityRestriction
-- IN:		RDM!OntologyElement
-- OUT:		Sequence(RDM!OntologyElement)
helper context RDM!CardinalityRestriction def: childrenElems(dtp : RDM!OntologyElement) : Sequence(RDM!OntologyElement) = 
	Sequence{self};	

-- HELPER: childrenElems
-- Returns all children data elements for Literal. It works also for elements
-- which extends Literal (TypedLiteral, PlainLiteral).
-- CONTEXT:	RDM!Literal
-- IN:		RDM!OntologyElement
-- OUT:		Sequence(RDM!OntologyElement)
helper context RDM!Literal def: childrenElems(dtp : RDM!OntologyElement) : Sequence(RDM!OntologyElement) =
	Sequence{self};
	
-- HELPER: childrenElems
-- Returns all children data elements for PrimitiveType. 
-- CONTEXT:	RDM!PrimitiveType
-- IN:		RDM!OntologyElement
-- OUT:		Sequence(RDM!OntologyElement)
helper context RDM!PrimitiveType def: childrenElems(dtp : RDM!OntologyElement) : Sequence(RDM!OntologyElement) =
	Sequence{self};
	
-- HELPER: childrenClasses
-- Returns all children elements for DatatypeProperty. 
-- This class doesn't have any children classes.
-- CONTEXT:	RDM!DatatypeProperty
-- IN:		RDM!OntologyElement
-- OUT:		Sequence(RDM!Class)
helper context RDM!DatatypeProperty def: childrenElems(dtp : RDM!OntologyElement) : Sequence(RDM!OntologyElement) =
	Sequence{};	

-- Other helpers

-- HELPER: maxCardinalityOnSameProperty
-- Returns MaxCardinalityRestriction which is defined on same property as 
-- contextual MinCardinalityRestriction. 
-- This helper is needed because we want to find if two restrictions (min, max)
-- are defined on same property.
-- CONTEXT:	RDM!MinCardinalityRestriction
-- OUT:		Sequence(RDM!MaxCardinalityRestriction)
helper context RDM!MinCardinalityRestriction def: maxCardinalityOnSameProperty : RDM!MaxCardinalityRestriction = 
	let maxCardinalityRestrictions : Sequence(RDM!MaxCardinalityRestriction) = RDM!MaxCardinalityRestriction.allInstancesFrom('IN')->asSequence() in
		maxCardinalityRestrictions->iterate(p; res : RDM!MaxCardinalityRestriction = maxCardinalityRestrictions->first() |
			if(p.onProperty->asSequence()->includes(self.onProperty->asSequence()->first()))
				then p
				else res
				endif
		);

-- HELPER: minCardinalityOnSameProperty
-- Returns MinCardinalityRestriction which is defined on same property as 
-- contextual MaxCardinalityRestriction. 
-- This helper is needed because we want to find if two restrictions (min, max)
-- are defined on same property.
-- CONTEXT:	RDM!MaxCardinalityRestriction
-- OUT:		Sequence(RDM!MinCardinalityRestriction)
helper context RDM!MaxCardinalityRestriction def: minCardinalityOnSameProperty : RDM!MinCardinalityRestriction = 
	let minCardinalityRestrictions : Sequence(RDM!MinCardinalityRestriction) = RDM!MinCardinalityRestriction.allInstancesFrom('IN')->asSequence() in
		minCardinalityRestrictions->iterate(p; res : RDM!MinCardinalityRestriction = minCardinalityRestrictions->first() |
			if(p.onProperty->asSequence()->includes(self.onProperty->asSequence()->first()))
				then p
				else res
				endif
		);
	
-- HELPER: transform
-- This OCL helper with side-effects, is used to create new instance of R2ML ObjectClassificationAtom
-- from RDM Class, using Class-es parent and transformed Class. It is used with lazy rule.
-- CONTEXT:	RDM!Class
-- IN:		RDM!Class, R2ML!Class
-- OUT:		R2ML!ObjectClassificationAtom
helper context RDM!Class def: transform(parent : RDM!Class, transformedClass : R2ML!Class) : R2ML!ObjectClassificationAtom =
               		R2ML!ObjectClassificationAtom.newInstance()
				    	.refSetValue('isNegated', false)
                    	.refSetValue('term', thisModule.IndividualVariable2ObjectVariable(thisModule.getAtomForClassElement(parent).terms->first()))
                    	.refSetValue('type', transformedClass);

-- HELPER: getDefaultTypedLiteral
-- Return always same typed literal with defined type. Or OclUndefined if no typed 
-- literal are found.
-- IN:		type
-- OUT:		RDM!TypedLiteral
helper def: getDefaultTypedLiteral(type : String) : RDM!TypedLiteral = 
	let typ : RDM!TypedLiteral = RDM!TypedLiteral.allInstancesFrom('IN')->asSequence()->select(c | c.theType = type)->first() in
		if typ.oclIsUndefined()
		then OclUndefined
		else typ
		endif;

-- HELPER: getDefaultPlainLiteral
-- Return always same plain literal. Or OclUndefined if no typed literal are found.
-- IN:		type
-- OUT:		RDM!PlainLiteral
helper def: getDefaultPlainLiteral() : RDM!PlainLiteral = 
	let typ : RDM!PlainLiteral = RDM!PlainLiteral.allInstancesFrom('IN')->asSequence()->first() in
		if typ.oclIsUndefined()
		then OclUndefined
		else typ
		endif;

-- HELPER: getAllAtoms
-- Return all RDM Atoms for RDM Rule.
-- CONTEXT:	RDM!Rule
-- OUT:		Sequence(RDM!Atom)
helper context RDM!Rule def: getAllAtoms() : Sequence(RDM!Atom) = 
	self.hasAntecedent.containsAtom->asSequence().union(self.hasConsequent.containsAtom->asSequence());
		
-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Atoms

-- ClassAtom

-- Rule 'ClassAtom2ObjectClassificationAtom'
-- Create R2ML ObjectClassificationAtom from RDM ClassAtom
-- with Class PredicateSymbol
rule ClassAtom2ObjectClassificationAtom {
	from i : RDM!Atom (
			i.name = 'ClassAtom' and i.hasPredicateSymbol.oclIsTypeOf(RDM!Class)
		)
	to o : R2ML!ObjectClassificationAtom (
				isNegated <- false,
				term <- thisModule.IndividualVariable2ObjectVariable(i.terms->first()),
				type <- thisModule.Class2Class(i.hasPredicateSymbol)
			)
}

-- Rule 'Intersection2Conjuction'
-- Create R2ML Conjuction of elements from RDM ClassAtom
-- with IntersectionClass PredicateSymbol
-- Annotation: design decision is that predicate symbol's elements
--             knows how to transform (based on his parent and Atom).
rule Intersection2Conjuction {
	from i : RDM!Atom (
			i.name = 'ClassAtom' and i.hasPredicateSymbol.oclIsTypeOf(RDM!IntersectionClass)
		)
	to 
		o : R2ML!Conjuction (
				formulas <- Sequence { i.hasPredicateSymbol.intersectionOf->asSequence()->select(c | c.oclIsTypeOf(RDM!Class))->collect(e | e.transform(i.hasPredicateSymbol, thisModule.Class2Class(e))),
									   i.hasPredicateSymbol.intersectionOf->asSequence()->select(c | not c.oclIsTypeOf(RDM!Class))->asSequence()
							}
			)
}

-- Rule 'UnionAtom2Disjunction'
-- Create R2ML Disjunction of elements from RDM ClassAtom
-- with UnionClass PredicateSymbol
rule UnionAtom2Disjunction {
	from i : RDM!Atom (
			i.name = 'ClassAtom' and i.hasPredicateSymbol.oclIsTypeOf(RDM!UnionClass)
		)
	to 
		o : R2ML!Disjunction (
				formulas <- Sequence { i.hasPredicateSymbol.unionOf->asSequence()->select(c | c.oclIsTypeOf(RDM!Class))->collect(e | e.transform(i.hasPredicateSymbol, thisModule.Class2Class(e))),
									   i.hasPredicateSymbol.unionOf->asSequence()->select(c | not c.oclIsTypeOf(RDM!Class))->asSequence()
							}
			)
}

-- Rule 'Union2Disjunction'
-- Create R2ML Disjunction of elements from UnionClass
rule Union2Disjunction {
	from i : RDM!UnionClass (
			i.oclIsTypeOf(RDM!UnionClass) and
			RDM!Atom.allInstancesFrom('IN')->asSequence()->collect(c | c.hasPredicateSymbol)->flatten()->excludes(i)
		)
	to 
		o : R2ML!Disjunction (
				formulas <- Sequence { i.unionOf->asSequence()->select(c | c.oclIsTypeOf(RDM!Class))->collect(e | e.transform(i, thisModule.Class2Class(e))),
									   i.unionOf->asSequence()->select(c | not c.oclIsTypeOf(RDM!Class))->asSequence()
							}
			)
}

-- Rule 'Complement2Negation'
-- Create R2ML Negation of elements from RDM ClassAtom
-- with ComplementClass PredicateSymbol
rule Complement2Negation {
	from i : RDM!Atom (
			i.name = 'ClassAtom' and i.hasPredicateSymbol.oclIsTypeOf(RDM!ComplementClass)
		)
	to 
		o : R2ML!StrongNegation (
				formula <- if i.hasPredicateSymbol.complementOf.oclIsTypeOf(RDM!Class) then
							    i.hasPredicateSymbol.complementOf.transform(i.hasPredicateSymbol, thisModule.Class2Class(i.hasPredicateSymbol.complementOf))
							else i.hasPredicateSymbol.complementOf
							endif
			)	
}

-- Rule 'EnumeratedClass2Disjunction'
-- Create R2ML Disjunction of elements from EnumeratedClass
rule EnumeratedClass2Disjunction {
	from i : RDM!EnumeratedClass (
			i.oclIsTypeOf(RDM!EnumeratedClass) and 
			RDM!Atom.allInstancesFrom('IN')->asSequence()->collect(c | c.hasPredicateSymbol)->flatten()->excludes(i)
		)
	to 
		o : R2ML!Disjunction (
				formulas <- i.oneOf
			)
}

-- Rule 'EnumeratedClassAtom2Disjunction'
-- Create R2ML Disjunction of elements from RDM ClassAtom
-- with EnumeratedClass PredicateSymbol
rule EnumeratedClassAtom2Disjunction {
	from i : RDM!Atom (
			i.name = 'ClassAtom' and i.hasPredicateSymbol.oclIsTypeOf(RDM!EnumeratedClass)
		)
	to 
		o : R2ML!Disjunction (
				formulas <- i.hasPredicateSymbol.oneOf
			)
}

-- Rule 'Individual2EqualityAtom'
-- Create R2ML EqualityAtom from Individual elements, which are
-- oneOf elements of EnumeratedClass.
rule Individual2EqualityAtom {
	from i : RDM!Individual (
			RDM!EnumeratedClass.allInstancesFrom('IN')->asSequence()->collect(e | e.oneOf)->flatten()->includes(i)
		)
	to o : R2ML!EqualityAtom (
			terms <- Sequence{obj, thisModule.IndividualVariable2ObjectVariable(thisModule.getAtomForClassElement(i).terms->first())}
		),
		obj : R2ML!ObjectName (
			name <- i.name
			)
}

-- Rule 'Class2ObjectClassificationAtom'
-- Create R2ML ObjectClassificationAtom from Class element
-- Annotation: Currently not used, switched with transform helper.
unique lazy rule Class2ObjectClassificationAtom {
	from i : RDM!Class 
	to o : R2ML!ObjectClassificationAtom (
				isNegated <- false,
				term <- thisModule.IndividualVariable2ObjectVariable(thisModule.getAtomForClassElement(i).terms->first()), -- Helper koji ce naci Atom koji sadrzi ovu klasu
				type <-	thisModule.Class2Class(i)
			)
}

-- Rule 'Class2Class'
-- Create R2ML Class from RDM Class element
unique lazy rule Class2Class {
	from i : RDM!Class 
	to cla : R2ML!Class (
				name <- i.name,
				predicateCategory <- #closed
			)
}

-- Rule 'HasValueRestrictionClass2ReferencePropertyAtom'
-- Create R2ML ReferencePropertyAtom from HasValueRestriction element, which have
-- hasValue attribute defined.
rule HasValueRestrictionClass2ReferencePropertyAtom {
	from i : RDM!HasValueRestriction (
			i.oclIsTypeOf(RDM!HasValueRestriction) and not i.hasValue.oclIsUndefined()
			and i.onProperty->asSequence()->first().oclIsTypeOf(RDM!ObjectProperty)
		)
	to o : R2ML!ReferencePropertyAtom (
		isNegated <- false,
		object <- thisModule.Individual2ObjectVariable(i.hasValue),
		referenceProperty <- i.onProperty->asSequence()->first(),
		subject <- thisModule.IndividualVariable2ObjectVariable(thisModule.getAtomForClassElement(i).terms->first())
		)
}

-- Rule 'SomeValuesFromRestrictionClass2ExistentiallyQuantifiedFormula'
-- Create R2ML ExistentiallyQuantifiedFormula from SomeValuesFromRestriction element, which have
-- someValuesFromClass attribute defined.
rule SomeValuesFromRestrictionClass2ExistentiallyQuantifiedFormula {
	from i : RDM!SomeValuesFromRestriction (
			i.oclIsTypeOf(RDM!SomeValuesFromRestriction) and not i.someValuesFromClass.oclIsUndefined()
		)
	to o : R2ML!ExistentiallyQuantifiedFormula (
			variables <- objVar,
			formula <- conj
		),
		objVar : R2ML!ObjectVariable (
				name <- 'x',
				typeCategory <- #individual
			),
		conj : R2ML!Conjuction (
				formulas <- if i.someValuesFromClass.oclIsTypeOf(RDM!Class) then
								Sequence {i.someValuesFromClass.transform(i, thisModule.Class2Class(i.someValuesFromClass)), refPropAt}
							else Sequence{ i.someValuesFromClass, refPropAt }
							endif
			),
		refPropAt : R2ML!ReferencePropertyAtom (
			isNegated <- false,
			subject <- thisModule.IndividualVariable2ObjectVariable(thisModule.getAtomForClassElement(i).terms->first()),
			object <- objVar,
			referenceProperty <- i.onProperty->asSequence()->first()
			)	
}

-- Rule 'AllValuesFromRestrictionClass2UniversallyQuantifiedFormula'
-- Create R2ML UniversallyQuantifiedFormula from AllValuesFromRestriction element, which have
-- allValuesFromClass attribute defined.
rule AllValuesFromRestrictionClass2UniversallyQuantifiedFormula {
	from i : RDM!AllValuesFromRestriction (
			i.oclIsTypeOf(RDM!AllValuesFromRestriction) and not i.allValuesFromClass.oclIsUndefined()
		)
	to o : R2ML!UniversallyQuantifiedFormula (
			variables <- objVar,
			formula <- impl
		),
		objVar : R2ML!ObjectVariable (
				name <- 'x',
				typeCategory <- #individual
			),
		impl : R2ML!Implication (
				antecedent <- refPropAt,
				consequent <- if i.allValuesFromClass.oclIsTypeOf(RDM!Class) then
								i.allValuesFromClass.transform(i, thisModule.Class2Class(i.allValuesFromClass))
							else i.allValuesFromClass
							endif
			),
		refPropAt : R2ML!ReferencePropertyAtom (
			isNegated <- false,
			subject <- thisModule.IndividualVariable2ObjectVariable(thisModule.getAtomForClassElement(i).terms->first()),
			object <- objVar,
			referenceProperty <- i.onProperty->asSequence()->first()
			)	
}

-- Rule 'MinCardinalityRestrictionClass2AtLeastQuantifiedFormula'
-- Create R2ML AtLeastQuantifiedFormula from MinCardinalityRestriction element, 
-- which is defined on ObjectProperty and there is no maxCardinality defined
-- on same property.
rule MinCardinalityRestrictionClass2AtLeastQuantifiedFormula {
	from i : RDM!MinCardinalityRestriction (
			i.oclIsTypeOf(RDM!MinCardinalityRestriction) and
			RDM!MaxCardinalityRestriction.allInstancesFrom('IN')->asSequence()->collect(c | c.onProperty)->flatten()->excludes(i.onProperty->asSequence()->first()) and
			i.onProperty->asSequence()->first().oclIsTypeOf(RDM!ObjectProperty)
		)
	to o : R2ML!AtLeastQuantifiedFormula (
		minCardinality <- i.minCardinality.lexicalForm.toInteger(),
		variables <- objVar,
		formula <- refPropAt
		),
		objVar : R2ML!ObjectVariable (
				name <- 'x',
				typeCategory <- #individual
		),
		refPropAt : R2ML!ReferencePropertyAtom (
			isNegated <- false,
			subject <- thisModule.IndividualVariable2ObjectVariable(thisModule.getAtomForClassElement(i).terms->first()),
			object <- objVar,
			referenceProperty <- i.onProperty->asSequence()->first()
		)		
}

-- Rule 'MaxCardinalityRestrictionClass2AtLeastQuantifiedFormula'
-- Create R2ML AtMostQuantifiedFormula from MaxCardinalityRestriction element, 
-- which is defined on ObjectProperty and there is no minCardinality defined
-- on same property.
rule MaxCardinalityRestrictionClass2AtLeastQuantifiedFormula {
	from i : RDM!MaxCardinalityRestriction (
			i.oclIsTypeOf(RDM!MaxCardinalityRestriction) and
			RDM!MinCardinalityRestriction.allInstancesFrom('IN')->asSequence()->collect(c | c.onProperty)->flatten()->excludes(i.onProperty->asSequence()->first()) and
			i.onProperty->asSequence()->first().oclIsTypeOf(RDM!ObjectProperty)
		)
	to o : R2ML!AtMostQuantifiedFormula (
		maxCardinality <- i.maxCardinality.lexicalForm.toInteger(),
		variables <- objVar,
		formula <- refPropAt
		),
		objVar : R2ML!ObjectVariable (
				name <- 'x',
				typeCategory <- #individual
		),
		refPropAt : R2ML!ReferencePropertyAtom (
			isNegated <- false,
			subject <- thisModule.IndividualVariable2ObjectVariable(thisModule.getAtomForClassElement(i).terms->first()),
			object <- objVar,
			referenceProperty <- i.onProperty->asSequence()->first()
		)		
}

-- Rule 'MaxMinCardinalityRestrictionClass2AtLeastAndAtMostQuantifiedFormula'
-- Create R2ML AtLeastAndAtMostQuantifiedFormula from MaxCardinalityRestriction element, 
-- which is defined on ObjectProperty and there is minCardinality defined
-- on same property.
-- ANNOTATION: It is needed, because we can have it as predicateSymbol of Atom, where
--             exists MinCardinaltyRestriction defined on it.
rule MaxMinCardinalityRestrictionClass2AtLeastAndAtMostQuantifiedFormula {
	from i : RDM!MaxCardinalityRestriction (
			i.oclIsTypeOf(RDM!MaxCardinalityRestriction) and
			RDM!MinCardinalityRestriction.allInstancesFrom('IN')->asSequence()->collect(c | c.onProperty)->flatten()->includes(i.onProperty->asSequence()->first()) and
			i.onProperty->asSequence()->first().oclIsTypeOf(RDM!ObjectProperty) and
			RDM!Atom.allInstancesFrom('IN')->asSequence()->collect(c | c.hasPredicateSymbol)->flatten()->excludes(i.minCardinalityOnSameProperty)
		)
	to o : R2ML!AtLeastAndAtMostQuantifiedFormula (
			maxCardinality <- i.maxCardinality.lexicalForm.toInteger(),
			minCardinality <- i.minCardinalityOnSameProperty.minCardinality.lexicalForm.toInteger(),
			variables <- objVar,
			formula <- refPropAt
		),
		objVar : R2ML!ObjectVariable (
				name <- 'x',
				typeCategory <- #individual
		),
		refPropAt : R2ML!ReferencePropertyAtom (
			isNegated <- false,
			subject <- thisModule.IndividualVariable2ObjectVariable(thisModule.getAtomForClassElement(i).terms->first()),
			object <- objVar,
			referenceProperty <- i.onProperty->asSequence()->first()
		)		
}

-- Rule 'MinMaxCardinalityRestrictionClass2AtLeastAndAtMostQuantifiedFormula'
-- Create R2ML AtLeastAndAtMostQuantifiedFormula from MinCardinalityRestriction element, 
-- which is defined on ObjectProperty and there is maxCardinality defined
-- on same property.
-- ANNOTATION: It is needed, because we can have it as predicateSymbol of Atom, where
--             exists MaxCardinaltyRestriction defined on it.
rule MinMaxCardinalityRestrictionClass2AtLeastAndAtMostQuantifiedFormula {
	from i : RDM!MinCardinalityRestriction ( -- We start from MinCardinality, but
											 -- we also can start from MaxCardinality.
			i.oclIsTypeOf(RDM!MinCardinalityRestriction) and
			RDM!MaxCardinalityRestriction.allInstancesFrom('IN')->asSequence()->collect(c | c.onProperty)->flatten()->includes(i.onProperty->asSequence()->first()) and
			i.onProperty->asSequence()->first().oclIsTypeOf(RDM!ObjectProperty) and
			RDM!Atom.allInstancesFrom('IN')->asSequence()->collect(c | c.hasPredicateSymbol)->flatten()->excludes(i.maxCardinalityOnSameProperty)
		)
	to o : R2ML!AtLeastAndAtMostQuantifiedFormula (
			maxCardinality <- i.maxCardinalityOnSameProperty.maxCardinality.lexicalForm.toInteger(),
			minCardinality <- i.minCardinality.lexicalForm.toInteger(),
			variables <- objVar,
			formula <- refPropAt
		),
		objVar : R2ML!ObjectVariable (
				name <- 'x',
				typeCategory <- #individual
		),
		refPropAt : R2ML!ReferencePropertyAtom (
			isNegated <- false,
			subject <- thisModule.IndividualVariable2ObjectVariable(thisModule.getAtomForClassElement(i).terms->first()),
			object <- objVar,
			referenceProperty <- i.onProperty->asSequence()->first()
		)		
}

-- Rule 'CardinalityRestrictionClass2AtLeastAndAtMostQuantifiedFormula'
-- Create R2ML AtLeastAndAtMostQuantifiedFormula from CardinalityRestriction element, 
-- which is defined on ObjectProperty.
rule CardinalityRestrictionClass2AtLeastAndAtMostQuantifiedFormula {
	from i : RDM!CardinalityRestriction (
			i.oclIsTypeOf(RDM!CardinalityRestriction) and i.onProperty->asSequence()->first().oclIsTypeOf(RDM!ObjectProperty)		
		)
	to o : R2ML!AtLeastAndAtMostQuantifiedFormula (
			maxCardinality <- i.cardinality.lexicalForm.toInteger(),
			minCardinality <- i.cardinality.lexicalForm.toInteger(),
			variables <- objVar,
			formula <- refPropAt
		),
		objVar : R2ML!ObjectVariable (
				name <- 'x',
				typeCategory <- #individual
		),
		refPropAt : R2ML!ReferencePropertyAtom (
			isNegated <- false,
			subject <- thisModule.IndividualVariable2ObjectVariable(thisModule.getAtomForClassElement(i).terms->first()),
			object <- objVar,
			referenceProperty <- i.onProperty->asSequence()->first()
		)		
}

-- DataRangeAtom

-- Rule 'DataRangeAtom2DataClassificationAtom'
-- Create R2ML DataClassificationAtom from Atom element, 
-- which have DataRange as predicate Symbol and undefined datatype.
rule DataRangeAtomOneOf2DataClassificationAtom {
	from i : RDM!Atom (
			i.name = 'DataRangeAtom' and 
			if i.hasPredicateSymbol.oclIsTypeOf(RDM!DataRange) then
				not i.hasPredicateSymbol.datatype.oclIsUndefined()
			else 
				false
			endif
		)
	to 
		o : R2ML!DataClassificationAtom (
				isNegated <- false,
				term <- thisModule.IndividualVariable2DataVariable(i.terms->first()),
				type <- if thisModule.getDefaultTypedLiteral(i.hasPredicateSymbol.datatype.name) <> OclUndefined
							then thisModule.TypedLiteral2Datatype( thisModule.getDefaultTypedLiteral(i.hasPredicateSymbol.datatype.name) )
							else thisModule.PrimitiveType2Datatype(i.hasPredicateSymbol.datatype)
						endif
				
				
			)
}

-- Rule 'DataRange2DataClassificationAtom'
-- Create R2ML DataClassificationAtom from DataRange element, 
-- which is not predicate symbol of Atom,
-- and datatype is defined.
rule DataRange2DataClassificationAtom {
	from i : RDM!DataRange (
		i.oclIsTypeOf(RDM!DataRange) 
		and RDM!Atom.allInstancesFrom('IN')->asSequence()->collect(c | c.hasPredicateSymbol)->flatten()->excludes(i)
		and if i.datatype.oclIsUndefined() then
				 false
			else true
			endif
		)
	to o : R2ML!DataClassificationAtom (
				isNegated <- false,
				term <- thisModule.IndividualVariable2DataVariable(thisModule.getAtomForDataElement(i).terms->first()),
				type <- if thisModule.getDefaultTypedLiteral(i.datatype.name) <> OclUndefined
							then thisModule.TypedLiteral2Datatype( thisModule.getDefaultTypedLiteral(i.datatype.name) )
							else thisModule.PrimitiveType2Datatype(i.datatype)
						endif
			)
}

-- Rule 'PrimitiveType2Datatype'
-- Create R2ML Datatype from RDM PrimitiveType element.
unique lazy rule PrimitiveType2Datatype {
	from i : RDM!PrimitiveType
	to o : R2ML!Datatype (
		predicateCategory <- #closed,
		name <- i.name
		)
}

-- Rule 'DataRangeAtom2Disjunction'
-- Create R2ML Disjunction from Atom element, 
-- which have DataRange as predicate Symbol and undefined datatype.
rule DataRangeAtom2Disjunction {
	from i : RDM!Atom (
			i.name = 'DataRangeAtom' and 
			if i.hasPredicateSymbol.oclIsTypeOf(RDM!DataRange) then
				i.hasPredicateSymbol.datatype.oclIsUndefined()
			else 
				false
			endif
		)
	to 
		o : R2ML!Disjunction (
				formulas <- i.hasPredicateSymbol.oneOf
			)
}

-- Rule 'DataRange2Disjunction'
-- Create R2ML Disjunction from DataRange element, 
-- which is not predicate symbol of Atom, and
-- datatype is undefined.
rule DataRange2Disjunction {
	from i : RDM!DataRange (
		i.oclIsTypeOf(RDM!DataRange) and
		RDM!Atom.allInstancesFrom('IN')->asSequence()->collect(c | c.hasPredicateSymbol)->flatten()->excludes(i)
		and if i.datatype.oclIsUndefined() then
		       true
			else false
			endif
		)
	to o : R2ML!Disjunction (
				formulas <- i.oneOf
			)
}

-- Rule 'PlainLiteral2PlainLiteral'
-- Create R2ML PlainLiteral from RDM PlainLiteral element,
-- which is not children of some DataRange.
rule PlainLiteral2PlainLiteral {
	from i : RDM!PlainLiteral (
		i.oclIsTypeOf(RDM!PlainLiteral) and RDM!DataRange.allInstancesFrom('IN')->asSequence()->select(e | not e.oneOf.oclIsUndefined())->collect(c | c.oneOf)->flatten()->excludes(i)
		)
	to o : R2ML!PlainLiteral (
		languageTag <- i.language,
		lexicalValue <- i.lexicalForm,
		typeCategory <- #individual
		)
}

-- Rule 'TypedLiteral2TypedLiteral'
-- Create R2ML TypedLiteral from RDM TypedLiteral element,
-- which is not children of some DataRange.
rule TypedLiteral2TypedLiteral {
	from i : RDM!TypedLiteral (
			i.oclIsTypeOf(RDM!TypedLiteral) and RDM!DataRange.allInstancesFrom('IN')->asSequence()->select(e | not e.oneOf.oclIsUndefined())->collect(c | c.oneOf)->flatten()->excludes(i) and
			RDM!CardinalityRestriction.allInstancesFrom('IN')->asSequence()->collect(c | c.cardinality)->flatten()->excludes(i) and
			RDM!MinCardinalityRestriction.allInstancesFrom('IN')->asSequence()->collect(c | c.minCardinality)->flatten()->excludes(i) and
			RDM!MaxCardinalityRestriction.allInstancesFrom('IN')->asSequence()->collect(c | c.maxCardinality)->flatten()->excludes(i)
		)
	to o : R2ML!TypedLiteral (
		type <- thisModule.TypedLiteral2Datatype( thisModule.getDefaultTypedLiteral(i.theType) ),
		lexicalValue <- i.lexicalForm,
		typeCategory <- #individual
		)
}

-- Rule 'TypedLiteral2Datatype'
-- Lazy rule which creates R2ML Datatype from RDM TypedLiteral element.
unique lazy rule TypedLiteral2Datatype {
	from i : RDM!TypedLiteral
	to o : R2ML!Datatype (
		name <- i.theType,
		predicateCategory <- #closed
		)
}

-- Rule 'PlainLiteral2DatatypePredicateAtom'
-- Create R2ML DatatypePredicateAtom from RDM PlainLiteral element,
-- which is children of some DataRange.
rule PlainLiteral2DatatypePredicateAtom {
	from i : RDM!PlainLiteral (
		i.oclIsTypeOf(RDM!PlainLiteral) and RDM!DataRange.allInstancesFrom('IN')->asSequence()->select(e | not e.oneOf.oclIsUndefined())->collect(c | c.oneOf)->flatten()->includes(i)
		)
	to o : R2ML!DatatypePredicateAtom (
		isNegated <- false,
		dataArguments <- Sequence { pl, thisModule.IndividualVariable2DataVariable(thisModule.getAtomForDataElement(i).terms->first()) },
		predicate <- thisModule.PlainLiteral2DatatypePredicate(thisModule.getDefaultPlainLiteral())
		),
	    pl : R2ML!PlainLiteral (
	    	lexicalValue <- i.lexicalForm,
			typeCategory <- #individual
	    	)
}

-- Rule 'TypedLiteral2DatatypePredicateAtom'
-- Create R2ML DatatypePredicateAtom from RDM TypedLiteral element,
-- which is children of some DataRange.
rule TypedLiteral2DatatypePredicateAtom {
	from i : RDM!TypedLiteral (
		i.oclIsTypeOf(RDM!TypedLiteral) and RDM!DataRange.allInstancesFrom('IN')->asSequence()->select(e | not e.oneOf.oclIsUndefined())->collect(c | c.oneOf)->flatten()->includes(i)
		)
	to o : R2ML!DatatypePredicateAtom (
		isNegated <- false,
		dataArguments <- Sequence { pl, thisModule.IndividualVariable2DataVariable(thisModule.getAtomForDataElement(i).terms->first()) },
		predicate <- thisModule.TypedLiteral2DatatypePredicate( thisModule.getDefaultTypedLiteral(i.theType) )
		),
	    pl : R2ML!TypedLiteral (
	    	lexicalValue <- i.lexicalForm,
			type <- thisModule.TypedLiteral2Datatype( thisModule.getDefaultTypedLiteral(i.theType) ),
			typeCategory <- #individual
	    	)
}

-- Rule 'TypedLiteral2DatatypePredicate'
-- Create R2ML DatatypePredicate (swrlb:equal) from RDM TypedLiteral element.
unique lazy rule TypedLiteral2DatatypePredicate {
	from i : RDM!TypedLiteral
	to o : R2ML!DatatypePredicate (
		   	name <- 'swrlb:equal',
			predicateCategory <- #closed
	   	)
}

-- Rule 'PlainLiteral2DatatypePredicate'
-- Create R2ML DatatypePredicate (swrlb:equal) from RDM PlainLiteral element.
unique lazy rule PlainLiteral2DatatypePredicate {
	from i : RDM!PlainLiteral
	to o : R2ML!DatatypePredicate (
		   	name <- 'swrlb:equal',
			predicateCategory <- #closed
	   	)
}

-- Rule 'DatatypeProperty2Attribute'
-- Create R2ML Attribute from RDM DatatypeProperty element.
unique lazy rule DatatypeProperty2Attribute {
	from i : RDM!DatatypeProperty
	to o : R2ML!Attribute(
		name <- i.name,
		predicateCategory <- #closed
		)
}

-- Rule 'AllValuesFromRestrictionData2UniversallyQuantifiedFormula'
-- Create R2ML UniversallyQuantifiedFormula from RDM AllValuesFromRestriction element,
-- in which allValuesFromRange is defined.
rule AllValuesFromRestrictionData2UniversallyQuantifiedFormula {
	from i : RDM!AllValuesFromRestriction (
			i.oclIsTypeOf(RDM!AllValuesFromRestriction) and not i.allValuesFromRange.oclIsUndefined()
		)
	to o : R2ML!UniversallyQuantifiedFormula (
			variables <- objVar,
			formula <- impl
		),
		objVar : R2ML!ObjectVariable (
				name <- 'x',
				typeCategory <- #individual
			),
		impl : R2ML!Implication (
				antecedent <- attrAt,
				consequent <- i.allValuesFromRange
			),
		attrAt : R2ML!AttributionAtom (
			isNegated <- false,
			attribute <- thisModule.DatatypeProperty2Attribute(i.onProperty->asSequence()->first()),
			subject <- objVar,
			dataValue <- thisModule.IndividualVariable2DataVariable(thisModule.getAtomForDataElement(i).terms->first())
			)
		
}

-- Rule 'SomeValuesFromRestrictionData2ExistentiallyQuantifiedFormula'
-- Create R2ML ExistentiallyQuantifiedFormula from RDM SomeValuesFromRestriction element,
-- in which someValuesFromRange is defined.
rule SomeValuesFromRestrictionData2ExistentiallyQuantifiedFormula {
	from i : RDM!SomeValuesFromRestriction (
			i.oclIsTypeOf(RDM!SomeValuesFromRestriction) and not i.someValuesFromRange.oclIsUndefined()
		)
	to o : R2ML!ExistentiallyQuantifiedFormula (
			variables <- objVar,
			formula <- conj
		),
		objVar : R2ML!ObjectVariable (
				name <- 'x',
				typeCategory <- #individual
			),
		conj : R2ML!Conjuction (
				formulas <- Sequence{i.someValuesFromRange, attrAt}
			),
		attrAt : R2ML!AttributionAtom (
			isNegated <- false,
			attribute <- thisModule.DatatypeProperty2Attribute(i.onProperty->asSequence()->first()),
			subject <- objVar,
			dataValue <- thisModule.IndividualVariable2DataVariable(thisModule.getAtomForDataElement(i).terms->first())
			)
}

-- Rule 'HasValueRestrictionData2AttributeAtom'
-- Create R2ML AttributionAtom from RDM HasValueRestriction element,
-- in which hasLiteralValue is defined.
rule HasValueRestrictionData2AttributeAtom {
	from i : RDM!HasValueRestriction (
			i.oclIsTypeOf(RDM!HasValueRestriction) and not i.hasLiteralValue.oclIsUndefined()
		)
	to o : R2ML!AttributionAtom (
			isNegated <- false,
			attribute <- thisModule.DatatypeProperty2Attribute(i.onProperty->asSequence()->first()),
			subject <- thisModule.IndividualVariable2ObjectVariable(thisModule.getAtomForDataElement(i).terms->first()),
			dataValue <- i.hasLiteralValue
			)
}

-- Rule 'MinCardinalityRestrictionData2AtLeastQuantifiedFormula'
-- Create R2ML AtLeastQuantifiedFormula from MinCardinalityRestriction element, 
-- which is defined on DatatypeProperty and there is no maxCardinality defined
-- on same property.
rule MinCardinalityRestrictionData2AtLeastQuantifiedFormula {
	from i : RDM!MinCardinalityRestriction (
			i.oclIsTypeOf(RDM!MinCardinalityRestriction) and
			RDM!MaxCardinalityRestriction.allInstancesFrom('IN')->asSequence()->collect(c | c.onProperty)->flatten()->excludes(i.onProperty->asSequence()->first()) and
			i.onProperty->asSequence()->first().oclIsTypeOf(RDM!DatatypeProperty)
		)
	to o : R2ML!AtLeastQuantifiedFormula (
		minCardinality <- i.minCardinality.lexicalForm.toInteger(),
		variables <- objVar,
		formula <- attrAt
		),
		objVar : R2ML!ObjectVariable (
				name <- 'x',
				typeCategory <- #individual
		), 
	   attrAt: R2ML!AttributionAtom (
	   		isNegated <- false,
			attribute <- thisModule.DatatypeProperty2Attribute(i.onProperty->asSequence()->first()),
			subject <- objVar,
			dataValue <- thisModule.IndividualVariable2DataVariable(thisModule.getAtomForDataElement(i).terms->first())
			)
}

-- Rule 'MaxCardinalityRestrictionData2AtLeastQuantifiedFormula'
-- Create R2ML AtMostQuantifiedFormula from MaxCardinalityRestriction element, 
-- which is defined on DatatypeProperty and there is no minCardinality defined
-- on same property.
rule MaxCardinalityRestrictionData2AtLeastQuantifiedFormula {
	from i : RDM!MaxCardinalityRestriction (
			i.oclIsTypeOf(RDM!MaxCardinalityRestriction) and
			RDM!MinCardinalityRestriction.allInstancesFrom('IN')->asSequence()->collect(c | c.onProperty)->flatten()->excludes(i.onProperty->asSequence()->first()) and
			i.onProperty->asSequence()->first().oclIsTypeOf(RDM!DatatypeProperty)
		)
	to o : R2ML!AtMostQuantifiedFormula (
		maxCardinality <- i.maxCardinality.lexicalForm.toInteger(),
		variables <- objVar,
		formula <- attrAt
		),
		objVar : R2ML!ObjectVariable (
				name <- 'x',
				typeCategory <- #individual
		), 
	   attrAt: R2ML!AttributionAtom (
		   	isNegated <- false,
			attribute <- thisModule.DatatypeProperty2Attribute(i.onProperty->asSequence()->first()),
			subject <- objVar,
			dataValue <- thisModule.IndividualVariable2DataVariable(thisModule.getAtomForDataElement(i).terms->first())
			)		
}

-- Rule 'MinMaxCardinalityRestrictionClass2AtLeastAndAtMostQuantifiedFormula'
-- Create R2ML AtLeastAndAtMostQuantifiedFormula from MinCardinalityRestriction element, 
-- which is defined on DatatypeProperty and there is maxCardinality defined
-- on same property.
-- ANNOTATION: It is needed, because we can have it as predicateSymbol of Atom, where
--             exists MaxCardinaltyRestriction defined on it.
rule MinMaxCardinalityRestrictionData2AtLeastAndAtMostQuantifiedFormula {
	from i : RDM!MinCardinalityRestriction ( -- We start from MinCardinality, but
											 -- we also can start from MaxCardinality.
			i.oclIsTypeOf(RDM!MinCardinalityRestriction) and
			RDM!MaxCardinalityRestriction.allInstancesFrom('IN')->asSequence()->collect(c | c.onProperty)->flatten()->includes(i.onProperty->asSequence()->first()) and
			RDM!Atom.allInstancesFrom('IN')->asSequence()->collect(c | c.hasPredicateSymbol)->flatten()->excludes(i.maxCardinalityOnSameProperty) and
			i.onProperty->asSequence()->first().oclIsTypeOf(RDM!DatatypeProperty)
		)
	to o : R2ML!AtLeastAndAtMostQuantifiedFormula (
			maxCardinality <- i.maxCardinalityOnSameProperty.maxCardinality.lexicalForm.toInteger(),
			minCardinality <- i.minCardinality.lexicalForm.toInteger(),
			variables <- objVar,
			formula <- attrAt
		),
		objVar : R2ML!ObjectVariable (
				name <- 'x',
				typeCategory <- #individual
		), 
	    attrAt: R2ML!AttributionAtom (
	    	isNegated <- false,
			attribute <- thisModule.DatatypeProperty2Attribute(i.onProperty->asSequence()->first()),
			subject <- objVar,
			dataValue <- thisModule.IndividualVariable2DataVariable(thisModule.getAtomForDataElement(i).terms->first())
			)		
}

-- Rule 'MaxMinCardinalityRestrictionClass2AtLeastAndAtMostQuantifiedFormula'
-- Create R2ML AtLeastAndAtMostQuantifiedFormula from MaxCardinalityRestriction element, 
-- which is defined on DatatypeProperty and there is minCardinality defined
-- on same property.
-- ANNOTATION: It is needed, because we can have it as predicateSymbol of Atom, where
--             exists MinCardinaltyRestriction defined on it.
rule MaxMinCardinalityRestrictionData2AtLeastAndAtMostQuantifiedFormula {
	from i : RDM!MaxCardinalityRestriction ( 
			i.oclIsTypeOf(RDM!MaxCardinalityRestriction) and
			RDM!MinCardinalityRestriction.allInstancesFrom('IN')->asSequence()->collect(c | c.onProperty)->flatten()->includes(i.onProperty->asSequence()->first()) and
			RDM!Atom.allInstancesFrom('IN')->asSequence()->collect(c | c.hasPredicateSymbol)->flatten()->excludes(i.minCardinalityOnSameProperty) and
			i.onProperty->asSequence()->first().oclIsTypeOf(RDM!DatatypeProperty)
		)
	to o : R2ML!AtLeastAndAtMostQuantifiedFormula (
			maxCardinality <- i.maxCardinality.lexicalForm.toInteger(),
			minCardinality <- i.minCardinalityOnSameProperty.minCardinality.lexicalForm.toInteger(),
			variables <- objVar,
			formula <- attrAt
		),
		objVar : R2ML!ObjectVariable (
				name <- 'x',
				typeCategory <- #individual
		), 
	    attrAt: R2ML!AttributionAtom (
	    	isNegated <- false,
			attribute <- thisModule.DatatypeProperty2Attribute(i.onProperty->asSequence()->first()),
			subject <- objVar,
			dataValue <- thisModule.IndividualVariable2DataVariable(thisModule.getAtomForDataElement(i).terms->first())
			)		
}

-- Rule 'CardinalityRestrictionData2AtLeastAndAtMostQuantifiedFormula'
-- Create R2ML AtLeastAndAtMostQuantifiedFormula from CardinalityRestriction element, 
-- which is defined on DatatypeProperty.
rule CardinalityRestrictionData2AtLeastAndAtMostQuantifiedFormula {
	from i : RDM!CardinalityRestriction (
			i.oclIsTypeOf(RDM!CardinalityRestriction) and i.onProperty->asSequence()->first().oclIsTypeOf(RDM!DatatypeProperty)
		)
	to o : R2ML!AtLeastAndAtMostQuantifiedFormula (
			maxCardinality <- i.cardinality.lexicalForm.toInteger(),
			minCardinality <- i.cardinality.lexicalForm.toInteger(),
			variables <- objVar,
			formula <- attrAt
		),
		objVar : R2ML!ObjectVariable (
				name <- 'x',
				typeCategory <- #individual
		),  
	    attrAt: R2ML!AttributionAtom (
	    	isNegated <- false,
			attribute <- thisModule.DatatypeProperty2Attribute(i.onProperty->asSequence()->first()),
			subject <- objVar,
			dataValue <- thisModule.IndividualVariable2DataVariable(thisModule.getAtomForDataElement(i).terms->first())
			)	
}

-- DataValuedPropertyAtom

-- Rule 'DataValuedPropertyAtom2AttributeAtom'
-- Create R2ML AttributionAtom from Atom element, 
-- which is DataValuedPropertyAtom.
rule DataValuedPropertyAtom2AttributeAtom {
	from i : RDM!Atom (
		i.name = 'DataValuedPropertyAtom'
	)
	to o : R2ML!AttributionAtom (
			isNegated <- false,
			attribute <- thisModule.DatatypeProperty2Attribute(i.hasPredicateSymbol),
			subject <- thisModule.IndividualVariable2ObjectVariable(i.terms->select(e | e.oclIsKindOf(RDM!IndividualVariable))->first()),
			dataValue <- if i.terms->select(c | c.oclIsTypeOf(RDM!DataValue))->size() > 0 then
						 i.terms->select(c | c.oclIsTypeOf(RDM!DataValue))->collect(e | thisModule.DataValue2TypedLiteral(e))->first()
					 else
					     i.terms->select(c | c.oclIsTypeOf(RDM!DataVariable))->collect(e | thisModule.DataVariable2DataVariable(e))->first()
				     endif
		)
}

-- Lazy Rule 'DataValue2TypedLiteral'
-- Create R2ML PlainLiteral from DataValue RDM element.
lazy rule DataValue2TypedLiteral {
	from i : RDM!DataValue
	to o : R2ML!TypedLiteral (
			lexicalValue <- i.value,
			type <- thisModule.PrimitiveType2Datatype(i.type),
			typeCategory <- #individual
		)
}

-- SameIndividualAtom

-- Rule 'SameIndividualAtom2EqualityAtom'
-- Create R2ML EqualityAtom from Atom element, 
-- which is SameIndividualAtom.
rule SameIndividualAtom2EqualityAtom {
	from i : RDM!Atom (
		i.name = 'SameIndividualAtom'
	)
	to o : R2ML!EqualityAtom (
			terms <- Sequence { i.terms->select(e | e.oclIsTypeOf(RDM!IndividualVariable))->collect(c | thisModule.IndividualVariable2ObjectVariable(c)),
								i.terms->select(e | e.oclIsTypeOf(RDM!Individual))->collect(c | thisModule.Individual2ObjectVariable(c))
					 }
		) 
}

-- DifferentIndividualAtom

-- Rule 'DifferentIndividualAtom2InequalityAtom'
-- Create R2ML InequalityAtom from Atom element, 
-- which is DifferentIndividualAtom.
rule DifferentIndividualAtom2InequalityAtom {
	from i : RDM!Atom (
		i.name = 'DifferentIndividualAtom'
	)
	to o : R2ML!InequalityAtom (
			terms <-  Sequence { i.terms->select(e | e.oclIsTypeOf(RDM!IndividualVariable))->collect(c | thisModule.IndividualVariable2ObjectVariable(c)),
								 i.terms->select(e | e.oclIsTypeOf(RDM!Individual))->collect(c | thisModule.Individual2ObjectVariable(c))
					  }
		)
}

-- BuiltinAtom

-- Rule 'BuiltinAtom2DatatypePredicateAtom'
-- Create R2ML DatatypePredicateAtom from Atom element, 
-- which is BuiltinAtom.
rule BuiltinAtom2DatatypePredicateAtom {
	from i : RDM!Atom (
		i.name = 'BuiltinAtom'
	)
	to o : R2ML!DatatypePredicateAtom (
		isNegated <- false,
		dataArguments <- Sequence { i.terms->select(e | e.oclIsKindOf(RDM!DataVariable))->collect(c | thisModule.DataVariable2DataVariable(c)),
									i.terms->select(e | e.oclIsKindOf(RDM!DataValue))->collect(c | thisModule.DataValue2TypedLiteral(c))							
						},		     
		predicate <- thisModule.BuiltIn2DatatypePredicate(i.hasPredicateSymbol)
		)
}

-- Rule 'BuiltIn2DatatypePredicate'
-- Lazy rule which creates R2ML DatatypePredicate from RDM BuiltIn
unique lazy rule BuiltIn2DatatypePredicate {
	from i : RDM!BuiltIn 
	to o : R2ML!DatatypePredicate (
		name <- i.buildInID
		)
}

-- IndividualPropertyAtom

-- Rule 'IndividualPropertyAtom2UniversallyQuantifiedFormula'
-- Create UniversallyQuantifiedFormula R2ML element from RDM Atom element.
rule IndividualPropertyAtom2ReferencePropertyAtom{
	from i : RDM!Atom (
		i.name = 'IndividualPropertyAtom'
	)
	to refpropat : R2ML!ReferencePropertyAtom (
				isNegated <- false,
				referenceProperty <- i.hasPredicateSymbol,
				subject <- if i.terms->last().oclIsTypeOf(RDM!IndividualVariable) then
							thisModule.IndividualVariable2ObjectVariable(i.terms->last())
						   else thisModule.Individual2ObjectVariable(i.terms->last())
						   endif,
				object <- thisModule.IndividualVariable2ObjectVariable(i.terms->first())
			)	
}

-- Rule 'ObjectProperty2ReferenceProperty'
-- Transformation from RDM ObjectProperty element to R2ML ReferenceProperty element.
rule ObjectProperty2ReferenceProperty {
	from i : RDM!ObjectProperty
	to o : R2ML!ReferenceProperty (
			predicateCategory <- #closed,
			name <- i.name
		)
}

-- Rule 'DatatypeProperty2ReferenceProperty'
-- Transformation from RDM DatatypeProperty element to R2ML ReferenceProperty element.
rule DatatypeProperty2ReferenceProperty {
	from i : RDM!DatatypeProperty
	to o : R2ML!ReferenceProperty (
			predicateCategory <- #closed,
			name <- i.name
		)
}
	
-- Rule 'Rule2Implication'
-- Create Implication R2ML element from RDM Rule element
rule Rule2Implication {
	from i : RDM!Rule 
	to  ir : R2ML!AlethicIntegrityRule (
				constraint <- o
			),
			o : R2ML!UniversallyQuantifiedFormula (
					-- Collects all variables from all Atoms
					variables <- let atoms : Sequence (RDM!Atom) = i.getAllAtoms() in
								Sequence { atoms->select(c | c.name = 'ClassAtom')->collect(e | e.terms)->flatten()->collect(c | thisModule.IndividualVariable2ObjectVariable(c)),
										   atoms->select(c | c.name = 'DataValuedPropertyAtom')->collect(e | e.terms)->flatten()->select(e | e.oclIsKindOf(RDM!IndividualVariable))->collect(c | thisModule.IndividualVariable2ObjectVariable(c)),
										   atoms->select(c | c.name = 'DataValuedPropertyAtom')->collect(e | e.terms)->flatten()->select(e | e.oclIsKindOf(RDM!DataVariable))->collect(c | thisModule.DataVariable2DataVariable(c)),
										   atoms->select(c | c.name = 'SameIndividualAtom')->collect(e | e.terms)->flatten()->select(e | e.oclIsKindOf(RDM!IndividualVariable))->collect(c | thisModule.IndividualVariable2ObjectVariable(c)),
										   atoms->select(c | c.name = 'SameIndividualAtom')->collect(e | e.terms)->flatten()->select(e | e.oclIsKindOf(RDM!Individual))->collect(c | thisModule.Individual2ObjectVariable(c)),
					  					   atoms->select(c | c.name = 'DifferentIndividualAtom')->collect(e | e.terms)->flatten()->select(e | e.oclIsKindOf(RDM!IndividualVariable))->collect(c | thisModule.IndividualVariable2ObjectVariable(c)),
										   atoms->select(c | c.name = 'DifferentIndividualAtom')->collect(e | e.terms)->flatten()->select(e | e.oclIsKindOf(RDM!Individual))->collect(c | thisModule.Individual2ObjectVariable(c)),
										   atoms->select(c | c.name = 'IndividualPropertyAtom')->collect(e | e.terms)->flatten()->select(e | e.oclIsKindOf(RDM!IndividualVariable))->collect(c | thisModule.IndividualVariable2ObjectVariable(c)),
										   atoms->select(c | c.name = 'DataRangeAtom')->collect(e | e.terms)->flatten()->select(e | e.oclIsKindOf(RDM!IndividualVariable))->collect(c | thisModule.IndividualVariable2DataVariable(c)),
										   atoms->select(c | c.name = 'BuiltinAtom')->collect(e | e.terms)->flatten()->select(e | e.oclIsKindOf(RDM!DataVariable))->collect(c | thisModule.DataVariable2DataVariable(c))										
										},
					formula <- imp
				),
			imp : R2ML!Implication (
				antecedent <- if i.hasAntecedent.containsAtom->size() > 1
	 				  	 	  then i.hasAntecedent
						      else if i.hasAntecedent.containsAtom->asSequence()->first().hasPredicateSymbol.oclIsKindOf(RDM!Restriction) then
							  		i.hasAntecedent.containsAtom->asSequence()->first().hasPredicateSymbol
									else i.hasAntecedent.containsAtom->asSequence()->first()
									endif
						      endif,
				consequent <- if i.hasConsequent.containsAtom->size() > 1
					  	      then i.hasConsequent
					  	      else if i.hasConsequent.containsAtom->asSequence()->first().hasPredicateSymbol.oclIsKindOf(RDM!Restriction) then
								  	i.hasConsequent.containsAtom->asSequence()->first().hasPredicateSymbol
								   else i.hasConsequent.containsAtom->asSequence()->first()
								   endif	
					  	      endif
		)
}

-- Endpoint Rule 'RuleBase'
-- Create RuleBase R2ML element as parent of all Integrity rules
endpoint rule RuleBase() {
     to rb : R2ML!RuleBase (
				rules <- Sequence { rs }
			),
    rs : R2ML!IntegrityRuleSet (
				rules <- RDM!Rule.allInstancesFrom('IN')->asSequence()
			)
}


-- Rule 'Antecedent2Conjuction'
-- Create Conjuction R2ML element from RDM Antecedent element,
-- if antecedent have more than one element.
rule Antecedent2Conjuction {
	from i : RDM!Antecedent (
			i.containsAtom->size () > 1
		)
	to o : R2ML!Conjuction (
			formulas <- Sequence{ i.containsAtom->select(c | c.hasPredicateSymbol.oclIsKindOf(RDM!Restriction))->collect(c | c.hasPredicateSymbol)->flatten(),
  								  i.containsAtom->select(c | not c.hasPredicateSymbol.oclIsKindOf(RDM!Restriction))			
								}
		)
}

-- Rule 'Consequent2Conjuction'
-- Create Conjuction R2ML element from RDM Consequent element,
-- if consequent have more than one element.
rule Consequent2Conjuction {
	from i : RDM!Consequent (
			i.containsAtom->size () > 1
		)
	to o : R2ML!Conjuction (
			formulas <- Sequence{ i.containsAtom->select(c | c.hasPredicateSymbol.oclIsKindOf(RDM!Restriction))->collect(c | c.hasPredicateSymbol)->flatten(),
  								  i.containsAtom->select(c | not c.hasPredicateSymbol.oclIsKindOf(RDM!Restriction))			
								}
		)
}

-- Rule 'IndividualVariable2ObjectVariable'
-- Create R2ML ObjectVariable from RDM IndividualVariable.
unique lazy rule IndividualVariable2ObjectVariable {
	from i : RDM!IndividualVariable
	to o : R2ML!ObjectVariable (
			name <- i.name,
			classRef <- if not i.classRef.oclIsUndefined() then
							thisModule.Class2Class(i.classRef)
						else OclUndefined
						endif
		)		
}

-- Rule 'Individual2ObjectVariable'
-- Create R2ML ObjectVariable from RDM Individual.
unique lazy rule Individual2ObjectVariable {
	from i : RDM!Individual
	to o : R2ML!ObjectVariable (
			name <- i.name,
			typeCategory <- #individual,
			classRef <- if not i.type.oclIsUndefined() then
							thisModule.Class2Class(i.type)
						else OclUndefined
						endif 
		)		
}

-- Rule 'IndividualVariable2DataVariable'
-- Create R2ML DataVariable from RDM IndividualVariable.
unique lazy rule IndividualVariable2DataVariable {
	from i : RDM!IndividualVariable
	to o : R2ML!DataVariable (
			name <- i.name,
			typeCategory <- #individual
		)		
}

-- Rule 'DataVariable2DataVariable'
-- Create R2ML DataVariable from RDM DataVariable.
unique lazy rule DataVariable2DataVariable {
	from i : RDM!DataVariable
	to o : R2ML!DataVariable (
			name <- i.name,
			typeCategory <- #individual
		)		
}",transform rdm metamodel r ml metamodel creat part m sc these good old ai laboratori author milan milanov milan milanov org work r ml v integr deriv rule licenc gnu general public licens version modul rdm r ml modul templat creat out r ml in rdm use string helper helper search class element atom predic symbol helper getatomforclassel return atom contain cla class element haspredicatesymbol children predic symbol this helper need want find element atom containt get term atom in rdm class out rdm atom helper def getatomforclassel cla rdm class rdm atom let allatom sequenc rdm atom rdm atom allinstancesfrom in assequ select c c haspredicatesymbol ocliskindof rdm class allatom iter p res rdm atom allatom first p childrenclass cla includ cla p els res endif helper childrenclass return children class predic symbol atom it return class element inherit class context rdm atom in rdm class out sequenc rdm class helper context rdm atom def childrenclass cla rdm class sequenc rdm class self haspredicatesymbol oclistypeof rdm class sequenc self haspredicatesymbol els sequenc self haspredicatesymbol childrenclass cla flatten endif helper childrenclass return children class intersectionclass if class contain element helper call element context rdm intersectionclass in rdm class out sequenc rdm class helper context rdm intersectionclass def childrenclass cla rdm class sequenc rdm class let allclass sequenc rdm class self intersectionof select e e oclistypeof rdm class allclass union self intersectionof select e e oclistypeof rdm class collect c c childrenclass cla flatten append self helper childrenclass return children class unionclass if class contain element helper call element context rdm unionclass in rdm class out sequenc rdm class helper context rdm unionclass def childrenclass cla rdm class sequenc rdm class let allclass sequenc rdm class self unionof select e e oclistypeof rdm class allclass union self unionof select e e oclistypeof rdm class collect c c childrenclass cla flatten append self helper childrenclass return children class complementclass if class contain element helper call element context rdm complementclass in rdm class out sequenc rdm class helper context rdm complementclass def childrenclass cla rdm class sequenc rdm class self complementof oclistypeof rdm class sequenc self complementof append self els self complementof childrenclass cla append self endif helper childrenclass return children class enumeratedclass this class children class context rdm enumeratedclass in rdm class out sequenc rdm class helper context rdm enumeratedclass def childrenclass cla rdm class sequenc rdm class self oneof assequ helper childrenclass return children class hasvaluerestrict this class children class context rdm hasvaluerestrict in rdm class out sequenc rdm class helper context rdm hasvaluerestrict def childrenclass cla rdm class sequenc rdm class sequenc self helper childrenclass return children class mincardinalityrestrict this class children class context rdm mincardinalityrestrict in rdm class out sequenc rdm class helper context rdm mincardinalityrestrict def childrenclass cla rdm class sequenc rdm class sequenc self helper childrenclass return children class maxcardinalityrestrict this class children class context rdm maxcardinalityrestrict in rdm class out sequenc rdm class helper context rdm maxcardinalityrestrict def childrenclass cla rdm class sequenc rdm class sequenc self helper childrenclass return children class cardinalityrestrict this class children class context rdm cardinalityrestrict in rdm class out sequenc rdm class helper context rdm cardinalityrestrict def childrenclass cla rdm class sequenc rdm class sequenc self helper childrenclass return children class somevaluesfromrestrict if class contain element helper call element context rdm somevaluesfromrestrict in rdm class out sequenc rdm class helper context rdm somevaluesfromrestrict def childrenclass cla rdm class sequenc rdm class self somevaluesfromclass oclisundefin sequenc self somevaluesfromclass append self els sequenc self endif helper childrenclass return children class allvaluesfromrestrict if class contain element helper call element context rdm allvaluesfromrestrict in rdm class out sequenc rdm class helper context rdm allvaluesfromrestrict def childrenclass cla rdm class sequenc rdm class self allvaluesfromclass oclisundefin sequenc self allvaluesfromclass append self els sequenc self endif helper childrenclass return children class objectproperti this class children class context rdm objectproperti in rdm class out sequenc rdm class helper context rdm objectproperti def childrenclass cla rdm class sequenc rdm class sequenc helper search data element atom predic symbol helper getatomfordatael return atom contain dtp ontologyel element haspredicatesymbol children predic symbol this helper need want find element atom containt get term atom annot use ontologyel instead datatyp becas want includ datarang element datatyp class in rdm ontologyel out rdm atom helper def getatomfordatael dtp rdm ontologyel rdm atom let allatom sequenc rdm atom rdm atom allinstancesfrom in assequ select c c haspredicatesymbol ocliskindof rdm ontologyel allatom iter p res rdm atom allatom first p childrenelem dtp includ dtp p els res endif helper childrenelem return children data element predic symbol atom it return datatyp also datarang context rdm atom in rdm ontologyel out sequenc rdm ontologyel helper context rdm atom def childrenelem ont rdm ontologyel sequenc rdm ontologyel self haspredicatesymbol ocliskindof rdm datatyp self haspredicatesymbol oclistypeof rdm datarang sequenc self haspredicatesymbol childrenelem ont flatten els sequenc self haspredicatesymbol endif helper childrenelem return children data element datarang context rdm datarang in rdm ontologyel out sequenc rdm ontologyel helper context rdm datarang def childrenelem dtp rdm ontologyel sequenc rdm ontologyel self oneof oclisundefin sequenc self datatyp append self els self oneof select e e ocliskindof rdm ontologyel append self endif helper childrenelem return children data element allvaluesfromrestrict context rdm allvaluesfromrestrict in rdm ontologyel out sequenc rdm ontologyel helper context rdm allvaluesfromrestrict def childrenelem dtp rdm ontologyel sequenc rdm ontologyel self allvaluesfromrang oneof select e e ocliskindof rdm ontologyel append self helper childrenelem return children data element somevaluesfromrestrict context rdm somevaluesfromrestrict in rdm ontologyel out sequenc rdm ontologyel helper context rdm somevaluesfromrestrict def childrenelem dtp rdm ontologyel sequenc rdm ontologyel self somevaluesfromrang oneof select e e ocliskindof rdm ontologyel append self helper childrenelem return children data element hasvaluerestrict context rdm hasvaluerestrict in rdm ontologyel out sequenc rdm ontologyel helper context rdm hasvaluerestrict def childrenelem dtp rdm ontologyel sequenc rdm ontologyel sequenc self hasliteralvalu append self helper childrenelem return children data element mincardinalityrestrict context rdm mincardinalityrestrict in rdm ontologyel out sequenc rdm ontologyel helper context rdm mincardinalityrestrict def childrenelem dtp rdm ontologyel sequenc rdm ontologyel sequenc self helper childrenelem return children data element maxcardinalityrestrict context rdm maxcardinalityrestrict in rdm ontologyel out sequenc rdm ontologyel helper context rdm maxcardinalityrestrict def childrenelem dtp rdm ontologyel sequenc rdm ontologyel sequenc self helper childrenelem return children data element cardinalityrestrict context rdm cardinalityrestrict in rdm ontologyel out sequenc rdm ontologyel helper context rdm cardinalityrestrict def childrenelem dtp rdm ontologyel sequenc rdm ontologyel sequenc self helper childrenelem return children data element liter it work also element extend liter typedliter plainliter context rdm liter in rdm ontologyel out sequenc rdm ontologyel helper context rdm liter def childrenelem dtp rdm ontologyel sequenc rdm ontologyel sequenc self helper childrenelem return children data element primitivetyp context rdm primitivetyp in rdm ontologyel out sequenc rdm ontologyel helper context rdm primitivetyp def childrenelem dtp rdm ontologyel sequenc rdm ontologyel sequenc self helper childrenclass return children element datatypeproperti this class children class context rdm datatypeproperti in rdm ontologyel out sequenc rdm class helper context rdm datatypeproperti def childrenelem dtp rdm ontologyel sequenc rdm ontologyel sequenc other helper helper maxcardinalityonsameproperti return maxcardinalityrestrict defin properti contextu mincardinalityrestrict this helper need want find two restrict min max defin properti context rdm mincardinalityrestrict out sequenc rdm maxcardinalityrestrict helper context rdm mincardinalityrestrict def maxcardinalityonsameproperti rdm maxcardinalityrestrict let maxcardinalityrestrict sequenc rdm maxcardinalityrestrict rdm maxcardinalityrestrict allinstancesfrom in assequ maxcardinalityrestrict iter p res rdm maxcardinalityrestrict maxcardinalityrestrict first p onproperti assequ includ self onproperti assequ first p els res endif helper mincardinalityonsameproperti return mincardinalityrestrict defin properti contextu maxcardinalityrestrict this helper need want find two restrict min max defin properti context rdm maxcardinalityrestrict out sequenc rdm mincardinalityrestrict helper context rdm maxcardinalityrestrict def mincardinalityonsameproperti rdm mincardinalityrestrict let mincardinalityrestrict sequenc rdm mincardinalityrestrict rdm mincardinalityrestrict allinstancesfrom in assequ mincardinalityrestrict iter p res rdm mincardinalityrestrict mincardinalityrestrict first p onproperti assequ includ self onproperti assequ first p els res endif helper transform this ocl helper side effect use creat new instanc r ml objectclassificationatom rdm class use class es parent transform class it use lazi rule context rdm class in rdm class r ml class out r ml objectclassificationatom helper context rdm class def transform parent rdm class transformedclass r ml class r ml objectclassificationatom r ml objectclassificationatom newinst refsetvalu isneg fals refsetvalu term thismodul individualvari objectvari thismodul getatomforclassel parent term first refsetvalu type transformedclass helper getdefaulttypedliter return alway type liter defin type or oclundefin type liter found in type out rdm typedliter helper def getdefaulttypedliter type string rdm typedliter let typ rdm typedliter rdm typedliter allinstancesfrom in assequ select c c thetyp type first typ oclisundefin oclundefin els typ endif helper getdefaultplainliter return alway plain liter or oclundefin type liter found in type out rdm plainliter helper def getdefaultplainliter rdm plainliter let typ rdm plainliter rdm plainliter allinstancesfrom in assequ first typ oclisundefin oclundefin els typ endif helper getallatom return rdm atom rdm rule context rdm rule out sequenc rdm atom helper context rdm rule def getallatom sequenc rdm atom self hasanteced containsatom assequ union self hasconsequ containsatom assequ rule atom classatom rule classatom objectclassificationatom creat r ml objectclassificationatom rdm classatom class predicatesymbol rule classatom objectclassificationatom rdm atom name classatom haspredicatesymbol oclistypeof rdm class r ml objectclassificationatom isneg fals term thismodul individualvari objectvari term first type thismodul class class haspredicatesymbol rule intersect conjuct creat r ml conjuct element rdm classatom intersectionclass predicatesymbol annot design decis predic symbol element know transform base parent atom rule intersect conjuct rdm atom name classatom haspredicatesymbol oclistypeof rdm intersectionclass r ml conjuct formula sequenc haspredicatesymbol intersectionof assequ select c c oclistypeof rdm class collect e e transform haspredicatesymbol thismodul class class e haspredicatesymbol intersectionof assequ select c c oclistypeof rdm class assequ rule unionatom disjunct creat r ml disjunct element rdm classatom unionclass predicatesymbol rule unionatom disjunct rdm atom name classatom haspredicatesymbol oclistypeof rdm unionclass r ml disjunct formula sequenc haspredicatesymbol unionof assequ select c c oclistypeof rdm class collect e e transform haspredicatesymbol thismodul class class e haspredicatesymbol unionof assequ select c c oclistypeof rdm class assequ rule union disjunct creat r ml disjunct element unionclass rule union disjunct rdm unionclass oclistypeof rdm unionclass rdm atom allinstancesfrom in assequ collect c c haspredicatesymbol flatten exclud r ml disjunct formula sequenc unionof assequ select c c oclistypeof rdm class collect e e transform thismodul class class e unionof assequ select c c oclistypeof rdm class assequ rule complement negat creat r ml negat element rdm classatom complementclass predicatesymbol rule complement negat rdm atom name classatom haspredicatesymbol oclistypeof rdm complementclass r ml strongneg formula haspredicatesymbol complementof oclistypeof rdm class haspredicatesymbol complementof transform haspredicatesymbol thismodul class class haspredicatesymbol complementof els haspredicatesymbol complementof endif rule enumeratedclass disjunct creat r ml disjunct element enumeratedclass rule enumeratedclass disjunct rdm enumeratedclass oclistypeof rdm enumeratedclass rdm atom allinstancesfrom in assequ collect c c haspredicatesymbol flatten exclud r ml disjunct formula oneof rule enumeratedclassatom disjunct creat r ml disjunct element rdm classatom enumeratedclass predicatesymbol rule enumeratedclassatom disjunct rdm atom name classatom haspredicatesymbol oclistypeof rdm enumeratedclass r ml disjunct formula haspredicatesymbol oneof rule individu equalityatom creat r ml equalityatom individu element oneof element enumeratedclass rule individu equalityatom rdm individu rdm enumeratedclass allinstancesfrom in assequ collect e e oneof flatten includ r ml equalityatom term sequenc obj thismodul individualvari objectvari thismodul getatomforclassel term first obj r ml objectnam name name rule class objectclassificationatom creat r ml objectclassificationatom class element annot current use switch transform helper uniqu lazi rule class objectclassificationatom rdm class r ml objectclassificationatom isneg fals term thismodul individualvari objectvari thismodul getatomforclassel term first helper koji ce naci atom koji sadrzi ovu klasu type thismodul class class rule class class creat r ml class rdm class element uniqu lazi rule class class rdm class cla r ml class name name predicatecategori close rule hasvaluerestrictionclass referencepropertyatom creat r ml referencepropertyatom hasvaluerestrict element hasvalu attribut defin rule hasvaluerestrictionclass referencepropertyatom rdm hasvaluerestrict oclistypeof rdm hasvaluerestrict hasvalu oclisundefin onproperti assequ first oclistypeof rdm objectproperti r ml referencepropertyatom isneg fals object thismodul individu objectvari hasvalu referenceproperti onproperti assequ first subject thismodul individualvari objectvari thismodul getatomforclassel term first rule somevaluesfromrestrictionclass existentiallyquantifiedformula creat r ml existentiallyquantifiedformula somevaluesfromrestrict element somevaluesfromclass attribut defin rule somevaluesfromrestrictionclass existentiallyquantifiedformula rdm somevaluesfromrestrict oclistypeof rdm somevaluesfromrestrict somevaluesfromclass oclisundefin r ml existentiallyquantifiedformula variabl objvar formula conj objvar r ml objectvari name x typecategori individu conj r ml conjuct formula somevaluesfromclass oclistypeof rdm class sequenc somevaluesfromclass transform thismodul class class somevaluesfromclass refpropat els sequenc somevaluesfromclass refpropat endif refpropat r ml referencepropertyatom isneg fals subject thismodul individualvari objectvari thismodul getatomforclassel term first object objvar referenceproperti onproperti assequ first rule allvaluesfromrestrictionclass universallyquantifiedformula creat r ml universallyquantifiedformula allvaluesfromrestrict element allvaluesfromclass attribut defin rule allvaluesfromrestrictionclass universallyquantifiedformula rdm allvaluesfromrestrict oclistypeof rdm allvaluesfromrestrict allvaluesfromclass oclisundefin r ml universallyquantifiedformula variabl objvar formula impl objvar r ml objectvari name x typecategori individu impl r ml implic anteced refpropat consequ allvaluesfromclass oclistypeof rdm class allvaluesfromclass transform thismodul class class allvaluesfromclass els allvaluesfromclass endif refpropat r ml referencepropertyatom isneg fals subject thismodul individualvari objectvari thismodul getatomforclassel term first object objvar referenceproperti onproperti assequ first rule mincardinalityrestrictionclass atleastquantifiedformula creat r ml atleastquantifiedformula mincardinalityrestrict element defin objectproperti maxcardin defin properti rule mincardinalityrestrictionclass atleastquantifiedformula rdm mincardinalityrestrict oclistypeof rdm mincardinalityrestrict rdm maxcardinalityrestrict allinstancesfrom in assequ collect c c onproperti flatten exclud onproperti assequ first onproperti assequ first oclistypeof rdm objectproperti r ml atleastquantifiedformula mincardin mincardin lexicalform tointeg variabl objvar formula refpropat objvar r ml objectvari name x typecategori individu refpropat r ml referencepropertyatom isneg fals subject thismodul individualvari objectvari thismodul getatomforclassel term first object objvar referenceproperti onproperti assequ first rule maxcardinalityrestrictionclass atleastquantifiedformula creat r ml atmostquantifiedformula maxcardinalityrestrict element defin objectproperti mincardin defin properti rule maxcardinalityrestrictionclass atleastquantifiedformula rdm maxcardinalityrestrict oclistypeof rdm maxcardinalityrestrict rdm mincardinalityrestrict allinstancesfrom in assequ collect c c onproperti flatten exclud onproperti assequ first onproperti assequ first oclistypeof rdm objectproperti r ml atmostquantifiedformula maxcardin maxcardin lexicalform tointeg variabl objvar formula refpropat objvar r ml objectvari name x typecategori individu refpropat r ml referencepropertyatom isneg fals subject thismodul individualvari objectvari thismodul getatomforclassel term first object objvar referenceproperti onproperti assequ first rule maxmincardinalityrestrictionclass atleastandatmostquantifiedformula creat r ml atleastandatmostquantifiedformula maxcardinalityrestrict element defin objectproperti mincardin defin properti annot it need predicatesymbol atom exist mincardinaltyrestrict defin rule maxmincardinalityrestrictionclass atleastandatmostquantifiedformula rdm maxcardinalityrestrict oclistypeof rdm maxcardinalityrestrict rdm mincardinalityrestrict allinstancesfrom in assequ collect c c onproperti flatten includ onproperti assequ first onproperti assequ first oclistypeof rdm objectproperti rdm atom allinstancesfrom in assequ collect c c haspredicatesymbol flatten exclud mincardinalityonsameproperti r ml atleastandatmostquantifiedformula maxcardin maxcardin lexicalform tointeg mincardin mincardinalityonsameproperti mincardin lexicalform tointeg variabl objvar formula refpropat objvar r ml objectvari name x typecategori individu refpropat r ml referencepropertyatom isneg fals subject thismodul individualvari objectvari thismodul getatomforclassel term first object objvar referenceproperti onproperti assequ first rule minmaxcardinalityrestrictionclass atleastandatmostquantifiedformula creat r ml atleastandatmostquantifiedformula mincardinalityrestrict element defin objectproperti maxcardin defin properti annot it need predicatesymbol atom exist maxcardinaltyrestrict defin rule minmaxcardinalityrestrictionclass atleastandatmostquantifiedformula rdm mincardinalityrestrict we start mincardin also start maxcardin oclistypeof rdm mincardinalityrestrict rdm maxcardinalityrestrict allinstancesfrom in assequ collect c c onproperti flatten includ onproperti assequ first onproperti assequ first oclistypeof rdm objectproperti rdm atom allinstancesfrom in assequ collect c c haspredicatesymbol flatten exclud maxcardinalityonsameproperti r ml atleastandatmostquantifiedformula maxcardin maxcardinalityonsameproperti maxcardin lexicalform tointeg mincardin mincardin lexicalform tointeg variabl objvar formula refpropat objvar r ml objectvari name x typecategori individu refpropat r ml referencepropertyatom isneg fals subject thismodul individualvari objectvari thismodul getatomforclassel term first object objvar referenceproperti onproperti assequ first rule cardinalityrestrictionclass atleastandatmostquantifiedformula creat r ml atleastandatmostquantifiedformula cardinalityrestrict element defin objectproperti rule cardinalityrestrictionclass atleastandatmostquantifiedformula rdm cardinalityrestrict oclistypeof rdm cardinalityrestrict onproperti assequ first oclistypeof rdm objectproperti r ml atleastandatmostquantifiedformula maxcardin cardin lexicalform tointeg mincardin cardin lexicalform tointeg variabl objvar formula refpropat objvar r ml objectvari name x typecategori individu refpropat r ml referencepropertyatom isneg fals subject thismodul individualvari objectvari thismodul getatomforclassel term first object objvar referenceproperti onproperti assequ first datarangeatom rule datarangeatom dataclassificationatom creat r ml dataclassificationatom atom element datarang predic symbol undefin datatyp rule datarangeatomoneof dataclassificationatom rdm atom name datarangeatom haspredicatesymbol oclistypeof rdm datarang haspredicatesymbol datatyp oclisundefin els fals endif r ml dataclassificationatom isneg fals term thismodul individualvari datavari term first type thismodul getdefaulttypedliter haspredicatesymbol datatyp name oclundefin thismodul typedliter datatyp thismodul getdefaulttypedliter haspredicatesymbol datatyp name els thismodul primitivetyp datatyp haspredicatesymbol datatyp endif rule datarang dataclassificationatom creat r ml dataclassificationatom datarang element predic symbol atom datatyp defin rule datarang dataclassificationatom rdm datarang oclistypeof rdm datarang rdm atom allinstancesfrom in assequ collect c c haspredicatesymbol flatten exclud datatyp oclisundefin fals els true endif r ml dataclassificationatom isneg fals term thismodul individualvari datavari thismodul getatomfordatael term first type thismodul getdefaulttypedliter datatyp name oclundefin thismodul typedliter datatyp thismodul getdefaulttypedliter datatyp name els thismodul primitivetyp datatyp datatyp endif rule primitivetyp datatyp creat r ml datatyp rdm primitivetyp element uniqu lazi rule primitivetyp datatyp rdm primitivetyp r ml datatyp predicatecategori close name name rule datarangeatom disjunct creat r ml disjunct atom element datarang predic symbol undefin datatyp rule datarangeatom disjunct rdm atom name datarangeatom haspredicatesymbol oclistypeof rdm datarang haspredicatesymbol datatyp oclisundefin els fals endif r ml disjunct formula haspredicatesymbol oneof rule datarang disjunct creat r ml disjunct datarang element predic symbol atom datatyp undefin rule datarang disjunct rdm datarang oclistypeof rdm datarang rdm atom allinstancesfrom in assequ collect c c haspredicatesymbol flatten exclud datatyp oclisundefin true els fals endif r ml disjunct formula oneof rule plainliter plainliter creat r ml plainliter rdm plainliter element children datarang rule plainliter plainliter rdm plainliter oclistypeof rdm plainliter rdm datarang allinstancesfrom in assequ select e e oneof oclisundefin collect c c oneof flatten exclud r ml plainliter languagetag languag lexicalvalu lexicalform typecategori individu rule typedliter typedliter creat r ml typedliter rdm typedliter element children datarang rule typedliter typedliter rdm typedliter oclistypeof rdm typedliter rdm datarang allinstancesfrom in assequ select e e oneof oclisundefin collect c c oneof flatten exclud rdm cardinalityrestrict allinstancesfrom in assequ collect c c cardin flatten exclud rdm mincardinalityrestrict allinstancesfrom in assequ collect c c mincardin flatten exclud rdm maxcardinalityrestrict allinstancesfrom in assequ collect c c maxcardin flatten exclud r ml typedliter type thismodul typedliter datatyp thismodul getdefaulttypedliter thetyp lexicalvalu lexicalform typecategori individu rule typedliter datatyp lazi rule creat r ml datatyp rdm typedliter element uniqu lazi rule typedliter datatyp rdm typedliter r ml datatyp name thetyp predicatecategori close rule plainliter datatypepredicateatom creat r ml datatypepredicateatom rdm plainliter element children datarang rule plainliter datatypepredicateatom rdm plainliter oclistypeof rdm plainliter rdm datarang allinstancesfrom in assequ select e e oneof oclisundefin collect c c oneof flatten includ r ml datatypepredicateatom isneg fals dataargu sequenc pl thismodul individualvari datavari thismodul getatomfordatael term first predic thismodul plainliter datatypepred thismodul getdefaultplainliter pl r ml plainliter lexicalvalu lexicalform typecategori individu rule typedliter datatypepredicateatom creat r ml datatypepredicateatom rdm typedliter element children datarang rule typedliter datatypepredicateatom rdm typedliter oclistypeof rdm typedliter rdm datarang allinstancesfrom in assequ select e e oneof oclisundefin collect c c oneof flatten includ r ml datatypepredicateatom isneg fals dataargu sequenc pl thismodul individualvari datavari thismodul getatomfordatael term first predic thismodul typedliter datatypepred thismodul getdefaulttypedliter thetyp pl r ml typedliter lexicalvalu lexicalform type thismodul typedliter datatyp thismodul getdefaulttypedliter thetyp typecategori individu rule typedliter datatypepred creat r ml datatypepred swrlb equal rdm typedliter element uniqu lazi rule typedliter datatypepred rdm typedliter r ml datatypepred name swrlb equal predicatecategori close rule plainliter datatypepred creat r ml datatypepred swrlb equal rdm plainliter element uniqu lazi rule plainliter datatypepred rdm plainliter r ml datatypepred name swrlb equal predicatecategori close rule datatypeproperti attribut creat r ml attribut rdm datatypeproperti element uniqu lazi rule datatypeproperti attribut rdm datatypeproperti r ml attribut name name predicatecategori close rule allvaluesfromrestrictiondata universallyquantifiedformula creat r ml universallyquantifiedformula rdm allvaluesfromrestrict element allvaluesfromrang defin rule allvaluesfromrestrictiondata universallyquantifiedformula rdm allvaluesfromrestrict oclistypeof rdm allvaluesfromrestrict allvaluesfromrang oclisundefin r ml universallyquantifiedformula variabl objvar formula impl objvar r ml objectvari name x typecategori individu impl r ml implic anteced attrat consequ allvaluesfromrang attrat r ml attributionatom isneg fals attribut thismodul datatypeproperti attribut onproperti assequ first subject objvar datavalu thismodul individualvari datavari thismodul getatomfordatael term first rule somevaluesfromrestrictiondata existentiallyquantifiedformula creat r ml existentiallyquantifiedformula rdm somevaluesfromrestrict element somevaluesfromrang defin rule somevaluesfromrestrictiondata existentiallyquantifiedformula rdm somevaluesfromrestrict oclistypeof rdm somevaluesfromrestrict somevaluesfromrang oclisundefin r ml existentiallyquantifiedformula variabl objvar formula conj objvar r ml objectvari name x typecategori individu conj r ml conjuct formula sequenc somevaluesfromrang attrat attrat r ml attributionatom isneg fals attribut thismodul datatypeproperti attribut onproperti assequ first subject objvar datavalu thismodul individualvari datavari thismodul getatomfordatael term first rule hasvaluerestrictiondata attributeatom creat r ml attributionatom rdm hasvaluerestrict element hasliteralvalu defin rule hasvaluerestrictiondata attributeatom rdm hasvaluerestrict oclistypeof rdm hasvaluerestrict hasliteralvalu oclisundefin r ml attributionatom isneg fals attribut thismodul datatypeproperti attribut onproperti assequ first subject thismodul individualvari objectvari thismodul getatomfordatael term first datavalu hasliteralvalu rule mincardinalityrestrictiondata atleastquantifiedformula creat r ml atleastquantifiedformula mincardinalityrestrict element defin datatypeproperti maxcardin defin properti rule mincardinalityrestrictiondata atleastquantifiedformula rdm mincardinalityrestrict oclistypeof rdm mincardinalityrestrict rdm maxcardinalityrestrict allinstancesfrom in assequ collect c c onproperti flatten exclud onproperti assequ first onproperti assequ first oclistypeof rdm datatypeproperti r ml atleastquantifiedformula mincardin mincardin lexicalform tointeg variabl objvar formula attrat objvar r ml objectvari name x typecategori individu attrat r ml attributionatom isneg fals attribut thismodul datatypeproperti attribut onproperti assequ first subject objvar datavalu thismodul individualvari datavari thismodul getatomfordatael term first rule maxcardinalityrestrictiondata atleastquantifiedformula creat r ml atmostquantifiedformula maxcardinalityrestrict element defin datatypeproperti mincardin defin properti rule maxcardinalityrestrictiondata atleastquantifiedformula rdm maxcardinalityrestrict oclistypeof rdm maxcardinalityrestrict rdm mincardinalityrestrict allinstancesfrom in assequ collect c c onproperti flatten exclud onproperti assequ first onproperti assequ first oclistypeof rdm datatypeproperti r ml atmostquantifiedformula maxcardin maxcardin lexicalform tointeg variabl objvar formula attrat objvar r ml objectvari name x typecategori individu attrat r ml attributionatom isneg fals attribut thismodul datatypeproperti attribut onproperti assequ first subject objvar datavalu thismodul individualvari datavari thismodul getatomfordatael term first rule minmaxcardinalityrestrictionclass atleastandatmostquantifiedformula creat r ml atleastandatmostquantifiedformula mincardinalityrestrict element defin datatypeproperti maxcardin defin properti annot it need predicatesymbol atom exist maxcardinaltyrestrict defin rule minmaxcardinalityrestrictiondata atleastandatmostquantifiedformula rdm mincardinalityrestrict we start mincardin also start maxcardin oclistypeof rdm mincardinalityrestrict rdm maxcardinalityrestrict allinstancesfrom in assequ collect c c onproperti flatten includ onproperti assequ first rdm atom allinstancesfrom in assequ collect c c haspredicatesymbol flatten exclud maxcardinalityonsameproperti onproperti assequ first oclistypeof rdm datatypeproperti r ml atleastandatmostquantifiedformula maxcardin maxcardinalityonsameproperti maxcardin lexicalform tointeg mincardin mincardin lexicalform tointeg variabl objvar formula attrat objvar r ml objectvari name x typecategori individu attrat r ml attributionatom isneg fals attribut thismodul datatypeproperti attribut onproperti assequ first subject objvar datavalu thismodul individualvari datavari thismodul getatomfordatael term first rule maxmincardinalityrestrictionclass atleastandatmostquantifiedformula creat r ml atleastandatmostquantifiedformula maxcardinalityrestrict element defin datatypeproperti mincardin defin properti annot it need predicatesymbol atom exist mincardinaltyrestrict defin rule maxmincardinalityrestrictiondata atleastandatmostquantifiedformula rdm maxcardinalityrestrict oclistypeof rdm maxcardinalityrestrict rdm mincardinalityrestrict allinstancesfrom in assequ collect c c onproperti flatten includ onproperti assequ first rdm atom allinstancesfrom in assequ collect c c haspredicatesymbol flatten exclud mincardinalityonsameproperti onproperti assequ first oclistypeof rdm datatypeproperti r ml atleastandatmostquantifiedformula maxcardin maxcardin lexicalform tointeg mincardin mincardinalityonsameproperti mincardin lexicalform tointeg variabl objvar formula attrat objvar r ml objectvari name x typecategori individu attrat r ml attributionatom isneg fals attribut thismodul datatypeproperti attribut onproperti assequ first subject objvar datavalu thismodul individualvari datavari thismodul getatomfordatael term first rule cardinalityrestrictiondata atleastandatmostquantifiedformula creat r ml atleastandatmostquantifiedformula cardinalityrestrict element defin datatypeproperti rule cardinalityrestrictiondata atleastandatmostquantifiedformula rdm cardinalityrestrict oclistypeof rdm cardinalityrestrict onproperti assequ first oclistypeof rdm datatypeproperti r ml atleastandatmostquantifiedformula maxcardin cardin lexicalform tointeg mincardin cardin lexicalform tointeg variabl objvar formula attrat objvar r ml objectvari name x typecategori individu attrat r ml attributionatom isneg fals attribut thismodul datatypeproperti attribut onproperti assequ first subject objvar datavalu thismodul individualvari datavari thismodul getatomfordatael term first datavaluedpropertyatom rule datavaluedpropertyatom attributeatom creat r ml attributionatom atom element datavaluedpropertyatom rule datavaluedpropertyatom attributeatom rdm atom name datavaluedpropertyatom r ml attributionatom isneg fals attribut thismodul datatypeproperti attribut haspredicatesymbol subject thismodul individualvari objectvari term select e e ocliskindof rdm individualvari first datavalu term select c c oclistypeof rdm datavalu size term select c c oclistypeof rdm datavalu collect e thismodul datavalu typedliter e first els term select c c oclistypeof rdm datavari collect e thismodul datavari datavari e first endif lazi rule datavalu typedliter creat r ml plainliter datavalu rdm element lazi rule datavalu typedliter rdm datavalu r ml typedliter lexicalvalu valu type thismodul primitivetyp datatyp type typecategori individu sameindividualatom rule sameindividualatom equalityatom creat r ml equalityatom atom element sameindividualatom rule sameindividualatom equalityatom rdm atom name sameindividualatom r ml equalityatom term sequenc term select e e oclistypeof rdm individualvari collect c thismodul individualvari objectvari c term select e e oclistypeof rdm individu collect c thismodul individu objectvari c differentindividualatom rule differentindividualatom inequalityatom creat r ml inequalityatom atom element differentindividualatom rule differentindividualatom inequalityatom rdm atom name differentindividualatom r ml inequalityatom term sequenc term select e e oclistypeof rdm individualvari collect c thismodul individualvari objectvari c term select e e oclistypeof rdm individu collect c thismodul individu objectvari c builtinatom rule builtinatom datatypepredicateatom creat r ml datatypepredicateatom atom element builtinatom rule builtinatom datatypepredicateatom rdm atom name builtinatom r ml datatypepredicateatom isneg fals dataargu sequenc term select e e ocliskindof rdm datavari collect c thismodul datavari datavari c term select e e ocliskindof rdm datavalu collect c thismodul datavalu typedliter c predic thismodul builtin datatypepred haspredicatesymbol rule builtin datatypepred lazi rule creat r ml datatypepred rdm builtin uniqu lazi rule builtin datatypepred rdm builtin r ml datatypepred name buildinid individualpropertyatom rule individualpropertyatom universallyquantifiedformula creat universallyquantifiedformula r ml element rdm atom element rule individualpropertyatom referencepropertyatom rdm atom name individualpropertyatom refpropat r ml referencepropertyatom isneg fals referenceproperti haspredicatesymbol subject term last oclistypeof rdm individualvari thismodul individualvari objectvari term last els thismodul individu objectvari term last endif object thismodul individualvari objectvari term first rule objectproperti referenceproperti transform rdm objectproperti element r ml referenceproperti element rule objectproperti referenceproperti rdm objectproperti r ml referenceproperti predicatecategori close name name rule datatypeproperti referenceproperti transform rdm datatypeproperti element r ml referenceproperti element rule datatypeproperti referenceproperti rdm datatypeproperti r ml referenceproperti predicatecategori close name name rule rule implic creat implic r ml element rdm rule element rule rule implic rdm rule ir r ml alethicintegrityrul constraint r ml universallyquantifiedformula collect variabl atom variabl let atom sequenc rdm atom getallatom sequenc atom select c c name classatom collect e e term flatten collect c thismodul individualvari objectvari c atom select c c name datavaluedpropertyatom collect e e term flatten select e e ocliskindof rdm individualvari collect c thismodul individualvari objectvari c atom select c c name datavaluedpropertyatom collect e e term flatten select e e ocliskindof rdm datavari collect c thismodul datavari datavari c atom select c c name sameindividualatom collect e e term flatten select e e ocliskindof rdm individualvari collect c thismodul individualvari objectvari c atom select c c name sameindividualatom collect e e term flatten select e e ocliskindof rdm individu collect c thismodul individu objectvari c atom select c c name differentindividualatom collect e e term flatten select e e ocliskindof rdm individualvari collect c thismodul individualvari objectvari c atom select c c name differentindividualatom collect e e term flatten select e e ocliskindof rdm individu collect c thismodul individu objectvari c atom select c c name individualpropertyatom collect e e term flatten select e e ocliskindof rdm individualvari collect c thismodul individualvari objectvari c atom select c c name datarangeatom collect e e term flatten select e e ocliskindof rdm individualvari collect c thismodul individualvari datavari c atom select c c name builtinatom collect e e term flatten select e e ocliskindof rdm datavari collect c thismodul datavari datavari c formula imp imp r ml implic anteced hasanteced containsatom size hasanteced els hasanteced containsatom assequ first haspredicatesymbol ocliskindof rdm restrict hasanteced containsatom assequ first haspredicatesymbol els hasanteced containsatom assequ first endif endif consequ hasconsequ containsatom size hasconsequ els hasconsequ containsatom assequ first haspredicatesymbol ocliskindof rdm restrict hasconsequ containsatom assequ first haspredicatesymbol els hasconsequ containsatom assequ first endif endif endpoint rule rulebas creat rulebas r ml element parent integr rule endpoint rule rulebas rb r ml rulebas rule sequenc rs rs r ml integrityruleset rule rdm rule allinstancesfrom in assequ rule anteced conjuct creat conjuct r ml element rdm anteced element anteced one element rule anteced conjuct rdm anteced containsatom size r ml conjuct formula sequenc containsatom select c c haspredicatesymbol ocliskindof rdm restrict collect c c haspredicatesymbol flatten containsatom select c c haspredicatesymbol ocliskindof rdm restrict rule consequ conjuct creat conjuct r ml element rdm consequ element consequ one element rule consequ conjuct rdm consequ containsatom size r ml conjuct formula sequenc containsatom select c c haspredicatesymbol ocliskindof rdm restrict collect c c haspredicatesymbol flatten containsatom select c c haspredicatesymbol ocliskindof rdm restrict rule individualvari objectvari creat r ml objectvari rdm individualvari uniqu lazi rule individualvari objectvari rdm individualvari r ml objectvari name name classref classref oclisundefin thismodul class class classref els oclundefin endif rule individu objectvari creat r ml objectvari rdm individu uniqu lazi rule individu objectvari rdm individu r ml objectvari name name typecategori individu classref type oclisundefin thismodul class class type els oclundefin endif rule individualvari datavari creat r ml datavari rdm individualvari uniqu lazi rule individualvari datavari rdm individualvari r ml datavari name name typecategori individu rule datavari datavari creat r ml datavari rdm datavari uniqu lazi rule datavari datavari rdm datavari r ml datavari name name typecategori individu,6
183,183,P79-XML2RDM.atl,"-- ============================================================
-- Transforms an XML metamodel (OWL) into the RDM metamodel.
-- Created as part of M.Sc. theses at GOOD OLD AI Laboratory
-- Author: Milan Milanovic (milan at milanovic.org)
-- Works for SWRL v0.6 (XML syntax)
-- Licence: GNU General Public License, version 2
-- ============================================================

module XML2RDM;
create OUT : RDM from IN : XML;

uses strings;
uses XMLHelpers; -- General XML metamodel helpers

-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

----------------------------------------------
-- XML2RDM Transformation specific XML helpers
----------------------------------------------

-- HELPER:	getAllRules
-- Returns a sequence of all XML elements which name is ruleml:imp
-- CONTEXT:	thisModule
-- OUT:		Sequence of XML elements
helper def: getAllRules() : Sequence(XML!Element) = 
	XML!Element.allInstances()->select(e | e.name = 'ruleml:imp')->asSequence();

-- HELPER: getRuleForElement
-- Returns XML element (Rule) which contains contextual XML element
-- CONTEXT:	XML!Element
-- OUT:		XML element
helper context XML!Element def: getRuleForElement() : XML!Element = 
	thisModule.getAllRules()->select(c | c.allSubElements->includes(self))->asSequence()->first();

-- HELPER: allSubElements
-- Returns a sequence of all XML sub elements for XML element, recursivelly
-- from this element to last element (children)
-- CONTEXT:	XML!Element
-- OUT:		Sequence of XML elements
helper context XML!Element def : allSubElements : Sequence(XML!Element) = 
	let subElems : Sequence(XML!Element) = 
		XML!Element.allInstances()->select(c | 
			c.parent = self
		)->collect(elems | elems.allSubElements)->flatten()  in
		subElems->union(
			self.children->select(ch | ch.oclIsTypeOf(XML!Element) and not subElems->exists(a | a.name = ch.name)
	    ))->flatten();

-- HELPER:	getDefaultVariable
-- Return always first Variable with value.
-- This is necessary for unique lazy rule that creates just one 
-- output IndividualVariable for multiple input (with same value)
-- CONTEXT:	thisModule
-- IN:		XML!Element, String
-- OUT:		XML!Element
helper def: getDefaultVariable(elem: XML!Element, value: String) : XML!Element = 
	elem.getRuleForElement().allSubElements->select(e | e.name = 'ruleml:var')->select(e | e.children->first().value = value)->asSequence()->first();

-- HELPER:	getVariables
-- Return all variables from input file
-- CONTEXT:	thisModule
-- OUT:		Sequence of XML Elements
helper def: getAllVariables() : Sequence(XML!Element) = 
	XML!Element.allInstances()->select(e | e.name = 'ruleml:var');

-- HELPER:	getDefaultClass
-- Return default Class with same name from input file
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		Sequence of XML Elements
helper def: getDefaultClass(value : String) : Sequence(XML!Element) = 
	XML!Element.allInstancesFrom('IN')->asSequence()->select(e | e.name = 'owlx:Class')->select(e | e.getAttrVal('owlx:name') = value)->asSequence()->first();

-- HELPER:	getAllIndividualPropertyAtomsForVariable
-- Return individual property atoms for some variable name
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		Sequence of XML Elements
helper def: getAllIndividualPropertyAtomsForVariable(name : String) : Sequence(XML!Element) =
	XML!Element.allInstancesFrom('IN')->asSequence()->select(e | e.name = 'swrlx:individualPropertyAtom')->select(c | c.children->select(c | c.oclIsTypeOf(XML!Element))->exists(e | e.name = 'ruleml:var' and e.getTextValue() = name));
	
-- HELPER:	getAllObjectProperties
-- Return all ObjectProperties
-- CONTEXT:	thisModule
-- OUT:		Sequence of XML Elements
helper def: getAllObjectProperties() : Sequence(XML!Element) = 
	XML!Element.allInstancesFrom('IN')->asSequence()->select(e | e.name = 'owlx:ObjectProperty')->asSequence();

-- HELPER:	getObjectPropertyForIndividualPropertyAtom
-- Return ObjectProperty for Individual property atom
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		Sequence of XML Elements
helper def: getObjectPropertyForIndividualPropertyAtom(property : String) : XML!Element = 
	thisModule.getAllObjectProperties()->select(c | c.getAttrVal('owlx:name') = property)->asSequence();

-- HELPER:	getClassNameForVariableInIndividualPropretyAtom
-- Return name of class for variable in Individual Property Atom (it is needed to link Individual Property atoms with object properties)
-- CONTEXT:	thisModule
-- IN:		String, XML!Element
-- OUT:		Sequence of XML Elements
helper def: getClassNameForVariableInIndividualPropretyAtom(var : String, atom : XML!Element) : String =
	if atom.getElementsByName('ruleml:var')->first().getTextValue() = var then
		thisModule.getObjectPropertyForIndividualPropertyAtom(atom.getAttrVal('swrlx:property'))->first().getElementsByName('owlx:domain')->first().children->asSequence()->first().getAttrVal('owlx:name')
	else thisModule.getObjectPropertyForIndividualPropertyAtom(atom.getAttrVal('swrlx:property'))->first().getElementsByName('owlx:range')->first().children->asSequence()->first().getAttrVal('owlx:name')
	endif;
	
-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- SWRL to RDM based transformations

-- Rule 'Ontology'
-- Create Ontology element from the XML Root element
rule Ontology {
	from i : XML!Root (
			i.name <> 'ruleml:imp'
		)
	to
		o : RDM!Ontology (
				elements <- i.children->select(c | c.oclIsKindOf(XML!Element))
			)
}

-- Rule 'Rule'
-- Creates Rule from the XML Element (with name = ""ruleml:imp"").
rule Rule {
	from
		i : XML!Element (
				i.name = 'ruleml:imp'
			)
	to
		o : RDM!Rule (
			hasConsequent <- i.children->select(c | c.name = 'ruleml:_head' and c.oclIsKindOf(XML!Element))->asSequence()->first(),
			hasAntecedent <- i.children->select(c | c.name = 'ruleml:_body' and c.oclIsKindOf(XML!Element))->asSequence()->first()
		)
}

-- Rule 'Consequent'
-- Create Consequent element from XML Element named 'ruleml:_head'
rule Consequent {
	from 
		i : XML!Element (
				i.name = 'ruleml:_head'
			)
	to
		o : RDM!Consequent (
				containsAtom <- i.children->asSequence()
			)
}

-- Rule 'Antecedent'
-- Create Antecedent element from XML Element named 'ruleml:_body'
rule Antecedent {
	from 
		i : XML!Element (
				i.name = 'ruleml:_body'
			)
	to
		o : RDM!Antecedent (
				containsAtom <- i.children->asSequence()
			)
}

-- Atoms 

-- Rule 'IndividualPropertyAtom'
-- Create IndividualPropertyAtom element from XML Element named 'swrlx:individualPropertyAtom'
rule IndividualPropertyAtom {
	from 
		i : XML!Element (
				i.name = 'swrlx:individualPropertyAtom'
			)
	to
		o : RDM!Atom (
				hasPredicateSymbol <- pred, 
				terms <- Sequence{ i.getElementsByName('ruleml:var')->select(e | thisModule.getAllVariables()->includes(e))->collect(e | thisModule.getDefaultVariable(i, e.children->first().value))->collect(e | thisModule.IndividualVariable(e)),
				           		   i.children->select(e | not thisModule.getAllVariables()->includes(e))->asSequence()},
			    name <- 'IndividualPropertyAtom'
			),
		pred : RDM!ObjectProperty (
				name <- i.getAttrVal('swrlx:property')
			)
}

-- Rule 'ClassAtom'
-- Create Atom element with name 'ClassAtom' from XML Element named 'swrlx:classAtom'
rule ClassAtom {
	from 
		i : XML!Element (
				i.name = 'swrlx:classAtom'
			)
	to
		o : RDM!Atom (
				hasPredicateSymbol <- let classElem : XML!Element = i.getElementsByName('owlx:Class')->first() in
										if classElem.oclIsUndefined()				
									    then if i.children->select (c | c.name = 'owlx:ObjectRestriction')->size() > 0 then
											 	i.children->select (c | c.name = 'owlx:ObjectRestriction')->collect(e | e.children)->flatten()->select(e | e.oclIsKindOf(XML!Element))->first()														
											 else i.children->select(e | e.name <> 'ruleml:var' and e.name <> 'owlx:Individual')->first()
											 endif
										else if classElem.children->select(c | c.name = 'owlx:ObjectRestriction')->size() > 0 then
												classElem.children->select(c | c.name = 'owlx:ObjectRestriction')->first().children->select(c | c.oclIsTypeOf(XML!Element))->first()
											 else thisModule.Class(thisModule.getDefaultClass(classElem.getAttrVal('owlx:name')))
											 endif
										endif,
				-- first transform variables, or other second XML element for ClassAtom
				terms <- Sequence{ i.getElementsByName('ruleml:var')->select(e | thisModule.getAllVariables()->includes(e))->collect(e | thisModule.getDefaultVariable(i, e.children->first().value))->collect(e | thisModule.IndividualVariable(e)),
					               i.getElementsByName('owlx:Individual')->asSequence()},
			    name <- 'ClassAtom'
			)
}

-- Rule 'DataRangeAtom'
-- Create Atom element with name 'DataRangeAtom' from XML Element named 'swrlx:datarangeAtom'
rule DataRangeAtom {
	from 
		i : XML!Element (
				i.name = 'swrlx:datarangeAtom'
			)
	to
		o : RDM!Atom (
				hasPredicateSymbol <-  if i.children->select (c | c.name = 'owlx:DataRestriction')->size() > 0 then
											i.children->select (c | c.name = 'owlx:DataRestriction')->collect(e | e.children)->flatten()->select(e | e.oclIsKindOf(XML!Element))->first()
									   else i.children->select(e | e.name = 'owlx:Datatype' or e.name = 'owlx:OneOf')->first() -- transform Class element
									   endif,
				-- first transform variables, or other second XML element for ClassAtom
				terms <- Sequence{ i.getElementsByName('ruleml:var')->select(e | thisModule.getAllVariables()->includes(e))->collect(e | thisModule.getDefaultVariable(i, e.children->first().value))->collect(e | thisModule.IndividualVariable(e)),
				           		   i.children->select(e | not thisModule.getAllVariables()->includes(e) and e.name <> 'owlx:Datatype' and e.name <> 'owlx:OneOf' and e.name <> 'owlx:DataRestriction')->asSequence()},
			 	name <- 'DataRangeAtom'
			)
}

-- Rule 'DataValuedPropertyAtom'
-- Create Atom element with name 'DataValuedPropertyAtom' from XML Element named 'swrlx:datavaluedPropertyAtom'
rule DataValuedPropertyAtom {
	from 
		i : XML!Element (
				i.name = 'swrlx:datavaluedPropertyAtom'
			)
	to
		o : RDM!Atom (
				hasPredicateSymbol <- pred, 
				terms <- if i.getElementsByName('ruleml:var')->size() = 1 then
						 Sequence{ i.getElementsByName('ruleml:var')->select(e | thisModule.getAllVariables()->includes(e))->collect(e | thisModule.getDefaultVariable(i, e.children->first().value))->collect(e | thisModule.IndividualVariable(e)),
				           		   i.children->select(e | not thisModule.getAllVariables()->includes(e))->asSequence()}
						 else
						 Sequence{ i.getElementsByName('ruleml:var')->first()->asSequence()->select(e | thisModule.getAllVariables()->includes(e))->collect(e | thisModule.getDefaultVariable(i, e.children->first().value))->collect(e | thisModule.IndividualVariable(e)),
						 		   i.getElementsByName('ruleml:var')->last()->asSequence()->select(e | thisModule.getAllVariables()->includes(e))->collect(e | thisModule.getDefaultVariable(i, e.children->first().value))->collect(e | thisModule.DataVariable(e)),
				           		   i.children->select(e | not thisModule.getAllVariables()->includes(e))->asSequence()}
						 endif,
				name <- 'DataValuedPropertyAtom'
			),
		pred : RDM!DatatypeProperty (
				name <- i.getAttrVal('swrlx:property')
			)
}

-- Rule 'SameIndividualAtom'
-- Create Atom element with name 'SameIndividualAtom' from XML Element named 'swrlx:sameIndividualAtom'
rule SameIndividualAtom {
	from 
		i : XML!Element (
				i.name = 'swrlx:sameIndividualAtom'
			)
	to
		o : RDM!Atom (
				hasPredicateSymbol <- same,
				terms <- Sequence{ i.getElementsByName('ruleml:var')->select(e | thisModule.getAllVariables()->includes(e))->collect(e | thisModule.getDefaultVariable(i, e.children->first().value))->collect(e | thisModule.IndividualVariable(e)),
				           		   i.children->select(e | not thisModule.getAllVariables()->includes(e))->asSequence()},
				name <- 'SameIndividualAtom'
			),
		same : RDM!SameAs
}

-- Rule 'DifferentIndividualsAtom'
-- Create Atom element with name 'DifferentIndividualAtom' from XML Element named 'swrlx:differentIndividualsAtom'
rule DifferentIndividualsAtom {
	from 
		i : XML!Element (
				i.name = 'swrlx:differentIndividualsAtom'
			)
	to
		o : RDM!Atom (
				hasPredicateSymbol <- different,
				terms <- Sequence{ i.getElementsByName('ruleml:var')->select(e | thisModule.getAllVariables()->includes(e))->collect(e | thisModule.getDefaultVariable(i, e.children->first().value))->collect(e | thisModule.IndividualVariable(e)),
				           		   i.children->select(e | not thisModule.getAllVariables()->includes(e))->asSequence()},
				name <- 'DifferentIndividualAtom'
			),
		different : RDM!DifferentFrom
}

-- Rule 'BuiltinAtom'
-- Create Atom element with name 'BuiltinAtom' from XML Element named 'swrlx:builtinAtom'
rule BuiltinAtom {
	from 
		i : XML!Element (
				i.name = 'swrlx:builtinAtom'
			)
	to
		o : RDM!Atom (
			hasPredicateSymbol <- builtIn,
			terms <- Sequence{ i.getElementsByName('ruleml:var')->asSequence()->select(e | thisModule.getAllVariables()->includes(e))->collect(e | thisModule.getDefaultVariable(i, e.children->first().value))->collect(e | thisModule.DataVariable(e)),
				           	   i.children->select(e | not thisModule.getAllVariables()->includes(e))->asSequence()},
			name <- 'BuiltinAtom'
		), 
		builtIn : RDM!BuiltIn (
			buildInID <- i.getAttrVal('swrlx:builtin')
		)
}

-- Predicate Symbols for RDM Atoms (OWL -> ODM)

-- Rule 'Class'
-- Create Class element from XML Element named 'owlx:Class'
unique lazy rule Class {
	from 
		i : XML!Element (
				i.name = 'owlx:Class'
			)
	to
		o : RDM!Class (
				name <- i.getAttrVal('owlx:name')
			)
}

-- Rule 'DataType'
-- Create DataRange element from XML Element named 'owlx:Datatype'
rule DataType {
	from 
		i : XML!Element (
				i.name = 'owlx:Datatype'
			)
	to
		o : RDM!DataRange(
				name <- i.getAttrVal('owlx:name'),
				datatype <- primType
			),
		primType : RDM!PrimitiveType (
				name <- i.getAttrVal('owlx:name')
			)
}

-- Rule 'Individual'
-- Create Individual element from XML Element named 'owlx:Individual'
rule Individual {
	from 
		i : XML!Element (
				i.name = 'owlx:Individual'
			)
	to
		o : RDM!Individual (
				name <- i.getAttrVal('owlx:name')
			)
}

-- Rule 'DataValueNotOneOf'
-- Create DataValue element from XML Element named 'owlx:DataValue'
-- This version of DataValue doesn't have OneOf element as parent, so
-- it is transformed to DataValue element
rule DataValueNotOneOf {
	from 
		i : XML!Element (
				-- This must be done with condition, ATL Manual - 4.3.4 Expressions tips & tricks (page 24)
			    if i.parent.oclIsUndefined()
				then i.name = 'owlx:DataValue'
				else
					i.name = 'owlx:DataValue' and i.parent.name <> 'owlx:OneOf'
				endif
			)
	to
		o : RDM!DataValue (
				type <- typ,
				value <- i.children->select(c | c.name = '#text')->first().value
			),
		typ : RDM!PrimitiveType (
			name <- i.getAttrVal('owlx:datatype')
			)
}

-- Rule 'DataValueOneOf'
-- Create DataValue element from XML Element named 'owlx:DataValue'
-- This version of DataValue have OneOf element as parent, so
-- it is transformed to TypedLiteral element
rule DataValueOneOf {
	from 
		i : XML!Element (
			 if i.parent.oclIsUndefined()
			 then i.name = 'owlx:DataValue'
			 else
					i.name = 'owlx:DataValue' and i.parent.name = 'owlx:OneOf'
			 endif
			)
	to
		o : RDM!TypedLiteral (
				lexicalForm <- i.children->select(e | e.name = '#text')->first().value,
				theType <- i.getAttrVal('owlx:datatype')
			)
}

-- Rule 'IndividualVariable'
-- Creates IndividualVariable element from an XML!Element named 'ruleml:var'
-- This rule is unique lazy rule, which means that is called from other rules
unique lazy rule IndividualVariable {
	from i : XML!Element
	to 
		o : RDM!IndividualVariable (
				name <- i.children->first().value,
				classRef <- if thisModule.getAllObjectProperties()->size() > 0 then
								let atom : XML!Element = thisModule.getAllIndividualPropertyAtomsForVariable(i.children->first().value)->first() in
									thisModule.Class(thisModule.getDefaultClass(thisModule.getClassNameForVariableInIndividualPropretyAtom(i.children->first().value, atom)))
							else OclUndefined
							endif
			)
}



-- Rule 'DataVariable'
-- Creates DataVariable element from an XML!Element named 'ruleml:var'
-- This rule is unique lazy rule, which means that is called from other rules
unique lazy rule DataVariable {
	from i : XML!Element
	to 
		o : RDM!DataVariable (
				name <- i.children->first().value
			)
}

-- OWL -> ODM based transformations 

-- Rule 'IntersectionOf'
-- Creates IntersectionClass element from an XML!Element named 'owlx:IntersectionOf'
rule IntersectionOf {
	from 
		i : XML!Element (
				i.name = 'owlx:IntersectionOf'
			)
	to
		o : RDM!IntersectionClass (
				intersectionOf <- Sequence {  let classElem : Sequence (XML!Element) = i.getElementsByName('owlx:Class') in
											  	if classElem->isEmpty()
												then Sequence{}
												else classElem->collect(c | thisModule.Class(thisModule.getDefaultClass(c.getAttrVal('owlx:name'))))
												endif,
											  i.children->select (c | c.name <> 'owlx:ObjectRestriction' and c.name <> 'owlx:DataRestriction' and c.name <> 'owlx:Class'),
										      i.children->select (c | c.name = 'owlx:ObjectRestriction' or c.name = 'owlx:DataRestriction')->collect(e | e.children)->flatten()->select(e | e.oclIsKindOf(XML!Element))														
				  				  }
			)
}

-- Rule 'UnionOf'
-- Creates UnionClass element from an XML!Element named 'owlx:UnionOf'
rule UnionOf {
	from 
		i : XML!Element (
				i.name = 'owlx:UnionOf'
			)
	to
		o : RDM!UnionClass (
			unionOf <- Sequence {  let classElem : Sequence (XML!Element) = i.getElementsByName('owlx:Class') in
									if classElem->isEmpty()
									then Sequence{}
									else classElem->collect(c | thisModule.Class(thisModule.getDefaultClass(c.getAttrVal('owlx:name'))))
									endif,
				  				  i.children->select (c | c.name <> 'owlx:ObjectRestriction' and c.name <> 'owlx:DataRestriction' and c.name <> 'owlx:Class'),
								  i.children->select (c | c.name = 'owlx:ObjectRestriction' or c.name = 'owlx:DataRestriction')->collect(e | e.children)->flatten()->select(e | e.oclIsKindOf(XML!Element))														
				  				  }
			)
}

-- Rule 'ComplementOf'
-- Creates ComplementClass element from an XML!Element named 'owlx:ComplementOf'
rule ComplementOf {
	from 
		i : XML!Element (
				i.name = 'owlx:ComplementOf'
			)
	to
		o : RDM!ComplementClass (
				complementOf <-  let classElem : XML!Element = i.getElementsByName('owlx:Class')->first() in
									if classElem.oclIsUndefined()
									then i.children->first()
									else thisModule.Class(thisModule.getDefaultClass(classElem.getAttrVal('owlx:name')))
									endif		
			)
}

-- Rule 'SomeValuesFromAttrClass'
-- Creates SomeValuesFromRestriction element from an XML!Element named 'owlx:someValuesFrom'
-- which have class attribute
rule SomeValuesFromAttrClass {
	from 
		i : XML!Element (
				i.name = 'owlx:someValuesFrom' and i.hasAttr('owlx:class')
			)
	to
		o : RDM!SomeValuesFromRestriction (
				someValuesFromClass <- class,
				onProperty <- i.parent
			),
		class : RDM!Class (
			name <- i.getAttrVal('owlx:class')
			)
}

-- Rule 'SomeValuesFromAttrDatatype'
-- Creates SomeValuesFromRestriction element from an XML!Element named 'owlx:someValuesFrom'
-- which have datatype attribute and have one children element
rule SomeValuesFromAttrDatatype {
	from 
		i : XML!Element (
				i.name = 'owlx:someValuesFrom' and i.hasAttr('owlx:datatype') and
				i.children->size() = 1
			)
	to
		o : RDM!SomeValuesFromRestriction (
				someValuesFromRange <- drange,
				onProperty <- i.parent
			),
		drange : RDM!DataRange (
			datatype <- type
			),
		type : RDM!PrimitiveType (
			name <- i.getAttrVal('owlx:datatype')
			)
}

-- Rule 'SomeValuesFromElemClass'
-- Creates SomeValuesFromRestriction element from an XML!Element named 'owlx:someValuesFrom'
-- which have class attribute and have exactly one children
rule SomeValuesFromElemClass {
	from 
		i : XML!Element (
				i.name = 'owlx:someValuesFrom' and not i.hasAttr('owlx:class') and not i.hasAttr('owlx:datatype') and
				i.children->size() = 1
			)
	to
		o : RDM!SomeValuesFromRestriction (
				someValuesFromClass <-  let classElem : XML!Element = i.getElementsByName('owlx:Class')->first() in
											if classElem.oclIsUndefined()
											then i.children->first()
											else thisModule.Class(thisModule.getDefaultClass(classElem.getAttrVal('owlx:name')))
											endif,		
				onProperty <- i.parent
			)
}

-- Rule 'SomeValuesFromChild'
-- Creates SomeValuesFromRestriction element from an XML!Element named 'owlx:someValuesFrom'
-- which doesn't have class attribute, have more than one children and childrens are Class elements
rule SomeValuesFromChild {
	from 
		i : XML!Element (
				i.name = 'owlx:someValuesFrom' and not i.hasAttr('owlx:class') and not i.hasAttr('owlx:datatype')
				and i.children->size() > 1 and i.children->first().name = 'owlx:Class' 
			)
	to
		o : RDM!SomeValuesFromRestriction (
				someValuesFromClass <- union,
				onProperty <- i.parent -- dodati uslov
			),
		union : RDM!UnionClass (
			unionOf <- let classElem : Sequence (XML!Element) = i.getElementsByName('owlx:Class') in
						if classElem->isEmpty()
						then i.children
						else classElem->collect(c | thisModule.Class(thisModule.getDefaultClass(c.getAttrVal('owlx:name'))))
						endif
			)
}

-- Rule 'AllValuesFromAttrClass'
-- Creates AllValuesFromRestriction element from an XML!Element named 'owlx:allValuesFrom'
-- which have class attribute
rule AllValuesFromAttrClass {
	from 
		i : XML!Element (
				i.name = 'owlx:allValuesFrom' and i.hasAttr('owlx:class')
			)
	to
		o : RDM!AllValuesFromRestriction (
				allValuesFromClass <- class,
				onProperty <- i.parent
			),
		class : RDM!Class (
			name <- i.getAttrVal('owlx:class')
			)
}

-- Rule 'AllValuesFromAttrDatatype'
-- Creates AllValuesFromRestriction element from an XML!Element named 'owlx:allValuesFrom'
-- which have datatype attribute and have one children element
rule AllValuesFromAttrDatatype {
	from 
		i : XML!Element (
				i.name = 'owlx:allValuesFrom' and i.hasAttr('owlx:datatype') and
				i.children->size() = 1
			)
	to
		o : RDM!AllValuesFromRestriction (
				allValuesFromRange <- drange,
				onProperty <- i.parent
			),
		drange : RDM!DataRange (
			datatype <- type
			),
		type : RDM!PrimitiveType (
			name <- i.getAttrVal('owlx:datatype')
			)
}

-- Rule 'AllValuesFromElemClass'
-- Creates AllValuesFromRestriction element from an XML!Element named 'owlx:allValuesFrom'
-- which have class attribute and have exactly one children
rule AllValuesFromElemClass {
	from 
		i : XML!Element (
				i.name = 'owlx:allValuesFrom' and not i.hasAttr('owlx:class') and not i.hasAttr('owlx:datatype') and 
				i.children->size() = 1
			)
	to
		o : RDM!AllValuesFromRestriction (
				allValuesFromClass <-let classElem : XML!Element = i.getElementsByName('owlx:Class')->first() in
											if classElem.oclIsUndefined()
											then i.children->first()
											else thisModule.Class(thisModule.getDefaultClass(classElem.getAttrVal('owlx:name')))
											endif,
				onProperty <- i.parent
			)
}

-- Rule 'AllValuesFromChild'
-- Creates AllValuesFromRestriction element from an XML!Element named 'owlx:allValuesFrom'
-- which doesn't have class attribute, have more than one children and childrens are Class elements
rule AllValuesFromChild {
	from 
		i : XML!Element (
				i.name = 'owlx:allValuesFrom' and not i.hasAttr('owlx:class') and not i.hasAttr('owlx:datatype')
				and i.children->size() > 1 and i.children->first().name = 'owlx:Class' 
			)
	to
		o : RDM!AllValuesFromRestriction (
				allValuesFromClass <- union,
				onProperty <- i.parent -- dodati uslov
			),
		union : RDM!UnionClass (
			unionOf <- let classElem : Sequence (XML!Element) = i.getElementsByName('owlx:Class') in
						if classElem->isEmpty()
						then i.children
						else classElem->collect(c | thisModule.Class(thisModule.getDefaultClass(c.getAttrVal('owlx:name'))))
						endif
			)
}

-- Rule 'HasValueObject'
-- Creates HasValueRestriction element from an XML!Element named 'owlx:hasValue'
-- which parent is ObjectRestriction
rule HasValueObject {
	from 
		i : XML!Element (
			   if i.parent.oclIsUndefined()
			   then i.name = 'owlx:hasValue'
			   else i.name = 'owlx:hasValue' and i.parent.name = 'owlx:ObjectRestriction'
			   endif	
			)
	to
		o : RDM!HasValueRestriction (
				hasValue <- individual,
				onProperty <-  if i.parent.oclIsUndefined()
			 				   then OclUndefined
			                   else i.parent
						 	   endif
			),
		individual : RDM!Individual (
			name <- i.getAttrVal('owlx:name')
			)
}

-- Rule 'HasValueObject'
-- Creates HasValueRestriction element from an XML!Element named 'owlx:hasValue'
-- which parent is DataRestriction
rule HasValueData {
	from 
		i : XML!Element (
			   if i.parent.oclIsUndefined()
			   then i.name = 'owlx:hasValue'
			   else i.name = 'owlx:hasValue' and i.parent.name = 'owlx:DataRestriction'
			   endif	
			)
	to
		o : RDM!HasValueRestriction (
				hasLiteralValue <- literal,
				onProperty <-  if not i.parent.oclIsUndefined()
			 				   then OclUndefined
			                   else i.parent
						 	   endif
			),
		literal : RDM!PlainLiteral (
			lexicalForm <- i.getAttrVal('owlx:name')
			)
}

-- Rule 'CardinalityRestriction'
-- Creates CardinalityRestriction element from an XML!Element named 'owlx:cardinality'
rule CardinalityRestriction {
	from 
		i : XML!Element (
				i.name = 'owlx:cardinality'
			)
	to
		o : RDM!CardinalityRestriction (
				cardinality <- value,
				onProperty <- i.parent
			),
		value : RDM!TypedLiteral (
			theType <- 'integer',
			lexicalForm <- i.getAttrVal('owlx:value')
			)
}

-- Rule 'MinCardinalityRestriction'
-- Creates MinCardinalityRestriction element from an XML!Element named 'owlx:minCardinality'
rule MinCardinalityRestriction {
	from 
		i : XML!Element (
				i.name = 'owlx:minCardinality'
			)
	to
		o : RDM!MinCardinalityRestriction (
				minCardinality <- value,
				onProperty <- i.parent
			),
		value : RDM!TypedLiteral (
			theType <- 'integer',
			lexicalForm <- i.getAttrVal('owlx:value')
			)
}

-- Rule 'MaxCardinalityRestriction'
-- Creates MaxCardinalityRestriction element from an XML!Element named 'owlx:maxCardinality'
rule MaxCardinalityRestriction {
	from 
		i : XML!Element (
				i.name = 'owlx:maxCardinality'
			)
	to
		o : RDM!MaxCardinalityRestriction (
				maxCardinality <- value,
				onProperty <- i.parent
			),
		value : RDM!TypedLiteral (
			theType <- 'integer',
			lexicalForm <- i.getAttrVal('owlx:value')
			)
}

-- Rule 'ObjectRestriction'
-- Creates ObjectRestriction element from an XML!Element named 'owlx:ObjectRestriction'
rule ObjectRestriction {
	from 
		i : XML!Element (
				i.name = 'owlx:ObjectRestriction'
			)
	to
		o : RDM!ObjectProperty (
				name <- i.getAttrVal('owlx:property')
			)
}

-- Rule 'DataRestriction'
-- Creates DataRestriction element from an XML!Element named 'owlx:DataRestriction'
rule DataRestriction {
	from 
		i : XML!Element (
				i.name = 'owlx:DataRestriction'
			)
	to
		o : RDM!DatatypeProperty (
				name <- i.getAttrVal('owlx:property')
			)
}

-- Rule 'OneOfIndividual'
-- Creates EnumeratedClass element from an XML!Element named 'owlx:OneOf' which
-- have Individual elements as childrens
rule OneOfIndividual {
	from 
		i : XML!Element (
				i.name = 'owlx:OneOf' and i.children->first().name = 'owlx:Individual'
			)
	to
		o : RDM!EnumeratedClass (
				oneOf <- i.children
			)
}

-- Rule 'OneOfDataValue'
-- Creates DataRange element from an XML!Element named 'owlx:OneOf' which
-- have DataValue elements as childrens
rule OneOfDataValue {
	from 
		i : XML!Element (
				i.name = 'owlx:OneOf' and i.children->first().name = 'owlx:DataValue'
			)
	to
		o : RDM!DataRange (
				oneOf <- i.children
			)
}",transform xml metamodel owl rdm metamodel creat part m sc these good old ai laboratori author milan milanov milan milanov org work swrl v xml syntax licenc gnu general public licens version modul xml rdm creat out rdm in xml use string use xmlhelper general xml metamodel helper helper xml rdm transform specif xml helper helper getallrul return sequenc xml element name ruleml imp context thismodul out sequenc xml element helper def getallrul sequenc xml element xml element allinst select e e name ruleml imp assequ helper getruleforel return xml element rule contain contextu xml element context xml element out xml element helper context xml element def getruleforel xml element thismodul getallrul select c c allsubel includ self assequ first helper allsubel return sequenc xml sub element xml element recursivelli element last element children context xml element out sequenc xml element helper context xml element def allsubel sequenc xml element let subelem sequenc xml element xml element allinst select c c parent self collect elem elem allsubel flatten subelem union self children select ch ch oclistypeof xml element subelem exist name ch name flatten helper getdefaultvari return alway first variabl valu this necessari uniqu lazi rule creat one output individualvari multipl input valu context thismodul in xml element string out xml element helper def getdefaultvari elem xml element valu string xml element elem getruleforel allsubel select e e name ruleml var select e e children first valu valu assequ first helper getvari return variabl input file context thismodul out sequenc xml element helper def getallvari sequenc xml element xml element allinst select e e name ruleml var helper getdefaultclass return default class name input file context thismodul in string out sequenc xml element helper def getdefaultclass valu string sequenc xml element xml element allinstancesfrom in assequ select e e name owlx class select e e getattrv owlx name valu assequ first helper getallindividualpropertyatomsforvari return individu properti atom variabl name context thismodul in string out sequenc xml element helper def getallindividualpropertyatomsforvari name string sequenc xml element xml element allinstancesfrom in assequ select e e name swrlx individualpropertyatom select c c children select c c oclistypeof xml element exist e e name ruleml var e gettextvalu name helper getallobjectproperti return objectproperti context thismodul out sequenc xml element helper def getallobjectproperti sequenc xml element xml element allinstancesfrom in assequ select e e name owlx objectproperti assequ helper getobjectpropertyforindividualpropertyatom return objectproperti individu properti atom context thismodul in string out sequenc xml element helper def getobjectpropertyforindividualpropertyatom properti string xml element thismodul getallobjectproperti select c c getattrv owlx name properti assequ helper getclassnameforvariableinindividualpropretyatom return name class variabl individu properti atom need link individu properti atom object properti context thismodul in string xml element out sequenc xml element helper def getclassnameforvariableinindividualpropretyatom var string atom xml element string atom getelementsbynam ruleml var first gettextvalu var thismodul getobjectpropertyforindividualpropertyatom atom getattrv swrlx properti first getelementsbynam owlx domain first children assequ first getattrv owlx name els thismodul getobjectpropertyforindividualpropertyatom atom getattrv swrlx properti first getelementsbynam owlx rang first children assequ first getattrv owlx name endif rule swrl rdm base transform rule ontolog creat ontolog element xml root element rule ontolog xml root name ruleml imp rdm ontolog element children select c c ocliskindof xml element rule rule creat rule xml element name ruleml imp rule rule xml element name ruleml imp rdm rule hasconsequ children select c c name ruleml head c ocliskindof xml element assequ first hasanteced children select c c name ruleml bodi c ocliskindof xml element assequ first rule consequ creat consequ element xml element name ruleml head rule consequ xml element name ruleml head rdm consequ containsatom children assequ rule anteced creat anteced element xml element name ruleml bodi rule anteced xml element name ruleml bodi rdm anteced containsatom children assequ atom rule individualpropertyatom creat individualpropertyatom element xml element name swrlx individualpropertyatom rule individualpropertyatom xml element name swrlx individualpropertyatom rdm atom haspredicatesymbol pred term sequenc getelementsbynam ruleml var select e thismodul getallvari includ e collect e thismodul getdefaultvari e children first valu collect e thismodul individualvari e children select e thismodul getallvari includ e assequ name individualpropertyatom pred rdm objectproperti name getattrv swrlx properti rule classatom creat atom element name classatom xml element name swrlx classatom rule classatom xml element name swrlx classatom rdm atom haspredicatesymbol let classelem xml element getelementsbynam owlx class first classelem oclisundefin children select c c name owlx objectrestrict size children select c c name owlx objectrestrict collect e e children flatten select e e ocliskindof xml element first els children select e e name ruleml var e name owlx individu first endif els classelem children select c c name owlx objectrestrict size classelem children select c c name owlx objectrestrict first children select c c oclistypeof xml element first els thismodul class thismodul getdefaultclass classelem getattrv owlx name endif endif first transform variabl second xml element classatom term sequenc getelementsbynam ruleml var select e thismodul getallvari includ e collect e thismodul getdefaultvari e children first valu collect e thismodul individualvari e getelementsbynam owlx individu assequ name classatom rule datarangeatom creat atom element name datarangeatom xml element name swrlx datarangeatom rule datarangeatom xml element name swrlx datarangeatom rdm atom haspredicatesymbol children select c c name owlx datarestrict size children select c c name owlx datarestrict collect e e children flatten select e e ocliskindof xml element first els children select e e name owlx datatyp e name owlx oneof first transform class element endif first transform variabl second xml element classatom term sequenc getelementsbynam ruleml var select e thismodul getallvari includ e collect e thismodul getdefaultvari e children first valu collect e thismodul individualvari e children select e thismodul getallvari includ e e name owlx datatyp e name owlx oneof e name owlx datarestrict assequ name datarangeatom rule datavaluedpropertyatom creat atom element name datavaluedpropertyatom xml element name swrlx datavaluedpropertyatom rule datavaluedpropertyatom xml element name swrlx datavaluedpropertyatom rdm atom haspredicatesymbol pred term getelementsbynam ruleml var size sequenc getelementsbynam ruleml var select e thismodul getallvari includ e collect e thismodul getdefaultvari e children first valu collect e thismodul individualvari e children select e thismodul getallvari includ e assequ els sequenc getelementsbynam ruleml var first assequ select e thismodul getallvari includ e collect e thismodul getdefaultvari e children first valu collect e thismodul individualvari e getelementsbynam ruleml var last assequ select e thismodul getallvari includ e collect e thismodul getdefaultvari e children first valu collect e thismodul datavari e children select e thismodul getallvari includ e assequ endif name datavaluedpropertyatom pred rdm datatypeproperti name getattrv swrlx properti rule sameindividualatom creat atom element name sameindividualatom xml element name swrlx sameindividualatom rule sameindividualatom xml element name swrlx sameindividualatom rdm atom haspredicatesymbol term sequenc getelementsbynam ruleml var select e thismodul getallvari includ e collect e thismodul getdefaultvari e children first valu collect e thismodul individualvari e children select e thismodul getallvari includ e assequ name sameindividualatom rdm samea rule differentindividualsatom creat atom element name differentindividualatom xml element name swrlx differentindividualsatom rule differentindividualsatom xml element name swrlx differentindividualsatom rdm atom haspredicatesymbol differ term sequenc getelementsbynam ruleml var select e thismodul getallvari includ e collect e thismodul getdefaultvari e children first valu collect e thismodul individualvari e children select e thismodul getallvari includ e assequ name differentindividualatom differ rdm differentfrom rule builtinatom creat atom element name builtinatom xml element name swrlx builtinatom rule builtinatom xml element name swrlx builtinatom rdm atom haspredicatesymbol builtin term sequenc getelementsbynam ruleml var assequ select e thismodul getallvari includ e collect e thismodul getdefaultvari e children first valu collect e thismodul datavari e children select e thismodul getallvari includ e assequ name builtinatom builtin rdm builtin buildinid getattrv swrlx builtin predic symbol rdm atom owl odm rule class creat class element xml element name owlx class uniqu lazi rule class xml element name owlx class rdm class name getattrv owlx name rule datatyp creat datarang element xml element name owlx datatyp rule datatyp xml element name owlx datatyp rdm datarang name getattrv owlx name datatyp primtyp primtyp rdm primitivetyp name getattrv owlx name rule individu creat individu element xml element name owlx individu rule individu xml element name owlx individu rdm individu name getattrv owlx name rule datavaluenotoneof creat datavalu element xml element name owlx datavalu this version datavalu oneof element parent transform datavalu element rule datavaluenotoneof xml element this must done condit atl manual express tip trick page parent oclisundefin name owlx datavalu els name owlx datavalu parent name owlx oneof endif rdm datavalu type typ valu children select c c name text first valu typ rdm primitivetyp name getattrv owlx datatyp rule datavalueoneof creat datavalu element xml element name owlx datavalu this version datavalu oneof element parent transform typedliter element rule datavalueoneof xml element parent oclisundefin name owlx datavalu els name owlx datavalu parent name owlx oneof endif rdm typedliter lexicalform children select e e name text first valu thetyp getattrv owlx datatyp rule individualvari creat individualvari element xml element name ruleml var this rule uniqu lazi rule mean call rule uniqu lazi rule individualvari xml element rdm individualvari name children first valu classref thismodul getallobjectproperti size let atom xml element thismodul getallindividualpropertyatomsforvari children first valu first thismodul class thismodul getdefaultclass thismodul getclassnameforvariableinindividualpropretyatom children first valu atom els oclundefin endif rule datavari creat datavari element xml element name ruleml var this rule uniqu lazi rule mean call rule uniqu lazi rule datavari xml element rdm datavari name children first valu owl odm base transform rule intersectionof creat intersectionclass element xml element name owlx intersectionof rule intersectionof xml element name owlx intersectionof rdm intersectionclass intersectionof sequenc let classelem sequenc xml element getelementsbynam owlx class classelem isempti sequenc els classelem collect c thismodul class thismodul getdefaultclass c getattrv owlx name endif children select c c name owlx objectrestrict c name owlx datarestrict c name owlx class children select c c name owlx objectrestrict c name owlx datarestrict collect e e children flatten select e e ocliskindof xml element rule unionof creat unionclass element xml element name owlx unionof rule unionof xml element name owlx unionof rdm unionclass unionof sequenc let classelem sequenc xml element getelementsbynam owlx class classelem isempti sequenc els classelem collect c thismodul class thismodul getdefaultclass c getattrv owlx name endif children select c c name owlx objectrestrict c name owlx datarestrict c name owlx class children select c c name owlx objectrestrict c name owlx datarestrict collect e e children flatten select e e ocliskindof xml element rule complementof creat complementclass element xml element name owlx complementof rule complementof xml element name owlx complementof rdm complementclass complementof let classelem xml element getelementsbynam owlx class first classelem oclisundefin children first els thismodul class thismodul getdefaultclass classelem getattrv owlx name endif rule somevaluesfromattrclass creat somevaluesfromrestrict element xml element name owlx somevaluesfrom class attribut rule somevaluesfromattrclass xml element name owlx somevaluesfrom hasattr owlx class rdm somevaluesfromrestrict somevaluesfromclass class onproperti parent class rdm class name getattrv owlx class rule somevaluesfromattrdatatyp creat somevaluesfromrestrict element xml element name owlx somevaluesfrom datatyp attribut one children element rule somevaluesfromattrdatatyp xml element name owlx somevaluesfrom hasattr owlx datatyp children size rdm somevaluesfromrestrict somevaluesfromrang drang onproperti parent drang rdm datarang datatyp type type rdm primitivetyp name getattrv owlx datatyp rule somevaluesfromelemclass creat somevaluesfromrestrict element xml element name owlx somevaluesfrom class attribut exact one children rule somevaluesfromelemclass xml element name owlx somevaluesfrom hasattr owlx class hasattr owlx datatyp children size rdm somevaluesfromrestrict somevaluesfromclass let classelem xml element getelementsbynam owlx class first classelem oclisundefin children first els thismodul class thismodul getdefaultclass classelem getattrv owlx name endif onproperti parent rule somevaluesfromchild creat somevaluesfromrestrict element xml element name owlx somevaluesfrom class attribut one children children class element rule somevaluesfromchild xml element name owlx somevaluesfrom hasattr owlx class hasattr owlx datatyp children size children first name owlx class rdm somevaluesfromrestrict somevaluesfromclass union onproperti parent dodati uslov union rdm unionclass unionof let classelem sequenc xml element getelementsbynam owlx class classelem isempti children els classelem collect c thismodul class thismodul getdefaultclass c getattrv owlx name endif rule allvaluesfromattrclass creat allvaluesfromrestrict element xml element name owlx allvaluesfrom class attribut rule allvaluesfromattrclass xml element name owlx allvaluesfrom hasattr owlx class rdm allvaluesfromrestrict allvaluesfromclass class onproperti parent class rdm class name getattrv owlx class rule allvaluesfromattrdatatyp creat allvaluesfromrestrict element xml element name owlx allvaluesfrom datatyp attribut one children element rule allvaluesfromattrdatatyp xml element name owlx allvaluesfrom hasattr owlx datatyp children size rdm allvaluesfromrestrict allvaluesfromrang drang onproperti parent drang rdm datarang datatyp type type rdm primitivetyp name getattrv owlx datatyp rule allvaluesfromelemclass creat allvaluesfromrestrict element xml element name owlx allvaluesfrom class attribut exact one children rule allvaluesfromelemclass xml element name owlx allvaluesfrom hasattr owlx class hasattr owlx datatyp children size rdm allvaluesfromrestrict allvaluesfromclass let classelem xml element getelementsbynam owlx class first classelem oclisundefin children first els thismodul class thismodul getdefaultclass classelem getattrv owlx name endif onproperti parent rule allvaluesfromchild creat allvaluesfromrestrict element xml element name owlx allvaluesfrom class attribut one children children class element rule allvaluesfromchild xml element name owlx allvaluesfrom hasattr owlx class hasattr owlx datatyp children size children first name owlx class rdm allvaluesfromrestrict allvaluesfromclass union onproperti parent dodati uslov union rdm unionclass unionof let classelem sequenc xml element getelementsbynam owlx class classelem isempti children els classelem collect c thismodul class thismodul getdefaultclass c getattrv owlx name endif rule hasvalueobject creat hasvaluerestrict element xml element name owlx hasvalu parent objectrestrict rule hasvalueobject xml element parent oclisundefin name owlx hasvalu els name owlx hasvalu parent name owlx objectrestrict endif rdm hasvaluerestrict hasvalu individu onproperti parent oclisundefin oclundefin els parent endif individu rdm individu name getattrv owlx name rule hasvalueobject creat hasvaluerestrict element xml element name owlx hasvalu parent datarestrict rule hasvaluedata xml element parent oclisundefin name owlx hasvalu els name owlx hasvalu parent name owlx datarestrict endif rdm hasvaluerestrict hasliteralvalu liter onproperti parent oclisundefin oclundefin els parent endif liter rdm plainliter lexicalform getattrv owlx name rule cardinalityrestrict creat cardinalityrestrict element xml element name owlx cardin rule cardinalityrestrict xml element name owlx cardin rdm cardinalityrestrict cardin valu onproperti parent valu rdm typedliter thetyp integ lexicalform getattrv owlx valu rule mincardinalityrestrict creat mincardinalityrestrict element xml element name owlx mincardin rule mincardinalityrestrict xml element name owlx mincardin rdm mincardinalityrestrict mincardin valu onproperti parent valu rdm typedliter thetyp integ lexicalform getattrv owlx valu rule maxcardinalityrestrict creat maxcardinalityrestrict element xml element name owlx maxcardin rule maxcardinalityrestrict xml element name owlx maxcardin rdm maxcardinalityrestrict maxcardin valu onproperti parent valu rdm typedliter thetyp integ lexicalform getattrv owlx valu rule objectrestrict creat objectrestrict element xml element name owlx objectrestrict rule objectrestrict xml element name owlx objectrestrict rdm objectproperti name getattrv owlx properti rule datarestrict creat datarestrict element xml element name owlx datarestrict rule datarestrict xml element name owlx datarestrict rdm datatypeproperti name getattrv owlx properti rule oneofindividu creat enumeratedclass element xml element name owlx oneof individu element children rule oneofindividu xml element name owlx oneof children first name owlx individu rdm enumeratedclass oneof children rule oneofdatavalu creat datarang element xml element name owlx oneof datavalu element children rule oneofdatavalu xml element name owlx oneof children first name owlx datavalu rdm datarang oneof children,6
184,184,P8-AssertionModification.atl,"-- @name		AssertionModification
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		SIMON Eric(simon.eric3<at>gmail.com)
-- @date		2006/08/09
-- @description	This transformation strenghthens or weakens an assertion(respectively postcondition and precondition).
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 1.6, page 5
-- @see author of article : K. Lano

module AssertionModification; -- Module Template
create OUT : UML2Target from IN : UML2, Lib : XML;


-- @comment this helper returns the first attribute named ""name""
helper context XML!Element def : getAttr(name : String) : XML!Attribute =
  self.children->
    select (c|c.oclIsTypeOf(XML!Attribute))->
      select(c|c.name = name)->first();

-- @comment this helper returns the value of the first attribute named ""name""
helper context XML!Element def : getAttrVal(name : String) : String =
  self.getAttr(name).value;

-- @comment this helper returns the set of childs for a given type
helper context XML!Element
def : getChildren(type : OclType, name : String) : Sequence(XML!Node) =
  self.children->
    select(e|e.oclIsKindOf(type))->select(e|e.name = name);

-- @comment this helper returns the new assertion contained by the library
helper context UML2!Constraint def: searchInLib : String =
	if self.owner.oclIsTypeOf(UML2!Class)
	then self.ClassExistInLib()
	else if self.owner.oclIsTypeOf(UML2!Association)
		then self.AssociationExistInLib()
		else if self.owner.oclIsTypeOf(UML2!Operation)
			then self.OperationExistInLib()
			else 'Erreur entry Type: either class or association or operation'
			endif
		endif
	endif
	;

-- @comment this helper is called by the helper searchInLib for the constraint is on a class
helper context UML2!Constraint def: ClassExistInLib() : String =
	if XML!Element.allInstances()->select(c|c.name='class')->
		select(c|c.getAttr('package').value = self.owner.package.name 
			and c.getAttr('name').value = self.owner.name 
			and c.getChildren(XML!Element, 'assertion')->
				exists(const|const.getAttr('name') = self.name)
		).first() <> OclUndefined
	then	
		XML!Element.allInstances()->select(c|c.name='class')->
		select(c|c.getAttr('package').value = self.owner.package.name 
			and c.getAttr('name').value = self.owner.name 
			and c.getChildren(XML!Element, 'assertion')->
				exists(const|const.getAttr('name') = self.name)
		).first().getChildren(XML!Element, 'assertion')->
		select(const|const.getAttr('name') = self.name).first().value
	else 'noRule'
	endif
	;

-- @comment this helper is called by the helper searchInLib for the constraint is on an association
helper context UML2!Constraint def: AssociationExistInLib() : String =
	if XML!Element.allInstances()->select(c|c.name='association')->
		select(c|c.getAttr('package').value = self.owner.package.name 
			and c.getAttr('name').value = self.owner.name 
			and c.getChildren(XML!Element, 'assertion')->
				exists(const|const.getAttr('name').value = self.name)
		).first() <> OclUndefined
	then
		XML!Element.allInstances()->select(c|c.name='association')->
		select(c|c.getAttr('package').value = self.owner.package.name 
			and c.getAttr('name').value = self.owner.name 
			and c.getChildren(XML!Element, 'assertion')->
				exists(const|const.getAttr('name').value = self.name)
		).first().getChildren(XML!Element, 'assertion')->
		select(const|const.getAttr('name').value = self.name).first().getAttr('value').value
	else 'noRule'
	endif
	;

-- @comment this helper is called by the helper searchInLib for the constraint is on an operation
helper context UML2!Constraint def: OperationExistInLib() : String =
	if self.owner.precondition->includes(self)
	then
		if XML!Element.allInstances()->select(c|c.name='operation')->
			select(c|c.getAttr('package').value = self.owner.owner.package.name
				and c.getAttr('class').value = self.owner.owner.name
				and c.getChildren(XML!Element, 'precondition')->
			exists(const|const.getAttr('name').value = self.name)
			).first() <> OclUndefined
		then
			XML!Element.allInstances()->select(c|c.name='operation')->
			select(c|c.getAttr('package').value = self.owner.owner.package.name
				and c.getAttr('class').value = self.owner.owner.name
				and c.getChildren(XML!Element, 'precondition')->
			exists(const|const.getAttr('name').value = self.name)
			).first().getChildren(XML!Element, 'precondition')->
			select(const|const.getAttr('name').value = self.name).first().getAttr('value').value
		else 'noRule'
		endif
	else if self.owner.postcondition->includes(self)
			then
				if XML!Element.allInstances()->select(c|c.name='operation')->
				select(c|c.getAttr('package').value = self.owner.owner.package.name
					and c.getAttr('class').value = self.owner.owner.name
					and c.getChildren(XML!Element, 'postcondition')->
					exists(const|const.getAttr('name').value = self.name)
				).first() <> OclUndefined
				then XML!Element.allInstances()->select(c|c.name='operation')->
					select(c|c.getAttr('package').value = self.owner.owner.package.name
						and c.getAttr('class').value = self.owner.owner.name
						and c.getChildren(XML!Element, 'postcondition')->
						exists(const|const.getAttr('name').value = self.name)
					).first().getChildren(XML!Element, 'postcondition')->
					select(const|const.getAttr('name').value = self.name).first().getAttr('value').value
				else 'noRule'
				endif
			else 'noRule'
			endif	
		endif
	;
		
-- @begin Model
rule Model {
	from
		inputM : UML2!Model
	to
		outputM : UML2Target!Model (
			name <- inputM.name,
			ownedMember <- inputM.ownedMember
		)
}
-- @end Model
		
-- @begin DataType
rule DataType {
	from 
		inputC : UML2!DataType
	to
		outputC : UML2Target!DataType (
		name <- inputC.name
		)
}
-- @end DataType

-- @begin LiteralNull
rule LiteralNull {
	from 
		inputLN : UML2!LiteralNull
	to
		outputLN : UML2Target!LiteralNull
}
-- @end LiteralNull

-- @begin LiteralInteger
rule LiteralInteger {
	from 
		inputLI : UML2!LiteralInteger
	to
		outputLI : UML2Target!LiteralInteger (
			value <- inputLI.value	
		)
}
-- @end LiteralInteger

-- @begin LiteralUnlimitedNatural
rule LiteralUnlimitedNatural {
	from 
		inputLUN : UML2!LiteralUnlimitedNatural
	to
		outputLUN : UML2Target!LiteralUnlimitedNatural (
			value <- inputLUN.value	
		)
}
-- @end LiteralUnlimitedNatural

-- @begin LiteralString
rule LiteralString {
	from 
		inputLS : UML2!LiteralString
		(inputLS.owner.OperationExistInLib()='noRule')
	to
		outputLS : UML2Target!LiteralString (
			value <- inputLS.value
		)
}
-- @end LiteralString

-- @begin Association
rule Association {
	from 
		inputA : UML2!Association
	to 
		outputA : UML2Target!Association (
			name <- inputA.name,
			memberEnd <- inputA.memberEnd
	)
}
-- @end Association

-- @begin Property
rule Property {
	from 
		inputP : UML2!Property
	to
		outputP : UML2Target!Property (
			owningAssociation <- inputP.owningAssociation,
			name <- inputP.name,
			type <- inputP.type,
			upperValue <- inputP.upperValue,
			lowerValue <- inputP.lowerValue,
			defaultValue <-inputP.defaultValue
		)
}
-- @end Property

-- @begin Constraint
rule Constraint {
	from 
		inputC : UML2!Constraint
	to
		outputC : UML2Target!Constraint (
			name <-	inputC.name,
			namespace <- inputC.namespace,
			specification <- if inputC.OperationExistInLib()='noRule'
								then inputC.specification
								else thisModule.newRule(inputC)
								endif
		)
}
-- @end Constraint

-- @begin Class
rule Class {
	from 
		inputC : UML2!Class
	to 
		outputC : UML2Target!Class (
			name <- inputC.name,
			ownedOperation <- inputC.ownedOperation,
			nestedClassifier <-  inputC.nestedClassifier,
			isActive <-  inputC.isActive,
			ownedReception <-  inputC.ownedReception,
			ownedAttribute <- inputC.ownedAttribute
		)
}
-- @end Class

-- @begin Operation
rule Operation {
	from 
		inputO : UML2!Operation
	to 
		outputO : UML2Target!Operation (
			name <- inputO.name,
			class_ <- inputO.class_,
			ownedRule <- inputO.ownedRule,
			ownedParameter <- inputO.ownedParameter
		)
}
-- @end Operation

-- @begin Parameter
rule Parameter {
	from 
		inputP : UML2!Parameter
	to 
		outputP : UML2Target!Parameter (
			name <- inputP.name,
			operation <- inputP.operation,
			type <- inputP.type
		)
}
-- @end Parameter

-- @comment this lazy rule replace the oldest assertion by a new
-- @begin newRule
lazy rule newRule {
	from
		inputC : UML2!Constraint
	to
		outputLS : UML2Target!LiteralString (
			value <- inputC.OperationExistInLib()	
		)
}
-- @end newRule
",name assertionmodif version domain catalogu model transform author simon eric simon eric gmail com date descript this transform strenghthen weaken assert respect postcondit precondit see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul assertionmodif modul templat creat out uml target in uml lib xml comment helper return first attribut name name helper context xml element def getattr name string xml attribut self children select c c oclistypeof xml attribut select c c name name first comment helper return valu first attribut name name helper context xml element def getattrv name string string self getattr name valu comment helper return set child given type helper context xml element def getchildren type ocltyp name string sequenc xml node self children select e e ocliskindof type select e e name name comment helper return new assert contain librari helper context uml constraint def searchinlib string self owner oclistypeof uml class self classexistinlib els self owner oclistypeof uml associ self associationexistinlib els self owner oclistypeof uml oper self operationexistinlib els erreur entri type either class associ oper endif endif endif comment helper call helper searchinlib constraint class helper context uml constraint def classexistinlib string xml element allinst select c c name class select c c getattr packag valu self owner packag name c getattr name valu self owner name c getchildren xml element assert exist const const getattr name self name first oclundefin xml element allinst select c c name class select c c getattr packag valu self owner packag name c getattr name valu self owner name c getchildren xml element assert exist const const getattr name self name first getchildren xml element assert select const const getattr name self name first valu els norul endif comment helper call helper searchinlib constraint associ helper context uml constraint def associationexistinlib string xml element allinst select c c name associ select c c getattr packag valu self owner packag name c getattr name valu self owner name c getchildren xml element assert exist const const getattr name valu self name first oclundefin xml element allinst select c c name associ select c c getattr packag valu self owner packag name c getattr name valu self owner name c getchildren xml element assert exist const const getattr name valu self name first getchildren xml element assert select const const getattr name valu self name first getattr valu valu els norul endif comment helper call helper searchinlib constraint oper helper context uml constraint def operationexistinlib string self owner precondit includ self xml element allinst select c c name oper select c c getattr packag valu self owner owner packag name c getattr class valu self owner owner name c getchildren xml element precondit exist const const getattr name valu self name first oclundefin xml element allinst select c c name oper select c c getattr packag valu self owner owner packag name c getattr class valu self owner owner name c getchildren xml element precondit exist const const getattr name valu self name first getchildren xml element precondit select const const getattr name valu self name first getattr valu valu els norul endif els self owner postcondit includ self xml element allinst select c c name oper select c c getattr packag valu self owner owner packag name c getattr class valu self owner owner name c getchildren xml element postcondit exist const const getattr name valu self name first oclundefin xml element allinst select c c name oper select c c getattr packag valu self owner owner packag name c getattr class valu self owner owner name c getchildren xml element postcondit exist const const getattr name valu self name first getchildren xml element postcondit select const const getattr name valu self name first getattr valu valu els norul endif els norul endif endif begin model rule model inputm uml model outputm uml target model name inputm name ownedmemb inputm ownedmemb end model begin datatyp rule datatyp inputc uml datatyp outputc uml target datatyp name inputc name end datatyp begin literalnul rule literalnul inputln uml literalnul outputln uml target literalnul end literalnul begin literalinteg rule literalinteg input uml literalinteg output uml target literalinteg valu input valu end literalinteg begin literalunlimitednatur rule literalunlimitednatur inputlun uml literalunlimitednatur outputlun uml target literalunlimitednatur valu inputlun valu end literalunlimitednatur begin literalstr rule literalstr inputl uml literalstr inputl owner operationexistinlib norul outputl uml target literalstr valu inputl valu end literalstr begin associ rule associ inputa uml associ outputa uml target associ name inputa name memberend inputa memberend end associ begin properti rule properti inputp uml properti outputp uml target properti owningassoci inputp owningassoci name inputp name type inputp type uppervalu inputp uppervalu lowervalu inputp lowervalu defaultvalu inputp defaultvalu end properti begin constraint rule constraint inputc uml constraint outputc uml target constraint name inputc name namespac inputc namespac specif inputc operationexistinlib norul inputc specif els thismodul newrul inputc endif end constraint begin class rule class inputc uml class outputc uml target class name inputc name ownedoper inputc ownedoper nestedclassifi inputc nestedclassifi isact inputc isact ownedrecept inputc ownedrecept ownedattribut inputc ownedattribut end class begin oper rule oper inputo uml oper outputo uml target oper name inputo name class inputo class ownedrul inputo ownedrul ownedparamet inputo ownedparamet end oper begin paramet rule paramet inputp uml paramet outputp uml target paramet name inputp name oper inputp oper type inputp type end paramet comment lazi rule replac oldest assert new begin newrul lazi rule newrul inputc uml constraint outputl uml target literalstr valu inputc operationexistinlib end newrul,13
185,185,P80-SimpleSBVR2SimpleUML.atl,"-- @atlcompiler atl2006

-- ******************************************************************************
-- Copyright (c) 2009 INRIA. 
-- All rights reserved. This program and the accompanying materials 
-- are made available under the terms of the Eclipse Public License v1.0 
-- which accompanies this distribution, and is available at
-- http://www.eclipse.org/legal/epl-v10.html
-- 
-- Contributors: 
-- 	INRIA - Initial implementation
--  
-- ******************************************************************************

--@author Mathias Kleiner (mathias.kleiner@inria.fr)


module SimpleSBVR2SimpleUML; -- Module Template
create  OUT : SimpleUML from IN : SimpleSBVR;

-- =============================================================================
-- SBVR2UML
-- Version 1.0
-- Release date : 16/03/2009
-- Author : Mathias Kleiner (mathias.kleiner@inria.fr)
-- =============================================================================
	
-- Classes

rule ObjectType2Class {
	
	from
		s : SimpleSBVR!ObjectType
	to
		t : SimpleUML!Class (
		
			name <- s.representations->first().text.value
		)
		
}

-- DataTypes

abstract rule DataType2DataType {
	
	from
		s : SimpleSBVR!DataType
	to
		t : SimpleUML!DataType (
		
		)
}

-- PrimitiveTypes

rule NonNegativeInteger2PrimitiveType extends DataType2DataType {
	
	from
		s : SimpleSBVR!NonNegativeInteger
	to
		t : SimpleUML!PrimitiveType (
		
			name <- 'Integer'
		)
}

rule NonEmptyString2PrimitiveType extends DataType2DataType {
	
	from
		s : SimpleSBVR!NonEmptyString
	to
		t : SimpleUML!PrimitiveType (
		
			name <- 'String'
		)
}

-- FactTypes

-- Associations

rule AssociativeFactType2Association  {
	
	from
		s : SimpleSBVR!AssociativeFactType
	to
		t : SimpleUML!Association (
			
			name <- s.representations->first().text.value,
			memberEnd <- Set{property1,property2}
		),
		property1 : SimpleUML!Property (
			
			name <- s.role1.nounConcept.representations->first().text.value,
			type <- s.role1.nounConcept,
			association <- t,
			lowerValue <- s.getLowerValueForAssociativeFactType(s.role1),
			upperValue <- s.getUpperValueForAssociativeFactType(s.role1),
			classifier <- s.role2.nounConcept
		),
		property2 : SimpleUML!Property (
			
			name <- s.role2.nounConcept.representations->first().text.value,
			type <- s.role2.nounConcept,
			association <- t,
			lowerValue <- s.getLowerValueForAssociativeFactType(s.role2),
			upperValue <- s.getUpperValueForAssociativeFactType(s.role2),
			classifier <- s.role1.nounConcept
		)
}

-- Categorizations (Generalizations)

rule CategorizationFactType2Generalization  {
	
	from
		s : SimpleSBVR!CategorizationFactType
	to
		t : SimpleUML!Generalization (
			
			specific <- s.role1.nounConcept,
			general <- s.role2.nounConcept
		)
}

-- Properties (Attributes)

rule IsPropertyOfFactType2Property  {
	
	from
		s : SimpleSBVR!IsPropertyOfFactType
	to
		t : SimpleUML!Property (
			
			classifier <- s.role1.nounConcept,
			type <- s.role2.nounConcept,
			name <- s.role2.nounConcept.representations->first().text.value
		)
}
--
-- Objectifications (Instance specifications)

rule ObjectificationFactType2InstanceSpecification  {
	
	from
		s : SimpleSBVR!ObjectificationFactType
	to
		t : SimpleUML!InstanceSpecification (
			
			classifier <- s.role2.nounConcept,
			name <- s.role1.nounConcept.representations->first().text.value
		)
}

-- Helpers

-- Those 2 helpers allow to retrieve the lower/upper values for an association, when there is an appropriate Quantification associated to the AssociativeFactType's Role

helper context SimpleSBVR!AssociativeFactType def : getLowerValueForAssociativeFactType(ftr : SimpleSBVR!FactTypeRole) : Integer =
	
	let exact : SimpleSBVR!ExactlyNQuantification = SimpleSBVR!ExactlyNQuantification.allInstancesFrom('IN')->select(
			i | i.scopesOver.isBasedOn = self and i.introducedVariable.rangesOver = ftr.nounConcept
		)->first() in 
	if(not exact.oclIsUndefined()) then exact.cardinality.value
	else
		let least : SimpleSBVR!AtLeastNQuantification = SimpleSBVR!AtLeastNQuantification.allInstancesFrom('IN')->select(
				i | i.scopesOver.isBasedOn = self and i.introducedVariable.rangesOver = ftr.nounConcept
			)->first() in 
		if(not least.oclIsUndefined()) then least.minCardinality.value
		else OclUndefined
		endif
	endif;

helper context SimpleSBVR!AssociativeFactType def : getUpperValueForAssociativeFactType(ftr : SimpleSBVR!FactTypeRole) : Integer =
	
	let exact : SimpleSBVR!ExactlyNQuantification = SimpleSBVR!ExactlyNQuantification.allInstancesFrom('IN')->select(
		i | i.scopesOver.isBasedOn = self and i.introducedVariable.rangesOver = ftr.nounConcept
	)->first() in 
	if(not exact.oclIsUndefined()) then exact.cardinality.value
	else
		let most : SimpleSBVR!AtMostNQuantification = SimpleSBVR!AtMostNQuantification.allInstancesFrom('IN')->select(
			i | i.scopesOver.isBasedOn = self and i.introducedVariable.rangesOver = ftr.nounConcept
	)->first() in 
		if(not most.oclIsUndefined()) then most.maxCardinality.value
		else OclUndefined
		endif
	endif;
",atlcompil atl copyright c inria all right reserv this program accompani materi made avail term eclips public licens v accompani distribut avail http www eclips org legal epl v html contributor inria initi implement author mathia kleiner mathia kleiner inria fr modul simplesbvr simpleuml modul templat creat out simpleuml in simplesbvr sbvr uml version releas date author mathia kleiner mathia kleiner inria fr class rule objecttyp class simplesbvr objecttyp simpleuml class name represent first text valu datatyp abstract rule datatyp datatyp simplesbvr datatyp simpleuml datatyp primitivetyp rule nonnegativeinteg primitivetyp extend datatyp datatyp simplesbvr nonnegativeinteg simpleuml primitivetyp name integ rule nonemptystr primitivetyp extend datatyp datatyp simplesbvr nonemptystr simpleuml primitivetyp name string facttyp associ rule associativefacttyp associ simplesbvr associativefacttyp simpleuml associ name represent first text valu memberend set properti properti properti simpleuml properti name role nounconcept represent first text valu type role nounconcept associ lowervalu getlowervalueforassociativefacttyp role uppervalu getuppervalueforassociativefacttyp role classifi role nounconcept properti simpleuml properti name role nounconcept represent first text valu type role nounconcept associ lowervalu getlowervalueforassociativefacttyp role uppervalu getuppervalueforassociativefacttyp role classifi role nounconcept categor general rule categorizationfacttyp general simplesbvr categorizationfacttyp simpleuml general specif role nounconcept general role nounconcept properti attribut rule ispropertyoffacttyp properti simplesbvr ispropertyoffacttyp simpleuml properti classifi role nounconcept type role nounconcept name role nounconcept represent first text valu objectif instanc specif rule objectificationfacttyp instancespecif simplesbvr objectificationfacttyp simpleuml instancespecif classifi role nounconcept name role nounconcept represent first text valu helper those helper allow retriev lower upper valu associ appropri quantif associ associativefacttyp role helper context simplesbvr associativefacttyp def getlowervalueforassociativefacttyp ftr simplesbvr facttyperol integ let exact simplesbvr exactlynquantif simplesbvr exactlynquantif allinstancesfrom in select scopesov isbasedon self introducedvari rangesov ftr nounconcept first exact oclisundefin exact cardin valu els let least simplesbvr atleastnquantif simplesbvr atleastnquantif allinstancesfrom in select scopesov isbasedon self introducedvari rangesov ftr nounconcept first least oclisundefin least mincardin valu els oclundefin endif endif helper context simplesbvr associativefacttyp def getuppervalueforassociativefacttyp ftr simplesbvr facttyperol integ let exact simplesbvr exactlynquantif simplesbvr exactlynquantif allinstancesfrom in select scopesov isbasedon self introducedvari rangesov ftr nounconcept first exact oclisundefin exact cardin valu els let simplesbvr atmostnquantif simplesbvr atmostnquantif allinstancesfrom in select scopesov isbasedon self introducedvari rangesov ftr nounconcept first oclisundefin maxcardin valu els oclundefin endif endif,7
186,186,P80-Syntax2SimpleSBVR.atl,"-- @atlcompiler atl2006

-- ******************************************************************************
-- Copyright (c) 2009 INRIA. 
-- All rights reserved. This program and the accompanying materials 
-- are made available under the terms of the Eclipse Public License v1.0 
-- which accompanies this distribution, and is available at
-- http://www.eclipse.org/legal/epl-v10.html
-- 
-- Contributors: 
-- 	INRIA - Initial implementation
--  
-- ******************************************************************************

--@author Mathias Kleiner (mathias.kleiner@inria.fr)

module Syntax2SimpleSBVR; -- Module Template
create  OUT : SimpleSBVR from IN : Syntax;

-- =============================================================================
-- Syntax2UML
-- Version 1.0
-- Release date : 16/03/2009
-- Author : Mathias Kleiner (mathias.kleiner@inria.fr)
-- =============================================================================
	
-- NounConcepts

abstract rule NounConcept2NounConcept {
	
	from
		s : Syntax!NounConcept
	to
		t : SimpleSBVR!NounConcept (
		
			objectName <- s.objectName
		)
		
}
-- ObjectTypes

rule ObjectType2ObjectType extends NounConcept2NounConcept {
	
	from
		s : Syntax!ObjectType
	to
		t : SimpleSBVR!ObjectType (
		
		)
		
}

-- DataTypes

abstract rule DataType2DataType extends NounConcept2NounConcept {
	
	from
		s : Syntax!DataType
	to
		t : SimpleSBVR!DataType (
		
		)
}

rule NonNegativeInteger2NonNegativeInteger extends DataType2DataType {
	
	from
		s : Syntax!NonNegativeInteger
	to
		t : SimpleSBVR!NonNegativeInteger (
		
			value <- s.expressedBy->first().word.baseDesignation.objectName.toInteger()
		)
}

rule NonEmptyString2NonEmptyString extends DataType2DataType {
	
	from
		s : Syntax!NonEmptyString
	to
		t : SimpleSBVR!NonEmptyString (
		
			value <- s.expressedBy->first().word.baseDesignation.objectName.toString()
		)
}

-- Designations

rule Designation2Designation {
	
	from
		s : Syntax!Designation
	to
		t : SimpleSBVR!Designation (
			
			objectName <- s.objectName,
			text <- text,
			meaning <- s.meaning
		),
		text : SimpleSBVR!Text (
			
			objectName <- s.objectName,
			value <- s.objectName
		)
}

-- FactTypes

abstract rule FactType2FactType {
	
	from
		s : Syntax!FactType
	to
		t : SimpleSBVR!FactType (
		
			objectName <- s.objectName
		)
}

-- BinaryFactTypes

abstract rule BinaryFactType2BinaryFactType extends FactType2FactType {
	
	from
		s : Syntax!BinaryFactType
	to
		t : SimpleSBVR!BinaryFactType (
			
			role1 <- role1,
			role2 <- role2
		),
		role1 : SimpleSBVR!FactTypeRole (
			
			nounConcept <- if(s.expressedBy->first().passive = true) then s.expressedBy->first().directObject.head.expresses
						   else s.expressedBy->first().subject.head.expresses
						   endif
		),
		role2 : SimpleSBVR!FactTypeRole (
			
			nounConcept <- if(s.expressedBy->first().passive = true) then s.expressedBy->first().subject.head.expresses
						   else s.expressedBy->first().directObject.head.expresses
						   endif
		)
}

-- AssociativeFactType

rule AssociativeFactType2AssociativeFactType extends BinaryFactType2BinaryFactType {
	
	from
		s : Syntax!AssociativeFactType
	to
		t : SimpleSBVR!AssociativeFactType ()
}

-- IsPropertyOfFactType

rule IsPropertyOfFactType2IsPropertyOfFactType extends BinaryFactType2BinaryFactType {
	
	from
		s : Syntax!IsPropertyOfFactType
	to
		t : SimpleSBVR!IsPropertyOfFactType ()
}

-- CategorizationFactType

rule CategorizationFactType2CategorizationFactType extends BinaryFactType2BinaryFactType {
	
	from
		s : Syntax!CategorizationFactType
	to
		t : SimpleSBVR!CategorizationFactType ()
}

-- ObjectificationFactType

rule ObjectificationFactType2ObjectificationFactType extends BinaryFactType2BinaryFactType {
	
	from
		s : Syntax!ObjectificationFactType
	to
		t : SimpleSBVR!ObjectificationFactType ()
}

-- AtomicFormulations
-- AFs are created upon necessity, we thus use a unique lazy rule

unique lazy abstract rule FactType2AtomicFormulation {
	
	from
		s : Syntax!FactType
	to
		t : SimpleSBVR!AtomicFormulation (
			
			isBasedOn <- s
		)
}

-- BinaryAtomicFormulations have 2 identified role bindings

unique lazy rule BinaryFactType2BinaryAtomicFormulation extends FactType2AtomicFormulation {
	
	from
		s : Syntax!BinaryFactType
	to
		t : SimpleSBVR!BinaryAtomicFormulation (
			
			--isBasedOn <- s,
			roleBinding1 <- roleBinding1,
			roleBinding2 <- roleBinding2
		),
		roleBinding1 : SimpleSBVR!RoleBinding (
			
			bindsTo <- if(s.expressedBy->first().passive = true) then thisModule.NounConcept2Variable(s.expressedBy->first().directObject.head.expresses)
					   else thisModule.NounConcept2Variable(s.expressedBy->first().subject.head.expresses)
					   endif,
			isOf <- thisModule.resolveTemp(s,'role1'),
			occursIn <- t
		),
		roleBinding2 : SimpleSBVR!RoleBinding (
			
			bindsTo <- if(s.expressedBy->first().passive = true) then thisModule.NounConcept2Variable(s.expressedBy->first().subject.head.expresses)
					   else thisModule.NounConcept2Variable(s.expressedBy->first().directObject.head.expresses)
					   endif,
			isOf <- thisModule.resolveTemp(s,'role2'),
			occursIn <- t
		)
}

-- Variables
-- Variables are created upon necessity, we thus use a unique lazy rule

unique lazy rule NounConcept2Variable {
	
	from
		s : Syntax!NounConcept
	to
		t : SimpleSBVR!Variable (
			
			rangesOver <- s
		)
}
-- Quantifications
-- The quantification scopes over an AtomicFormulation, which can be retrieved through the VP of the Quantifier's sentence
-- The quantification introduces a variable that is shared with the AtomicFormulation. We can retrieve it with the corresponding unique lazy rule
	
abstract rule Quantification2Quantification {
	
	from
		s : Syntax!Quantification
	to
		t : SimpleSBVR!Quantification (
			
			introducedVariable <- thisModule.NounConcept2Variable(s.expressedBy->first().object.expresses),
			scopesOver <- thisModule.FactType2AtomicFormulation(s.expressedBy->first().np.getVPFromNP().expresses)
		)
}

-- Concrete rules for each quantification type

rule UniversalQuantification2UniversalQuantification extends Quantification2Quantification {
	
	from
		s : Syntax!UniversalQuantification
		
	to
		t : SimpleSBVR!UniversalQuantification (
		
		)
}

rule AtMostNQuantification2AtMostNQuantification extends Quantification2Quantification {
	
	from
		s : Syntax!AtMostNQuantification
		
	to
		t : SimpleSBVR!AtMostNQuantification (
		
			maxCardinality <- s.expressedBy->first().value.expresses
		)
}

rule AtLeastNQuantification2AtLeastNQuantification extends Quantification2Quantification {
	
	from
		s : Syntax!AtLeastNQuantification
		
	to
		t : SimpleSBVR!AtLeastNQuantification (
		
			minCardinality <- s.expressedBy->first().value.expresses
		)
}

rule ExactlyNQuantification2ExactlyNQuantification extends Quantification2Quantification {
	
	from
		s : Syntax!ExactlyNQuantification
		
	to
		t : SimpleSBVR!ExactlyNQuantification (
		
			cardinality <- s.expressedBy->first().value.expresses
		)
}

-- Helpers

-- This helper retrieves the VP from a NP that is either its subject or its directObject

helper context Syntax!NPCat def : getVPFromNP() : Syntax!VPCat =
	
	if(self.isSubject()) then self.isSubjectOf
	else 
		if (self.isDirectObject()) then self.isDirectObjectOf
		else OclUndefined
		endif
	endif;

-- Those helpers indicate whether a NP is a subject or a directObject

helper context Syntax!NPCat def : isSubject() : Boolean = 
	if(not self.isSubjectOf.oclIsUndefined()) then true
	else false
	endif;

helper context Syntax!NPCat def : isDirectObject() : Boolean = 
	if(not self.isDirectObjectOf.oclIsUndefined()) then true
	else false
	endif;
	",atlcompil atl copyright c inria all right reserv this program accompani materi made avail term eclips public licens v accompani distribut avail http www eclips org legal epl v html contributor inria initi implement author mathia kleiner mathia kleiner inria fr modul syntax simplesbvr modul templat creat out simplesbvr in syntax syntax uml version releas date author mathia kleiner mathia kleiner inria fr nounconcept abstract rule nounconcept nounconcept syntax nounconcept simplesbvr nounconcept objectnam objectnam objecttyp rule objecttyp objecttyp extend nounconcept nounconcept syntax objecttyp simplesbvr objecttyp datatyp abstract rule datatyp datatyp extend nounconcept nounconcept syntax datatyp simplesbvr datatyp rule nonnegativeinteg nonnegativeinteg extend datatyp datatyp syntax nonnegativeinteg simplesbvr nonnegativeinteg valu expressedbi first word basedesign objectnam tointeg rule nonemptystr nonemptystr extend datatyp datatyp syntax nonemptystr simplesbvr nonemptystr valu expressedbi first word basedesign objectnam tostr design rule design design syntax design simplesbvr design objectnam objectnam text text mean mean text simplesbvr text objectnam objectnam valu objectnam facttyp abstract rule facttyp facttyp syntax facttyp simplesbvr facttyp objectnam objectnam binaryfacttyp abstract rule binaryfacttyp binaryfacttyp extend facttyp facttyp syntax binaryfacttyp simplesbvr binaryfacttyp role role role role role simplesbvr facttyperol nounconcept expressedbi first passiv true expressedbi first directobject head express els expressedbi first subject head express endif role simplesbvr facttyperol nounconcept expressedbi first passiv true expressedbi first subject head express els expressedbi first directobject head express endif associativefacttyp rule associativefacttyp associativefacttyp extend binaryfacttyp binaryfacttyp syntax associativefacttyp simplesbvr associativefacttyp ispropertyoffacttyp rule ispropertyoffacttyp ispropertyoffacttyp extend binaryfacttyp binaryfacttyp syntax ispropertyoffacttyp simplesbvr ispropertyoffacttyp categorizationfacttyp rule categorizationfacttyp categorizationfacttyp extend binaryfacttyp binaryfacttyp syntax categorizationfacttyp simplesbvr categorizationfacttyp objectificationfacttyp rule objectificationfacttyp objectificationfacttyp extend binaryfacttyp binaryfacttyp syntax objectificationfacttyp simplesbvr objectificationfacttyp atomicformul af creat upon necess thus use uniqu lazi rule uniqu lazi abstract rule facttyp atomicformul syntax facttyp simplesbvr atomicformul isbasedon binaryatomicformul identifi role bind uniqu lazi rule binaryfacttyp binaryatomicformul extend facttyp atomicformul syntax binaryfacttyp simplesbvr binaryatomicformul isbasedon rolebind rolebind rolebind rolebind rolebind simplesbvr rolebind bindsto expressedbi first passiv true thismodul nounconcept variabl expressedbi first directobject head express els thismodul nounconcept variabl expressedbi first subject head express endif isof thismodul resolvetemp role occursin rolebind simplesbvr rolebind bindsto expressedbi first passiv true thismodul nounconcept variabl expressedbi first subject head express els thismodul nounconcept variabl expressedbi first directobject head express endif isof thismodul resolvetemp role occursin variabl variabl creat upon necess thus use uniqu lazi rule uniqu lazi rule nounconcept variabl syntax nounconcept simplesbvr variabl rangesov quantif the quantif scope atomicformul retriev vp quantifi sentenc the quantif introduc variabl share atomicformul we retriev correspond uniqu lazi rule abstract rule quantif quantif syntax quantif simplesbvr quantif introducedvari thismodul nounconcept variabl expressedbi first object express scopesov thismodul facttyp atomicformul expressedbi first np getvpfromnp express concret rule quantif type rule universalquantif universalquantif extend quantif quantif syntax universalquantif simplesbvr universalquantif rule atmostnquantif atmostnquantif extend quantif quantif syntax atmostnquantif simplesbvr atmostnquantif maxcardin expressedbi first valu express rule atleastnquantif atleastnquantif extend quantif quantif syntax atleastnquantif simplesbvr atleastnquantif mincardin expressedbi first valu express rule exactlynquantif exactlynquantif extend quantif quantif syntax exactlynquantif simplesbvr exactlynquantif cardin expressedbi first valu express helper this helper retriev vp np either subject directobject helper context syntax npcat def getvpfromnp syntax vpcat self issubject self issubjectof els self isdirectobject self isdirectobjectof els oclundefin endif endif those helper indic whether np subject directobject helper context syntax npcat def issubject boolean self issubjectof oclisundefin true els fals endif helper context syntax npcat def isdirectobject boolean self isdirectobjectof oclisundefin true els fals endif,6
187,187,P81-SpreadsheetMLSimplified2XML.atl,"module SpreadsheetMLSimplified2XML; -- Module Template
create  OUT : XML from  IN : SpreadsheetMLSimplified;



-- This helper permits to obtain the string associated
-- to a DateTimeType value.
-- CONTEXT: n/a
-- RETURN: String
helper def: getDateTimeStringValue(dtv : SpreadsheetMLSimplified!DateTimeType) : String =
	dtv.year.toString() + '-' + dtv.month.toString() + '-' + dtv.day.toString() + 'T' 
	+ dtv.hour.toString() + ':' + dtv.minute.toString() + ':' + dtv.second.toString() + '.000';
	


-- Rule 'DocumentRoot'.
-- This rule generates the root element of an Excel xml file
-- which is the ""Workbook"" element
rule DocumentRoot {
	 from 
	 	wb : SpreadsheetMLSimplified!Workbook
	 to 
	 	r : XML!Root(
		 	name<-'Workbook',
			value <- '',
			children <- Sequence{	att1,att2,
		 							wb.wb_worksheets->collect(e | thisModule.resolveTemp(e, 'wsElt')) }
		),
		att1 : XML!Attribute (
			name <- 'xmlns',
			value <- 'urn:schemas-microsoft-com:office:spreadsheet'
		),
		att2 : XML!Attribute (
			name <- 'xmlns:ss',
			value <-'urn:schemas-microsoft-com:office:spreadsheet'
		)
}


-- Rule 'Worksheets'.
-- This rule generates the different ""Worksheet"" elements 
-- contained in a ""Workbook"" element
rule Worksheets {
	from 
		ws : SpreadsheetMLSimplified!Worksheet
		
	to
		wsElt : XML!Element (
			name <- 'Worksheet',
			children <- Sequence{nameAtt,Sequence{ws.ws_table}->collect(e | thisModule.resolveTemp(e, 'tElt'))->first()}
		),
		nameAtt : XML!Attribute (
			name <- 'ss:Name',
			value <- ws.name,
			parent <- wsElt
		)
}


-- Rule 'WorksheetTable'.
-- This rule generates the ""Table"" element  
-- contained in a ""Worksheet"" element
rule WorksheetTable {
	from 
		t : SpreadsheetMLSimplified!Table

	to
		tElt : XML!Element (
			name <- 'Table',
			children <- Sequence{
									t.t_cols->collect(e | thisModule.resolveTemp(e, 'colElt')),
									t.t_rows->collect(e | thisModule.resolveTemp(e, 'rowElt'))
								}
		)
}


-- Rule 'TableColumn'.
-- This rule generates the ""Column"" elements  
-- contained in a ""Table"" element
rule TableColumn {
	from 
		col : SpreadsheetMLSimplified!Column
	
	using {
		widthOrNot : Sequence(String) =
			let wdh : Real = col.width
			in
				if wdh.oclIsUndefined()
				then
					Sequence{}
				else
					Sequence{wdh.toString()}
				endif;		
	}

	to
		colElt : XML!Element (
			name <- 'Column',
			children <- Sequence{colWidth}
		),
		colWidth : distinct XML!Attribute foreach(widthValue in widthOrNot)(
			name <- 'ss:Width',
			value <- widthValue
		)
}


-- Rule 'TableRow'.
-- This rule generates the ""Row"" elements  
-- contained in a ""Table"" element
rule TableRow {
	from 
		row : SpreadsheetMLSimplified!Row

	to
		rowElt : XML!Element (
			name <- 'Row',
			children <- Sequence{row.r_cells->collect(e | thisModule.resolveTemp(e, 'cellElt'))}
		)
}


-- Rule 'RowCell'.
-- This rule generates the ""Cell"" elements  
-- contained in a ""Row"" element
rule RowCell {
	from 
		cell : SpreadsheetMLSimplified!Cell

	to
		cellElt : XML!Element (
			name <- 'Cell',
			children <- Sequence{
							Sequence{cell.c_data}->collect(e | thisModule.resolveTemp(e, 'dataElt'))->first()
						}
		)
}


-- Rule 'CellData'.
-- This rule generates the ""Data"" element  
-- contained in a ""Cell"" element
rule CellData {
	from 
		data : SpreadsheetMLSimplified!Data

	to
		dataElt : XML!Element (
			name <- 'Data'
		)
}


-- Rule 'DataStringValue'.
-- This rule generates the string value  
-- associated to a ""Data"" element
rule DataStringValue {
	from 
		strVal: SpreadsheetMLSimplified!StringValue

	to
		strValAtt : XML!Attribute (
			parent <- Sequence{strVal.vt_data}->collect(e | thisModule.resolveTemp(e, 'dataElt'))->first(),
			name <- 'ss:Type',
			value <- 'String'
		),
		strValTxt : XML!Text (
			parent <- Sequence{strVal.vt_data}->collect(e | thisModule.resolveTemp(e, 'dataElt'))->first(),
			value <- strVal.value
		)
}


-- Rule 'DataNumberValue'.
-- This rule generates the number value  
-- associated to a ""Data"" element
rule DataNumberValue {
	from 
		numVal: SpreadsheetMLSimplified!NumberValue

	to
		numValAtt : XML!Attribute (
			parent <- Sequence{numVal.vt_data}->collect(e | thisModule.resolveTemp(e, 'dataElt'))->first(),
			name <- 'ss:Type',
			value <- 'Number'
		),
		numValTxt : XML!Text (
			parent <- Sequence{numVal.vt_data}->collect(e | thisModule.resolveTemp(e, 'dataElt'))->first(),
			value <- numVal.value.toString()
		)
}


-- Rule 'DataBooleanValue'.
-- This rule generates the boolean value  
-- associated to a ""Data"" element
rule DataBooleanValue {
	from 
		boolVal: SpreadsheetMLSimplified!BooleanValue

	to
		boolValAtt : XML!Attribute (
			parent <- Sequence{boolVal.vt_data}->collect(e | thisModule.resolveTemp(e, 'dataElt'))->first(),
			name <- 'ss:Type',
			value <- 'Boolean'
		),
		boolValTxt : XML!Text (
			parent <- Sequence{boolVal.vt_data}->collect(e | thisModule.resolveTemp(e, 'dataElt'))->first(),
			value <- boolVal.value.toString()
		)
}


-- Rule 'DataErrorValue'.
-- This rule generates the error value  
-- associated to a ""Data"" element
rule DataErrorValue {
	from 
		errVal: SpreadsheetMLSimplified!ErrorValue

	to
		errValAtt : XML!Attribute (
			parent <- Sequence{errVal.vt_data}->collect(e | thisModule.resolveTemp(e, 'dataElt'))->first(),
			name <- 'ss:Type',
			value <- 'Error'
		)
}


-- Rule 'DataDateTimeValue'.
-- This rule generates the date/time value  
-- associated to a ""Data"" element
rule DataDateTimeValue {
	from 
		dtVal: SpreadsheetMLSimplified!DateTimeTypeValue

	to
		dtValAtt : XML!Attribute (
			parent <- Sequence{dtVal.vt_data}->collect(e | thisModule.resolveTemp(e, 'dataElt'))->first(),
			name <- 'ss:Type',
			value <- 'DateTime'
		),
		dtValTxt : XML!Text (
			parent <- Sequence{dtVal.vt_data}->collect(e | thisModule.resolveTemp(e, 'dataElt'))->first(),
			value <- thisModule.getDateTimeStringValue(dtVal.value)
		)
}",modul spreadsheetmlsimplifi xml modul templat creat out xml in spreadsheetmlsimplifi this helper permit obtain string associ datetimetyp valu context n return string helper def getdatetimestringvalu dtv spreadsheetmlsimplifi datetimetyp string dtv year tostr dtv month tostr dtv day tostr t dtv hour tostr dtv minut tostr dtv second tostr rule documentroot this rule generat root element excel xml file workbook element rule documentroot wb spreadsheetmlsimplifi workbook r xml root name workbook valu children sequenc att att wb wb worksheet collect e thismodul resolvetemp e wselt att xml attribut name xmlns valu urn schema microsoft com offic spreadsheet att xml attribut name xmlns ss valu urn schema microsoft com offic spreadsheet rule worksheet this rule generat differ worksheet element contain workbook element rule worksheet ws spreadsheetmlsimplifi worksheet wselt xml element name worksheet children sequenc nameatt sequenc ws ws tabl collect e thismodul resolvetemp e telt first nameatt xml attribut name ss name valu ws name parent wselt rule worksheett this rule generat tabl element contain worksheet element rule worksheett spreadsheetmlsimplifi tabl telt xml element name tabl children sequenc col collect e thismodul resolvetemp e colelt row collect e thismodul resolvetemp e rowelt rule tablecolumn this rule generat column element contain tabl element rule tablecolumn col spreadsheetmlsimplifi column use widthornot sequenc string let wdh real col width wdh oclisundefin sequenc els sequenc wdh tostr endif colelt xml element name column children sequenc colwidth colwidth distinct xml attribut foreach widthvalu widthornot name ss width valu widthvalu rule tablerow this rule generat row element contain tabl element rule tablerow row spreadsheetmlsimplifi row rowelt xml element name row children sequenc row r cell collect e thismodul resolvetemp e cellelt rule rowcel this rule generat cell element contain row element rule rowcel cell spreadsheetmlsimplifi cell cellelt xml element name cell children sequenc sequenc cell c data collect e thismodul resolvetemp e dataelt first rule celldata this rule generat data element contain cell element rule celldata data spreadsheetmlsimplifi data dataelt xml element name data rule datastringvalu this rule generat string valu associ data element rule datastringvalu strval spreadsheetmlsimplifi stringvalu strvalatt xml attribut parent sequenc strval vt data collect e thismodul resolvetemp e dataelt first name ss type valu string strvaltxt xml text parent sequenc strval vt data collect e thismodul resolvetemp e dataelt first valu strval valu rule datanumbervalu this rule generat number valu associ data element rule datanumbervalu numval spreadsheetmlsimplifi numbervalu numvalatt xml attribut parent sequenc numval vt data collect e thismodul resolvetemp e dataelt first name ss type valu number numvaltxt xml text parent sequenc numval vt data collect e thismodul resolvetemp e dataelt first valu numval valu tostr rule databooleanvalu this rule generat boolean valu associ data element rule databooleanvalu boolval spreadsheetmlsimplifi booleanvalu boolvalatt xml attribut parent sequenc boolval vt data collect e thismodul resolvetemp e dataelt first name ss type valu boolean boolvaltxt xml text parent sequenc boolval vt data collect e thismodul resolvetemp e dataelt first valu boolval valu tostr rule dataerrorvalu this rule generat error valu associ data element rule dataerrorvalu errval spreadsheetmlsimplifi errorvalu errvalatt xml attribut parent sequenc errval vt data collect e thismodul resolvetemp e dataelt first name ss type valu error rule datadatetimevalu this rule generat date time valu associ data element rule datadatetimevalu dtval spreadsheetmlsimplifi datetimetypevalu dtvalatt xml attribut parent sequenc dtval vt data collect e thismodul resolvetemp e dataelt first name ss type valu datetim dtvaltxt xml text parent sequenc dtval vt data collect e thismodul resolvetemp e dataelt first valu thismodul getdatetimestringvalu dtval valu,11
188,188,P81-Table2SpreadsheetMLSimplified.atl,"module Table2SpreadsheetMLSimplified; -- Module Template
create OUT : SpreadsheetMLSimplified from IN : Table;


-- This helper permits to determine whether a string contains a number value or not.
-- The method used in this helper is not exactly correct because it considers as a number 
-- a string that can be composed of several '.' characters. It should be improved in order 
-- to solve this problem. However, the helper returns the right value in most cases. 
-- CONTEXT: n/a
-- RETURN: Boolean
helper context Table!Cell def: isNumber(value : String, itIsFirstChar : Boolean) : Boolean =
	if value <> ''
	then
		let char : String =  value.substring(1,1)
		in
			if( char = '.' or char = '0' or char = '1' or char = '2' or char = '3' or char = '4' 
				or char = '5' or char = '6' or char = '7' or char = '8' or char = '9')
			then
				self.isNumber(value.substring(2,value.size()),false)
			else
				false
			endif
	else
		if itIsFirstChar
		then
			false
		else
			true
		endif
	endif;



-- Rule 'Table2ExcelTable'
-- This rule generates the global structure of an Excel document 
-- and creates the Excel table
rule Table2ExcelTable {
	from 
		t : Table!Table

	using {
		tableRow : Sequence(Table!Cell) = t.rows->first().cells;		
	}
	
	to 
		wb : SpreadsheetMLSimplified!Workbook (
			wb_worksheets <- Sequence{ws}
		),
		ws : SpreadsheetMLSimplified!Worksheet (
			name <- 'Java source code Info',
			ws_table <- et
		),
		et : SpreadsheetMLSimplified!Table (
			t_rows <- Sequence{t.rows->collect(e | thisModule.resolveTemp(e, 'erow'))},
			t_cols <- Sequence{col}
		),
		col : distinct SpreadsheetMLSimplified!Column foreach(cell in tableRow)(
			width <- 150.0
		)
}


-- Rule 'Row2ExcelRow'
-- This rule generates the rows that will contain the cells 
rule Row2ExcelRow {
	from 
		row : Table!Row
	
	to
		erow : SpreadsheetMLSimplified!Row (
			r_cells <- Sequence{ row.cells->collect(e | thisModule.resolveTemp(e, 'ecell'))}
		)
}


-- Rule 'Cell2ExcelCell'
-- This rule generates the cells that will contain the data
rule Cell2ExcelCell {
	from 
		cell : Table!Cell
		
	using {
		stringTypeOrNot : Sequence(String) = 
			let ct : String = cell.content
			in
				if cell.isNumber(ct,true)
				then
					Sequence{}
				else
					Sequence{ct}
				endif;
		numberTypeOrNot : Sequence(Real) =
			let ct : String = cell.content
			in
				if cell.isNumber(ct,true)
				then
					Sequence{ct.toReal()}
				else
					Sequence{}
				endif;
	}

	to
		ecell : SpreadsheetMLSimplified!Cell (
			c_data <- edata
		),
		edata : SpreadsheetMLSimplified!Data (),
		stringVal : distinct SpreadsheetMLSimplified!StringValue foreach(stringTypeVal in stringTypeOrNot) (
			vt_data <- edata,
			value <- stringTypeVal
		),
		numberVal : distinct SpreadsheetMLSimplified!NumberValue foreach(numberTypeVal in numberTypeOrNot) (
			vt_data <- edata,
			value <- numberTypeVal
		)
}

",modul tabl spreadsheetmlsimplifi modul templat creat out spreadsheetmlsimplifi in tabl this helper permit determin whether string contain number valu the method use helper exact correct consid number string compos sever charact it improv order solv problem howev helper return right valu case context n return boolean helper context tabl cell def isnumb valu string itisfirstchar boolean boolean valu let char string valu substr char char char char char char char char char char char self isnumb valu substr valu size fals els fals endif els itisfirstchar fals els true endif endif rule tabl excelt this rule generat global structur excel document creat excel tabl rule tabl excelt tabl tabl use tablerow sequenc tabl cell row first cell wb spreadsheetmlsimplifi workbook wb worksheet sequenc ws ws spreadsheetmlsimplifi worksheet name java sourc code info ws tabl et et spreadsheetmlsimplifi tabl row sequenc row collect e thismodul resolvetemp e erow col sequenc col col distinct spreadsheetmlsimplifi column foreach cell tablerow width rule row excelrow this rule generat row contain cell rule row excelrow row tabl row erow spreadsheetmlsimplifi row r cell sequenc row cell collect e thismodul resolvetemp e ecel rule cell excelcel this rule generat cell contain data rule cell excelcel cell tabl cell use stringtypeornot sequenc string let ct string cell content cell isnumb ct true sequenc els sequenc ct endif numbertypeornot sequenc real let ct string cell content cell isnumb ct true sequenc ct toreal els sequenc endif ecel spreadsheetmlsimplifi cell c data edata edata spreadsheetmlsimplifi data stringval distinct spreadsheetmlsimplifi stringvalu foreach stringtypev stringtypeornot vt data edata valu stringtypev numberv distinct spreadsheetmlsimplifi numbervalu foreach numbertypev numbertypeornot vt data edata valu numbertypev,11
189,189,P81-XML2ExcelText.atl,"query XML2Text = XML!Root.allInstances()
		->asSequence()
		->first().ExcelFile().writeTo('C:\\Documents and Settings\\Hugo\\Mes documents\\Stage\\eclipse_workspace\\OfficeTransformations\\OfficeExtractors\\SpreadsheetML2Text\\exampleExcelJavaSource.xml');

helper context XML!Root def: ExcelFile() : String =
	'<?xml version=""1.0""?>'+'\n'+'<?mso-application progid=""Excel.Sheet""?>'+'\n'
	+ self.toString2('');
	

helper context XML!Element def: toString2(indent : String) : String =
	let na : Sequence(XML!Node) =
		self.children->select(e | not e.oclIsKindOf(XML!Attribute)) in
	let a : Sequence(XML!Node) =
		self.children->select(e | e.oclIsKindOf(XML!Attribute)) in
	indent + '<' + self.name + 
	a->iterate(e; acc : String = '' |
		acc + ' ' + e.toString2()
	) +
	if na->size() > 0 then
		'>'
		+ na->iterate(e; acc : String = '' |
			acc + 
			if e.oclIsKindOf(XML!Text) then
				''
			else
				'\r\n'
			endif
			+ e.toString2(indent + '  ')
		) +
		if na->first().oclIsKindOf(XML!Text) then
			'</' + self.name + '>'
			else
				'\r\n' + indent + '</' + self.name + '>'
		endif
	else
		'/>'
	endif;

	
helper context XML!Attribute def: toString2() : String =
	self.name + '=\""' + self.value + '\""';


helper context XML!Text def: toString2() : String =
	self.value;
",queri xml text xml root allinst assequ first excelfil writeto c document set hugo mes document stage eclips workspac officetransform officeextractor spreadsheetml text exampleexceljavasourc xml helper context xml root def excelfil string xml version n mso applic progid excel sheet n self tostr helper context xml element def tostr indent string string let na sequenc xml node self children select e e ocliskindof xml attribut let sequenc xml node self children select e e ocliskindof xml attribut indent self name iter e acc string acc e tostr na size na iter e acc string acc e ocliskindof xml text els r n endif e tostr indent na first ocliskindof xml text self name els r n indent self name endif els endif helper context xml attribut def tostr string self name self valu helper context xml text def tostr string self valu,5
190,190,P82-SVG2XML.atl,"--@atlcompiler	atl2006
--@name			SVG2XML
--@version		2.0
--@domains		SVG, extractor
--@authors		Eric Vepa (evepa <at> sodius.com) for SODIUS (www.sodius.com)
--@date			2007/05/28
--@description	SVG extractor for a subset of the SVG metamodel.

module SVG2XML; -- Module Template
create OUT : XML from IN : SVG;

--@begin helper notNull
--@comments Returns true if the value is not null (0 or 0.0).
helper context Real
def : notNull() : Boolean =
	self <> 0 and self <> 0.0;
--@end helper notNull

--@begin helper scale
--@comments Returns the string value for a scale transformation attribute.
helper context SVG!Scale
def : scale() : String =
	if (self.sx = 1 or self.sx = 1.0)
		then ''
		else 'scale(' + self.sx.toString() +
			if self.sy = self.sx
				then ''
				else ',' + self.sy.toString()
			endif + ')'
	endif;
--@end helper scale

--@begin helper translate
--@comments Returns the string value for a translate transformation attribute.
helper context SVG!Translate
def : translate() : String =
	if self.tx.notNull() or self.ty.notNull()
		then 'translate(' + self.tx.toString() + ',' + self.ty.toString() + ')'
		else ''
	endif;
--@end helper translate

--@begin helper rotate
--@comments Returns the string value for a rotate transformation attribute.
helper context SVG!Rotate
def : rotate() : String =
	if self.angle.notNull()
		then 'rotate(' + self.angle.toString() + ')'
		else ''
	endif;
--@end helper rotate

--@begin rule Svg
rule Svg {
	from
		svg : SVG!Svg
	to
		root : XML!Root (
			name <- 'svg',
			children <- xmlns,
			children <- version,
			children <- thisModule.Attribute('width',
				if not svg.size.oclIsUndefined()
					then svg.size.width.toString()
					else '100%'
				endif),
			children <- thisModule.Attribute('height',
				if not svg.size.oclIsUndefined()
					then svg.size.height.toString()
					else '100%'
				endif),
			children <- svg.children
		),
		xmlns : XML!Attribute (
			name <- 'xmlns',
			value <- svg.namespace
		),
		version : XML!Attribute (
			name <- 'version',
			value <- svg.version
		)
	do {
		if (not svg.viewBox.oclIsUndefined()) {
			root.children <- thisModule.Attribute('viewBox', svg.viewBox);
		}
	}
}	
--@end rule Svg

--@begin rule G
rule G {
	from
		g : SVG!G
	using {
		transforms : Sequence(SVG!Transform) =
			g.attribute->select(a|a.oclIsKindOf(SVG!Transform));
		transformValue : String =
			transforms->iterate(transf; str : String = ''|
				str +
				if transf.oclIsTypeOf(SVG!Scale)
					then transf.scale()
					else if transf.oclIsTypeOf(SVG!Translate)
						then transf.translate()
						else if transf.oclIsTypeOf(SVG!Rotate)
							then transf.rotate()
							else ''
						endif
					endif
				endif +
				if (transf <> transforms->last())
					then ' '
					else ''
				endif);
	}
	to
		elmt : XML!Element (
			name <- 'g',
			children <- g.groupContent
		)
	do {
		if (not g.fill.oclIsUndefined()) {
			if (g.fill <> 'black') {
				elmt.children <- thisModule.Attribute('fill', g.fill);
			}
		}
		if (transforms->notEmpty()) {
			if (transformValue <> '') {
				elmt.children <- thisModule.Attribute('transform',
					transformValue);
			}
		}
	}
}	
--@end rule G

--@begin rule Rect
rule Rect {
	from
		rect : SVG!Rect
	to
		elmt : XML!Element (
			name <- 'rect',
			children <- thisModule.Attribute('width',
				if not rect.size.oclIsUndefined()
					then rect.size.width.toString()
					else '100%'
				endif),
			children <- thisModule.Attribute('height',
				if not rect.size.oclIsUndefined()
					then rect.size.height.toString()
					else '100%'
				endif)
		)
	do {
		if (not rect.position.oclIsUndefined()) {
			if (rect.position.x.notNull()) {
				elmt.children <- thisModule.Attribute('x',
					rect.position.x.toString());
			}
		}
		if (not rect.position.oclIsUndefined()) {
			if (rect.position.y.notNull()) {
				elmt.children <- thisModule.Attribute('y',
					rect.position.y.toString());
			}
		}
		if (not rect.fill.oclIsUndefined()) {
			if (rect.fill <> 'black') {
				elmt.children <- thisModule.Attribute('fill', rect.fill);
			}
		}
		if (not rect.stroke.oclIsUndefined()) {
			if (rect.stroke <> 'none') {
				elmt.children <- thisModule.Attribute('stroke', rect.stroke);
			}
		}
	}
}	
--@end rule Rect

--@begin rule Circle
rule Circle {
	from
		circ : SVG!Circle
	to
		elmt : XML!Element (
			name <- 'circle',
			children <- thisModule.Attribute('r',
				if not circ.size.oclIsUndefined()
					then circ.size.width.toString()
					else '0'
				endif)
		)
	do {
		if (not circ.position.oclIsUndefined()) {
			if (circ.position.x.notNull()) {
				elmt.children <- thisModule.Attribute('x',
					circ.position.x.toString());
			}
		}
		if (not circ.position.oclIsUndefined()) {
			if (circ.position.y.notNull()) {
				elmt.children <- thisModule.Attribute('y',
					circ.position.y.toString());
			}
		}
		if (not circ.fill.oclIsUndefined()) {
			if (circ.fill <> 'black') {
				elmt.children <- thisModule.Attribute('fill', circ.fill);
			}
		}
		if (not circ.stroke.oclIsUndefined()) {
			if (circ.stroke <> 'none') {
				elmt.children <- thisModule.Attribute('stroke', circ.stroke);
			}
		}
	}
}	
--@end rule Circle

--@begin rule Path
rule Path {
	from
		path : SVG!Path
	to
		elmt : XML!Element (
			name <- 'path',
			children <- thisModule.Attribute('d', path.d)
		)
	do {
		if (not path.fill.oclIsUndefined()) {
			if (path.fill <> 'black') {
				elmt.children <- thisModule.Attribute('fill', path.fill);
			}
		}
		if (not path.stroke.oclIsUndefined()) {
			if (path.stroke <> 'none') {
				elmt.children <- thisModule.Attribute('stroke', path.stroke);
			}
		}
	}
}	
--@end rule Path

--@begin rule Text
rule Text {
	from
		text : SVG!Text
	to
		elmt : XML!Element (
			name <- 'text',
			children <- txt
		),
		txt : XML!Text (
			value <- text.content
		)
	do {
		if (not text.position.oclIsUndefined()) {
			if (text.position.x.notNull()) {
				elmt.children <- thisModule.Attribute('x',
					text.position.x.toString());
			}
		}
		if (not text.position.oclIsUndefined()) {
			if (text.position.y.notNull()) {
				elmt.children <- thisModule.Attribute('y',
					text.position.y.toString());
			}
		}
		if (not text.stroke.oclIsUndefined()) {
			if (text.stroke <> 'none') {
				elmt.children <- thisModule.Attribute('stroke', text.stroke);
			}
		}
		if (not text.fontSize.oclIsUndefined()) {
			if (text.fontSize <> 'medium') {
				elmt.children <- thisModule.Attribute('font-size',
					text.fontSize);
			}
		}
		--@comments text-anchor value stored in lengthAdjust attribute
		if (not text.lengthAdjust.oclIsUndefined()) {
			if (text.lengthAdjust <> 'start') {
				elmt.children <- thisModule.Attribute('text-anchor',
					text.lengthAdjust);
			}
		}
	}
}	
--@end rule Text

--@begin called rule Attribute
rule Attribute(attrName : String, attrValue : String) {
	to
		attr : XML!Attribute (
			name <- attrName,
			value <- attrValue
		)
	do {
		attr;
	}
}	
--@end called rule Attribute",atlcompil atl name svg xml version domain svg extractor author eric vepa evepa sodius com sodius www sodius com date descript svg extractor subset svg metamodel modul svg xml modul templat creat out xml in svg begin helper notnul comment return true valu null helper context real def notnul boolean self self end helper notnul begin helper scale comment return string valu scale transform attribut helper context svg scale def scale string self sx self sx els scale self sx tostr self sy self sx els self sy tostr endif endif end helper scale begin helper translat comment return string valu translat transform attribut helper context svg translat def translat string self tx notnul self ty notnul translat self tx tostr self ty tostr els endif end helper translat begin helper rotat comment return string valu rotat transform attribut helper context svg rotat def rotat string self angl notnul rotat self angl tostr els endif end helper rotat begin rule svg rule svg svg svg svg root xml root name svg children xmlns children version children thismodul attribut width svg size oclisundefin svg size width tostr els endif children thismodul attribut height svg size oclisundefin svg size height tostr els endif children svg children xmlns xml attribut name xmlns valu svg namespac version xml attribut name version valu svg version svg viewbox oclisundefin root children thismodul attribut viewbox svg viewbox end rule svg begin rule g rule g g svg g use transform sequenc svg transform g attribut select ocliskindof svg transform transformvalu string transform iter transf str string str transf oclistypeof svg scale transf scale els transf oclistypeof svg translat transf translat els transf oclistypeof svg rotat transf rotat els endif endif endif transf transform last els endif elmt xml element name g children g groupcont g fill oclisundefin g fill black elmt children thismodul attribut fill g fill transform notempti transformvalu elmt children thismodul attribut transform transformvalu end rule g begin rule rect rule rect rect svg rect elmt xml element name rect children thismodul attribut width rect size oclisundefin rect size width tostr els endif children thismodul attribut height rect size oclisundefin rect size height tostr els endif rect posit oclisundefin rect posit x notnul elmt children thismodul attribut x rect posit x tostr rect posit oclisundefin rect posit notnul elmt children thismodul attribut rect posit tostr rect fill oclisundefin rect fill black elmt children thismodul attribut fill rect fill rect stroke oclisundefin rect stroke none elmt children thismodul attribut stroke rect stroke end rule rect begin rule circl rule circl circ svg circl elmt xml element name circl children thismodul attribut r circ size oclisundefin circ size width tostr els endif circ posit oclisundefin circ posit x notnul elmt children thismodul attribut x circ posit x tostr circ posit oclisundefin circ posit notnul elmt children thismodul attribut circ posit tostr circ fill oclisundefin circ fill black elmt children thismodul attribut fill circ fill circ stroke oclisundefin circ stroke none elmt children thismodul attribut stroke circ stroke end rule circl begin rule path rule path path svg path elmt xml element name path children thismodul attribut path path fill oclisundefin path fill black elmt children thismodul attribut fill path fill path stroke oclisundefin path stroke none elmt children thismodul attribut stroke path stroke end rule path begin rule text rule text text svg text elmt xml element name text children txt txt xml text valu text content text posit oclisundefin text posit x notnul elmt children thismodul attribut x text posit x tostr text posit oclisundefin text posit notnul elmt children thismodul attribut text posit tostr text stroke oclisundefin text stroke none elmt children thismodul attribut stroke text stroke text fontsiz oclisundefin text fontsiz medium elmt children thismodul attribut font size text fontsiz comment text anchor valu store lengthadjust attribut text lengthadjust oclisundefin text lengthadjust start elmt children thismodul attribut text anchor text lengthadjust end rule text begin call rule attribut rule attribut attrnam string attrvalu string attr xml attribut name attrnam valu attrvalu attr end call rule attribut,9
191,191,P82-Table2SVGBarChart.atl,"--@atlcompiler	atl2006
--@name			Table2SVGBarChart
--@version		2.0
--@domains		Table, SVG, bar chart
--@authors		Eric Vepa (evepa <at> sodius.com) for SODIUS (www.sodius.com)
--@date			2007/08/28
--@description	This transformation is used to transform generic tables into SVG bar charts. A bar chart is produced for a table with values (excluding the header row and the first cell of each other row).

module Table2SVGBarChart; -- Module Template
create OUT : SVG from IN : Table;

uses TableHelpers;

--@comments ===================================
--@comments Values used for the SVG rendering =
--@comments ===================================

--@begin attribute helper scale
--@comments The 'scale' value used in the SVG document.
helper def : scale : Real = 1;
--@end attribute helper scale

--@begin attribute helper barPattern
--@comments The 'fill' value used by bar in the SVG document.
helper def : barPattern : String = 'grey';
--@end attribute helper barPattern

--@begin attribute helper barMaxWidth
--@comments Returns the max width of a bar of the chart.
helper def : barMaxWidth : Real = 150 * thisModule.scale;
--@end attribute helper barWidth

--@begin attribute helper fill
--@comments The 'fill' value used in the SVG document.
helper def : fill : String = 'none';
--@end attribute helper fill

--@begin attribute helper stroke
--@comments The 'stroke' value used in the SVG document.
helper def : stroke : String = 'black';
--@end attribute helper stroke

--@begin attribute helper margin
--@comments The margin value used in the SVG document between charts.
helper def : margin : Real = 10;
--@end attribute helper margin

--@begin attribute helper titleFontSize
--@comments The 'fontSize' value used for titles in the SVG document.
helper def : titleFontSize : Real =  thisModule.barMaxWidth * 0.1;
--@end attribute helper titleFontSize

--@begin attribute helper fontSize
--@comments The 'fontSize' value used in the SVG document.
helper def : fontSize : Real = thisModule.titleFontSize * 0.85;
--@end attribute helper fontSize

--@begin attribute helper barHeight
--@comments Returns height of a bar of the chart.
helper def : barHeight : Real = thisModule.fontSize;
--@end attribute helper barHeight

--@begin attribute helper svgFile
--@comments The unique SVG file element.
helper def : svgFile : SVG!SvgFile = OclUndefined;
--@end attribute helper svgFile


--@comments ===============================
--@comments Helpers for the SVG rendering =
--@comments ===============================

--@begin helper maxSizeName
--@comments Returns the maximal size for a name of a table.
helper context Table!Table
def : maxSizeName() : Real =
	(self.rows.seqWithoutFirst()->iterate(r; maxSize : Integer = 0|
		if r.cells->first().content->size() > maxSize
			then r.cells->first().content->size()
			else maxSize
		endif) + 7) * (thisModule.fontSize / 2);
--@end helper maxSizeName

--@begin helper boundingBoxWidth
--@comments Returns the width of the bouding box computed for a table.
helper context Table!Table
def : boundingBoxWidth() : Real =
	self.maxSizeName() + thisModule.barMaxWidth +
		thisModule.barHeight + 3 * thisModule.margin;
--@end helper boundingBoxWidth

--@begin helper boundingBoxHeight
--@comments Returns the height of the bouding box computed for a table.
helper context Table!Table
def : boundingBoxHeight() : Real =
	(self.rows->size() - 1) * thisModule.barHeight +
		2 * thisModule.margin +	2 * thisModule.titleFontSize;
--@end helper boundingBoxHeight

--@begin attribute helper prevWidth
--@comments The previous width of all the charts generated.
helper def : prevWidth : Real = 0;
--@end attribute helper prevWidth

--@begin helper scaleFactor
--@comments The scale factor for adjusting bar width for the column which index is given.
helper context Table!Table
def : scaleFactor(idx : Integer) : Real =	
	let max : Real =
		self.rows->seqWithoutFirst()->
			iterate(r; max : Real = 0|
				let value : Real =
					r.cells->at(idx).realValue() in
				value->max(max)) in
	if max = 0
		then 1
		else thisModule.barMaxWidth / max
	endif;
--@end helper scaleFactor

--@begin entrypoint rule SvgFile
--@comments Creates the SVG file with one svg tag.
entrypoint rule SvgFile() {
	using {
		width : Real =
			thisModule.allValidTables->iterate(table; sum : Integer = 0|
				sum + (table.boundingBoxWidth() +
					thisModule.margin) *
						(table.rows->first().cells->size() - 1)) +
							thisModule.margin;
		height : Real =
			thisModule.allValidTables->iterate(table; max : Integer = 0|
				table.boundingBoxHeight()->max(max)) +
					2 * thisModule.titleFontSize;
	}
	to
		svgFile : SVG!SvgFile (
			tag <- svg
		),
		svg : SVG!Svg (
			size <- svgSize,
			namespace <- 'http://www.w3.org/2000/svg',
			version <- '1.1'
		),
		svgSize : SVG!Dimension (
			width <- width,
			height <- height
		)
	do {					
		if (thisModule.allValidTables->size() > 0) {
			thisModule.svgFile <- svgFile;
			thisModule.svgFile.tag.viewBox <- '0 0 ' +
				width.toString() + ' ' + height.toString();			
					
			for (table in thisModule.allValidTables) {
				for (cell in table.rows->first().cells->seqWithoutFirst()) {
					thisModule.Table2BarChart(table,
						table.rows->first().cells->indexOf(cell));
				}
			}
		}
	}
}
--@end entrypoint rule SvgFile

--@begin lazy rule Table2BarChart
--@comments Creates a bar chart (SVG group) for the metric which column index is given.
lazy rule Table2BarChart {
	from
		table : Table!Table,
		idx : Integer
	to
		g : SVG!G (
			attribute <- boundingBoxTransl,
			groupContent <- boundingBox,
			groupContent <- textTitle,
			groupContent <- axis,
			groupContent <- table.rows->seqWithoutFirst()->
				iterate(row; acc : Sequence(SVG!G) = Sequence{}|
					acc->including(thisModule.Row2Bar(row,
						table.rows->indexOf(row),idx,table.scaleFactor(idx))))
		),
		boundingBox : SVG!Rect (
			size <- boundingBoxSize,
			position <- boundingBoxCoord,
			fill <- thisModule.fill,
			stroke <- thisModule.stroke
		),
		boundingBoxSize : SVG!Dimension (
			width <- table.boundingBoxWidth(),
			height <- table.boundingBoxHeight()
		),
		boundingBoxCoord : SVG!AbsoluteCoord (
			x <- 0 - table.maxSizeName() - 2 * thisModule.margin,
			y <- 0 - thisModule.margin
		),
		boundingBoxTransl : SVG!Translate (
			tx <- thisModule.prevWidth + 3 * thisModule.margin +
				table.maxSizeName(),
			ty <- 2 * thisModule.margin
		),
		textTitle : SVG!Text (
			position <- textTitleCoord,
			stroke <- thisModule.stroke,
			fontSize <- thisModule.titleFontSize.toString(),
			--@comments text-anchor value strored in lengthAdjust attribute
			lengthAdjust <- 'middle',
			content <- table.rows->first().cells->at(idx).content
		),
		textTitleCoord : SVG!AbsoluteCoord (
			x <- boundingBoxSize.width / 2 - table.maxSizeName(),
			y <- boundingBoxSize.height - 2 * thisModule.margin
		),
		axis : SVG!Path (
			d <- 'M' + (thisModule.barMaxWidth +
				thisModule.barHeight).toString() + ',0 H0 V' +
					(table.rows->size() *
						thisModule.barHeight).toString() + ',0 z',
			fill <- thisModule.fill,
			stroke <- thisModule.stroke
		)	
	do {
		thisModule.prevWidth <- thisModule.prevWidth +
			thisModule.margin +	boundingBoxSize.width;
		thisModule.svgFile.tag.children <- g;
	}
}
--@end lazy rule Table2BarChart

--@begin lazy rule Row2Bar
--@comments Creates a bar (SVG line) for the cell at index given and with a scale factor.
lazy rule Row2Bar {
	from
		row : Table!Row,
		rowIdx : Integer,
		cellIdx : Integer,
		scaleFactor : Real
	to
		g : SVG!G (
			groupContent <- bar,
			groupContent <- textCaption
		),
		bar : SVG!Rect (
			size <- barSize,
			position <- barCoord,
			fill <- thisModule.barPattern,
			stroke <- thisModule.stroke
		),
		barSize : SVG!Dimension (
			width <- row.cells->at(cellIdx).realValue() * scaleFactor,
			height <- thisModule.barHeight
		),
		barCoord : SVG!AbsoluteCoord (
			x <- 0,
			y <- (rowIdx - 2) * barSize.height 
		),
		textCaption : SVG!Text (
			position <- textCaptionCoord,
			stroke <- thisModule.stroke,
			fontSize <- thisModule.fontSize.toString(),
			--@comments text-anchor value strored in lengthAdjust attribute
			lengthAdjust <- 'end',
			content <- row.cells->first().content +
				' (' +	row.cells->at(cellIdx).value() + ')'
		),
		textCaptionCoord : SVG!AbsoluteCoord (
			x <- 0 - thisModule.margin,
			y <- barCoord.y + barSize.height
		)
}
--@end lazy rule Row2Bar",atlcompil atl name tabl svgbarchart version domain tabl svg bar chart author eric vepa evepa sodius com sodius www sodius com date descript this transform use transform generic tabl svg bar chart a bar chart produc tabl valu exclud header row first cell row modul tabl svgbarchart modul templat creat out svg in tabl use tablehelp comment comment valu use svg render comment begin attribut helper scale comment the scale valu use svg document helper def scale real end attribut helper scale begin attribut helper barpattern comment the fill valu use bar svg document helper def barpattern string grey end attribut helper barpattern begin attribut helper barmaxwidth comment return max width bar chart helper def barmaxwidth real thismodul scale end attribut helper barwidth begin attribut helper fill comment the fill valu use svg document helper def fill string none end attribut helper fill begin attribut helper stroke comment the stroke valu use svg document helper def stroke string black end attribut helper stroke begin attribut helper margin comment the margin valu use svg document chart helper def margin real end attribut helper margin begin attribut helper titlefonts comment the fontsiz valu use titl svg document helper def titlefonts real thismodul barmaxwidth end attribut helper titlefonts begin attribut helper fontsiz comment the fontsiz valu use svg document helper def fontsiz real thismodul titlefonts end attribut helper fontsiz begin attribut helper barheight comment return height bar chart helper def barheight real thismodul fontsiz end attribut helper barheight begin attribut helper svgfile comment the uniqu svg file element helper def svgfile svg svgfile oclundefin end attribut helper svgfile comment comment helper svg render comment begin helper maxsizenam comment return maxim size name tabl helper context tabl tabl def maxsizenam real self row seqwithoutfirst iter r maxsiz integ r cell first content size maxsiz r cell first content size els maxsiz endif thismodul fontsiz end helper maxsizenam begin helper boundingboxwidth comment return width boud box comput tabl helper context tabl tabl def boundingboxwidth real self maxsizenam thismodul barmaxwidth thismodul barheight thismodul margin end helper boundingboxwidth begin helper boundingboxheight comment return height boud box comput tabl helper context tabl tabl def boundingboxheight real self row size thismodul barheight thismodul margin thismodul titlefonts end helper boundingboxheight begin attribut helper prevwidth comment the previous width chart generat helper def prevwidth real end attribut helper prevwidth begin helper scalefactor comment the scale factor adjust bar width column index given helper context tabl tabl def scalefactor idx integ real let max real self row seqwithoutfirst iter r max real let valu real r cell idx realvalu valu max max max els thismodul barmaxwidth max endif end helper scalefactor begin entrypoint rule svgfile comment creat svg file one svg tag entrypoint rule svgfile use width real thismodul allvalidt iter tabl sum integ sum tabl boundingboxwidth thismodul margin tabl row first cell size thismodul margin height real thismodul allvalidt iter tabl max integ tabl boundingboxheight max max thismodul titlefonts svgfile svg svgfile tag svg svg svg svg size svgsize namespac http www w org svg version svgsize svg dimens width width height height thismodul allvalidt size thismodul svgfile svgfile thismodul svgfile tag viewbox width tostr height tostr tabl thismodul allvalidt cell tabl row first cell seqwithoutfirst thismodul tabl barchart tabl tabl row first cell indexof cell end entrypoint rule svgfile begin lazi rule tabl barchart comment creat bar chart svg group metric column index given lazi rule tabl barchart tabl tabl tabl idx integ g svg g attribut boundingboxtransl groupcont boundingbox groupcont texttitl groupcont axi groupcont tabl row seqwithoutfirst iter row acc sequenc svg g sequenc acc includ thismodul row bar row tabl row indexof row idx tabl scalefactor idx boundingbox svg rect size boundingboxs posit boundingboxcoord fill thismodul fill stroke thismodul stroke boundingboxs svg dimens width tabl boundingboxwidth height tabl boundingboxheight boundingboxcoord svg absolutecoord x tabl maxsizenam thismodul margin thismodul margin boundingboxtransl svg translat tx thismodul prevwidth thismodul margin tabl maxsizenam ty thismodul margin texttitl svg text posit texttitlecoord stroke thismodul stroke fontsiz thismodul titlefonts tostr comment text anchor valu strore lengthadjust attribut lengthadjust middl content tabl row first cell idx content texttitlecoord svg absolutecoord x boundingboxs width tabl maxsizenam boundingboxs height thismodul margin axi svg path m thismodul barmaxwidth thismodul barheight tostr h v tabl row size thismodul barheight tostr z fill thismodul fill stroke thismodul stroke thismodul prevwidth thismodul prevwidth thismodul margin boundingboxs width thismodul svgfile tag children g end lazi rule tabl barchart begin lazi rule row bar comment creat bar svg line cell index given scale factor lazi rule row bar row tabl row rowidx integ cellidx integ scalefactor real g svg g groupcont bar groupcont textcapt bar svg rect size barsiz posit barcoord fill thismodul barpattern stroke thismodul stroke barsiz svg dimens width row cell cellidx realvalu scalefactor height thismodul barheight barcoord svg absolutecoord x rowidx barsiz height textcapt svg text posit textcaptioncoord stroke thismodul stroke fontsiz thismodul fontsiz tostr comment text anchor valu strore lengthadjust attribut lengthadjust end content row cell first content row cell cellidx valu textcaptioncoord svg absolutecoord x thismodul margin barcoord barsiz height end lazi rule row bar,2
192,192,P83-SVG2XML.atl,"--@atlcompiler	atl2006
--@name			SVG2XML
--@version		2.0
--@domains		SVG, extractor
--@authors		Eric Vepa (evepa <at> sodius.com) for SODIUS (www.sodius.com)
--@date			2007/05/28
--@description	SVG extractor for a subset of the SVG metamodel.

module SVG2XML; -- Module Template
create OUT : XML from IN : SVG;

--@begin helper notNull
--@comments Returns true if the value is not null (0 or 0.0).
helper context Real
def : notNull() : Boolean =
	self <> 0 and self <> 0.0;
--@end helper notNull

--@begin helper scale
--@comments Returns the string value for a scale transformation attribute.
helper context SVG!Scale
def : scale() : String =
	if (self.sx = 1 or self.sx = 1.0)
		then ''
		else 'scale(' + self.sx.toString() +
			if self.sy = self.sx
				then ''
				else ',' + self.sy.toString()
			endif + ')'
	endif;
--@end helper scale

--@begin helper translate
--@comments Returns the string value for a translate transformation attribute.
helper context SVG!Translate
def : translate() : String =
	if self.tx.notNull() or self.ty.notNull()
		then 'translate(' + self.tx.toString() + ',' + self.ty.toString() + ')'
		else ''
	endif;
--@end helper translate

--@begin helper rotate
--@comments Returns the string value for a rotate transformation attribute.
helper context SVG!Rotate
def : rotate() : String =
	if self.angle.notNull()
		then 'rotate(' + self.angle.toString() + ')'
		else ''
	endif;
--@end helper rotate

--@begin rule Svg
rule Svg {
	from
		svg : SVG!Svg
	to
		root : XML!Root (
			name <- 'svg',
			children <- xmlns,
			children <- version,
			children <- thisModule.Attribute('width',
				if not svg.size.oclIsUndefined()
					then svg.size.width.toString()
					else '100%'
				endif),
			children <- thisModule.Attribute('height',
				if not svg.size.oclIsUndefined()
					then svg.size.height.toString()
					else '100%'
				endif),
			children <- svg.children
		),
		xmlns : XML!Attribute (
			name <- 'xmlns',
			value <- svg.namespace
		),
		version : XML!Attribute (
			name <- 'version',
			value <- svg.version
		)
	do {
		if (not svg.viewBox.oclIsUndefined()) {
			root.children <- thisModule.Attribute('viewBox', svg.viewBox);
		}
	}
}	
--@end rule Svg

--@begin rule G
rule G {
	from
		g : SVG!G
	using {
		transforms : Sequence(SVG!Transform) =
			g.attribute->select(a|a.oclIsKindOf(SVG!Transform));
		transformValue : String =
			transforms->iterate(transf; str : String = ''|
				str +
				if transf.oclIsTypeOf(SVG!Scale)
					then transf.scale()
					else if transf.oclIsTypeOf(SVG!Translate)
						then transf.translate()
						else if transf.oclIsTypeOf(SVG!Rotate)
							then transf.rotate()
							else ''
						endif
					endif
				endif +
				if (transf <> transforms->last())
					then ' '
					else ''
				endif);
	}
	to
		elmt : XML!Element (
			name <- 'g',
			children <- g.groupContent
		)
	do {
		if (not g.fill.oclIsUndefined()) {
			if (g.fill <> 'black') {
				elmt.children <- thisModule.Attribute('fill', g.fill);
			}
		}
		if (transforms->notEmpty()) {
			if (transformValue <> '') {
				elmt.children <- thisModule.Attribute('transform',
					transformValue);
			}
		}
	}
}	
--@end rule G

--@begin rule Rect
rule Rect {
	from
		rect : SVG!Rect
	to
		elmt : XML!Element (
			name <- 'rect',
			children <- thisModule.Attribute('width',
				if not rect.size.oclIsUndefined()
					then rect.size.width.toString()
					else '100%'
				endif),
			children <- thisModule.Attribute('height',
				if not rect.size.oclIsUndefined()
					then rect.size.height.toString()
					else '100%'
				endif)
		)
	do {
		if (not rect.position.oclIsUndefined()) {
			if (rect.position.x.notNull()) {
				elmt.children <- thisModule.Attribute('x',
					rect.position.x.toString());
			}
		}
		if (not rect.position.oclIsUndefined()) {
			if (rect.position.y.notNull()) {
				elmt.children <- thisModule.Attribute('y',
					rect.position.y.toString());
			}
		}
		if (not rect.fill.oclIsUndefined()) {
			if (rect.fill <> 'black') {
				elmt.children <- thisModule.Attribute('fill', rect.fill);
			}
		}
		if (not rect.stroke.oclIsUndefined()) {
			if (rect.stroke <> 'none') {
				elmt.children <- thisModule.Attribute('stroke', rect.stroke);
			}
		}
	}
}	
--@end rule Rect

--@begin rule Circle
rule Circle {
	from
		circ : SVG!Circle
	to
		elmt : XML!Element (
			name <- 'circle',
			children <- thisModule.Attribute('r',
				if not circ.size.oclIsUndefined()
					then circ.size.width.toString()
					else '0'
				endif)
		)
	do {
		if (not circ.position.oclIsUndefined()) {
			if (circ.position.x.notNull()) {
				elmt.children <- thisModule.Attribute('x',
					circ.position.x.toString());
			}
		}
		if (not circ.position.oclIsUndefined()) {
			if (circ.position.y.notNull()) {
				elmt.children <- thisModule.Attribute('y',
					circ.position.y.toString());
			}
		}
		if (not circ.fill.oclIsUndefined()) {
			if (circ.fill <> 'black') {
				elmt.children <- thisModule.Attribute('fill', circ.fill);
			}
		}
		if (not circ.stroke.oclIsUndefined()) {
			if (circ.stroke <> 'none') {
				elmt.children <- thisModule.Attribute('stroke', circ.stroke);
			}
		}
	}
}	
--@end rule Circle

--@begin rule Path
rule Path {
	from
		path : SVG!Path
	to
		elmt : XML!Element (
			name <- 'path',
			children <- thisModule.Attribute('d', path.d)
		)
	do {
		if (not path.fill.oclIsUndefined()) {
			if (path.fill <> 'black') {
				elmt.children <- thisModule.Attribute('fill', path.fill);
			}
		}
		if (not path.stroke.oclIsUndefined()) {
			if (path.stroke <> 'none') {
				elmt.children <- thisModule.Attribute('stroke', path.stroke);
			}
		}
	}
}	
--@end rule Path

--@begin rule Text
rule Text {
	from
		text : SVG!Text
	to
		elmt : XML!Element (
			name <- 'text',
			children <- txt
		),
		txt : XML!Text (
			value <- text.content
		)
	do {
		if (not text.position.oclIsUndefined()) {
			if (text.position.x.notNull()) {
				elmt.children <- thisModule.Attribute('x',
					text.position.x.toString());
			}
		}
		if (not text.position.oclIsUndefined()) {
			if (text.position.y.notNull()) {
				elmt.children <- thisModule.Attribute('y',
					text.position.y.toString());
			}
		}
		if (not text.stroke.oclIsUndefined()) {
			if (text.stroke <> 'none') {
				elmt.children <- thisModule.Attribute('stroke', text.stroke);
			}
		}
		if (not text.fontSize.oclIsUndefined()) {
			if (text.fontSize <> 'medium') {
				elmt.children <- thisModule.Attribute('font-size',
					text.fontSize);
			}
		}
		--@comments text-anchor value stored in lengthAdjust attribute
		if (not text.lengthAdjust.oclIsUndefined()) {
			if (text.lengthAdjust <> 'start') {
				elmt.children <- thisModule.Attribute('text-anchor',
					text.lengthAdjust);
			}
		}
	}
}	
--@end rule Text

--@begin called rule Attribute
rule Attribute(attrName : String, attrValue : String) {
	to
		attr : XML!Attribute (
			name <- attrName,
			value <- attrValue
		)
	do {
		attr;
	}
}	
--@end called rule Attribute",atlcompil atl name svg xml version domain svg extractor author eric vepa evepa sodius com sodius www sodius com date descript svg extractor subset svg metamodel modul svg xml modul templat creat out xml in svg begin helper notnul comment return true valu null helper context real def notnul boolean self self end helper notnul begin helper scale comment return string valu scale transform attribut helper context svg scale def scale string self sx self sx els scale self sx tostr self sy self sx els self sy tostr endif endif end helper scale begin helper translat comment return string valu translat transform attribut helper context svg translat def translat string self tx notnul self ty notnul translat self tx tostr self ty tostr els endif end helper translat begin helper rotat comment return string valu rotat transform attribut helper context svg rotat def rotat string self angl notnul rotat self angl tostr els endif end helper rotat begin rule svg rule svg svg svg svg root xml root name svg children xmlns children version children thismodul attribut width svg size oclisundefin svg size width tostr els endif children thismodul attribut height svg size oclisundefin svg size height tostr els endif children svg children xmlns xml attribut name xmlns valu svg namespac version xml attribut name version valu svg version svg viewbox oclisundefin root children thismodul attribut viewbox svg viewbox end rule svg begin rule g rule g g svg g use transform sequenc svg transform g attribut select ocliskindof svg transform transformvalu string transform iter transf str string str transf oclistypeof svg scale transf scale els transf oclistypeof svg translat transf translat els transf oclistypeof svg rotat transf rotat els endif endif endif transf transform last els endif elmt xml element name g children g groupcont g fill oclisundefin g fill black elmt children thismodul attribut fill g fill transform notempti transformvalu elmt children thismodul attribut transform transformvalu end rule g begin rule rect rule rect rect svg rect elmt xml element name rect children thismodul attribut width rect size oclisundefin rect size width tostr els endif children thismodul attribut height rect size oclisundefin rect size height tostr els endif rect posit oclisundefin rect posit x notnul elmt children thismodul attribut x rect posit x tostr rect posit oclisundefin rect posit notnul elmt children thismodul attribut rect posit tostr rect fill oclisundefin rect fill black elmt children thismodul attribut fill rect fill rect stroke oclisundefin rect stroke none elmt children thismodul attribut stroke rect stroke end rule rect begin rule circl rule circl circ svg circl elmt xml element name circl children thismodul attribut r circ size oclisundefin circ size width tostr els endif circ posit oclisundefin circ posit x notnul elmt children thismodul attribut x circ posit x tostr circ posit oclisundefin circ posit notnul elmt children thismodul attribut circ posit tostr circ fill oclisundefin circ fill black elmt children thismodul attribut fill circ fill circ stroke oclisundefin circ stroke none elmt children thismodul attribut stroke circ stroke end rule circl begin rule path rule path path svg path elmt xml element name path children thismodul attribut path path fill oclisundefin path fill black elmt children thismodul attribut fill path fill path stroke oclisundefin path stroke none elmt children thismodul attribut stroke path stroke end rule path begin rule text rule text text svg text elmt xml element name text children txt txt xml text valu text content text posit oclisundefin text posit x notnul elmt children thismodul attribut x text posit x tostr text posit oclisundefin text posit notnul elmt children thismodul attribut text posit tostr text stroke oclisundefin text stroke none elmt children thismodul attribut stroke text stroke text fontsiz oclisundefin text fontsiz medium elmt children thismodul attribut font size text fontsiz comment text anchor valu store lengthadjust attribut text lengthadjust oclisundefin text lengthadjust start elmt children thismodul attribut text anchor text lengthadjust end rule text begin call rule attribut rule attribut attrnam string attrvalu string attr xml attribut name attrnam valu attrvalu attr end call rule attribut,9
193,193,P83-Table2SVGPieChart.atl,"--@atlcompiler	atl2006
--@name			Table2SVGPieChart
--@version		2.1
--@domains		Table, SVG, pie chart
--@authors		Eric Vepa (evepa <at> sodius.com) for SODIUS (www.sodius.com)
--@date			2007/08/28
--@description	This transformation is used to transform generic tables into SVG pie charts. A pie chart is produced for a table with values (excluding the header row and the first cell of each other row, and at least 3 columns).
--@see			Scalable Vector Graphics 1.1, World Wide Web Consortium, http://www.w3.org/TR/SVG11/

module Table2SVGPieChart; -- Module Template
create OUT : SVG from IN : Table;

uses TableHelpers;

--@comments ===================================
--@comments Values used for the SVG rendering =
--@comments ===================================

--@begin attribute helper scale
--@comments The 'scale' value used in the SVG document.
helper def : scale : Real = 1;
--@end attribute helper scale

--@begin attribute helper radius
--@comments The radius value used in the SVG document for a pie chart.
helper def : radius : Real = 100 * thisModule.scale;
--@end attribute helper radius

--@begin attribute helper fill
--@comments The 'fill' value used in the SVG document.
helper def : fill : String = 'none';
--@end attribute helper fill

--@begin attribute helper stroke
--@comments The 'stroke' value used in the SVG document.
helper def : stroke : String = 'black';
--@end attribute helper stroke

--@begin attribute helper margin
--@comments The margin value used in the SVG document between charts.
helper def : margin : Real = 10;
--@end attribute helper margin

--@begin attribute helper titleFontSize
--@comments The 'fontSize' value used for titles in the SVG document.
helper def : titleFontSize : Real = thisModule.radius * 0.2;
--@end attribute helper titleFontSize

--@begin attribute helper fontSize
--@comments The 'fontSize' value used in the SVG document.
helper def : fontSize : Real = thisModule.titleFontSize * 0.8;
--@end attribute helper fontSize

--@begin attribute helper caption
--@comments The value used in the SVG document the caption of one sector.
helper def : caption : Real = thisModule.fontSize;
--@end attribute helper caption

--@begin attribute helper svgFile
--@comments The unique SVG file element.
helper def : svgFile : SVG!SvgFile = OclUndefined;
--@end attribute helper svgFile


--@comments ===============================
--@comments Helpers for the SVG rendering =
--@comments ===============================

--@begin helper maxSizeName
--@comments Returns the maximal size for a name of the cells of the header row (adds 7 characters for the display of the value).
helper context Table!Table
def : maxSizeName() : Real =
	(self.rows.seqWithoutFirst()->iterate(r; maxSize : Integer = 0|
		if r.cells->first().content->size() > maxSize
			then r.cells->first().content->size()
			else maxSize
		endif) + 7 * 2) * (thisModule.fontSize / 2);
--@end helper maxSizeName

--@begin helper boundingBoxWidth
--@comments Returns the width of the bouding box computed for a table.
helper context Table!Table
def : boundingBoxWidth() : Real =
	self.captionBoxWidth() + 2 * thisModule.radius + 3 * thisModule.margin;
--@end helper boundingBoxWidth

--@begin attribute helper prevAngle
--@comments The previous rotation angle of the last sector generated.
helper def : prevAngle : Real = 0;
--@end attribute helper prevAngle

--@begin attribute helper prevWidth
--@comments The previous width of all the charts generated.
helper def : prevWidth : Real = 0;
--@end attribute helper prevWidth

--@begin helper captionBoxWidth
--@comments Returns the width of the caption box for a table.
helper context Table!Table
def : captionBoxWidth() : Real =
	self.maxSizeName() + thisModule.caption + 3 * thisModule.margin;
--@end helper captionBoxWidth

--@begin helper captionBoxHeight
--@comments Returns the height of the caption box for a table.
helper context Table!Table
def : captionBoxHeight() : Real =
	self.rows->size() * (thisModule.caption + thisModule.margin / 2) -
		thisModule.margin / 2;
--@end helper captionBoxHeight

--@begin helper computeColor
--@comments Computes a RGB color with the number of the element and the total number of colors to compute.
helper def : computeColor(idx : Integer, nbColor : Integer) : String =
	let value : Integer =
		(idx * 6 * 255 / nbColor).floor() in
	if value < 255
		then 'rgb(255,255,' + (255 - value).toString() + ')'
		else if value < 2 * 255
				then 'rgb(' + (2 * 255 - value).toString() + ',255,0)'
				else if value < 3 * 255
						then 'rgb(0,255,' + (255 - (3 * 255 - value)).toString() + ')'
						else if value < 4 * 255
								then 'rgb(0,' + (4 * 255 - value).toString() + ',255)'
								else if value < 5 * 255
										then 'rgb(' + (255 - (5 * 255 - value)).toString() + ',0,255)'
										else 'rgb(255,0,' + (6 * 255 - value).toString() + ')'
									endif
							endif
					endif
			endif
	endif;
--@end helper computeColor

--@begin helper ColorByElementName
--@comments Color used by sectors and captions of pie charts for each element.
helper def : ColorByElementName : Map(String,String) = Map{};
--@end helper ColorByElementName


--@begin entrypoint rule SvgFile
--@comments Creates the SVG file with one svg tag.
entrypoint rule SvgFile() {
	using {
		width : Real =
			thisModule.allValidTables->iterate(t; sum : Real = 0|
				sum + (t.captionBoxWidth() +
					2 * thisModule.radius + 4 * thisModule.margin) *
						(t.rows->first().cells->size() - 1)) +
							thisModule.margin;
		height : Real =
			let heightWithoutCaption : Real =
				2 * (thisModule.radius + 2 * thisModule.margin +
					thisModule.titleFontSize) in
			let heightWithCaption : Real =
				thisModule.allValidTables->iterate(t; max : Real = 0|
					t.captionBoxHeight()->max(max)) + 4 * thisModule.margin in
			heightWithoutCaption->max(heightWithCaption);
	}
	to
		svgFile : SVG!SvgFile (
			tag <- svg
		),
		svg : SVG!Svg (
			size <- svgSize,
			namespace <- 'http://www.w3.org/2000/svg',
			version <- '1.1'
		),
		svgSize : SVG!Dimension (
			width <- width,
			height <- height
		)
	do {
		if (thisModule.allValidTables->size() > 0) {
			thisModule.svgFile <- svgFile;
			thisModule.svgFile.tag.viewBox <- '0 0 ' +
				width.toString() + ' ' + height.toString();

			for (table in thisModule.allValidTables) {
				for (elmtName in table.rows->seqWithoutFirst()->
					collect(r|r.cells->first().content)->sortedBy(n|n)) {
					thisModule.ColorByElementName <-
						thisModule.ColorByElementName.including(elmtName,
							thisModule.computeColor(table.rows->seqWithoutFirst()->
								collect(r|r.cells->first().content)->
									sortedBy(n|n)->indexOf(elmtName),
										table.rows->seqWithoutFirst()->
											collect(r|r.cells->first().content)->
												sortedBy(n|n)->size()));
				}
				
				for (cell in table.rows->first().cells->seqWithoutFirst()) {
					thisModule.Table2PieChart(table,
						table.rows->first().cells->indexOf(cell));
				}
			}
		}
	}
}
--@end entrypoint rule SvgFile

--@begin lazy rule Table2PieChart
--@comments Creates a pie chart (SVG group) for the metric which column index is given.
lazy rule Table2PieChart {
	from
		table : Table!Table,
		idx : Integer
	using {
		valuesSum : Real =
			table.rows->seqWithoutFirst()->iterate(row; acc : Real = 0|
				acc + row.cells->at(idx).realValue());
	}
	to
		g : SVG!G (
			attribute <- boundingBoxTransl,
			groupContent <- boundingBox,
			groupContent <- textTitle,
			groupContent <-
				if table.rows->seqWithoutFirst()->
					collect(r|r.cells->at(idx))->
						select(c|c.valueNotNull())->size() = 1
					then thisModule.Table2Circle(table,idx)
					else thisModule.Table2Sectors(table,idx,valuesSum)
				endif,
			groupContent <- thisModule.Table2Captions(table,idx,valuesSum)
		),
		boundingBox : SVG!Rect (
			size <- boundingBoxSize,
			position <- boundingBoxCoord,
			fill <- thisModule.fill,
			stroke <- thisModule.stroke
		),
		boundingBoxSize : SVG!Dimension (
			width <- table.boundingBoxWidth(),
			height <- thisModule.svgFile.tag.size.height -
				2 * thisModule.margin
		),
		boundingBoxCoord : SVG!AbsoluteCoord (
			x <- 0 - boundingBoxSize.width / 2,
			y <- 0 - boundingBoxSize.height / 2
		),
		boundingBoxTransl : SVG!Translate (
			tx <- thisModule.prevWidth + boundingBoxSize.width / 2 +
				thisModule.margin,
			ty <- thisModule.svgFile.tag.size.height / 2
		),
		textTitle : SVG!Text (
			position <- textTitleCoord,
			stroke <- thisModule.stroke,
			fontSize <- thisModule.titleFontSize.toString(),
			--@comments text-anchor value strored in lengthAdjust attribute
			lengthAdjust <- 'middle',
			content <- table.rows->first().cells->at(idx).content
		),
		textTitleCoord : SVG!AbsoluteCoord (
			x <- 0 - (table.captionBoxWidth() + thisModule.margin) / 2,
			y <- (boundingBoxSize.height - thisModule.titleFontSize -
				thisModule.margin) / 2
		)
	do {
		thisModule.prevWidth <-
			thisModule.prevWidth + boundingBoxSize.width + thisModule.margin;
		thisModule.svgFile.tag.children <- g;
		--@comments initialise rotation angle
		thisModule.prevAngle <- 0;
	}
}
--@end lazy rule Table2PieChart

--@begin lazy rule Table2Circle
--@comments Creates a complete pie (SVG Circle) for the metric at index given.
lazy rule Table2Circle {
	from
		table : Table!Cell,
		idx : Integer
	to
		g : SVG!G (
			attribute <- pieTransl,
			groupContent <- pie
		),
		pieTransl : SVG!Translate (
			tx <- 0 - (table.captionBoxWidth() + thisModule.margin) / 2,
			ty <- 0 - thisModule.titleFontSize
		),
		pie : SVG!Circle (
			size <- pieSize,
			position <- pieCoord,
			fill <- thisModule.ColorByElementName.get(table.rows->
				seqWithoutFirst()->select(r|r.cells->at(idx).valueNotNull())->
					first().cells->first().content),
			stroke <- thisModule.stroke
		),
		pieSize : SVG!Dimension (
			width <- thisModule.radius,
			height <- pieSize.width
		),
		pieCoord : SVG!AbsoluteCoord (
			x <- 0,
			y <- 0
		)
}
--@end lazy rule Table2Circle

--@begin lazy rule Table2Sectors
--@comments Creates a pie with sectors (SVG paths) for the metric at index given.
lazy rule Table2Sectors {
	from
		table : Table!Table,
		idx : Integer,
		valuesSum : Real
	to
		g : SVG!G (
			attribute <- sectorsTransl,
			groupContent <- table.rows->seqWithoutFirst()->
				collect(row|thisModule.Row2Sector(row,
					table.rows->indexOf(row),idx,valuesSum))
		),
		sectorsTransl : SVG!Translate (
			tx <- 0 - (table.captionBoxWidth() + thisModule.margin) / 2,
			ty <- 0 - thisModule.titleFontSize
		)
}
--@end lazy rule Table2Sectors

--@begin lazy rule Row2Sector
--@comments Creates a sector (SVG path) for the cell at index given.
lazy rule Row2Sector {
	from
		row : Table!Row,
		rowIdx : Integer,
		cellIdx : Integer,
		valuesSum : Real
	using {
		value : Real =
			if valuesSum = 0
				then 0
				else row.cells->at(cellIdx).realValue() / valuesSum * 100
			endif;
		x : Real =
			thisModule.radius * (value * 3.6).toRadians().cos();
		y : Real =
			thisModule.radius * (value * 3.6).toRadians().sin();
	}
	to
		g : SVG!G (
			attribute <- sectorRotate,
			groupContent <- sector
		),
		sectorRotate : SVG!Rotate (
			angle <- thisModule.prevAngle
		),
		sector : SVG!Path (
			d <- 'M0,0 L' + thisModule.radius.toString() + ',0 ' +
				'A' + thisModule.radius.toString() + ',' +
					thisModule.radius.toString() + ' 0 ' +
						if 3.6 * value < 180
							then '0,1 '
							else '1,1 '
						endif +	x.toString() + ',' + y.toString() + ' z',
			fill <- thisModule.ColorByElementName.get(row.cells->
				first().content),
			stroke <- thisModule.stroke
		)
	do {
		--@comments Adds the angle value of the new sector.
		thisModule.prevAngle <- sectorRotate.angle + 3.6 * value;
	}
}
--@end lazy rule Row2Sector

--@begin lazy rule Table2Captions
--@comments Creates captions (SVG rect) for a table.
lazy rule Table2Captions {
	from
		table : Table!Cell,
		idx : Integer,
		valuesSum : Real
	to
		g : SVG!G (
			groupContent <- captionBox,
			groupContent <- table.rows.seqWithoutFirst()->
				collect(row|thisModule.Table2Caption(table,
					table.rows->indexOf(row),idx,valuesSum))
		),
		captionBox : SVG!Rect (
			size <- captionBoxSize,
			position <- captionBoxCoord,
			fill <- thisModule.fill,
			stroke <- thisModule.stroke
		),
		captionBoxSize : SVG!Dimension (
			width <- table.captionBoxWidth(),
			height <- table.captionBoxHeight()
		),
		captionBoxCoord : SVG!AbsoluteCoord (
			x <- thisModule.radius -
				(captionBoxSize.width - thisModule.margin) / 2,
			y <- 0 - captionBoxSize.height / 2
		)
}
--@end lazy rule Table2Captions

--@begin lazy rule Table2Caption
--@comments Creates a caption (SVG rect + text) for the cell at index given.
lazy rule Table2Caption {
	from
		table : Table!Table,
		rowIdx : Integer,
		cellIdx : Integer,
		valuesSum : Real
	using {
		value : String =
			let realValue : Real =
				if valuesSum = 0
					then 0
					else table.rows->at(rowIdx).cells->at(cellIdx).realValue() /
						valuesSum * 100
				endif in
			realValue.toString().value() + '%';
	}
	to
		g : SVG!G (
			groupContent <- caption,
			groupContent <- textCaption
		),
		caption : SVG!Rect (
			size <- captionSize,
			position <- captionCoord,
			fill <- thisModule.ColorByElementName.get(table.rows->
				at(rowIdx).cells->first().content),
			stroke <- thisModule.stroke
		),
		captionSize : SVG!Dimension (
			width <- thisModule.caption,
			height <- thisModule.caption
		),
		captionCoord : SVG!AbsoluteCoord (
			x <- (table.boundingBoxWidth() + thisModule.margin) / 2 -
				thisModule.margin - table.captionBoxWidth(),
			y <- (0 - table.captionBoxHeight()) / 2 - thisModule.margin +
				(rowIdx - 1) * (thisModule.caption + thisModule.margin / 2)
		),
		textCaption : SVG!Text (
			position <- textCaptionCoord,
			stroke <- thisModule.stroke,
			fontSize <- thisModule.fontSize.toString(),
			content <- '(' + value + ') ' +
				table.rows->at(rowIdx).cells->first().content +	' (' +
					table.rows->at(rowIdx).cells->at(cellIdx).value() +	')'
		),
		textCaptionCoord : SVG!AbsoluteCoord (
			x <- captionCoord.x + thisModule.caption + thisModule.fontSize,
			y <- captionCoord.y + thisModule.caption -
				thisModule.fontSize * 0.1
		)
}
--@end lazy rule Table2Caption",atlcompil atl name tabl svgpiechart version domain tabl svg pie chart author eric vepa evepa sodius com sodius www sodius com date descript this transform use transform generic tabl svg pie chart a pie chart produc tabl valu exclud header row first cell row least column see scalabl vector graphic world wide web consortium http www w org tr svg modul tabl svgpiechart modul templat creat out svg in tabl use tablehelp comment comment valu use svg render comment begin attribut helper scale comment the scale valu use svg document helper def scale real end attribut helper scale begin attribut helper radius comment the radius valu use svg document pie chart helper def radius real thismodul scale end attribut helper radius begin attribut helper fill comment the fill valu use svg document helper def fill string none end attribut helper fill begin attribut helper stroke comment the stroke valu use svg document helper def stroke string black end attribut helper stroke begin attribut helper margin comment the margin valu use svg document chart helper def margin real end attribut helper margin begin attribut helper titlefonts comment the fontsiz valu use titl svg document helper def titlefonts real thismodul radius end attribut helper titlefonts begin attribut helper fontsiz comment the fontsiz valu use svg document helper def fontsiz real thismodul titlefonts end attribut helper fontsiz begin attribut helper caption comment the valu use svg document caption one sector helper def caption real thismodul fontsiz end attribut helper caption begin attribut helper svgfile comment the uniqu svg file element helper def svgfile svg svgfile oclundefin end attribut helper svgfile comment comment helper svg render comment begin helper maxsizenam comment return maxim size name cell header row add charact display valu helper context tabl tabl def maxsizenam real self row seqwithoutfirst iter r maxsiz integ r cell first content size maxsiz r cell first content size els maxsiz endif thismodul fontsiz end helper maxsizenam begin helper boundingboxwidth comment return width boud box comput tabl helper context tabl tabl def boundingboxwidth real self captionboxwidth thismodul radius thismodul margin end helper boundingboxwidth begin attribut helper prevangl comment the previous rotat angl last sector generat helper def prevangl real end attribut helper prevangl begin attribut helper prevwidth comment the previous width chart generat helper def prevwidth real end attribut helper prevwidth begin helper captionboxwidth comment return width caption box tabl helper context tabl tabl def captionboxwidth real self maxsizenam thismodul caption thismodul margin end helper captionboxwidth begin helper captionboxheight comment return height caption box tabl helper context tabl tabl def captionboxheight real self row size thismodul caption thismodul margin thismodul margin end helper captionboxheight begin helper computecolor comment comput rgb color number element total number color comput helper def computecolor idx integ nbcolor integ string let valu integ idx nbcolor floor valu rgb valu tostr els valu rgb valu tostr els valu rgb valu tostr els valu rgb valu tostr els valu rgb valu tostr els rgb valu tostr endif endif endif endif endif end helper computecolor begin helper colorbyelementnam comment color use sector caption pie chart element helper def colorbyelementnam map string string map end helper colorbyelementnam begin entrypoint rule svgfile comment creat svg file one svg tag entrypoint rule svgfile use width real thismodul allvalidt iter sum real sum captionboxwidth thismodul radius thismodul margin row first cell size thismodul margin height real let heightwithoutcapt real thismodul radius thismodul margin thismodul titlefonts let heightwithcapt real thismodul allvalidt iter max real captionboxheight max max thismodul margin heightwithoutcapt max heightwithcapt svgfile svg svgfile tag svg svg svg svg size svgsize namespac http www w org svg version svgsize svg dimens width width height height thismodul allvalidt size thismodul svgfile svgfile thismodul svgfile tag viewbox width tostr height tostr tabl thismodul allvalidt elmtnam tabl row seqwithoutfirst collect r r cell first content sortedbi n n thismodul colorbyelementnam thismodul colorbyelementnam includ elmtnam thismodul computecolor tabl row seqwithoutfirst collect r r cell first content sortedbi n n indexof elmtnam tabl row seqwithoutfirst collect r r cell first content sortedbi n n size cell tabl row first cell seqwithoutfirst thismodul tabl piechart tabl tabl row first cell indexof cell end entrypoint rule svgfile begin lazi rule tabl piechart comment creat pie chart svg group metric column index given lazi rule tabl piechart tabl tabl tabl idx integ use valuessum real tabl row seqwithoutfirst iter row acc real acc row cell idx realvalu g svg g attribut boundingboxtransl groupcont boundingbox groupcont texttitl groupcont tabl row seqwithoutfirst collect r r cell idx select c c valuenotnul size thismodul tabl circl tabl idx els thismodul tabl sector tabl idx valuessum endif groupcont thismodul tabl caption tabl idx valuessum boundingbox svg rect size boundingboxs posit boundingboxcoord fill thismodul fill stroke thismodul stroke boundingboxs svg dimens width tabl boundingboxwidth height thismodul svgfile tag size height thismodul margin boundingboxcoord svg absolutecoord x boundingboxs width boundingboxs height boundingboxtransl svg translat tx thismodul prevwidth boundingboxs width thismodul margin ty thismodul svgfile tag size height texttitl svg text posit texttitlecoord stroke thismodul stroke fontsiz thismodul titlefonts tostr comment text anchor valu strore lengthadjust attribut lengthadjust middl content tabl row first cell idx content texttitlecoord svg absolutecoord x tabl captionboxwidth thismodul margin boundingboxs height thismodul titlefonts thismodul margin thismodul prevwidth thismodul prevwidth boundingboxs width thismodul margin thismodul svgfile tag children g comment initialis rotat angl thismodul prevangl end lazi rule tabl piechart begin lazi rule tabl circl comment creat complet pie svg circl metric index given lazi rule tabl circl tabl tabl cell idx integ g svg g attribut pietransl groupcont pie pietransl svg translat tx tabl captionboxwidth thismodul margin ty thismodul titlefonts pie svg circl size piesiz posit piecoord fill thismodul colorbyelementnam get tabl row seqwithoutfirst select r r cell idx valuenotnul first cell first content stroke thismodul stroke piesiz svg dimens width thismodul radius height piesiz width piecoord svg absolutecoord x end lazi rule tabl circl begin lazi rule tabl sector comment creat pie sector svg path metric index given lazi rule tabl sector tabl tabl tabl idx integ valuessum real g svg g attribut sectorstransl groupcont tabl row seqwithoutfirst collect row thismodul row sector row tabl row indexof row idx valuessum sectorstransl svg translat tx tabl captionboxwidth thismodul margin ty thismodul titlefonts end lazi rule tabl sector begin lazi rule row sector comment creat sector svg path cell index given lazi rule row sector row tabl row rowidx integ cellidx integ valuessum real use valu real valuessum els row cell cellidx realvalu valuessum endif x real thismodul radius valu toradian cos real thismodul radius valu toradian sin g svg g attribut sectorrot groupcont sector sectorrot svg rotat angl thismodul prevangl sector svg path m l thismodul radius tostr a thismodul radius tostr thismodul radius tostr valu els endif x tostr tostr z fill thismodul colorbyelementnam get row cell first content stroke thismodul stroke comment add angl valu new sector thismodul prevangl sectorrot angl valu end lazi rule row sector begin lazi rule tabl caption comment creat caption svg rect tabl lazi rule tabl caption tabl tabl cell idx integ valuessum real g svg g groupcont captionbox groupcont tabl row seqwithoutfirst collect row thismodul tabl caption tabl tabl row indexof row idx valuessum captionbox svg rect size captionboxs posit captionboxcoord fill thismodul fill stroke thismodul stroke captionboxs svg dimens width tabl captionboxwidth height tabl captionboxheight captionboxcoord svg absolutecoord x thismodul radius captionboxs width thismodul margin captionboxs height end lazi rule tabl caption begin lazi rule tabl caption comment creat caption svg rect text cell index given lazi rule tabl caption tabl tabl tabl rowidx integ cellidx integ valuessum real use valu string let realvalu real valuessum els tabl row rowidx cell cellidx realvalu valuessum endif realvalu tostr valu g svg g groupcont caption groupcont textcapt caption svg rect size captions posit captioncoord fill thismodul colorbyelementnam get tabl row rowidx cell first content stroke thismodul stroke captions svg dimens width thismodul caption height thismodul caption captioncoord svg absolutecoord x tabl boundingboxwidth thismodul margin thismodul margin tabl captionboxwidth tabl captionboxheight thismodul margin rowidx thismodul caption thismodul margin textcapt svg text posit textcaptioncoord stroke thismodul stroke fontsiz thismodul fontsiz tostr content valu tabl row rowidx cell first content tabl row rowidx cell cellidx valu textcaptioncoord svg absolutecoord x captioncoord x thismodul caption thismodul fontsiz captioncoord thismodul caption thismodul fontsiz end lazi rule tabl caption,2
194,194,P84-HTML2XML.atl,"--@atlcompiler	atl2006
--@name			HTML2XML
--@version		2.0
--@domains		HTML, Table
--@authors		Eric Vepa (evepa <at> sodius.com) for SODIUS (www.sodius.com)
--@date			2007/05/28
--@description	HTML extractor for a subset of the HTML metamodel (table representation).

module HTML2XML; -- Module Template
create OUT : XML from IN : HTML;

--@begin rule HTML
rule HTML {
	from
		html : HTML!HTML
	to
		xml : XML!Root (
			name <- 'html',
			children <- html.head,
			children <- html.body
		)
}	
--@end rule HTML

--@begin rule HTMLElement
rule HTMLElement {
	from
		html : HTML!HTMLElement
	to
		xml : XML!Element (
			children <-  html.children
		)
}	
--@end rule HTMLElement

--@begin rule HEAD
rule HEAD extends HTMLElement {
	from
		html : HTML!HEAD
	to
		xml : XML!Element (
			name <- 'head',
			children <- html.headElements
		)
}	
--@end rule HEAD

--@begin abstract rule HEADElement
abstract rule HEADElement extends HTMLElement {
	from
		html : HTML!HEADElement
	to
		xml : XML!Element
}	
--@end abstract rule HEADElement

--@begin rule TITLE
rule TITLE extends HEADElement {
	from
		html : HTML!TITLE
	to
		xml : XML!Element (
			name <- 'title',
			children <- thisModule.Text(html.value)
		)
}	
--@end rule TITLE

--@begin rule BODY
rule BODY extends HTMLElement {
	from
		html : HTML!BODY
	to
		xml : XML!Element (
			name <- 'body',
			children <- html.bodyElements
		)
}	
--@end rule BODY

--@begin abstract rule BODYElement
abstract rule BODYElement extends HTMLElement {
	from
		html : HTML!BODYElement
	to
		xml : XML!Element
}	
--@end abstract rule BODYElement

--@begin abstract rule TABLEElement
abstract rule TABLEElement extends BODYElement {
	from
		html : HTML!TABLEElement
	to
		xml : XML!Element
}	
--@end abstract rule TABLEElement

--@begin rule TABLE
rule TABLE extends TABLEElement {
	from
		html : HTML!TABLE
	to
		xml : XML!Element (
			name <- 'table',
			children <- thisModule.Attribute('border',
				if not html.border.oclIsUndefined()
					then html.border
					else '0'
				endif),
			children <- html.trs
		)
}	
--@end rule TABLE

--@begin rule TR
rule TR extends TABLEElement {
	from
		html : HTML!TR
	to
		xml : XML!Element (
			name <- 'tr',
			children <- html.tds
		)
}	
--@end rule TR

--@begin rule TD
rule TD extends TABLEElement {
	from
		html : HTML!TD
	to
		xml : XML!Element (
			name <- 'td',
			children <- thisModule.Text(html.value)
		)
	do {
		if (not html.align.oclIsUndefined()) {
			xml.children <- thisModule.Attribute('align', html.align);
		}
	}
}	
--@end rule TD

--@begin rule TH
rule TH extends TD {
	from
		html : HTML!TH
	to
		xml : XML!Element (
			name <- 'th'
		)
}	
--@end rule TH

--@begin called rule Attribute
rule Attribute(attrName : String, attrValue : String) {
	to
		attr : XML!Attribute (
			name <- attrName,
			value <- attrValue
		)
	do {
		attr;
	}
}	
--@end called rule Attribute

--@begin called rule Text
rule Text(value : String) {
	to
		text : XML!Text (
			value <-
				if not value.oclIsUndefined()
					then value
					else ''
				endif
		)
	do {
		text;
	}
}	
--@end called rule Text",atlcompil atl name html xml version domain html tabl author eric vepa evepa sodius com sodius www sodius com date descript html extractor subset html metamodel tabl represent modul html xml modul templat creat out xml in html begin rule html rule html html html html xml xml root name html children html head children html bodi end rule html begin rule htmlelement rule htmlelement html html htmlelement xml xml element children html children end rule htmlelement begin rule head rule head extend htmlelement html html head xml xml element name head children html headel end rule head begin abstract rule headel abstract rule headel extend htmlelement html html headel xml xml element end abstract rule headel begin rule titl rule titl extend headel html html titl xml xml element name titl children thismodul text html valu end rule titl begin rule bodi rule bodi extend htmlelement html html bodi xml xml element name bodi children html bodyel end rule bodi begin abstract rule bodyel abstract rule bodyel extend htmlelement html html bodyel xml xml element end abstract rule bodyel begin abstract rule tableel abstract rule tableel extend bodyel html html tableel xml xml element end abstract rule tableel begin rule tabl rule tabl extend tableel html html tabl xml xml element name tabl children thismodul attribut border html border oclisundefin html border els endif children html trs end rule tabl begin rule tr rule tr extend tableel html html tr xml xml element name tr children html tds end rule tr begin rule td rule td extend tableel html html td xml xml element name td children thismodul text html valu html align oclisundefin xml children thismodul attribut align html align end rule td begin rule th rule th extend td html html th xml xml element name th end rule th begin call rule attribut rule attribut attrnam string attrvalu string attr xml attribut name attrnam valu attrvalu attr end call rule attribut begin call rule text rule text valu string text xml text valu valu oclisundefin valu els endif text end call rule text,9
195,195,P84-Table2TabularHTML.atl,"--@atlcompiler	atl2006
--@name			Table2TabularHTML
--@version		2.0
--@domains		Table, HTML
--@authors		Eric Vepa (evepa <at> sodius.com) for SODIUS (www.sodius.com)
--@date			2007/06/04
--@description	This transformation is used to transform generic tables into a HTML model with tables.

module Table2TabularHTML; -- Module Template
create OUT : HTML from IN : Table;

uses TableHelpers;

--@begin attribute helper html
--@comments The unique HTML tag.
helper def : html : HTML!HTML = OclUndefined;
--@end attribute helper html

--@begin entrypoint rule HTML
--@comments Creates the unique HTML, HEAD, TITLE and BODY tags.
entrypoint rule HTML() {
	to
		html : HTML!HTML (
			head <- head,
			body <- body
		),
		head : HTML!HEAD (
			headElements <- title
		),
		title : HTML!TITLE (
			value <- ''
		),
		body : HTML!BODY
	do {
		thisModule.html <- html;
	}
}
--@end entrypoint rule HTML

--@begin rule Table2TABLE
rule Table2TABLE {
	from
		table : Table!Table (
			table.rows->size() > 0
		)
	to
		tab : HTML!TABLE (
			border <- '1',
			trs <- thisModule.Row2TRwithTH(table.rows->first()),
			trs <- table.rows->subSequence(2,table.rows->size())->
				collect(row|thisModule.Row2TRwithTD(row))
		)
	do {
		thisModule.html.body.bodyElements <- tab;
	}
}
--@end rule Table2TABLE

--@begin lazy rule Row2TRwithTH
lazy rule Row2TRwithTH {
	from
		row : Table!Row
	to
		tr : HTML!TR (
			tds <- row.cells->
				collect(cell|thisModule.Cell2TH(cell))
		)
}
--@end lazy rule Row2TRwithTH

--@begin lazy rule Cell2TH
lazy rule Cell2TH {
	from
		cell : Table!Cell
	to
		th : HTML!TH (
			value <- cell.value()
		)
}
--@end lazy rule Cell2TH

--@begin lazy rule Row2TRwithTD
lazy rule Row2TRwithTD {
	from
		row : Table!Row
	to
		tr : HTML!TR (
			tds <- thisModule.Cell2TD(row.cells->first()),
			tds <- row.cells->subSequence(2,row.cells->size())->
				collect(cell|thisModule.Cell2TDRightAlign(cell))
		)
}
--@end lazy rule Row2TRwithTD

--@begin lazy rule Cell2TD
lazy rule Cell2TD {
	from
		cell : Table!Cell
	to
		td : HTML!TD (
			value <- cell.value()
		)
}
--@end lazy rule Cell2TD

--@begin lazy rule Cell2TDRightAlign
lazy rule Cell2TDRightAlign {
	from
		cell : Table!Cell
	to
		td : HTML!TD (
			value <- cell.value(),
			align <- 'right'
		)
}
--@end lazy rule Cell2TDRightAlign",atlcompil atl name tabl tabularhtml version domain tabl html author eric vepa evepa sodius com sodius www sodius com date descript this transform use transform generic tabl html model tabl modul tabl tabularhtml modul templat creat out html in tabl use tablehelp begin attribut helper html comment the uniqu html tag helper def html html html oclundefin end attribut helper html begin entrypoint rule html comment creat uniqu html head titl bodi tag entrypoint rule html html html html head head bodi bodi head html head headel titl titl html titl valu bodi html bodi thismodul html html end entrypoint rule html begin rule tabl tabl rule tabl tabl tabl tabl tabl tabl row size tab html tabl border trs thismodul row trwithth tabl row first trs tabl row subsequ tabl row size collect row thismodul row trwithtd row thismodul html bodi bodyel tab end rule tabl tabl begin lazi rule row trwithth lazi rule row trwithth row tabl row tr html tr tds row cell collect cell thismodul cell th cell end lazi rule row trwithth begin lazi rule cell th lazi rule cell th cell tabl cell th html th valu cell valu end lazi rule cell th begin lazi rule row trwithtd lazi rule row trwithtd row tabl row tr html tr tds thismodul cell td row cell first tds row cell subsequ row cell size collect cell thismodul cell tdrightalign cell end lazi rule row trwithtd begin lazi rule cell td lazi rule cell td cell tabl cell td html td valu cell valu end lazi rule cell td begin lazi rule cell tdrightalign lazi rule cell tdrightalign cell tabl cell td html td valu cell valu align right end lazi rule cell tdrightalign,12
196,196,P85-Lib4MMTree.atl,"-- @name Lib for MMTree
-- @version 1.0
-- @domains 
-- @authors Cyril Faure
-- @date 01/06/2007
-- @description this lib contains helpers usefull for MMTree
-- @path MMTree=/Tree2List/metamodels/MMTree.ecore

library Lib4MMTree;

-- This helper returns true if the current tree element is the tree root
helper context MMTree!Node def : isTreeNodeRoot() : Boolean =
	self.refImmediateComposite().oclIsUndefined();
	-- refImmediateComposite() is a reflective operation that returns the immediate composite (e.g. the immediate container) of self
	-- So if there is no immediate composite then the current node is the root (we suppose in our example that there is only one root).

-- We retrieve all the tree elements via a DFS starting from a given node 
helper context MMTree!Node def : getAllChildren () : OrderedSet(MMTree!TreeElement) =
	self.children->iterate( child ; elements : OrderedSet(MMTree!TreeElement) = 
		OrderedSet{} | 
		if child.oclIsTypeOf(MMTree!Node) then
			elements.union(child.getAllChildren()) -- NODE : recursive call
		else
			elements.append(child) -- LEAF
		endif
		)
	;

-- This function sorts the leaves retrieved via the DFS 
-- according to their size and to their position in the tree
helper context MMTree!Node def : getLeavesInOrder() : OrderedSet (MMTree!Leaf) =
	let leavesList : OrderedSet (MMTree!Leaf) = 
		self.getAllChildren ()->select(currChild | currChild.oclIsTypeOf(MMTree!Leaf))
	in 
		leavesList->select(leaf | leaf.size = #big)
		->union(leavesList->select(leaf | leaf.size = #medium))
		->union(leavesList->select(leaf | leaf.size = #small))
	;
",name lib mmtree version domain author cyril faur date descript lib contain helper useful mmtree path mmtree tree list metamodel mmtree ecor librari lib mmtree this helper return true current tree element tree root helper context mmtree node def istreenoderoot boolean self refimmediatecomposit oclisundefin refimmediatecomposit reflect oper return immedi composit e g immedi contain self so immedi composit current node root suppos exampl one root we retriev tree element via dfs start given node helper context mmtree node def getallchildren orderedset mmtree treeelement self children iter child element orderedset mmtree treeelement orderedset child oclistypeof mmtree node element union child getallchildren node recurs call els element append child leaf endif this function sort leav retriev via dfs accord size posit tree helper context mmtree node def getleavesinord orderedset mmtree leaf let leaveslist orderedset mmtree leaf self getallchildren select currchild currchild oclistypeof mmtree leaf leaveslist select leaf leaf size big union leaveslist select leaf leaf size medium union leaveslist select leaf leaf size small,5
197,197,P85-Tree2List.atl,"-- @name Tree structure to List structure
-- @version 1.0
-- @domains 
-- @authors Cyril Faure
-- @date 01/06/2007
-- @description ""toy example"" of model transformation usually made with a DFS (Depth First Search) imperative algorithms
-- @see http://en.wikipedia.org/wiki/Depth-first_search
-- @path MMTree=/Tree2List/metamodels/MMTree.ecore
-- @path MMElementList=/Tree2List/metamodels/MMElementList.ecore

module Tree2List;
create elmList : MMElementList from aTree : MMTree;

uses Lib4MMTree;

-- we want to process the tree via DFS and create an ordered list containing :
-- all big leafs, then all medium leafs, then all small leafs. We add the
-- constraint we want all three ""sublists"" to be ordered on the DFS traversal order
-- Note : the nodes (other than the tree root) are not kept in the destination model

-- The transformation is done with only one matched rule. For each element of its elements reference, we create a MMElementList!CommonElement. 
-- Each element of this list is computed via a distinct keyword which creates a CommonElement for each Leaf of a list we compute via an helper.
rule TreeNodeRoot2RootElement { 
	from 	-- should be unique
		rt : MMTree!Node (rt.isTreeNodeRoot()) 
	to
		lstRt : MMElementList!RootElement (
			name <- rt.name,
			elements <- elmLst
		),
		elmLst : distinct MMElementList!CommonElement foreach(leaf in rt.getLeavesInOrder())(
			name <- leaf.name
		)
}",name tree structur list structur version domain author cyril faur date descript toy exampl model transform usual made dfs depth first search imper algorithm see http en wikipedia org wiki depth first search path mmtree tree list metamodel mmtree ecor path mmelementlist tree list metamodel mmelementlist ecor modul tree list creat elmlist mmelementlist atre mmtree use lib mmtree want process tree via dfs creat order list contain big leaf medium leaf small leaf we add constraint want three sublist order dfs travers order note node tree root kept destin model the transform done one match rule for element element refer creat mmelementlist commonel each element list comput via distinct keyword creat commonel leaf list comput via helper rule treenoderoot rootel uniqu rt mmtree node rt istreenoderoot lstrt mmelementlist rootel name rt name element elmlst elmlst distinct mmelementlist commonel foreach leaf rt getleavesinord name leaf name,10
198,198,P85-Tree2List_usingATLResolveAlgorithm.atl,"-- @name Tree structure to List structure (using ATL Resolve Algorithm)
-- @version 1.0
-- @domains 
-- @authors Cyril Faure, Freddy Allilaire
-- @date 01/07/2007
-- @description ""toy example"" of model transformation usually made with a DFS (Depth First Search) imperative algorithms
-- @see http://en.wikipedia.org/wiki/Depth-first_search
-- @path MMTree=/Tree2List/metamodels/MMTree.ecore
-- @path MMElementList=/Tree2List/metamodels/MMElementList.ecore

module Tree2List;
create elmList : MMElementList from aTree : MMTree;

uses Lib4MMTree;

-- we want to process the tree via DFS and create an ordered list containing :
-- all big leafs, then all medium leafs, then all small leafs. We add the
-- constraint we want all three ""sublists"" to be ordered on the DFS traversal order
-- Note : the nodes (other than the tree root) are not kept in the destination model

-- Rule to transform ""Tree Node Root"" in ""Element List Root""
rule TreeNodeRoot2RootElement { 
	from 	-- should be unique
		rt : MMTree!Node (rt.isTreeNodeRoot()) 
	to
		lstRt : MMElementList!RootElement (
			name <- rt.name,
			elements <- rt.getLeavesInOrder() -- reference copy,
			-- Correspondance ""Leaf to CommonElement"" will be made thanks to a traceability link.
			-- Traceability links record correspondences between source and target elements established during transformation execution.
		)
}

-- Rule to transform Leaf to CommonElement
rule Leaf2CommonElement {
	from
		s : MMTree!Leaf
	to
		t : MMElementList!CommonElement(
			name <- s.name
		)
}",name tree structur list structur use atl resolv algorithm version domain author cyril faur freddi allilair date descript toy exampl model transform usual made dfs depth first search imper algorithm see http en wikipedia org wiki depth first search path mmtree tree list metamodel mmtree ecor path mmelementlist tree list metamodel mmelementlist ecor modul tree list creat elmlist mmelementlist atre mmtree use lib mmtree want process tree via dfs creat order list contain big leaf medium leaf small leaf we add constraint want three sublist order dfs travers order note node tree root kept destin model rule transform tree node root element list root rule treenoderoot rootel uniqu rt mmtree node rt istreenoderoot lstrt mmelementlist rootel name rt name element rt getleavesinord refer copi correspond leaf commonel made thank traceabl link traceabl link record correspond sourc target element establish transform execut rule transform leaf commonel rule leaf commonel mmtree leaf mmelementlist commonel name name,10
199,199,P86-TT2BDD.atl,"
module TT2BDD;
create OUT:BDD from IN:TT;

rule TruthTable2BDD {
   from src : TT!TruthTable
   to dest : BDD!BDD
      (
         name <- src.name,
         ports <- src.ports,
         tree <- src.getTree().cell
      )
}

rule InputPort2InputPort {
   from src : TT!InputPort
   to dest : BDD!InputPort
      (
         name <- src.name
      )
}

rule OutputPort2OutputPort {
   from src : TT!OutputPort
   to dest : BDD!OutputPort
      (
         name <- src.name
      )
}

rule Row2Leaf {
   from src : TT!Row
   to dest : BDD!Leaf
      (
         assignments <- src.cells->select(c | c.port.oclIsKindOf(TT!OutputPort))
      )
}

rule Cell2Assignment {
   from src: TT!Cell (src.port.oclIsKindOf(TT!OutputPort))
   to dest : BDD!Assignment
      (
         value <- src.value,
         port <- src.port
      )
}

rule Cell2Subtree {
   from src: TT!Cell (not src.getNode().oclIsUndefined())
   using {
      node : TupleType( cell : TT!Cell , zeroSubtree : OclAny , oneSubtree : OclAny ) =
         src.getNode();
   }
   to dest : BDD!Subtree
      (
         port <- src.port,
         treeForZero <-
            if node.zeroSubtree.oclIsKindOf(TT!Row) then
               node.zeroSubtree
            else
               node.zeroSubtree.cell
            endif,
         treeForOne <-
            if node.oneSubtree.oclIsKindOf(TT!Row) then
               node.oneSubtree
            else
               node.oneSubtree.cell
            endif
      )
}

---------------------------------------------------------------------------------------------------
-- Partitionner une partie de la table de vérité.
--
-- Ce helper effectue un travail préparatoire à la création d'un arbre binaire.
-- En prenant une sous-ensemble des lignes d'une table de vérité et un port de référence, il 
-- retourne deux sous-ensembles de lignes : celles pour lesquelles le port vaut faux
-- et celles pour lesquelles le port vaut vrai.
--
-- Entrées :
--    rows : l'ensemble des lignes à traiter
--    port : le port qui doit servir de référence au partitionnement
--
-- Sorties :
--    un tuple contenant :
--       zeroPart : l'ensemble des lignes pour lesquelles ce port vaut zéro (faux)
--       onePart  : l'ensemble des lignes pour lesquelles ce port vaut un (vrai)
--
-- Préconditions :
--
--    Le port à utiliser doit être un port d'entrée :
--
--       port.oclIsKindOf(TT!InputPort))
--
--    Sa valeur est définie dans toutes les lignes
--
--         rows->forAll(r |
--            r.cells->collect(c | c.port)
--                   ->includes(port)
--         )
---------------------------------------------------------------------------------------------------
helper def:
   getPartition(rows : Sequence(TT!Row), port : TT!Port)
      : TupleType( zeroPart : Sequence(TT!Row) , onePart : Sequence(TT!Row) ) =
      
      -- Sélectionner les lignes pour lesquelles ce port vaut faux
      let _zeroPart : Sequence(TT!Row) =
         rows->select(r |
            r.cells->exists(c |
               c.port = port and c.value = false
            )
         ) in
         
      -- Sélectionner les lignes pour lesquelles ce port vaut vrai
      let _onePart : Sequence(TT!Row) =
         rows->select(r |
            r.cells->exists(c |
               c.port = port and c.value = true
            )
         ) in

      -- Construire le tuple résultat
      Tuple{
         zeroPart = _zeroPart,
         onePart = _onePart
      };

---------------------------------------------------------------------------------------------------
-- Construire une structure d'arbre à partir d'un ensemble de lignes.
--
-- Ce helper construit un arbre à base de tuples.
-- Parmi l'ensemble des ports d'entrée utilisables, il sélectionne un port dont la valeur est
-- définie dans toutes les lignes.
-- Le helper getPartition est invoqué pour obtenir deux sous-ensembles de lignes correspondant
-- aux deux états possibles du port sélectionné.
-- L'arbre se construit de manière récursive jusqu'à ce que l'ensemble de lignes fourni se
-- réduise à une seule ligne.
--
-- Entrées :
--    rows        : l'ensemble des lignes à traiter
--    usablePorts : l'ensemble des ports dont la valeur doit être considérée dans la construction
--                  de l'arbre 
--
-- Sorties :
--    un tuple contenant :
--       cell        : une cellule qui sert de référence et désigne le noeud courant de l'arbre
--       zeroSubtree : le sous-arbre correspondant à la valeur zéro du port
--       oneSubtree  : le sous-arbre correspondant à la valeur un du port
---------------------------------------------------------------------------------------------------
helper def:
   getTree(rows : Sequence(TT!Row), usablePorts : Sequence(TT!Port))
      : TupleType( cell : TT!Cell , zeroSubtree : OclAny , oneSubtree : OclAny ) =

      -- Parmi tous les ports utilisables, en choisir un dont la valeur est définie
      -- dans toutes les lignes
      let _port : TT!Port =
         usablePorts->any(p |
            rows->forAll(r |
               r.cells->collect(c | c.port)
                     ->includes(p)
            )
         ) in
      
      -- Sélectionner une cellule qui définit une valeur pour ce port
      let _cell : TT!Cell =
         rows->first().cells->any(c | c.port = _port) in
         
      -- Partitionner l'ensemble de lignes fourni
      let _part : TupleType( zeroPart : Sequence(TT!Row), onePart : Sequence(TT!Row) ) =
         thisModule.getPartition(rows, _port) in

      -- Définir le nouvel ensemble de ports utilisables pour les partitionnements ultérieurs
      let _updatedPorts : Sequence(TT!Port) =
         usablePorts->excluding(_port) in
            
      -- Construire le tuple résultat : une structure d'arbre est construite récursivement
      Tuple{
         cell = _cell,
         zeroSubtree =
            if _part.zeroPart->size() = 1 then
               _part.zeroPart->first()
            else
               thisModule.getTree(_part.zeroPart, _updatedPorts)
            endif,
         oneSubtree =
            if _part.onePart->size() = 1 then
               _part.onePart->first()
            else
               thisModule.getTree(_part.onePart, _updatedPorts)
            endif
      };

---------------------------------------------------------------------------------------------------
-- Obtenir l'arbre représentatif d'une table de vérité complète.
--
-- Ce helper construit une structure d'arbre en utilisant thisModule.getTree().
---------------------------------------------------------------------------------------------------
helper context TT!TruthTable def:
   getTree()
      : TupleType( cell : TT!Cell , zeroSubtree : OclAny , oneSubtree : OclAny ) =
      thisModule.getTree(self.rows, self.ports->select(p | p.oclIsKindOf(TT!InputPort)));
      
---------------------------------------------------------------------------------------------------
-- Recherche une cellule de table de vérité dans un arbre.
--
-- Ce helper explore récursivement les sous-arbres jusqu'à ce que la cellule cherchée ait été
-- trouvée ou jusqu'à ce que l'arbre entier ait été parcouru sans succès.
--
-- Entrées :
--    cell : la cellule cherchée
--    tree : le noeud racine de l'arbre dans lequel il faut le rechercher
--
-- Sorties :
--    un noeud de l'arbre en cas de succès,
--    OclUndefined en cas d'échec
---------------------------------------------------------------------------------------------------
helper def:
   findCell(cell : TT!Cell, tree : TupleType( cell : TT!Cell, zeroSubtree : OclAny, oneSubtree : OclAny ))
      : TupleType( cell : TT!Cell , zeroSubtree : OclAny , oneSubtree : OclAny ) =

      if tree.cell = cell then
         tree
      else if tree.zeroSubtree.oclIsKindOf(TT!Row) then
         if tree.oneSubtree.oclIsKindOf(TT!Row) then
            -- Les deux sous-arbres sont des feuilles
            Sequence{}->first()
         else
            -- Seul Le sous-arbre 1 n'est pas une feuille
            thisModule.findCell(cell,tree.oneSubtree)
         endif
      else
         let tryInZero : OclAny = thisModule.findCell(cell,tree.zeroSubtree) in
         if tree.oneSubtree.oclIsKindOf(TT!Row) then
            -- Seul Le sous-arbre 0 n'est pas une feuille
            tryInZero
         else if tryInZero.oclIsUndefined() then
            -- Aucun des sous-arbres n'est une feuille
            -- mais le sous-arbre 0 n'a donné aucun résultat
            thisModule.findCell(cell,tree.oneSubtree)
         else
            -- Aucun des sous-arbres n'est une feuille
            -- et le sous-arbre 0 a donné un résultat
            tryInZero
         endif endif
      endif endif;

---------------------------------------------------------------------------------------------------
-- Obtenir, pour une cellule donnée d'une table de vérité, le noeud correspondant dans l'arbre
-- représentatif de cette table.
--
-- Ce helper utilise getTree et findCell.
---------------------------------------------------------------------------------------------------
helper context TT!Cell def:
   getNode() 
      : TupleType( cell : TT!Cell , zeroSubtree : OclAny , oneSubtree : OclAny ) =

      thisModule.findCell(self, self.owner.owner.getTree());
",modul tt bdd creat out bdd in tt rule truthtabl bdd src tt truthtabl dest bdd bdd name src name port src port tree src gettre cell rule inputport inputport src tt inputport dest bdd inputport name src name rule outputport outputport src tt outputport dest bdd outputport name src name rule row leaf src tt row dest bdd leaf assign src cell select c c port ocliskindof tt outputport rule cell assign src tt cell src port ocliskindof tt outputport dest bdd assign valu src valu port src port rule cell subtre src tt cell src getnod oclisundefin use node tupletyp cell tt cell zerosubtre oclani onesubtre oclani src getnod dest bdd subtre port src port treeforzero node zerosubtre ocliskindof tt row node zerosubtre els node zerosubtre cell endif treeforon node onesubtre ocliskindof tt row node onesubtre els node onesubtre cell endif partitionn une parti de la tabl de v rit ce helper effectu un travail pr paratoir la cr ation un arbr binair en prenant une sous ensembl des lign une tabl de v rit et un port de r f renc il retourn deux sous ensembl de lign cell pour lesquell le port vaut faux et cell pour lesquell le port vaut vrai entr es row l ensembl des lign traiter port le port qui doit servir de r f renc au partitionn sorti un tupl conten zeropart l ensembl des lign pour lesquell ce port vaut z ro faux onepart l ensembl des lign pour lesquell ce port vaut un vrai pr condit le port utilis doit tre un port entr e port ocliskindof tt inputport sa valeur est fini dan tout les lign row foral r r cell collect c c port includ port helper def getpartit row sequenc tt row port tt port tupletyp zeropart sequenc tt row onepart sequenc tt row s lectionn les lign pour lesquell ce port vaut faux let zeropart sequenc tt row row select r r cell exist c c port port c valu fals s lectionn les lign pour lesquell ce port vaut vrai let onepart sequenc tt row row select r r cell exist c c port port c valu true construir le tupl r sultat tupl zeropart zeropart onepart onepart construir une structur arbr partir un ensembl de lign ce helper construit un arbr base de tupl parmi l ensembl des port entr e utilis il lectionn un port dont la valeur est fini dan tout les lign le helper getpartit est invoqu pour obtenir deux sous ensembl de lign correspond aux deux tat possibl du port lectionn l arbr se construit de mani r cursiv jusqu ce que l ensembl de lign fourni se r duis une seul lign entr es row l ensembl des lign traiter usableport l ensembl des port dont la valeur doit tre consid r e dan la construct de l arbr sorti un tupl conten cell une cellul qui sert de r f renc et sign le noeud courant de l arbr zerosubtre le sous arbr correspond la valeur z ro du port onesubtre le sous arbr correspond la valeur un du port helper def gettre row sequenc tt row usableport sequenc tt port tupletyp cell tt cell zerosubtre oclani onesubtre oclani parmi tous les port utilis en choisir un dont la valeur est fini dan tout les lign let port tt port usableport p row foral r r cell collect c c port includ p s lectionn une cellul qui finit une valeur pour ce port let cell tt cell row first cell c c port port partitionn l ensembl de lign fourni let part tupletyp zeropart sequenc tt row onepart sequenc tt row thismodul getpartit row port d finir le nouvel ensembl de port utilis pour les partitionn ult rieur let updatedport sequenc tt port usableport exclud port construir le tupl r sultat une structur arbr est construit r cursiv tupl cell cell zerosubtre part zeropart size part zeropart first els thismodul gettre part zeropart updatedport endif onesubtre part onepart size part onepart first els thismodul gettre part onepart updatedport endif obtenir l arbr repr sentatif une tabl de v rit compl te ce helper construit une structur arbr en utilis thismodul gettre helper context tt truthtabl def gettre tupletyp cell tt cell zerosubtre oclani onesubtre oclani thismodul gettre self row self port select p p ocliskindof tt inputport recherch une cellul de tabl de v rit dan un arbr ce helper explor r cursiv les sous arbr jusqu ce que la cellul cherch e ait trouv e ou jusqu ce que l arbr entier ait parcouru san succ entr es cell la cellul cherch e tree le noeud racin de l arbr dan lequel il faut le recherch sorti un noeud de l arbr en cas de succ oclundefin en cas chec helper def findcel cell tt cell tree tupletyp cell tt cell zerosubtre oclani onesubtre oclani tupletyp cell tt cell zerosubtre oclani onesubtre oclani tree cell cell tree els tree zerosubtre ocliskindof tt row tree onesubtre ocliskindof tt row les deux sous arbr sont des feuill sequenc first els seul le sous arbr n est pas une feuill thismodul findcel cell tree onesubtre endif els let tryinzero oclani thismodul findcel cell tree zerosubtre tree onesubtre ocliskindof tt row seul le sous arbr n est pas une feuill tryinzero els tryinzero oclisundefin aucun des sous arbr n est une feuill mai le sous arbr n donn aucun r sultat thismodul findcel cell tree onesubtre els aucun des sous arbr n est une feuill et le sous arbr donn un r sultat tryinzero endif endif endif endif obtenir pour une cellul donn e une tabl de v rit le noeud correspond dan l arbr repr sentatif de cett tabl ce helper utilis gettre et findcel helper context tt cell def getnod tupletyp cell tt cell zerosubtre oclani onesubtre oclani thismodul findcel self self owner owner gettre,0
200,200,P87-UML2Amble.atl,"module UML2Amble;
create OUT : Amble from IN : UMLDI;


-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------


-- This helper computes the sequence of Class model element ordered according
-- to their name.
-- CONTEXT: thisModule
-- RETURN:	Sequence(UMLDI!Class)
helper def : sortedClasses : Sequence(UMLDI!Class) =
	UMLDI!Class.allInstances()
		->select(a | a.oclIsTypeOf(UMLDI!Class))
		->asSequence()
		->sortedBy(b | b.name);


-- This helper calculates the number of declared instances of a given process.
-- This data is encoded as a taggedValue, of type 'instances' associated with
-- each Class model element.
-- CONTEXT: UMLDI!Class
-- RETURN:	Integer
helper context UMLDI!Class def : getInstancesNb() : Integer =
	self.taggedValue
		->select(x | x.type.name = 'instances')
		->first().dataValue
		->asSequence()->first().toInteger();

	
-- This helper calculates the minId of the process associated with the
-- contextual Class. Consecutive Ids are assigned to processes according to
-- their rank in the sortedClasses Sequence, and their instances number.
-- The minId associated with a Class C corresponds to the sum of instances
-- number of the classes that appear before C within sortedClasses.
-- CONTEXT: UMLDI!Class
-- RETURN:	Integer
helper context UMLDI!Class def : getMinId() : Integer =
	thisModule.sortedClasses
		->iterate(e; acc : Integer = 0 |
			if thisModule.sortedClasses->indexOf(e)
				< thisModule.sortedClasses->indexOf(self) then
				acc + e.getInstancesNb()
			else
				acc
			endif
		);


-- This helper calculates the maxId of the process associated with the
-- contextual Class. This value corresponds to the minId of the Class
-- plus the instances number of the Class.
-- CONTEXT: UMLDI!Class
-- RETURN:	Integer
helper context UMLDI!Class def : getMaxId() : Integer =
	self.getMinId() + self.getInstancesNb() - 1;


-- This helper computes the set of attributes that are owned by the UML class
-- that has the same name that the contextual state machine.
-- CONTEXT: UMLDI!StateMachine
-- RETURN:	Set(UMLDI!Attribute)
helper context UMLDI!StateMachine def : getVariables() : Set(UMLDI!Attribute) =
	UMLDI!Attribute.allInstances()
		->select(a | a.owner.oclIsTypeOf(UMLDI!Class) and
					 a.owner.name = self.name
				);


-- This helper computes the message receipt operation (owned by an association
-- class) associated with the contextual transition.
-- CONTEXT: UMLDI!Transition
-- RETURN:	UMLDI!Operation
helper context UMLDI!Transition	def : getMessage() : UMLDI!Operation =
	let statemachine_name : String = 
		UMLDI!StateMachine.allInstances()
			->select(a | a.transitions->includes(self))
			->first().name in
	let guard_name : String = self.guard.name in
	UMLDI!Operation.allInstances()
		->select(a | a.owner.oclIsTypeOf(UMLDI!AssociationClass))
		->select(b | 'received_' + b.name = guard_name)
		->select(c | c.owner.connection
					->collect(d | d.participant)
					->collect(e | e.name)
					->includes(statemachine_name)
				)
		->first();


-- This helper computes the state machine that has the same name that the
-- source class of the contextual association class.
-- CONTEXT: UMLDI!AssociationClass
-- RETURN:	UMLDI!StateMachine
helper context UMLDI!AssociationClass
	def : getSourceProcess() : UMLDI!StateMachine =
	let source_name : String =
		self.connection
			->select(a | not a.isNavigable)
			->first().participant.name in
	UMLDI!StateMachine.allInstances()
		->select(a | a.name = source_name)->first();
	

-- This helper computes the state machine that has the same name that the
-- target class of the contextual association class.
-- CONTEXT: UMLDI!AssociationClass
-- RETURN:	UMLDI!StateMachine
helper context UMLDI!AssociationClass
	def : getTargetProcess() : UMLDI!StateMachine =
	let target_name : String =
		self.connection
			->select(a | a.isNavigable)
			->first().participant.name in
	UMLDI!StateMachine.allInstances()
		->select(a | a.name = target_name)->first();



-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------


-- Rule 'Model2Program'.
-- This rule generates the structure of the root Program element from the UML
-- model.
rule Model2Program {
	from
		model: UMLDI!Model
	to
		prg: Amble!Program (
			name <- model.name,
			processes <- UMLDI!StateMachine.allInstances(),
			networks <- UMLDI!AssociationClass.allInstances()
		)
}


-- Rule 'StateMachine2Process'.
-- This rule generates an Amble process, with its states, its transitions and
-- its initial action from an UML state machine.
-- It also generates the 'id' variable associated with the created Amble
-- process.
rule StateMachine2Process {
	from
		statemachine: UMLDI!StateMachine
	using {
		crt_class : UMLDI!Class =
			UMLDI!Class.allInstances()
				->select(a | a.name = statemachine.name)
				->first();
	}
	to
		process: Amble!Process (
			name <- statemachine.name,
			instancesNb <- crt_class.getInstancesNb(),
			minId <- crt_class.getMinId(),
			maxId <- crt_class.getMaxId(),
			states <- statemachine.top.subvertex
						->select(d | d.oclIsKindOf(UMLDI!SimpleState)),
			transitions <- statemachine.transitions,
			initial <- statemachine.top.subvertex
						->select(d | d.oclIsKindOf(UMLDI!Pseudostate)) 
						->collect(o | o.outgoing
								->collect(e | e.effect)).flatten()->first(),
			variables <- statemachine.getVariables(),
			connectedTo <- UMLDI!AssociationClass.allInstances()
							->select(e | e.connection
								->collect(d | d.participant.name)
								->includes(statemachine.name))
		)
}


-- Rule 'Attribute2Variable'.
-- This rule generates an Amble process Variable from each UML attribute
-- that is defined within the context of an UML Class.
rule Attribute2Variable {
	from
		attribute: UMLDI!Attribute (
			attribute.owner.oclIsTypeOf(UMLDI!Class)
		)
	to
		variable: Amble!Variable (
			name <- attribute.name,
			type <- attribute.type.name,
			initValue <- attribute.initialValue.body
		)
}


-- Rule 'State2State'.
-- This rule generates an Amble state with its name and its incoming and
-- outgoing transitions from an UML simple state.
-- The 'isInitial' property is computed by checking if one of the incoming
-- transitions is initialted by an UML pseudostate.
rule State2State {
	from
		uml_state: UMLDI!SimpleState
	to
		amble_state: Amble!State (
			name <- uml_state.name,
			isInitial <- not uml_state.incoming
							->collect(e | e.source)
							->select(d | d.oclIsKindOf(UMLDI!Pseudostate))
							->isEmpty(),
			incoming <- uml_state.incoming,
			outgoing <- uml_state.outgoing
		)
}


-- Rule 'Transition2Trans'.
-- This rule generates the structure of the root Program element when the
-- input element contains no monitors.
rule Transition2Trans {
	from
		uml_trans: UMLDI!Transition(
			uml_trans.name = 'RECEIPT'
		)
	to
		trans: Amble!Trans (
			source <- uml_trans.source,
			target <- uml_trans.target,
			guard <- uml_trans.guard,
			action <- uml_trans.effect,
			waitFor <- uml_trans.getMessage()
		)
}


-- Rule 'Transition2TransAll'.
-- This rule generates the structure of the root Program element when the
-- input element contains no monitors.
rule Transition2TransAll {
	from
		uml_trans: UMLDI!Transition(
			uml_trans.name = 'RECEIPT_ANY'
		)
	to
		trans: Amble!Transall (
			source <- uml_trans.source,
			target <- uml_trans.target,
			guard <- uml_trans.guard,
			action <- uml_trans.effect,
			waitFor <- uml_trans.getMessage()
		)
}


-- Rule 'Transition2Strans'.
-- This rule generates the structure of the root Program element when the
-- input element contains no monitors.
rule Transition2Strans {
	from
		uml_trans: UMLDI!Transition(
			(
				uml_trans.name.oclIsUndefined()
				or uml_trans.name = 'CONDITION'
			)
			and
			uml_trans.source->oclIsKindOf(UMLDI!SimpleState)
		)
	to
		trans: Amble!Strans (
			source <- uml_trans.source,
			target <- uml_trans.target,
			guard <- uml_trans.guard,
			action <- uml_trans.effect 
		)
}


-- Rule 'Guard2Guard'.
-- This rule generates an Amble guard from an UML guard.
rule Guard2Guard {
	from
		uml_guard: UMLDI!Guard
	to
		amble_guard: Amble!Guard (
			name <- uml_guard.name
		)
}


-- Rule 'Effect2Action'.
-- This rule generates an Amble action from an UML effect.
rule Effect2Action {
	from
		effect: UMLDI!CallAction
	to
		action: Amble!Action (
			name <- effect.name
		)
}


-- Rule 'Class2Network'.
-- This rule generates ...
rule Class2Network {
	from
		class: UMLDI!AssociationClass
	to
		net: Amble!Network (
			name <- class.name,
			channels <- new_channel
		),
		new_channel: Amble!Channel (
			name <- class.name,
			messages <- class.feature,
			source <- class.getSourceProcess(),
			target <- class.getTargetProcess()
		)
}


-- Rule 'Operation2Message'.
-- This rule generates ...
rule Operation2Message {
	from
		operation: UMLDI!Operation (
			operation.owner.oclIsTypeOf(UMLDI!AssociationClass)
		)
	to
		message: Amble!Message (
			name <- operation.name
		)
}
",modul uml ambl creat out ambl in umldi helper this helper comput sequenc class model element order accord name context thismodul return sequenc umldi class helper def sortedclass sequenc umldi class umldi class allinst select oclistypeof umldi class assequ sortedbi b b name this helper calcul number declar instanc given process this data encod taggedvalu type instanc associ class model element context umldi class return integ helper context umldi class def getinstancesnb integ self taggedvalu select x x type name instanc first datavalu assequ first tointeg this helper calcul minid process associ contextu class consecut id assign process accord rank sortedclass sequenc instanc number the minid associ class c correspond sum instanc number class appear c within sortedclass context umldi class return integ helper context umldi class def getminid integ thismodul sortedclass iter e acc integ thismodul sortedclass indexof e thismodul sortedclass indexof self acc e getinstancesnb els acc endif this helper calcul maxid process associ contextu class this valu correspond minid class plus instanc number class context umldi class return integ helper context umldi class def getmaxid integ self getminid self getinstancesnb this helper comput set attribut own uml class name contextu state machin context umldi statemachin return set umldi attribut helper context umldi statemachin def getvari set umldi attribut umldi attribut allinst select owner oclistypeof umldi class owner name self name this helper comput messag receipt oper own associ class associ contextu transit context umldi transit return umldi oper helper context umldi transit def getmessag umldi oper let statemachin name string umldi statemachin allinst select transit includ self first name let guard name string self guard name umldi oper allinst select owner oclistypeof umldi associationclass select b receiv b name guard name select c c owner connect collect particip collect e e name includ statemachin name first this helper comput state machin name sourc class contextu associ class context umldi associationclass return umldi statemachin helper context umldi associationclass def getsourceprocess umldi statemachin let sourc name string self connect select isnavig first particip name umldi statemachin allinst select name sourc name first this helper comput state machin name target class contextu associ class context umldi associationclass return umldi statemachin helper context umldi associationclass def gettargetprocess umldi statemachin let target name string self connect select isnavig first particip name umldi statemachin allinst select name target name first rule rule model program this rule generat structur root program element uml model rule model program model umldi model prg ambl program name model name process umldi statemachin allinst network umldi associationclass allinst rule statemachin process this rule generat ambl process state transit initi action uml state machin it also generat id variabl associ creat ambl process rule statemachin process statemachin umldi statemachin use crt class umldi class umldi class allinst select name statemachin name first process ambl process name statemachin name instancesnb crt class getinstancesnb minid crt class getminid maxid crt class getmaxid state statemachin top subvertex select ocliskindof umldi simplest transit statemachin transit initi statemachin top subvertex select ocliskindof umldi pseudost collect outgo collect e e effect flatten first variabl statemachin getvari connectedto umldi associationclass allinst select e e connect collect particip name includ statemachin name rule attribut variabl this rule generat ambl process variabl uml attribut defin within context uml class rule attribut variabl attribut umldi attribut attribut owner oclistypeof umldi class variabl ambl variabl name attribut name type attribut type name initvalu attribut initialvalu bodi rule state state this rule generat ambl state name incom outgo transit uml simpl state the isiniti properti comput check one incom transit initialt uml pseudost rule state state uml state umldi simplest ambl state ambl state name uml state name isiniti uml state incom collect e e sourc select ocliskindof umldi pseudost isempti incom uml state incom outgo uml state outgo rule transit tran this rule generat structur root program element input element contain monitor rule transit tran uml tran umldi transit uml tran name receipt tran ambl tran sourc uml tran sourc target uml tran target guard uml tran guard action uml tran effect waitfor uml tran getmessag rule transit transal this rule generat structur root program element input element contain monitor rule transit transal uml tran umldi transit uml tran name receipt ani tran ambl transal sourc uml tran sourc target uml tran target guard uml tran guard action uml tran effect waitfor uml tran getmessag rule transit stran this rule generat structur root program element input element contain monitor rule transit stran uml tran umldi transit uml tran name oclisundefin uml tran name condit uml tran sourc ocliskindof umldi simplest tran ambl stran sourc uml tran sourc target uml tran target guard uml tran guard action uml tran effect rule guard guard this rule generat ambl guard uml guard rule guard guard uml guard umldi guard ambl guard ambl guard name uml guard name rule effect action this rule generat ambl action uml effect rule effect action effect umldi callact action ambl action name effect name rule class network this rule generat rule class network class umldi associationclass net ambl network name class name channel new channel new channel ambl channel name class name messag class featur sourc class getsourceprocess target class gettargetprocess rule oper messag this rule generat rule oper messag oper umldi oper oper owner oclistypeof umldi associationclass messag ambl messag name oper name,0
201,201,P88-AnyLogic2XML.atl,"-- @atlcompiler atl2006
module AnyLogic2XML; -- Module Template
create OUT : XML from IN : AnyLogic  ;

abstract rule ModelElement {
	from 
		i: AnyLogic!ModelElement
	to
		id: XML!Element (
			name <- 'Id',
			children <- Sequence{idT}
		),
		idT: XML!Text (
			value <- i.id.toString()
		),
		name: XML!Element (
			name <- 'Name',
			children <- Sequence{nameT}
		),
		nameT: XML!Text (
			value <- i.name
		),
		efb: XML!Element (
			name <- 'ExcludeFromBuild',
			children <- Sequence{efbT}
		) ,
		efbT: XML!Text (
			value <- i.excludeFromBuild.toString()
		)  
}

abstract rule VisualModelElement extends ModelElement {
	from 
		i: AnyLogic!VisualModelElement
	to
		positionX: XML!Element (
			name <- 'X',
			children <- Sequence{positionXT}
		),
		positionXT: XML!Text (
			value <- i.position.x.toString()
		) ,
		positionY: XML!Element (
			name <- 'Y',
			children <- Sequence{positionYT}
		),
		positionYT: XML!Text (
			value <- i.position.y.toString()
		),
		
		label: XML!Element (
			name <- 'Label',
			children <- Sequence{labelX, labelY}			
		),
		labelX: XML!Element (
			name <- 'X',
			children <- Sequence{labelXT}
		),
		labelXT: XML!Text (
			value <- i.label.x.toString()
		) ,
		labelY: XML!Element (
			name <- 'Y',
			children <- Sequence{labelYT}
		),
		labelYT: XML!Text (
			value <- i.label.y.toString()
		),

		publicFlag: XML!Element (
			name <- 'PublicFlag',
			children <- Sequence{publicFlagT}
		),
		publicFlagT: XML!Text (
			value <- i.publicFlag.toString()
		),
		presentationFlag: XML!Element (
			name <- 'PresentationFlag',
			children <- Sequence{presentationFlagT}
		) ,
		presentationFlagT: XML!Text (
			value <- i.presentationFlag.toString()
		),
		showLabel: XML!Element (
			name <- 'ShowLabel',
			children <- Sequence{showLabelT}
		) ,
		showLabelT: XML!Text (
			value <- i.showLabel.toString()
		)
 
}



rule Model extends ModelElement {
	from 
		i: AnyLogic!Model
	to
		o: XML!Root (
			name <- 'AnyLogicWorkspace',
			children <- Sequence{WV_Att,ALV_Att,AV_Att,model}
		),
		model: XML!Element (
			name <- 'Model',
			children <- Sequence{id,name,efb,ev,jpn,aoClasses,experiments}
		),
		WV_Att: XML!Attribute (
			name <- 'WorkspaceVersion',
			value <- '1.9'
		),
		ALV_Att: XML!Attribute (
			name <- 'AnyLogicVersion',
			value <- '6.0.0'
		),
		AV_Att: XML!Attribute (
			name <- 'AlpVersion',
			value <- '6.0.10'
		),
		ev: XML!Element (
			name <- 'EngineVersion',
			children <- Sequence{evT}
		),
		evT: XML!Text (
			value <- i.engineVersion.toString()
		),
		jpn: XML!Element (
			name <- 'JavaPackageName',
			children <- Sequence{jpnT}
		),
		jpnT: XML!Text (
			value <- i.javaPackageName
		),		
		aoClasses : XML!Element (
			name <- 'ActiveObjectClasses',
			children <- i.activeObjectClasses
		),
		experiments : XML!Element (
			name <- 'Experiments',
			children <- i.experiments
		)
		
}

rule ActiveObjectClass extends ModelElement {
	from
		i: AnyLogic!ActiveObjectClass
	to
		aoc: XML!Element (
			name <- 'ActiveObjectClass',
			children <- Sequence{id,name,efb,catl,ptgp,ptgp,itgp,generic,genericP,agent,agentP,connectors,eObjects,shapes} 
		),
		catl: XML!Element (
			name <- 'ClientAreaTopLeft',
			children <- Sequence{catlX,catlY}
		),	
		catlX: XML!Element (
			name <- 'X',
			children <- Sequence{catlXT}
		),
		catlXT: XML!Text (
			value <- i.clientAreaTopLeft.x.toString()
		),
		catlY: XML!Element (
			name <- 'Y',
			children <- Sequence{catlYT}
		),
		catlYT: XML!Text (
			value <- i.clientAreaTopLeft.y.toString()
		),
        ptgp: XML!Element (
        	name <- 'PresentationTopGroupPersistent',
			children <- Sequence{ptgpT}
		),
        ptgpT: XML!Text (
			value <- i.presentationTopGroupPersistent.toString()
		),
		itgp: XML!Element (
        	name <- 'IconTopGroupPersistent',
			children <- Sequence{itgpT}
		),
		itgpT: XML!Text (
			value <- i.iconTopGroupPersistent.toString()
		),
		generic: XML!Element (
        	name <- 'Generic',
			children <- Sequence{genericT}
		),
		genericT: XML!Text (
			value <- i.generic.toString()
		),
        genericP: XML!Element (
        	name <- 'GenericParameters',
			children <- Sequence{genericPT}
		),
	   genericPT: XML!Text (
			value <- i.genericParameters
		),
        agent: XML!Element (
        	name <- 'Agent',
			children <- Sequence{agentT}
		),
        agentT: XML!Text (
			value <- i.agent.toString()
		),
		agentP : XML!Element (
			name <- 'AgentProperties',
			children <- Sequence{edil}
		),
		edil : XML!Element (
			name <- 'EnvironmentDefinesInitialLocation',
			children <- Sequence{edilT}
		),
		edilT : XML!Text (
			value <- i.environmentDefinesInitialLocation.toString()
		),
			
		connectors: XML!Element (
			name <- 'Connectors',
			children <- i.connectors
		),
		
		eObjects: XML!Element (
			name <- 'EmbeddedObjects',
		    children <- i.embeddedObjects
		),
		
		shapes: XML!Element(
			name <- 'Shapes',
			children <- i.shapes
		)
}

rule  EmbeddedObjectPresentation extends VisualModelElement{
	from
		i: AnyLogic!EmbeddedObjectPresentation
	to
		o: XML!Element (
			name <- 'EmbeddedObjectPresentation',
			children <- Sequence{id,name,efb,positionX,positionY,label,publicFlag,presentationFlag,showLabel,asObject,eIcon,rotation}
		),
		asObject: XML!Element (
			name <- 'AsObject',
			children <- Sequence{asObjectT}
		),
		asObjectT: XML!Text (
			value <- i.asObject.toString()
		),
		eIcon: XML!Element (
			name <- 'EmbeddedIcon',
			children <- Sequence{eIconT}
		),
		eIconT: XML!Text (
			value <- i.embeddedIcon.toString()
		),
		rotation: XML!Element (
			name <- 'Rotation',
			children <- Sequence{rotationT}
		),
		rotationT: XML!Text (
			value <- i.rotation.toString()
		)
}

rule Connector extends VisualModelElement {
	from 
		i: AnyLogic!Connector
	to
	    connector: XML!Element (
	    	name <- 'Connector',
			children <- Sequence{id,name,efb,positionX,positionY,label,publicFlag,presentationFlag,showLabel,seObject,scName,teObject,tcName,points}
	    ),
    	seObject: XML!Element (
    		name <- 'SourceEmbeddedObject',
			children <- Sequence{seObjectT}
    	),	
		seObjectT: XML!Text (
			value <- i.sourceEmbeddedObject.id.toString()
    	),	
		scName: XML!Element (
			name <- 'SourceConnectableName',
			children <- Sequence{scNameT}
		),
		scNameT: XML!Text (
			value <- i.sourceConnectableName
		),
    	teObject: XML!Element (
    		name <- 'TargetEmbeddedObject',
			children <- Sequence{teObjectT}
    	),	
		teObjectT: XML!Text (
			value <- i.targetEmbeddedObject.id.toString()
    	),	
		tcName: XML!Element (
			name <- 'TargetConnectableName',
			children <- Sequence{tcNameT}
		),
		tcNameT: XML!Text (
			value <- i.targetConnectableName
		),
		points: XML!Element (
			name <- 'Points',
			children <- i.points
		)
}

rule Point {
	from 
		i: AnyLogic!Point
	to
		o: XML!Element (
			name <- 'Point',
			children <- Sequence{x,y}
		),
		x: XML!Element (
			name <- 'X',
			children <- Sequence{xT}
		),
		xT: XML!Text (
			value <- i.x.toString()
		) ,
		y: XML!Element (
			name <- 'Y',
			children <- Sequence{yT}
		),
		yT: XML!Text (
			value <- i.y.toString()
		) 
}
   
rule EmbeddedObject extends VisualModelElement {
	from 
		i: AnyLogic!EmbeddedObject
	to
		embeddedObject: XML!Element (
	    	name <- 'EmbeddedObject',
			children <- Sequence{id,name,efb,positionX,positionY,label,publicFlag,presentationFlag,showLabel,presentationId,i.activeObjectClass,gps,parameters}
	    ),	
		presentationId: XML!Element (
			name <- 'PresentationId',
			children <- Sequence{presentationIdT}
		),
		presentationIdT: XML!Text (
			value <- i.presentation.id.toString()
		),
		gps: XML!Element (
			name <- 'GenericParametersSubstitute',
			children <- Sequence{gpsT}
		),
		gpsT: XML!Text (
			value <- i.genericParametersSubstitute.toString()
		),
		
		parameters: XML!Element (
			name <- 'Parameters',
			children <- i.parameters
		)
}

	
rule ActiveObjectClassRef {
	from
		i: AnyLogic!ActiveObjectClassRef
	to
	   o: XML!Element (
			name <- 'ActiveObjectClass',
			children <- Sequence{package,className}
		),
		package: XML!Element (
			name <- 'PackageName',
			children <- Sequence{packageT}
		),
		packageT: XML!Text (
			value <- i.packageName
		),
		className: XML!Element (
			name <- 'ClassName',
			children <- Sequence{classNameT}
		),
		classNameT: XML!Text (
			value <- i.className
		)
}

rule Parameter {
	from 
		i: AnyLogic!Parameter
	to
	    o: XML!Element (
			name <- 'Parameter',
			children <- Sequence{name,value}
		),
		name: XML!Element (
			name <- 'Name',
			children <- Sequence{nameT}
		),
		nameT: XML!Text (
			value <- i.name
		),
		value: XML!Element (
			name <- 'Value',
			children <- Sequence{valueT}
		),
		valueT: XML!Text (
			value <- i.value
		)
}

rule SimulationExperiment extends ModelElement {
	from
		i: AnyLogic!SimulationExperiment
	to
		o: XML!Element (
			name <- 'SimulationExperiment',
			children <- Sequence{aoc,id,name,efb,catl,ptgp,itgp,frame,cla,maxMem,randomSeed,seedValue,
				vmArgs,absAcc,relAcc,timeAcc,fixedTimeStep,shapes,controls,parameters,presentationProperties,timeProperties}
			
		),
		aoc: XML!Attribute (
			name <- 'ActiveObjectClassId',
			value <- i.activeObjectClass.id.toString()
		),
		catl: XML!Element (
			name <- 'ClientAreaTopLeft',
			children <- Sequence{catlX,catlY}
		),	
		catlX: XML!Element (
			name <- 'X',
			children <- Sequence{catlXT}
		),
		catlXT: XML!Text (
			value <- i.clientAreaTopLeft.x.toString()
		),
		catlY: XML!Element (
			name <- 'Y',
			children <- Sequence{catlYT}
		),
		catlYT: XML!Text (
			value <- i.clientAreaTopLeft.y.toString()
		),
		
        ptgp: XML!Element (
        	name <- 'PresentationTopGroupPersistent',
			children <- Sequence{ptgpT}
		),
        ptgpT: XML!Text (
			value <- i.presentationTopGroupPersistent.toString()
		),
		
		itgp: XML!Element (
        	name <- 'IconTopGroupPersistent',
			children <- Sequence{itgpT}
		),
		itgpT: XML!Text (
			value <- i.iconTopGroupPersistent.toString()
		),		

        frame: XML!Element (
        	name <- 'Frame',
			children <- Sequence{positionX,positionY,width,height}
		),		
		positionX: XML!Element (
			name <- 'X',
			children <- Sequence{positionXT}
		),
		positionXT: XML!Text (
			value <- i.frame.x.toString()
		) ,
		positionY: XML!Element (
			name <- 'Y',
			children <- Sequence{positionYT}
		),
		positionYT: XML!Text (
			value <- i.frame.y.toString()
		),
		width: XML!Element (
			name <- 'Width',
			children <- Sequence{widthT}
		),
		widthT: XML!Text (
			value <- i.frame.width.toString()
		) ,
		height: XML!Element (
			name <- 'Height',
			children <- Sequence{heightT}
		),
		heightT: XML!Text (
			value <- i.frame.height.toString()
		) ,

		cla: XML!Element (
			name <- 'CommandLineArguments',
			children <- Sequence{claT}
		),
		claT: XML!Text (
			value <- i.commandLineArguments.toString()
		),
		
		maxMem: XML!Element (
			name <- 'MaximumMemory',
			children <- Sequence{maxMemT}
		) ,
		maxMemT: XML!Text (
			value <- i.maximumMemory.toString()
		),
		
		randomSeed: XML!Element (
			name <- 'RandomSeed',
			children <- Sequence{randomSeedT}
		),
		randomSeedT: XML!Text (
			value <- i.randomSeed.toString()
		),
		
		seedValue: XML!Element (
			name <- 'SeedValue',
			children <- Sequence{seedValueT}
		),
		seedValueT: XML!Text (
			value <- i.seedValue.toString()
		),
		
		vmArgs: XML!Element (
			name <- 'VmArgs',
			children <- Sequence{vmArgsT}
		),
		vmArgsT: XML!Text (
			value <- i.vmArgs
		),
		
		absAcc: XML!Element (
			name <- 'AbsoluteAccuracy',
			children <- Sequence{absAccT}
		),
		absAccT: XML!Text (
			value <- i.absoluteAccuracy.toString()
		),
		
		relAcc: XML!Element (
			name <- 'RelativeAccuracy',
			children <- Sequence{relAccT}
		),
		relAccT: XML!Text (
			value <- i.relativeAccuracy.toString()
		),
		
		timeAcc: XML!Element (
			name <- 'TimeAccuracy',
			children <- Sequence{timeAccT}
		),
		timeAccT: XML!Text (
			value <- i.timeAccuracy.toString()
		),

		fixedTimeStep: XML!Element (
			name <- 'FixedTimeStep',
			children <- Sequence{fixedTimeStepT}
		),
		fixedTimeStepT: XML!Text (
			value <- i.fixedTimeStep.toString()
		),
		
		shapes: XML!Element (
			name <- 'Shapes',
			children <- i.shapes
		),
			
		controls: XML!Element (
			name <- 'Controls',
			children <- i.controls
		),
		parameters: XML!Element (
			name <- 'Parameters',
			children <- Sequence{}
		),
		presentationProperties: XML!Element (
			name <- 'PresentationProperties',
			children <- Sequence{enableAdaptiveFrameManagement,enableAntiAliasing,enablePanning,enableZoom,
				executionMode,cpuRatio,title,framesPerSecond,realTimeScale,uiProperties}
		),
		enableAdaptiveFrameManagement: XML!Attribute (
			name <- 'EnableAdaptiveFrameManagement',
			value <- i.enableAdaptiveFrameManagement.toString()
		),
		enableAntiAliasing: XML!Attribute (
			name <- 'EnableAntiAliasing',
			value <- i.enableAntiAliasing.toString()
		),
		enablePanning: XML!Attribute (
			name <- 'EnablePanning',
			value <- i.enablePanning.toString()
		),
		enableZoom: XML!Attribute (
			name <- 'EnableZoom',
			value <- i.enableZoom.toString()
		),
		executionMode: XML!Element (
			name <- 'ExecutionMode',
			children <- Sequence{executionModeT}
		),
		executionModeT: XML!Text (
			value <- i.executionMode.toString()
		),
		cpuRatio: XML!Element (
			name <- 'CpuRatio',
			children <- Sequence{cpuRatioT}
		),
		cpuRatioT: XML!Text (
			value <- i.cpuRatio.toString()
		),
		title: XML!Element (
			name <- 'Title',
			children <- Sequence{titleT}
		),
		titleT: XML!Text (
			value <- i.title.toString()
		),
		framesPerSecond: XML!Element (
			name <- 'FramesPerSecond',
			children <- Sequence{framesPerSecondT}
		),
		framesPerSecondT: XML!Text (
			value <- i.framesPerSecond.toString()
		),		
 		realTimeScale: XML!Element (
			name <- 'RealTimeScale',
			children <- Sequence{realTimeScaleT}
		),
		realTimeScaleT: XML!Text (
			value <- i.realTimeScale.toString()
		),
		uiProperties: distinct XML!Element foreach (e in i.uiProperties)(
			name <- 'UIProperty'
		),
		uipName: distinct XML!Attribute foreach (e in i.uiProperties) (
			name <- 'Name',
			value <- e.name
		),	
		uipValue: distinct XML!Attribute foreach (e in i.uiProperties) (
			name <- 'Value',
			value <- e.value
		),		

		timeProperties: XML!Element (
			name <- 'ModelTimeProperties',
			children <- Sequence{useCalendar,stopOption,initialTime,finalTime,modelTimeUnit}
		),
		useCalendar: XML!Attribute (
			name <- 'UseCalendar',
			value <- i.useCalendar.toString()
		),	
		stopOption: XML!Element (
			name <- 'StopOption',
			children <- Sequence{stopOptionT}
		),
		stopOptionT: XML!Text (
			value <- i.stopOption
		),
		initialTime: XML!Element (
			name <- 'InitialTime',
			children <- Sequence{initialTimeT}
		),
		initialTimeT: XML!Text (
			value <- i.initialTime
		),		
		finalTime: XML!Element (
			name <- 'FinalTime',
			children <- Sequence{finalTimeT}
		),
		finalTimeT: XML!Text (
			value <- i.finalTime
		),				
		modelTimeUnit: XML!Element (
			name <- 'ModelTimeUnit',
			children <- Sequence{modelTimeUnitT}
		),
		modelTimeUnitT: XML!Text (
			value <- i.modelTimeUnit
		)
	do {
		for (e in uiProperties) {
			e.children <- Sequence{uipName->at(uiProperties.indexOf(e)),uipValue->at(uiProperties.indexOf(e))};
		}
	}
}

rule Text extends VisualModelElement {
	from 
		i: AnyLogic!Text
	to
		o: XML!Element (
			name <- 'Text',
			children <- Sequence{id,name,efb,positionX,positionY,label,publicFlag,presentationFlag,showLabel,
				asObject,eIcon,rotation,color,text,font,alignment}
			
		),
		asObject: XML!Element (
			name <- 'AsObject',
			children <- Sequence{asObjectT}
		),
		asObjectT: XML!Text (
			value <- i.asObject.toString()
		),
		eIcon: XML!Element (
			name <- 'EmbeddedIcon',
			children <- Sequence{eIconT}
		),
		eIconT: XML!Text (
			value <- i.embeddedIcon.toString()
		),
		rotation: XML!Element (
			name <- 'Rotation',
			children <- Sequence{rotationT}
		),
		rotationT: XML!Text (
			value <- i.rotation.toString()
		),
		color: XML!Element (
			name <- 'Color',
			children <- Sequence{colorT}
		),
		colorT: XML!Text (
			value <- i.color.toString()
		),
		text: XML!Element (
			name <- 'Text',
			children <- Sequence{textT}
		),
		textT: XML!Text (
			value <- i.text
		),
		font: XML!Element (
			name <- 'Font',
			children <- Sequence{fName,fSize,fStyle}
		),
		fName: XML!Element (
			name <- 'Name',
			children <- Sequence{fNameT}
		),
		fNameT: XML!Text (
			value <- i.font.name
		),		
		fSize: XML!Element (
			name <- 'Size',
			children <- Sequence{fSizeT}
		),
		fSizeT: XML!Text (
			value <- i.font.size.toString()
		),	
		fStyle: XML!Element (
			name <- 'Style',
			children <- Sequence{fStyleT}
		),
		fStyleT: XML!Text (
			value <- i.font.style.toString()
		),	
		alignment: XML!Element (
			name <- 'Alignment',
			children <- Sequence{alignmentT}
		),
		alignmentT: XML!Text (
			value <- i.alignment
		)
}

rule Button extends VisualModelElement {
	from 
		i: AnyLogic!Button
	to
		o: XML!Element (
			name <- 'Control',
			children <- Sequence{button,id,name,efb,positionX,positionY,label,publicFlag,presentationFlag,showLabel,
				basicProperties,extendedProperties}
			
		),
		button: XML!Attribute (
			name <- 'Type',
			value <- 'Button'
		),			
		basicProperties: XML!Element (
			name <- 'BasicProperties',
			children <- Sequence{width, height, asObject, color, enableExpression, actionCode}
		),	
		width: XML!Attribute (
			name <- 'Width',
			value <- i.width.toString()
		),
		height: XML!Attribute (
			name <- 'Height',
			value <- i.height.toString()
		),
		asObject: XML!Attribute (
			name <- 'AsObject',
			value <- i.asObject.toString()
		),
		embeddedIcon: XML!Element (
			name <- 'EmbeddedIcon',
			children <- Sequence{embeddedIconT}
		),
		embeddedIconT: XML!Text (
			value <- i.embeddedIcon.toString()
		),
		color: XML!Element (
			name <- 'TextColor',
			children <- Sequence{colorT}
		),
		colorT: XML!Text (
			value <- i.textColor.toString()
		),
		enableExpression: XML!Element (
			name <- 'EnableExpression',
			children <- Sequence{enableExpressionT}
		),
		enableExpressionT: XML!Text (
			value <- i.enableExpression.toString()
		),		
		actionCode: XML!Element (
			name <- 'ActionCode',
			children <- Sequence{actionCodeT}
		),
		actionCodeT: XML!Text (
			value <- i.actionCode.toString()
		),		
		
		extendedProperties: XML!Element (
			name <- 'ExtendedProperties',
			children <- Sequence{text, font}
		),	
		text: XML!Element (
			name <- 'LabelText',
			children <- Sequence{textT}
		),
		textT: XML!Text (
			value <- i.labelText
		),
		font: XML!Element (
			name <- 'Font',
			children <- Sequence{fName,fSize,fStyle}
		),
		fName: XML!Attribute (
			name <- 'Name',
			value <- i.font.name
		),		
		fSize: XML!Attribute (
			name <- 'Size',
			value <- i.font.size.toString()
		),	
		fStyle: XML!Attribute (
			name <- 'Style',
			value <- i.font.style.toString()
		)
}

",atlcompil atl modul anylog xml modul templat creat out xml in anylog abstract rule modelel anylog modelel id xml element name id children sequenc idt idt xml text valu id tostr name xml element name name children sequenc namet namet xml text valu name efb xml element name excludefrombuild children sequenc efbt efbt xml text valu excludefrombuild tostr abstract rule visualmodelel extend modelel anylog visualmodelel positionx xml element name x children sequenc positionxt positionxt xml text valu posit x tostr positioni xml element name y children sequenc positionyt positionyt xml text valu posit tostr label xml element name label children sequenc labelx labe labelx xml element name x children sequenc labelxt labelxt xml text valu label x tostr labe xml element name y children sequenc labelyt labelyt xml text valu label tostr publicflag xml element name publicflag children sequenc publicflagt publicflagt xml text valu publicflag tostr presentationflag xml element name presentationflag children sequenc presentationflagt presentationflagt xml text valu presentationflag tostr showlabel xml element name showlabel children sequenc showlabelt showlabelt xml text valu showlabel tostr rule model extend modelel anylog model xml root name anylogicworkspac children sequenc wv att alv att av att model model xml element name model children sequenc id name efb ev jpn aoclass experi wv att xml attribut name workspacevers valu alv att xml attribut name anylogicvers valu av att xml attribut name alpvers valu ev xml element name enginevers children sequenc evt evt xml text valu enginevers tostr jpn xml element name javapackagenam children sequenc jpnt jpnt xml text valu javapackagenam aoclass xml element name activeobjectclass children activeobjectclass experi xml element name experi children experi rule activeobjectclass extend modelel anylog activeobjectclass aoc xml element name activeobjectclass children sequenc id name efb catl ptgp ptgp itgp generic genericp agent agentp connector eobject shape catl xml element name clientareatopleft children sequenc catlx cat catlx xml element name x children sequenc catlxt catlxt xml text valu clientareatopleft x tostr cat xml element name y children sequenc catlyt catlyt xml text valu clientareatopleft tostr ptgp xml element name presentationtopgrouppersist children sequenc ptgpt ptgpt xml text valu presentationtopgrouppersist tostr itgp xml element name icontopgrouppersist children sequenc itgpt itgpt xml text valu icontopgrouppersist tostr generic xml element name generic children sequenc generict generict xml text valu generic tostr genericp xml element name genericparamet children sequenc genericpt genericpt xml text valu genericparamet agent xml element name agent children sequenc agentt agentt xml text valu agent tostr agentp xml element name agentproperti children sequenc edil edil xml element name environmentdefinesinitialloc children sequenc edilt edilt xml text valu environmentdefinesinitialloc tostr connector xml element name connector children connector eobject xml element name embeddedobject children embeddedobject shape xml element name shape children shape rule embeddedobjectpresent extend visualmodelel anylog embeddedobjectpresent xml element name embeddedobjectpresent children sequenc id name efb positionx positioni label publicflag presentationflag showlabel asobject eicon rotat asobject xml element name asobject children sequenc asobjectt asobjectt xml text valu asobject tostr eicon xml element name embeddedicon children sequenc eicont eicont xml text valu embeddedicon tostr rotat xml element name rotat children sequenc rotationt rotationt xml text valu rotat tostr rule connector extend visualmodelel anylog connector connector xml element name connector children sequenc id name efb positionx positioni label publicflag presentationflag showlabel seobject scname teobject tcname point seobject xml element name sourceembeddedobject children sequenc seobjectt seobjectt xml text valu sourceembeddedobject id tostr scname xml element name sourceconnectablenam children sequenc scnamet scnamet xml text valu sourceconnectablenam teobject xml element name targetembeddedobject children sequenc teobjectt teobjectt xml text valu targetembeddedobject id tostr tcname xml element name targetconnectablenam children sequenc tcnamet tcnamet xml text valu targetconnectablenam point xml element name point children point rule point anylog point xml element name point children sequenc x x xml element name x children sequenc xt xt xml text valu x tostr xml element name y children sequenc yt yt xml text valu tostr rule embeddedobject extend visualmodelel anylog embeddedobject embeddedobject xml element name embeddedobject children sequenc id name efb positionx positioni label publicflag presentationflag showlabel presentationid activeobjectclass gps paramet presentationid xml element name presentationid children sequenc presentationidt presentationidt xml text valu present id tostr gps xml element name genericparameterssubstitut children sequenc gpst gpst xml text valu genericparameterssubstitut tostr paramet xml element name paramet children paramet rule activeobjectclassref anylog activeobjectclassref xml element name activeobjectclass children sequenc packag classnam packag xml element name packagenam children sequenc packaget packaget xml text valu packagenam classnam xml element name classnam children sequenc classnamet classnamet xml text valu classnam rule paramet anylog paramet xml element name paramet children sequenc name valu name xml element name name children sequenc namet namet xml text valu name valu xml element name valu children sequenc valuet valuet xml text valu valu rule simulationexperi extend modelel anylog simulationexperi xml element name simulationexperi children sequenc aoc id name efb catl ptgp itgp frame cla maxmem randomse seedvalu vmarg absacc relacc timeacc fixedtimestep shape control paramet presentationproperti timeproperti aoc xml attribut name activeobjectclassid valu activeobjectclass id tostr catl xml element name clientareatopleft children sequenc catlx cat catlx xml element name x children sequenc catlxt catlxt xml text valu clientareatopleft x tostr cat xml element name y children sequenc catlyt catlyt xml text valu clientareatopleft tostr ptgp xml element name presentationtopgrouppersist children sequenc ptgpt ptgpt xml text valu presentationtopgrouppersist tostr itgp xml element name icontopgrouppersist children sequenc itgpt itgpt xml text valu icontopgrouppersist tostr frame xml element name frame children sequenc positionx positioni width height positionx xml element name x children sequenc positionxt positionxt xml text valu frame x tostr positioni xml element name y children sequenc positionyt positionyt xml text valu frame tostr width xml element name width children sequenc widtht widtht xml text valu frame width tostr height xml element name height children sequenc heightt heightt xml text valu frame height tostr cla xml element name commandlineargu children sequenc clat clat xml text valu commandlineargu tostr maxmem xml element name maximummemori children sequenc maxmemt maxmemt xml text valu maximummemori tostr randomse xml element name randomse children sequenc randomseedt randomseedt xml text valu randomse tostr seedvalu xml element name seedvalu children sequenc seedvaluet seedvaluet xml text valu seedvalu tostr vmarg xml element name vmarg children sequenc vmargst vmargst xml text valu vmarg absacc xml element name absoluteaccuraci children sequenc absacct absacct xml text valu absoluteaccuraci tostr relacc xml element name relativeaccuraci children sequenc relacct relacct xml text valu relativeaccuraci tostr timeacc xml element name timeaccuraci children sequenc timeacct timeacct xml text valu timeaccuraci tostr fixedtimestep xml element name fixedtimestep children sequenc fixedtimestept fixedtimestept xml text valu fixedtimestep tostr shape xml element name shape children shape control xml element name control children control paramet xml element name paramet children sequenc presentationproperti xml element name presentationproperti children sequenc enableadaptiveframemanag enableantialias enablepan enablezoom executionmod cpuratio titl framespersecond realtimescal uiproperti enableadaptiveframemanag xml attribut name enableadaptiveframemanag valu enableadaptiveframemanag tostr enableantialias xml attribut name enableantialias valu enableantialias tostr enablepan xml attribut name enablepan valu enablepan tostr enablezoom xml attribut name enablezoom valu enablezoom tostr executionmod xml element name executionmod children sequenc executionmodet executionmodet xml text valu executionmod tostr cpuratio xml element name cpuratio children sequenc cpuratiot cpuratiot xml text valu cpuratio tostr titl xml element name titl children sequenc titlet titlet xml text valu titl tostr framespersecond xml element name framespersecond children sequenc framespersecondt framespersecondt xml text valu framespersecond tostr realtimescal xml element name realtimescal children sequenc realtimescalet realtimescalet xml text valu realtimescal tostr uiproperti distinct xml element foreach e uiproperti name uiproperti uipnam distinct xml attribut foreach e uiproperti name name valu e name uipvalu distinct xml attribut foreach e uiproperti name valu valu e valu timeproperti xml element name modeltimeproperti children sequenc usecalendar stopopt initialtim finaltim modeltimeunit usecalendar xml attribut name usecalendar valu usecalendar tostr stopopt xml element name stopopt children sequenc stopoptiont stopoptiont xml text valu stopopt initialtim xml element name initialtim children sequenc initialtimet initialtimet xml text valu initialtim finaltim xml element name finaltim children sequenc finaltimet finaltimet xml text valu finaltim modeltimeunit xml element name modeltimeunit children sequenc modeltimeunitt modeltimeunitt xml text valu modeltimeunit e uiproperti e children sequenc uipnam uiproperti indexof e uipvalu uiproperti indexof e rule text extend visualmodelel anylog text xml element name text children sequenc id name efb positionx positioni label publicflag presentationflag showlabel asobject eicon rotat color text font align asobject xml element name asobject children sequenc asobjectt asobjectt xml text valu asobject tostr eicon xml element name embeddedicon children sequenc eicont eicont xml text valu embeddedicon tostr rotat xml element name rotat children sequenc rotationt rotationt xml text valu rotat tostr color xml element name color children sequenc colort colort xml text valu color tostr text xml element name text children sequenc textt textt xml text valu text font xml element name font children sequenc fname fsize fstyle fname xml element name name children sequenc fnamet fnamet xml text valu font name fsize xml element name size children sequenc fsizet fsizet xml text valu font size tostr fstyle xml element name style children sequenc fstylet fstylet xml text valu font style tostr align xml element name align children sequenc alignmentt alignmentt xml text valu align rule button extend visualmodelel anylog button xml element name control children sequenc button id name efb positionx positioni label publicflag presentationflag showlabel basicproperti extendedproperti button xml attribut name type valu button basicproperti xml element name basicproperti children sequenc width height asobject color enableexpress actioncod width xml attribut name width valu width tostr height xml attribut name height valu height tostr asobject xml attribut name asobject valu asobject tostr embeddedicon xml element name embeddedicon children sequenc embeddedicont embeddedicont xml text valu embeddedicon tostr color xml element name textcolor children sequenc colort colort xml text valu textcolor tostr enableexpress xml element name enableexpress children sequenc enableexpressiont enableexpressiont xml text valu enableexpress tostr actioncod xml element name actioncod children sequenc actioncodet actioncodet xml text valu actioncod tostr extendedproperti xml element name extendedproperti children sequenc text font text xml element name labeltext children sequenc textt textt xml text valu labeltext font xml element name font children sequenc fname fsize fstyle fname xml attribut name name valu font name fsize xml attribut name size valu font size tostr fstyle xml attribut name style valu font style tostr,11
202,202,P88-UML2AnyLogic.atl,"-- @atlcompiler atl2006
module UML2AnyLogic; -- Module Template

create OUT : AnyLogic from IN : UML, IN_DI : DI;

--- !!! HELPER !!! ---

--default values for missing annotations
helper def : defaultCPUTime  : Real = 60;
helper def : defaultDBAccess : Integer = 0;
helper def : defaultDBRows   : Integer = 0;

helper def : defaultProbability : Real = 0.5;

helper def : defaultRate      : Real = 120;

--to scale the presentation
helper def : scaleFactor : Real = 1.2;

--counter to generate unique IDs use by AnyLogic
helper def : idCounter   : Integer = 1000;

--helper to clean a string to a valid Java identifier which is required for names in AnyLogic
helper context String def : clean() : String = 
	self.regexReplaceAll('[^a-zA-Z_0-9]','');

--helper to access an applied stereotype from the PerformanceProfile
helper context UML!Element def : getPerformanceAnnotation(stereotype : String) :  OclAny = 
	if self.getAppliedStereotype('SPT::' + stereotype).oclIsUndefined()
		then OclUndefined
		else 
			self.getStereotypeApplication(self.getAppliedStereotype('SPT::' + stereotype))
	endif;

--helpers to retrieve diagram information from the DI input model
helper context UML!Element def : getVisual() : DI!GraphNode = 
	if (DI!GraphNode.allInstances()->select( e | e.semanticModel.element = self )->size() = 0)
		then OclUndefined
		else DI!GraphNode.allInstances()->select( e | e.semanticModel.element = self )->first()
	endif;

helper context UML!Activity def : getAllVisuals() : Sequence(DI!GraphNode) = 
	DI!GraphNode.allInstances()->select( e | 
		self.node->exists(e2 | e2 = e.semanticModel.element) or
		self.edge->exists(e2 | e2 = e.semanticModel.element)
	);

helper context UML!ActivityEdge def: getAllWaypoints() : Sequence(String) = 
	if (DI!GraphEdge.allInstances()->select( e | e.semanticModel.element = self )->size() = 0)
		then Sequence{}
		else 
			DI!GraphEdge.allInstances()->select( e | e.semanticModel.element = self )->first().waypoints
	endif;

helper context UML!Element def : getX() : Integer =
	if (DI!GraphNode.allInstances()->select( e | e.semanticModel.element = self )->size() = 0)
		then -200
		else DI!GraphNode.allInstances()->select( e | e.semanticModel.element = self )->first().getX()
	endif;

helper context UML!Element def : getY() : Integer =
	if (DI!GraphNode.allInstances()->select( e | e.semanticModel.element = self )->size() = 0)
		then 100
		else DI!GraphNode.allInstances()->select( e | e.semanticModel.element = self )->first().getY()
	endif;
	
helper context DI!GraphNode def : getX() : Integer = 
	((self.position.substring(self.position.indexOf('(') + 2,self.position.indexOf(',')).toInteger()) * thisModule.scaleFactor).round();

helper context DI!GraphNode def : getY() : Integer = 
	((self.position.substring(self.position.indexOf(',') + 3,self.position.indexOf(')')).toInteger()) * thisModule.scaleFactor).round();

helper context DI!GraphNode def: getName() :String =
	if(UML!Element.allInstances()->select(e  | e = self.semanticModel.element)->size() = 0)
		then ''
		else UML!Element.allInstances()->select(e | e = self.semanticModel.element)->first().name
	endif;

helper context String def : getWaypointX() : Integer = 
	((self.substring(self.indexOf('sourceX: ') + 10, self.indexOf('sourceY') - 2).toInteger()) * thisModule.scaleFactor).round();

helper context String def : getWaypointY() : Integer = 
	((self.substring(self.indexOf('sourceY: ') + 10, self.indexOf('targetX') - 2).toInteger()) * thisModule.scaleFactor).round();


-- !!! RULES !!! --- 

abstract rule ModelElement {
	from
	    i : UML!Element
	to
		o : AnyLogic!ModelElement (
			excludeFromBuild <- false,
			name <- i.name.clean()
		)	
}

rule EmbeddedObjectPresentation {
	from
		i : DI!GraphNode (
			i.semanticModel.element.oclIsKindOf(UML!ActivityNode)
		)
	to
		o : AnyLogic!EmbeddedObjectPresentation (
			excludeFromBuild <- false,
			name <-i.getName().clean(),
			position <- position,
        	label <- label,
        	publicFlag <- true,
	    	presentationFlag <- true,
			showLabel <- false,
			
			asObject <- false,
			embeddedIcon <- false,
			rotation <- 0.0		
		),
		label : AnyLogic!Point (
			x <- 10,
			y <- 0
		),
		position: AnyLogic!Point (
			x <- i.getX(),
			y <- i.getY()
		)
	do {
		thisModule.idCounter <- thisModule.idCounter + 1;
		o.id <- thisModule.idCounter;
		if (o.name.size() = 0) o.name <- 'presetation' + thisModule.idCounter.toString();
		else  o.name <- o.name + '_presentation' + thisModule.idCounter.toString();
	}
}

--the ""main"" model rule
rule Model extends ModelElement {
	from
	    i : UML!Model 
	to
		o : AnyLogic!Model (
			engineVersion <- 6,
		    javaPackageName <- i.name.clean().toLower(),
			activeObjectClasses <- UML!Activity.allInstances(),
			experiments <- Sequence{simulationExperiment}
		),

		-- One simulation experiment is created
		simulationExperiment: AnyLogic!SimulationExperiment (
			activeObjectClass <- UML!Activity.allInstances()->asSequence()->first(), --TODO ok, as long as there is only one activity
			
			excludeFromBuild <- false,
			name <- i.name.clean() + 'Simulation',
			
			clientAreaTopLeft <- expPos,
			presentationTopGroupPersistent <- true,
			iconTopGroupPersistent <- true,
			frame <- expFrame ,
			commandLineArguments <- '',
			maximumMemory <- 64,
			randomSeed <- false,
			seedValue <- 1,
			vmArgs <- '',
			absoluteAccuracy <- 0.00001,
			relativeAccuracy <- 0.00001,
			timeAccuracy <- 0.00001,
			fixedTimeStep <- 0.0010,
			shapes <- Sequence{expText1, expText2},
			controls <- Sequence{expButton},
			parameters <- Sequence{},

			enableAdaptiveFrameManagement <- true,
			enableAntiAliasing <- true,
			enablePanning <- true,
			enableZoom <- true,
			executionMode <- 'realTime',
			cpuRatio <- 'ratio_1_2',
			title <- i.name + ' : Derived Simulation',
			framesPerSecond <- '20.0',
			realTimeScale <- 'SCALE_1',
			uiProperties <- Sequence{uiP1,uiP2,uiP3,uiP4,uiP5,uiP6,uiP7,uiP8,uiP9,uiP11,uiP12,uiP13,uiP14,uiP15,uiP16},
		
		 	useCalendar <- false,
			stopOption <- 'Stop at specified time',
			initialTime <- '0.0',
			finalTime <- '100000.0',	
			modelTimeUnit <- 'Millisecond'
		),
		expPos: AnyLogic!Point (
			x <- 0,
			y <- 0
		),
		expFrame: AnyLogic!Frame (
			x <-0,
			y <-0,
			width <- 800,
			height <- 600
		),
		expText1: AnyLogic!Text (
			id <- 0,
			name <- 'generatedText1',
			excludeFromBuild <- false,
			position <- expText1Position,
        	label <- expText1Label,
			publicFlag <- true,
			presentationFlag <- true,
			showLabel <- false,
			asObject <- true,
			embeddedIcon <- false,
			rotation <- 0.0,
			color <- -16777216,
			text <- i.name + ' Simulation',
			font <- expText1Font,
			alignment <- 'LEFT'		
		),
		expText1Position : AnyLogic!Point (
			x <- 40,
			y <- 30
		),
		expText1Label: AnyLogic!Point (
			x <- 0,
			y <- 0
		),
		expText1Font: AnyLogic!Font (
			name <- 'Times New Roman',
			size <- 28,
			style <- 1		
		),
		expText2: AnyLogic!Text (
			id <- 0,
			name <- 'generatedText2',
			excludeFromBuild <- false,
			position <- expText2Position,
        	label <- expText2Label,
			publicFlag <- true,
			presentationFlag <- true,
			showLabel <- false,
			asObject <- true,
			embeddedIcon <- false,
			rotation <- 0.0,
			color <- -16777216,
			text <- 'Simulation generated from the UML model ' + i.name + '\nby the transformation developed in Task 4.2 of the MODELPLEX IP.',
			font <- expText2Font,
			alignment <- 'LEFT'		
		),
		expText2Position : AnyLogic!Point (
			x <- 40,
			y <- 63
		),
		expText2Label: AnyLogic!Point (
			x <- 0,
			y <- 0
		),
		expText2Font: AnyLogic!Font (
			name <- 'Times New Roman',
			size <- 16,
			style <- 2		
		),
		expButton: AnyLogic!Button (
			embeddedIcon <- false,				
			id <- 0,
			name <- 'generatedButton',
			excludeFromBuild <- false,
			position <- expButtonPosition,
        	label <- expButtonLabel,
			publicFlag <- true,
			presentationFlag <- true,
			showLabel <- false,
			width <- 220,
			height <- 30, 
			asObject <- true,
            embeddedIcon <- false,			
			textColor <- -16777216,
			enableExpression <- 'getState() == IDLE',
			actionCode <- 'run(); getEngine().getPresentation().setPresentable( getEngine().getRoot() );',
			labelText <- 'Run the simulation model and switch to Main view',
			font <- expButtonFont	
		),
		expButtonPosition : AnyLogic!Point (
			x <- 40,
			y <- 120
		),
		expButtonLabel: AnyLogic!Point (
			x <- 0,
			y <- 0
		),
		expButtonFont: AnyLogic!Font (
			name <- 'Tahoma',
			size <- 11,
			style <- 0		
		),
		uiP1: AnyLogic!Parameter (
			name <- 'Statusbar Memory',
			value <- 'true'
		),
		uiP2: AnyLogic!Parameter (
			name <- 'Statusbar Model Step',
			value <- 'false'
		),
		uiP3: AnyLogic!Parameter (
			name <- 'Experiment Progress',
			value <- 'false'
		),
		uiP4: AnyLogic!Parameter (
			name <- 'Toolbar Animation setup',
			value <- 'false'
		),
		uiP5: AnyLogic!Parameter (
			name <- 'Statusbar Status',
			value <- 'true'
		),
		uiP6: AnyLogic!Parameter (
			name <- 'Toolbar File',
			value <- 'false'
		),
		uiP7: AnyLogic!Parameter (
			name <- 'Toolbar Time scale setup',
			value <- 'true'
		),
		uiP8: AnyLogic!Parameter (
			name <- 'Toolbar Model navigation',
			value <- 'true'
		),
		uiP9: AnyLogic!Parameter (
			name <- 'Statusbar Real Time Of Simulation',
			value <- 'true'
		),
		uiP10: AnyLogic!Parameter (
			name <- 'Toolbar Execution control',
			value <- 'true'
		),
		uiP11: AnyLogic!Parameter (
			name <- 'Statusbar Model Time',
			value <- 'false'
		),
		uiP12: AnyLogic!Parameter (
			name <- 'Statusbar Events Per Second',
			value <- 'false'
		),
		uiP13: AnyLogic!Parameter (
			name <- 'Toolbar View',
			value <- 'false'
		),
		uiP14: AnyLogic!Parameter (
			name <- 'Simulation Progress',
			value <- 'true'
		),
		uiP15: AnyLogic!Parameter (
			name <- 'Statusbar Frames Per Second',
			value <- 'false'
		),
		uiP16: AnyLogic!Parameter (
			name <- 'Statusbar Model Date',
			value <- 'false'
		)
	do {
		thisModule.idCounter <- thisModule.idCounter + 1;
		o.id <- thisModule.idCounter;
		if (o.name.size() = 0) o.name <- 'DerivedSimulationModel';
	
		thisModule.idCounter <- thisModule.idCounter + 1;
		simulationExperiment.id <- thisModule.idCounter;
	}
}

rule ActiveObjectClass extends ModelElement {
	from 
	    i : UML!Activity
	using {
		actionNodes : Sequence(UML!Action) = i.node->select(e | e.oclIsKindOf(UML!Action));
	}
	to
		o : AnyLogic!ActiveObjectClass (
			clientAreaTopLeft <- catl,
		    presentationTopGroupPersistent <- true,
		    iconTopGroupPersistent <- true,
		    generic <- false,
		    genericParameters <- 'T',
            agent <- false,
			connectors <- i.edge->union(cpuConnectors),
			embeddedObjects <- i.node->union(cpus),
			shapes <- i.getAllVisuals()->union(cpuVisuals)
		),
		catl: AnyLogic!Point (
			x <- 0,
			y <- 0
		),
		
		-- TODO: for now we simpley attach one cpu to each action
		cpuVisuals : distinct AnyLogic!EmbeddedObjectPresentation foreach(e in actionNodes)(
			excludeFromBuild <- false,
			name <-'cpu_presentation',
			position <- positionList1->at(actionNodes->indexOf(e)),
			label <- labelList1->at(actionNodes->indexOf(e)),
        	publicFlag <- true,
	    	presentationFlag <- true,
			showLabel <- false,
			
			asObject <- false,
			embeddedIcon <- false,
			rotation <- 0.0
		),
		positionList1: distinct AnyLogic!Point foreach(e in actionNodes) (
			x <- e.getX() + 220,
			y <- e.getY() + 10
		),
		labelList1: distinct AnyLogic!Point foreach (e in actionNodes) (
			x <- 10,
			y <- 0
		),

		cpus : distinct AnyLogic!EmbeddedObject foreach(e in actionNodes)(
			excludeFromBuild <- false,
			name <- 'cpu',
			position <- positionList2->at(actionNodes->indexOf(e)),
			label <- labelList2->at(actionNodes->indexOf(e)),
        	publicFlag <- false,
	    	presentationFlag <- true,
			showLabel <- false,
			presentation <- cpuVisuals->at(actionNodes->indexOf(e)),
			
		    activeObjectClass <- aoRefList->at(actionNodes->indexOf(e)),	
			genericParametersSubstitute <- ''
		),
		aoRefList: distinct AnyLogic!ActiveObjectClassRef foreach(e in actionNodes) (
			packageName <- 'de.tudresden.anylogic.activity',
			className <- 'CPU'
		),
		positionList2: distinct AnyLogic!Point foreach(e in actionNodes) (
			x <- e.getX() + 220,
			y <- e.getY() + 10
		),
		labelList2: distinct AnyLogic!Point foreach (e in actionNodes) (
			x <- 10,
			y <- 0
		),
		cpuConnectors : distinct AnyLogic!Connector foreach(e in actionNodes)(
			excludeFromBuild <- false,
			name <-'cpu_connector',
			position <- positionList3->at(actionNodes->indexOf(e)),
			label <- labelList3->at(actionNodes->indexOf(e)),
        	publicFlag <- false,
	    	presentationFlag <- true,
			showLabel <- false,
			sourceEmbeddedObject <- e,
			sourceConnectableName <- 'cpu',
			targetEmbeddedObject <- cpus->at(actionNodes->indexOf(e)),
			targetConnectableName <- 'cpu'
		),
		positionList3: distinct AnyLogic!Point foreach(e in actionNodes) (
			x <- 0,
			y <- 0
		),
		labelList3: distinct AnyLogic!Point foreach (e in actionNodes) (
			x <- 10,
			y <- 0
		),
		pointSourceList: distinct AnyLogic!Point foreach (e in actionNodes) (
			x <- 0,
			y <- 0
		),
		pointTargetList: distinct AnyLogic!Point foreach (e in actionNodes) (
			x <- 0,
			y <- 0
		)
	do {
		thisModule.idCounter <- thisModule.idCounter + 1;
		o.id <- thisModule.idCounter;
		if (o.name.size() = 0) o.name <- 'Activity' + thisModule.idCounter.toString();
		
		for (e in cpus) {
			thisModule.idCounter <- thisModule.idCounter + 1;
			e.id <- thisModule.idCounter;
			e.name <- e.name + thisModule.idCounter.toString();
		}
		for (e in cpuVisuals) {
			thisModule.idCounter <- thisModule.idCounter + 1;
			e.id <- thisModule.idCounter;
			e.name <- e.name + thisModule.idCounter.toString();
		}
		for (e in cpuConnectors) {
			thisModule.idCounter <- thisModule.idCounter + 1;
			e.id <- thisModule.idCounter;
			e.name <- e.name + thisModule.idCounter.toString();
			e.points <- Sequence{pointSourceList->at(cpuConnectors->indexOf(e)),pointTargetList->at(cpuConnectors->indexOf(e))};
		}
		
	}
}

rule Connector extends ModelElement {
	from
		i : UML!ActivityEdge
	to
		o : AnyLogic!Connector (
			position <- position,
        	label <- label,
        	publicFlag <- false,
	    	presentationFlag <- true,
			showLabel <- false,
			sourceEmbeddedObject <- i.source,
			-- TODO at the moment ony Yes/No is support in decission nodes
			sourceConnectableName <- 
				if (i.source.oclIsTypeOf(UML!DecisionNode))
					then if (i.name = 'Yes')
						then 'outYes'
						else 'outNo'
					endif
					else 'out'
				endif,
			-- sourceConnectableName <- 'out',
			targetEmbeddedObject <- i.target,
			targetConnectableName <- 'in',
			points <- Sequence{pointSource}->union(waypoints)->union(Sequence{pointTarget})
		),
		position: AnyLogic!Point (
			x <- 0,
			y <- 0
		),
		label : AnyLogic!Point (
			x <- 10,
			y <- 0
		),
		pointSource : AnyLogic!Point (
			x <- i.source.getX(),
			y <- i.source.getY()
		),
		pointTarget : AnyLogic!Point (
			x <- i.target.getX(),
			y <- i.target.getY()
		),
		waypoints : distinct AnyLogic!Point foreach(e in i.getAllWaypoints())(
			x <- e.getWaypointX() + i.source.getX(),
			y <- e.getWaypointY() + i.source.getY()
		)
	do {
		thisModule.idCounter <- thisModule.idCounter + 1;
		o.id <- thisModule.idCounter;
		if (o.name.size() = 0) o.name <- 'connector' + thisModule.idCounter.toString();
		else o.name <- o.name + thisModule.idCounter.toString(); 
	}
}

abstract rule EmbeddedObject extends ModelElement {
	from 
	    i : UML!ActivityNode 
	to
		o : AnyLogic!EmbeddedObject (
			position <- position,
        	label <- label,
        	publicFlag <- false,
	    	presentationFlag <- true,
			presentation <- i.getVisual(),
			showLabel <- true,
			
		    activeObjectClass <- aoRef,	
			genericParametersSubstitute <- ''
		),
		position: AnyLogic!Point (
			x <- i.getX(),
			y <- i.getY()
		),
		label : AnyLogic!Point (
			x <- 10,
			y <- 0
		),
		aoRef: AnyLogic!ActiveObjectClassRef (
			packageName <- 'de.tudresden.anylogic.activity'
		)

}

rule EmbeddedObjectInitialNode extends EmbeddedObject {
	from 
	    i : UML!InitialNode 
	to
		o : AnyLogic!EmbeddedObject (
			parameters <- Sequence{arrivalRate},
			showLabel <- false
		),
		aoRef: AnyLogic!ActiveObjectClassRef (
			className <- 'InitialNode'
		),
		arrivalRate : AnyLogic!Parameter (
			name <- 'rate',
			value <- 
				if 	(i.outgoing->first().target.getPerformanceAnnotation('PStep').oclIsUndefined())
					then thisModule.defaultRate.toString()
					else i.outgoing->first().target.getPerformanceAnnotation('PStep').repetition.substring(12,14)
				endif
		)
	do {
		thisModule.idCounter <- thisModule.idCounter + 1;
		o.id <- thisModule.idCounter;
		if (o.name.size() = 0) o.name <- 'initialNode' + thisModule.idCounter.toString();
		else o.name <- o.name   + thisModule.idCounter.toString();
	}
}

rule EmbeddedObjectFinalNode extends EmbeddedObject {
	from 
	    i : UML!FinalNode 
	to
		o : AnyLogic!EmbeddedObject (
		),
		aoRef: AnyLogic!ActiveObjectClassRef (
			className <- 'FinalNode'
		)
	do {
		thisModule.idCounter <- thisModule.idCounter + 1;
		o.id <- thisModule.idCounter;
		if (o.name.size() = 0) o.name <- 'finalNode' + thisModule.idCounter.toString();
		else o.name <- o.name   + thisModule.idCounter.toString();
	}
}

rule EmbeddedObjectJoinNode extends EmbeddedObject {
	from 
	    i : UML!JoinNode 
	to
		o : AnyLogic!EmbeddedObject (
			showLabel <- false
		),
		aoRef: AnyLogic!ActiveObjectClassRef (
			className <- 'JoinNode'
		)
	do {
		thisModule.idCounter <- thisModule.idCounter + 1;
		o.id <- thisModule.idCounter;
		if (o.name.size() = 0) o.name <- 'joinNode' + thisModule.idCounter.toString();
		else o.name <- o.name   + thisModule.idCounter.toString();
	}
}

rule EmbeddedObjectMergeNode extends EmbeddedObject {
	from 
	    i : UML!MergeNode 
	to
		o : AnyLogic!EmbeddedObject (
			showLabel <- false
		),
		aoRef: AnyLogic!ActiveObjectClassRef (
			className <- 'MergeNode'
		)
	do {
		thisModule.idCounter <- thisModule.idCounter + 1;
		o.id <- thisModule.idCounter;
		if (o.name.size() = 0) o.name <- 'mergeNode' + thisModule.idCounter.toString();
		else o.name <- o.name   + thisModule.idCounter.toString();
	}
}

rule EmbeddedObjectForkNode extends EmbeddedObject {
	from 
	    i : UML!ForkNode 
	to
		o : AnyLogic!EmbeddedObject (
			showLabel <- false
		),
		aoRef: AnyLogic!ActiveObjectClassRef (
			className <- 'ForkNode'
		)
	do {
		thisModule.idCounter <- thisModule.idCounter + 1;
		o.id <- thisModule.idCounter;
		if (o.name.size() = 0) o.name <- 'forkNode' + thisModule.idCounter.toString();
		else o.name <- o.name   + thisModule.idCounter.toString();
	}
}

rule EmbeddedObjectDecisionNode extends EmbeddedObject {
	from 
	    i : UML!DecisionNode 
	to
		o : AnyLogic!EmbeddedObject (
			parameters <- Sequence{probability},
			showLabel <- false
		),
		aoRef: AnyLogic!ActiveObjectClassRef (
			className <- 'DecisionNode'
		),
		probability : AnyLogic!Parameter (
			name <- 'probabilityYes',
			value <- 
				if (i.outgoing->select(e | e.name = 'Yes')->size() = 0)
					then thisModule.defaultProbability.toString()
					else if (i.outgoing->select(e | e.name = 'Yes')->first().getPerformanceAnnotation('PStep').oclIsUndefined())
						then thisModule.defaultProbability.toString()
						else (i.outgoing->select(e | e.name = 'Yes')->first().getPerformanceAnnotation('PStep').probability / 100 ).toString()
					endif
				endif
		)
	do {
		thisModule.idCounter <- thisModule.idCounter + 1;
		o.id <- thisModule.idCounter;
		if (o.name.size() = 0) o.name <- 'decisionNode' + thisModule.idCounter.toString();
		else o.name <- o.name   + thisModule.idCounter.toString();
	}
}

rule EmbeddedObjectAction extends EmbeddedObject {
	from 
	    i : UML!Action 
	to
		o : AnyLogic!EmbeddedObject (
			parameters <- Sequence{cpuTime,dbAccess,dbRows}
		),
		aoRef: AnyLogic!ActiveObjectClassRef (
			className <- 'Action'
		),
		cpuTime : AnyLogic!Parameter (
			name <- 'cpuTime',
			value <- 
				if 	(i.getPerformanceAnnotation('PStep').oclIsUndefined())
					then thisModule.defaultCPUTime.toString()
					else i.getPerformanceAnnotation('PStep').hostExecutionDemand.substring(12,14)
				endif		
		),
		dbAccess : AnyLogic!Parameter (
			name <- 'dbAccess',
			value <- '0'
		),
		dbRows : AnyLogic!Parameter (
			name <- 'dbRows',
			value <- '0'
		)
	do {
		thisModule.idCounter <- thisModule.idCounter + 1;
		o.id <- thisModule.idCounter;
		if (o.name.size() = 0) o.name <- 'action' + thisModule.idCounter.toString();
		else o.name <- o.name   + thisModule.idCounter.toString();
	}
}

rule EmbeddedObjectSendSignalAction extends EmbeddedObjectAction {
	from 
	    i : UML!SendSignalAction 
	to
		o : AnyLogic!EmbeddedObject (
		),
		aoRef: AnyLogic!ActiveObjectClassRef (
			className <- 'SendSignalAction'
		)
	do {
		thisModule.idCounter <- thisModule.idCounter + 1;
		o.id <- thisModule.idCounter;
		if (o.name.size() = 0) o.name <- 'sendSignalAction' + thisModule.idCounter.toString();
		else o.name <- o.name   + thisModule.idCounter.toString();
	}
}

rule EmbeddedObjectAcceptEventAction extends EmbeddedObjectAction {
	from 
	    i : UML!AcceptEventAction 
	to
		o : AnyLogic!EmbeddedObject (
		),
		aoRef: AnyLogic!ActiveObjectClassRef (
			className <- 'AcceptEventAction'
		)
	do {
		thisModule.idCounter <- thisModule.idCounter + 1;
		o.id <- thisModule.idCounter;
		if (o.name.size() = 0) o.name <- 'acceptEventAction' + thisModule.idCounter.toString();
		else o.name <- o.name   + thisModule.idCounter.toString();
	}
}








",atlcompil atl modul uml anylog modul templat creat out anylog in uml in di di helper default valu miss annot helper def defaultcputim real helper def defaultdbaccess integ helper def defaultdbrow integ helper def defaultprob real helper def defaultr real scale present helper def scalefactor real counter generat uniqu id use anylog helper def idcount integ helper clean string valid java identifi requir name anylog helper context string def clean string self regexreplaceal za z helper access appli stereotyp performanceprofil helper context uml element def getperformanceannot stereotyp string oclani self getappliedstereotyp spt stereotyp oclisundefin oclundefin els self getstereotypeappl self getappliedstereotyp spt stereotyp endif helper retriev diagram inform di input model helper context uml element def getvisu di graphnod di graphnod allinst select e e semanticmodel element self size oclundefin els di graphnod allinst select e e semanticmodel element self first endif helper context uml activ def getallvisu sequenc di graphnod di graphnod allinst select e self node exist e e e semanticmodel element self edg exist e e e semanticmodel element helper context uml activityedg def getallwaypoint sequenc string di graphedg allinst select e e semanticmodel element self size sequenc els di graphedg allinst select e e semanticmodel element self first waypoint endif helper context uml element def getx integ di graphnod allinst select e e semanticmodel element self size els di graphnod allinst select e e semanticmodel element self first getx endif helper context uml element def geti integ di graphnod allinst select e e semanticmodel element self size els di graphnod allinst select e e semanticmodel element self first geti endif helper context di graphnod def getx integ self posit substr self posit indexof self posit indexof tointeg thismodul scalefactor round helper context di graphnod def geti integ self posit substr self posit indexof self posit indexof tointeg thismodul scalefactor round helper context di graphnod def getnam string uml element allinst select e e self semanticmodel element size els uml element allinst select e e self semanticmodel element first name endif helper context string def getwaypointx integ self substr self indexof sourcex self indexof sourcey tointeg thismodul scalefactor round helper context string def getwaypointi integ self substr self indexof sourcey self indexof targetx tointeg thismodul scalefactor round rule abstract rule modelel uml element anylog modelel excludefrombuild fals name name clean rule embeddedobjectpresent di graphnod semanticmodel element ocliskindof uml activitynod anylog embeddedobjectpresent excludefrombuild fals name getnam clean posit posit label label publicflag true presentationflag true showlabel fals asobject fals embeddedicon fals rotat label anylog point x posit anylog point x getx geti thismodul idcount thismodul idcount id thismodul idcount name size name preset thismodul idcount tostr els name name present thismodul idcount tostr main model rule rule model extend modelel uml model anylog model enginevers javapackagenam name clean tolow activeobjectclass uml activ allinst experi sequenc simulationexperi one simul experi creat simulationexperi anylog simulationexperi activeobjectclass uml activ allinst assequ first todo ok long one activ excludefrombuild fals name name clean simul clientareatopleft exppo presentationtopgrouppersist true icontopgrouppersist true frame expfram commandlineargu maximummemori randomse fals seedvalu vmarg absoluteaccuraci relativeaccuraci timeaccuraci fixedtimestep shape sequenc exptext exptext control sequenc expbutton paramet sequenc enableadaptiveframemanag true enableantialias true enablepan true enablezoom true executionmod realtim cpuratio ratio titl name deriv simul framespersecond realtimescal scale uiproperti sequenc uip uip uip uip uip uip uip uip uip uip uip uip uip uip uip usecalendar fals stopopt stop specifi time initialtim finaltim modeltimeunit millisecond exppo anylog point x expfram anylog frame x width height exptext anylog text id name generatedtext excludefrombuild fals posit exptext posit label exptext label publicflag true presentationflag true showlabel fals asobject true embeddedicon fals rotat color text name simul font exptext font align left exptext posit anylog point x exptext label anylog point x exptext font anylog font name time new roman size style exptext anylog text id name generatedtext excludefrombuild fals posit exptext posit label exptext label publicflag true presentationflag true showlabel fals asobject true embeddedicon fals rotat color text simul generat uml model name nbi transform develop task modelplex ip font exptext font align left exptext posit anylog point x exptext label anylog point x exptext font anylog font name time new roman size style expbutton anylog button embeddedicon fals id name generatedbutton excludefrombuild fals posit expbuttonposit label expbuttonlabel publicflag true presentationflag true showlabel fals width height asobject true embeddedicon fals textcolor enableexpress getstat idl actioncod run getengin getpresent setpresent getengin getroot labeltext run simul model switch main view font expbuttonfont expbuttonposit anylog point x expbuttonlabel anylog point x expbuttonfont anylog font name tahoma size style uip anylog paramet name statusbar memori valu true uip anylog paramet name statusbar model step valu fals uip anylog paramet name experi progress valu fals uip anylog paramet name toolbar anim setup valu fals uip anylog paramet name statusbar status valu true uip anylog paramet name toolbar file valu fals uip anylog paramet name toolbar time scale setup valu true uip anylog paramet name toolbar model navig valu true uip anylog paramet name statusbar real time of simul valu true uip anylog paramet name toolbar execut control valu true uip anylog paramet name statusbar model time valu fals uip anylog paramet name statusbar event per second valu fals uip anylog paramet name toolbar view valu fals uip anylog paramet name simul progress valu true uip anylog paramet name statusbar frame per second valu fals uip anylog paramet name statusbar model date valu fals thismodul idcount thismodul idcount id thismodul idcount name size name derivedsimulationmodel thismodul idcount thismodul idcount simulationexperi id thismodul idcount rule activeobjectclass extend modelel uml activ use actionnod sequenc uml action node select e e ocliskindof uml action anylog activeobjectclass clientareatopleft catl presentationtopgrouppersist true icontopgrouppersist true generic fals genericparamet t agent fals connector edg union cpuconnector embeddedobject node union cpus shape getallvisu union cpuvisu catl anylog point x todo simpley attach one cpu action cpuvisu distinct anylog embeddedobjectpresent foreach e actionnod excludefrombuild fals name cpu present posit positionlist actionnod indexof e label labellist actionnod indexof e publicflag true presentationflag true showlabel fals asobject fals embeddedicon fals rotat positionlist distinct anylog point foreach e actionnod x e getx e geti labellist distinct anylog point foreach e actionnod x cpus distinct anylog embeddedobject foreach e actionnod excludefrombuild fals name cpu posit positionlist actionnod indexof e label labellist actionnod indexof e publicflag fals presentationflag true showlabel fals present cpuvisu actionnod indexof e activeobjectclass aoreflist actionnod indexof e genericparameterssubstitut aoreflist distinct anylog activeobjectclassref foreach e actionnod packagenam de tudresden anylog activ classnam cpu positionlist distinct anylog point foreach e actionnod x e getx e geti labellist distinct anylog point foreach e actionnod x cpuconnector distinct anylog connector foreach e actionnod excludefrombuild fals name cpu connector posit positionlist actionnod indexof e label labellist actionnod indexof e publicflag fals presentationflag true showlabel fals sourceembeddedobject e sourceconnectablenam cpu targetembeddedobject cpus actionnod indexof e targetconnectablenam cpu positionlist distinct anylog point foreach e actionnod x labellist distinct anylog point foreach e actionnod x pointsourcelist distinct anylog point foreach e actionnod x pointtargetlist distinct anylog point foreach e actionnod x thismodul idcount thismodul idcount id thismodul idcount name size name activ thismodul idcount tostr e cpus thismodul idcount thismodul idcount e id thismodul idcount e name e name thismodul idcount tostr e cpuvisu thismodul idcount thismodul idcount e id thismodul idcount e name e name thismodul idcount tostr e cpuconnector thismodul idcount thismodul idcount e id thismodul idcount e name e name thismodul idcount tostr e point sequenc pointsourcelist cpuconnector indexof e pointtargetlist cpuconnector indexof e rule connector extend modelel uml activityedg anylog connector posit posit label label publicflag fals presentationflag true showlabel fals sourceembeddedobject sourc todo moment oni yes no support deciss node sourceconnectablenam sourc oclistypeof uml decisionnod name yes outy els outno endif els endif sourceconnectablenam targetembeddedobject target targetconnectablenam point sequenc pointsourc union waypoint union sequenc pointtarget posit anylog point x label anylog point x pointsourc anylog point x sourc getx sourc geti pointtarget anylog point x target getx target geti waypoint distinct anylog point foreach e getallwaypoint x e getwaypointx sourc getx e getwaypointi sourc geti thismodul idcount thismodul idcount id thismodul idcount name size name connector thismodul idcount tostr els name name thismodul idcount tostr abstract rule embeddedobject extend modelel uml activitynod anylog embeddedobject posit posit label label publicflag fals presentationflag true present getvisu showlabel true activeobjectclass aoref genericparameterssubstitut posit anylog point x getx geti label anylog point x aoref anylog activeobjectclassref packagenam de tudresden anylog activ rule embeddedobjectinitialnod extend embeddedobject uml initialnod anylog embeddedobject paramet sequenc arrivalr showlabel fals aoref anylog activeobjectclassref classnam initialnod arrivalr anylog paramet name rate valu outgo first target getperformanceannot pstep oclisundefin thismodul defaultr tostr els outgo first target getperformanceannot pstep repetit substr endif thismodul idcount thismodul idcount id thismodul idcount name size name initialnod thismodul idcount tostr els name name thismodul idcount tostr rule embeddedobjectfinalnod extend embeddedobject uml finalnod anylog embeddedobject aoref anylog activeobjectclassref classnam finalnod thismodul idcount thismodul idcount id thismodul idcount name size name finalnod thismodul idcount tostr els name name thismodul idcount tostr rule embeddedobjectjoinnod extend embeddedobject uml joinnod anylog embeddedobject showlabel fals aoref anylog activeobjectclassref classnam joinnod thismodul idcount thismodul idcount id thismodul idcount name size name joinnod thismodul idcount tostr els name name thismodul idcount tostr rule embeddedobjectmergenod extend embeddedobject uml mergenod anylog embeddedobject showlabel fals aoref anylog activeobjectclassref classnam mergenod thismodul idcount thismodul idcount id thismodul idcount name size name mergenod thismodul idcount tostr els name name thismodul idcount tostr rule embeddedobjectforknod extend embeddedobject uml forknod anylog embeddedobject showlabel fals aoref anylog activeobjectclassref classnam forknod thismodul idcount thismodul idcount id thismodul idcount name size name forknod thismodul idcount tostr els name name thismodul idcount tostr rule embeddedobjectdecisionnod extend embeddedobject uml decisionnod anylog embeddedobject paramet sequenc probabl showlabel fals aoref anylog activeobjectclassref classnam decisionnod probabl anylog paramet name probabilityy valu outgo select e e name yes size thismodul defaultprob tostr els outgo select e e name yes first getperformanceannot pstep oclisundefin thismodul defaultprob tostr els outgo select e e name yes first getperformanceannot pstep probabl tostr endif endif thismodul idcount thismodul idcount id thismodul idcount name size name decisionnod thismodul idcount tostr els name name thismodul idcount tostr rule embeddedobjectact extend embeddedobject uml action anylog embeddedobject paramet sequenc cputim dbaccess dbrow aoref anylog activeobjectclassref classnam action cputim anylog paramet name cputim valu getperformanceannot pstep oclisundefin thismodul defaultcputim tostr els getperformanceannot pstep hostexecutiondemand substr endif dbaccess anylog paramet name dbaccess valu dbrow anylog paramet name dbrow valu thismodul idcount thismodul idcount id thismodul idcount name size name action thismodul idcount tostr els name name thismodul idcount tostr rule embeddedobjectsendsignalact extend embeddedobjectact uml sendsignalact anylog embeddedobject aoref anylog activeobjectclassref classnam sendsignalact thismodul idcount thismodul idcount id thismodul idcount name size name sendsignalact thismodul idcount tostr els name name thismodul idcount tostr rule embeddedobjectaccepteventact extend embeddedobjectact uml accepteventact anylog embeddedobject aoref anylog activeobjectclassref classnam accepteventact thismodul idcount thismodul idcount id thismodul idcount name size name accepteventact thismodul idcount tostr els name name thismodul idcount tostr,0
203,203,P89-JAVA2String-query.atl,"query JAVA2String_query = JAVA!JavaClass.allInstances()->
	select(e | e.oclIsTypeOf(JAVA!JavaClass))->
	collect(x | x.toString().writeTo('C:/test/' + x.package.name.replaceAll('.', '/') + '/' + x.name + '.java'));

uses JAVA2String;


-- Please note that this ATL program serves only for demonstration purposes.
-- The rules and functions in this program may not be complete.

-- Usage hints:
-- Please give a folder name that makes sense.
-- Don't forget to fill in the library link in the Model Configuration.
-- Pay attention, ATL and it's configuration are case sensitive.

",queri java string queri java javaclass allinst select e e oclistypeof java javaclass collect x x tostr writeto c test x packag name replaceal x name java use java string pleas note atl program serv demonstr purpos the rule function program may complet usag hint pleas give folder name make sens don forget fill librari link model configur pay attent atl configur case sensit,15
204,204,P89-JAVA2String.atl,"library JAVA2String;

-- Please note that this ATL program serves only for demonstration purposes.
-- The rules and functions in this program may not be complete.

helper context JAVA!ClassFeature def: modifierFinal() : String =
	if self.isFinal then
		'final '
	else
		''
	endif;

helper context JAVA!ClassMember def: visibility() : String =
	if self.isPublic then
		'public '
	else
		'private '
	endif;

helper context JAVA!JavaClass def: visibility() : String =
	if self.isPublic then
		'public '
	else
		'private '
	endif;

helper context JAVA!ClassMember def: scope() : String =
	if self.isStatic then
		'static '
	else
		''
	endif;

helper context JAVA!JavaClass def: scope() : String =
	if self.isStatic then
		'static '
	else
		''
	endif;

helper context JAVA!JavaClass def: modifierAbstract() : String =
	if self.isAbstract then
		'abstract '
	else
		''
	endif;

helper context JAVA!Package def: toString() : String =
	'package ' + self.name + ';\n\n';

helper context JAVA!JavaClass def: toString() : String =
	self.package.toString() + self.visibility() +
	self.scope() + self.modifierAbstract() +
	self.modifierFinal() + 'class ' + self.name + ' {\n' +
	self.members->iterate(i; acc : String = '' |
		acc + i.toString()
	) +
	'\n}\n\n';

helper context JAVA!PrimitiveType def: toString() : String =
	if self.name = 'Integer' then
		'int '
	else if self.name = 'Boolean' then
		'boolean '
	else if self.name = 'String' then
		'java.lang.String '
	else if self.name = 'Long' then
		'long '
	else
		'void '
	endif endif endif endif;

helper context JAVA!Field def: toString() : String =
	'\t' + self.visibility() + self.scope() + self.modifierFinal() +
	self.type.name + ' ' + self.name + ';\n';

helper context JAVA!Method def: toString() : String =
	'\t' + self.visibility() + self.scope() + self.modifierFinal() +
	self.type.name + ' ' + self.name + '(' +
	self.parameters->iterate(i; acc : String = '' |
		acc +
		if acc = '' then
			''
		else
			', '
		endif +
		i.toString()
	) +
	') {\n\t\t//Your code here\n\t}\n';

helper context JAVA!FeatureParameter def: toString() : String =
	self.type.name + ' ' + self.name;
",librari java string pleas note atl program serv demonstr purpos the rule function program may complet helper context java classfeatur def modifierfin string self isfin final els endif helper context java classmemb def visibl string self ispubl public els privat endif helper context java javaclass def visibl string self ispubl public els privat endif helper context java classmemb def scope string self isstat static els endif helper context java javaclass def scope string self isstat static els endif helper context java javaclass def modifierabstract string self isabstract abstract els endif helper context java packag def tostr string packag self name n n helper context java javaclass def tostr string self packag tostr self visibl self scope self modifierabstract self modifierfin class self name n self member iter acc string acc tostr n n n helper context java primitivetyp def tostr string self name integ int els self name boolean boolean els self name string java lang string els self name long long els void endif endif endif endif helper context java field def tostr string self visibl self scope self modifierfin self type name self name n helper context java method def tostr string self visibl self scope self modifierfin self type name self name self paramet iter acc string acc acc els endif tostr n your code n n helper context java featureparamet def tostr string self type name self name,18
205,205,P89-UML2JAVA.atl,"module UML2JAVA;
create OUT : JAVA from IN : UML;

-- Please note that this ATL program serves only for demonstration purposes.
-- The rules and functions in this program may not be complete.

helper context UML!ModelElement def: isPublic() : Boolean =
	self.visibility = #vk_public;

helper context UML!Feature def: isStatic() : Boolean =
	self.ownerScope = #sk_static;

helper context UML!Attribute def: isFinal() : Boolean =
	self.changeability = #ck_frozen;

helper context UML!Namespace def: getExtendedName() : String =
	if self.namespace.oclIsUndefined() then
		''
	else if self.namespace.oclIsKindOf(UML!Model) then
		''
	else
		self.namespace.getExtendedName() + '.'
	endif endif + self.name;

rule P2P {
	from e : UML!Package (e.oclIsTypeOf(UML!Package))
	to out : JAVA!Package (
		name <- e.getExtendedName()
	)
}

rule C2C {
	from e : UML!Class
	to out : JAVA!JavaClass (
		name <- e.name,
		isAbstract <- e.isAbstract,
		isPublic <- e.isPublic(),
		package <- e.namespace
	)
}

rule D2P {
	from e : UML!DataType
	to out : JAVA!PrimitiveType (
		name <- e.name,
		package <- e.namespace
	)
}

rule A2F {
	from e : UML!Attribute
	to out : JAVA!Field (
		name <- e.name,
		isStatic <- e.isStatic(),
		isPublic <- e.isPublic(),
		isFinal <- e.isFinal(),
		owner <- e.owner,
		type <- e.type
	)
}

rule O2M {
	from e : UML!Operation
	to out : JAVA!Method (
		name <- e.name,
		isStatic <- e.isStatic(),
		isPublic <- e.isPublic(),
		owner <- e.owner,
		type <- e.parameter->select(x|x.kind=#pdk_return)->asSequence()->first().type,
		parameters <- e.parameter->select(x|x.kind<>#pdk_return)->asSequence()
	)
}

rule P2F {
	from e : UML!Parameter (e.kind <> #pdk_return)
	to out : JAVA!FeatureParameter (
		name <- e.name,
		type <- e.type
	)
}

",modul uml java creat out java in uml pleas note atl program serv demonstr purpos the rule function program may complet helper context uml modelel def ispubl boolean self visibl vk public helper context uml featur def isstat boolean self ownerscop sk static helper context uml attribut def isfin boolean self changeabl ck frozen helper context uml namespac def getextendednam string self namespac oclisundefin els self namespac ocliskindof uml model els self namespac getextendednam endif endif self name rule p p e uml packag e oclistypeof uml packag java packag name e getextendednam rule c c e uml class java javaclass name e name isabstract e isabstract ispubl e ispubl packag e namespac rule d p e uml datatyp java primitivetyp name e name packag e namespac rule a f e uml attribut java field name e name isstat e isstat ispubl e ispubl isfin e isfin owner e owner type e type rule o m e uml oper java method name e name isstat e isstat ispubl e ispubl owner e owner type e paramet select x x kind pdk return assequ first type paramet e paramet select x x kind pdk return assequ rule p f e uml paramet e kind pdk return java featureparamet name e name type e type,18
206,206,P9-Disaggregation-context.atl,"-- @name		Disaggregation
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		SIMON Eric(simon.eric3<at>gmail.com)
-- @date		2006/07/27
-- @description	This transformation strenghthens or weakens an assertion(respectively postcondition and precondition).
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 2.8, page 23
-- @see author of article : K. Lano

module Disaggregation; -- Module Template
create OUT : KM3 from IN : KM3;

-- @comment this helper returns the metadata ""commentsBefore"" of name : <name>
helper context KM3!Attribute def: getMetadata(name : String) : String =
	let comment : String = self.commentsBefore->select(e | e.startsWith('-- @' + name + ' '))->first() in
	if comment.oclIsUndefined() then
		OclUndefined
	else
		comment.substring(6 + name.size(), comment.size())
	endif;

-- @comment this helper returns the class set of the metadatas
helper context KM3!Class def : getClass : Set(String) =
	KM3!Attribute->allInstances()->select(c|c.commentsBefore->notEmpty())->iterate(a; acc : Set(String) = Set{}| acc->including(a.getMetadata('label')))
	;
--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
-- @end rule Metamodel

-- @begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
-- @end rule Package

-- @begin rule DataType
rule DataType {
	from
		inputData:KM3!DataType
	to
		outputData:KM3!DataType(
			name <- inputData.name,
			location <- inputData.location
		)
}
-- @end rule DataType

-- @begin rule Enumeration 
rule Enumeration {
	from
		inputEnum:KM3!Enumeration
	to
		outputEnum:KM3!Enumeration (
			name <- inputEnum.name,
			location <- inputEnum.location,
			package <- inputEnum.package,
			literals <- inputEnum.literals
		)
}
-- @end rule Enumeration 


--@begin rule EnumLiteral
rule EnumLiteral {
	from
		inputL:KM3!EnumLiteral
	to
		outputL:KM3!EnumLiteral (
			name <- inputL.name,
			location <- inputL.location,
			enum  <- inputL.enum,
			package <- inputL.package
		)
}
--@end rule EnumLiteral

-- @begin rule Class
rule Class {
	from
		inputC:KM3!Class
		(not (inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Attribute))->exists(a|a.commentsBefore->notEmpty())))
	to
		outputC:KM3!Class (
			isAbstract <- inputC.isAbstract,
			supertypes <- inputC.supertypes,
			name <- inputC.name,
			location <- inputC.location,
			package <- inputC.package,
			structuralFeatures <- inputC.structuralFeatures
		)
}
-- @end rule Class

-- @begin rule Attribute
rule Attribute {
	from
		inputAttr : KM3!Attribute
	to
		outputAttr : KM3!Attribute (
			package <- inputAttr.package,
			name <- inputAttr.name,
			lower <- inputAttr.lower,
			upper <- inputAttr.upper,
			isOrdered <- inputAttr.isOrdered,
			isUnique <- inputAttr.isUnique,
			owner <- inputAttr.owner,
			type <- inputAttr.type
		)
}
-- @end rule Attribute

-- @begin rule Reference
rule Reference {
	from
		inputRef : KM3!Reference
			
	to
		outputRef : KM3!Reference (
			package <- inputRef.package,
			name <- inputRef.name,
			lower <- inputRef.lower,
			upper <- inputRef.upper,
			isOrdered <- inputRef.isOrdered,
			isUnique <- inputRef.isUnique,
			owner <- inputRef.owner,
			type <- inputRef.type,
			isContainer <- inputRef.isContainer,
			opposite <- inputRef.opposite
		)
}
-- @end rule Attribute

-- @begin rule Disaggregation
rule Disaggregation {
	from
		inputC : KM3!Class
		(inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Attribute))->exists(a|a.commentsBefore->notEmpty()))
	using {
		subClasses : Set(String) = inputC.getClass;		
		}
	to
		outputPrimaryClass : KM3!Class (	
			isAbstract <- inputC.isAbstract,
			supertypes <- inputC.supertypes,
			name <- inputC.name,
			location <- inputC.location,
			package <- inputC.package,
			structuralFeatures <- inputC.structuralFeatures->select(a| not a.oclIsTypeOf(KM3!Attribute)),
			structuralFeatures <- inputC.structuralFeatures->select(a| a.oclIsTypeOf(KM3!Attribute))->select(a|a.commentsBefore->oclIsUndefined()),
			structuralFeatures <- subClasses->iterate(a; acc : Sequence(KM3!Reference)=Sequence{}| acc->append(thisModule.composition(inputC,a)))			
		)
}
-- @end rule Disaggregation

-- @comment this lazy rule creates a auxiliarie class and this link with the root element for each element in the metadata.
-- @begin rule composition
lazy rule composition{
	from
		inputC : KM3!Class,
		Name : String
		
	to
		outputRef1 : KM3!Reference (
			package <- inputC.package,
			name <- 'ref1'+Name,
			lower <- 1,
			upper <- 1,
			isOrdered <- false,
			isUnique <- false,
			owner <- inputC,
			type <- subClass,
			isContainer <- true,
			opposite <- outputRef2
		),
		subClass : KM3!Class (
			isAbstract <- false,
			name <- Name,
			location <- inputC.location,
			package <- inputC.package,
			structuralFeatures <- inputC.structuralFeatures->select(a| a.oclIsTypeOf(KM3!Attribute))->select(a|a.commentsBefore->notEmpty() and a.getMetadata('label') = Name)
		),
		
		outputRef2 : KM3!Reference (
			package <- inputC.package,
			name <- 'ref'+inputC.name,
			lower <- 1,
			upper <- 1,
			isOrdered <- false,
			isUnique <- false,
			owner <- subClass,
			type <- inputC,
			isContainer <- false,
			opposite <- outputRef1
		)
}
-- @end rule composition
",name disaggreg version domain catalogu model transform author simon eric simon eric gmail com date descript this transform strenghthen weaken assert respect postcondit precondit see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul disaggreg modul templat creat out km in km comment helper return metadata commentsbefor name name helper context km attribut def getmetadata name string string let comment string self commentsbefor select e e startswith name first comment oclisundefin oclundefin els comment substr name size comment size endif comment helper return class set metadata helper context km class def getclass set string km attribut allinst select c c commentsbefor notempti iter acc set string set acc includ getmetadata label begin rule metamodel rule metamodel inputmm km metamodel outputmm km metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km packag name inputpkg name content inputpkg content end rule packag begin rule datatyp rule datatyp inputdata km datatyp outputdata km datatyp name inputdata name locat inputdata locat end rule datatyp begin rule enumer rule enumer inputenum km enumer outputenum km enumer name inputenum name locat inputenum locat packag inputenum packag liter inputenum liter end rule enumer begin rule enumliter rule enumliter inputl km enumliter outputl km enumliter name inputl name locat inputl locat enum inputl enum packag inputl packag end rule enumliter begin rule class rule class inputc km class inputc structuralfeatur select r r oclistypeof km attribut exist commentsbefor notempti outputc km class isabstract inputc isabstract supertyp inputc supertyp name inputc name locat inputc locat packag inputc packag structuralfeatur inputc structuralfeatur end rule class begin rule attribut rule attribut inputattr km attribut outputattr km attribut packag inputattr packag name inputattr name lower inputattr lower upper inputattr upper isord inputattr isord isuniqu inputattr isuniqu owner inputattr owner type inputattr type end rule attribut begin rule refer rule refer inputref km refer outputref km refer packag inputref packag name inputref name lower inputref lower upper inputref upper isord inputref isord isuniqu inputref isuniqu owner inputref owner type inputref type iscontain inputref iscontain opposit inputref opposit end rule attribut begin rule disaggreg rule disaggreg inputc km class inputc structuralfeatur select r r oclistypeof km attribut exist commentsbefor notempti use subclass set string inputc getclass outputprimaryclass km class isabstract inputc isabstract supertyp inputc supertyp name inputc name locat inputc locat packag inputc packag structuralfeatur inputc structuralfeatur select oclistypeof km attribut structuralfeatur inputc structuralfeatur select oclistypeof km attribut select commentsbefor oclisundefin structuralfeatur subclass iter acc sequenc km refer sequenc acc append thismodul composit inputc end rule disaggreg comment lazi rule creat auxiliari class link root element element metadata begin rule composit lazi rule composit inputc km class name string outputref km refer packag inputc packag name ref name lower upper isord fals isuniqu fals owner inputc type subclass iscontain true opposit outputref subclass km class isabstract fals name name locat inputc locat packag inputc packag structuralfeatur inputc structuralfeatur select oclistypeof km attribut select commentsbefor notempti getmetadata label name outputref km refer packag inputc packag name ref inputc name lower upper isord fals isuniqu fals owner subclass type inputc iscontain fals opposit outputref end rule composit,8
207,207,P9-Disaggregation-without.atl,"-- @name		Disaggregation
-- @version		1.0
-- @domains		Catalogue of Model Transformations
-- @authors		SIMON Eric(simon.eric3<at>gmail.com)
-- @date		2006/07/27
-- @description	This transformation strenghthens or weakens an assertion(respectively postcondition and precondition).
-- @see http://www.dcs.kcl.ac.uk/staff/kcl/tcat.pdf   
-- @see section 2.8, page 23
-- @see author of article : K. Lano

module Disaggregation; -- Module Template
create OUT : KM3 from IN : KM3;

helper context KM3!Attribute def: getMetadata(name : String) : String =
	let comment : String = self.commentsBefore->select(e | e.startsWith('-- @' + name + ' '))->first() in
	if comment.oclIsUndefined() then
		OclUndefined
	else
		comment.substring(6 + name.size(), comment.size())
	endif;

helper context KM3!Class def : getClass : Set(String) =
	KM3!Attribute->allInstances()->select(c|c.commentsBefore->notEmpty())->iterate(a; acc : Set(String) = Set{}| acc->including(a.getMetadata('label')))
	;
--@begin rule Metamodel
rule Metamodel {
	from
		inputMm:KM3!Metamodel
	to
		outputMm:KM3!Metamodel (
			location <- inputMm.location,
			contents <- inputMm.contents
		)
}
-- @end rule Metamodel

-- @begin rule Package
rule Package {
	from
		inputPkg:KM3!Package
	to
		outputPkg:KM3!Package (
			name <- inputPkg.name,
			contents <- inputPkg.contents
		)
}
-- @end rule Package

-- @begin rule DataType
rule DataType {
	from
		inputData:KM3!DataType
	to
		outputData:KM3!DataType(
			name <- inputData.name,
			location <- inputData.location
		)
}
-- @end rule DataType

--@begin rule EnumLiteral
rule EnumLiteral {
	from
		inputL:KM3!EnumLiteral
	to
		outputL:KM3!EnumLiteral (
			name <- inputL.name,
			location <- inputL.location,
			enum  <- inputL.enum,
			package <- inputL.package
		)
}
--@end rule EnumLiteral

-- @begin rule Class
rule Class {
	from
		inputC:KM3!Class
		(not (inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Attribute))->exists(a|a.commentsBefore->notEmpty())))
	to
		outputC:KM3!Class (
			isAbstract <- inputC.isAbstract,
			supertypes <- inputC.supertypes,
			name <- inputC.name,
			location <- inputC.location,
			package <- inputC.package,
			structuralFeatures <- inputC.structuralFeatures
		)
}
-- @end rule Class

-- @begin rule Attribute
rule Attribute {
	from
		inputAttr : KM3!Attribute
	to
		outputAttr : KM3!Attribute (
			package <- inputAttr.package,
			name <- inputAttr.name,
			lower <- inputAttr.lower,
			upper <- inputAttr.upper,
			isOrdered <- inputAttr.isOrdered,
			isUnique <- inputAttr.isUnique,
			owner <- inputAttr.owner,
			type <- inputAttr.type
		)
}
-- @end rule Attribute

-- @begin rule Disaggregation
rule Disaggregation {
	from
		inputC : KM3!Class
		(inputC.structuralFeatures->select(r|r.oclIsTypeOf(KM3!Attribute))->exists(a|a.commentsBefore->notEmpty()))
	using {
		subClasses : Set(String) = inputC.getClass;		
		}
	to
		outputPrimaryClass : KM3!Class (	
			isAbstract <- inputC.isAbstract,
			supertypes <- inputC.supertypes,
			name <- inputC.name,
			location <- inputC.location,
			package <- inputC.package,
			structuralFeatures <- inputC.structuralFeatures->select(a| not a.oclIsTypeOf(KM3!Attribute)),
			structuralFeatures <- inputC.structuralFeatures->select(a| a.oclIsTypeOf(KM3!Attribute))->select(a|a.commentsBefore->oclIsUndefined()),
			structuralFeatures <- subClasses->iterate(a; acc : Sequence(KM3!Reference)=Sequence{}| acc->append(thisModule.composition(inputC,a)))			
		)
}
-- @end rule Disaggregation

lazy rule composition{
	from
		inputC : KM3!Class,
		Name : String
		
	to
		outputRef1 : KM3!Reference (
			package <- inputC.package,
			name <- 'ref1'+Name,
			lower <- 1,
			upper <- 1,
			isOrdered <- false,
			isUnique <- false,
			owner <- inputC,
			type <- subClass,
			isContainer <- true,
			opposite <- outputRef2
		),
		subClass : KM3!Class (
			isAbstract <- false,
			name <- Name,
			location <- inputC.location,
			package <- inputC.package,
			structuralFeatures <- inputC.structuralFeatures->select(a| a.oclIsTypeOf(KM3!Attribute))->select(a|a.commentsBefore->notEmpty() and a.getMetadata('label') = Name)
		),
		
		outputRef2 : KM3!Reference (
			package <- inputC.package,
			name <- 'ref'+inputC.name,
			lower <- 1,
			upper <- 1,
			isOrdered <- false,
			isUnique <- false,
			owner <- subClass,
			type <- inputC,
			isContainer <- false,
			opposite <- outputRef1
		)
}

",name disaggreg version domain catalogu model transform author simon eric simon eric gmail com date descript this transform strenghthen weaken assert respect postcondit precondit see http www dcs kcl ac uk staff kcl tcat pdf see section page see author articl k lano modul disaggreg modul templat creat out km in km helper context km attribut def getmetadata name string string let comment string self commentsbefor select e e startswith name first comment oclisundefin oclundefin els comment substr name size comment size endif helper context km class def getclass set string km attribut allinst select c c commentsbefor notempti iter acc set string set acc includ getmetadata label begin rule metamodel rule metamodel inputmm km metamodel outputmm km metamodel locat inputmm locat content inputmm content end rule metamodel begin rule packag rule packag inputpkg km packag outputpkg km packag name inputpkg name content inputpkg content end rule packag begin rule datatyp rule datatyp inputdata km datatyp outputdata km datatyp name inputdata name locat inputdata locat end rule datatyp begin rule enumliter rule enumliter inputl km enumliter outputl km enumliter name inputl name locat inputl locat enum inputl enum packag inputl packag end rule enumliter begin rule class rule class inputc km class inputc structuralfeatur select r r oclistypeof km attribut exist commentsbefor notempti outputc km class isabstract inputc isabstract supertyp inputc supertyp name inputc name locat inputc locat packag inputc packag structuralfeatur inputc structuralfeatur end rule class begin rule attribut rule attribut inputattr km attribut outputattr km attribut packag inputattr packag name inputattr name lower inputattr lower upper inputattr upper isord inputattr isord isuniqu inputattr isuniqu owner inputattr owner type inputattr type end rule attribut begin rule disaggreg rule disaggreg inputc km class inputc structuralfeatur select r r oclistypeof km attribut exist commentsbefor notempti use subclass set string inputc getclass outputprimaryclass km class isabstract inputc isabstract supertyp inputc supertyp name inputc name locat inputc locat packag inputc packag structuralfeatur inputc structuralfeatur select oclistypeof km attribut structuralfeatur inputc structuralfeatur select oclistypeof km attribut select commentsbefor oclisundefin structuralfeatur subclass iter acc sequenc km refer sequenc acc append thismodul composit inputc end rule disaggreg lazi rule composit inputc km class name string outputref km refer packag inputc packag name ref name lower upper isord fals isuniqu fals owner inputc type subclass iscontain true opposit outputref subclass km class isabstract fals name name locat inputc locat packag inputc packag structuralfeatur inputc structuralfeatur select oclistypeof km attribut select commentsbefor notempti getmetadata label name outputref km refer packag inputc packag name ref inputc name lower upper isord fals isuniqu fals owner subclass type inputc iscontain fals opposit outputref,8
208,208,P90-UML2KM3.atl,"-- @atlcompiler atl2006
module UML2KM3;
create OUT : KM3 from IN : UML;

helper def: model : UML!Model = UML!Model.allInstances()->any(e | true);

-- Root Element Creation: Model to Metamodel
rule Model2Metamodel {
	from
		s : UML!Model (s.oclIsTypeOf(UML!Model))
	to
		t : KM3!Metamodel (
			contents <- Set {s.nestedPackage, pt}
		),
		pt : KM3!Package (
			name <- 'PrimitiveType'
		)
}

-- Abstruct rule for Element extending NamedElement
abstract rule NamedElement {
	from 
		s : UML!NamedElement
	to
		t : KM3!ModelElement (
			name <- s.name
		)
}

-- UML Package 2 KM3 Package
rule Package extends NamedElement {
	from
		s : UML!Package (not s.oclIsTypeOf(UML!Model))
	to
		t : KM3!Package (
			contents <- Set {s.nestedPackage, s.ownedMember}
		)
}

-- UML Classifier 2 KM3 Classifier
abstract rule Classifier extends NamedElement {
	from
		s : UML!Classifier
	to
		t : KM3!Classifier
}

-- UML Class 2 KM3 Class
rule Class extends Classifier {
	from
		s : UML!Class
	to
		t : KM3!Class (
			isAbstract <- s.isAbstract,
			supertypes <- s.superClass,
			structuralFeatures <- Set {s.attribute}
		)
}

-- UML Datatype to KM3 Datatype
rule DataType extends Classifier {
	from
		s : UML!DataType
	to
		t : KM3!DataType
}

-- UML Enumeration 2 KM3 Enumeration
rule Enumeration extends DataType {
	from
		s : UML!Enumeration
	to
		t : KM3!Enumeration(
			literals <- s.ownedLiteral
		)
}

--UML Enumeration Literal 2 KM3 Enum Literal
rule EnumLiteral extends NamedElement {
	from
		s : UML!EnumerationLiteral
	to
		t : KM3!EnumLiteral
}

helper def: dataTypeByName : Map(String, KM3!DataType) = Map {};

-- Called rule
rule getType(s : UML!StructuralFeature) {
	do {	
		if(Set {'Boolean', 'Integer', 'String'}->includes(s.type.name)) {
			if(thisModule.dataTypeByName.containsKey(s.type.name)) {
				thisModule.dataTypeByName.get(s.type.name);
			} else {
				thisModule.dataType(s);
			}
		} else {
			s.type;
		}
	}
}

rule dataType(s : UML!StructuralFeature) {
	to
		t : KM3!DataType(
			name <- s.type.name,
			package <- thisModule.resolveTemp(thisModule.model, 'pt')
		)
	do {
		thisModule.dataTypeByName <- thisModule.dataTypeByName.including(s.type.name, t);
		t;
	}
}

abstract rule StructuralFeature extends NamedElement {
	from
		s : UML!StructuralFeature
	to
		t : KM3!StructuralFeature(
			lower <- s.lower,
			upper <- s.upper,
			isOrdered <- s.isOrdered,
			type <- thisModule.getType(s)
		)
}

rule Attribute extends StructuralFeature {
	from
		s : UML!Property (s.association.oclIsUndefined())
	to
		t : KM3!Attribute(
			isUnique <- s.isUnique
		)
}

-- checker
helper context UML!Property def: isContainer : Boolean =
	if self.aggregation = #composite then
		true
	else
		false
	endif;

-- Opposite property is returned if this property belongs to a class
helper context UML!Property def: getOpposite : KM3!Reference =
	let oppositeProp : OclAny = self.association.memberEnd->select(e | not (e = self))->asSequence()->first() in
	let oppositeClass : OclAny = oppositeProp.class in
	if (not oppositeClass.oclIsUndefined()) then
		self.association.memberEnd->select(e | not (e = self))->asSequence()->first()
	else
		OclUndefined
	endif;

helper context UML!Property def: isATwoEndsAssociation : Boolean =
	if (self.isAnAssociation) then
		if self.association.memberEnd->size() = 2 then
			true
		else
			false
		endif
	else
		false
	endif;

-- This helper returns true if the current property is an association end
helper context UML!Property def: isAnAssociation : Boolean =
	if (self.association.oclIsUndefined()) then
		false
	else
		true
	endif;

-- UML Association End (from a 2 Ends Association) 2 KM3 Reference
rule Reference extends StructuralFeature {
	from
		s : UML!Property (s.isATwoEndsAssociation)
	to
		t : KM3!Reference(
			isContainer <- s.isContainer,
			opposite <- s.getOpposite
		)
}",atlcompil atl modul uml km creat out km in uml helper def model uml model uml model allinst e true root element creation model metamodel rule model metamodel uml model oclistypeof uml model km metamodel content set nestedpackag pt pt km packag name primitivetyp abstruct rule element extend namedel abstract rule namedel uml namedel km modelel name name uml packag km packag rule packag extend namedel uml packag oclistypeof uml model km packag content set nestedpackag ownedmemb uml classifi km classifi abstract rule classifi extend namedel uml classifi km classifi uml class km class rule class extend classifi uml class km class isabstract isabstract supertyp superclass structuralfeatur set attribut uml datatyp km datatyp rule datatyp extend classifi uml datatyp km datatyp uml enumer km enumer rule enumer extend datatyp uml enumer km enumer liter ownedliter uml enumer liter km enum liter rule enumliter extend namedel uml enumerationliter km enumliter helper def datatypebynam map string km datatyp map call rule rule gettyp uml structuralfeatur set boolean integ string includ type name thismodul datatypebynam containskey type name thismodul datatypebynam get type name els thismodul datatyp els type rule datatyp uml structuralfeatur km datatyp name type name packag thismodul resolvetemp thismodul model pt thismodul datatypebynam thismodul datatypebynam includ type name abstract rule structuralfeatur extend namedel uml structuralfeatur km structuralfeatur lower lower upper upper isord isord type thismodul gettyp rule attribut extend structuralfeatur uml properti associ oclisundefin km attribut isuniqu isuniqu checker helper context uml properti def iscontain boolean self aggreg composit true els fals endif opposit properti return properti belong class helper context uml properti def getopposit km refer let oppositeprop oclani self associ memberend select e e self assequ first let oppositeclass oclani oppositeprop class oppositeclass oclisundefin self associ memberend select e e self assequ first els oclundefin endif helper context uml properti def isatwoendsassoci boolean self isanassoci self associ memberend size true els fals endif els fals endif this helper return true current properti associ end helper context uml properti def isanassoci boolean self associ oclisundefin fals els true endif uml associ end end associ km refer rule refer extend structuralfeatur uml properti isatwoendsassoci km refer iscontain iscontain opposit getopposit,18
209,209,P91-MOF2UML.atl,"module MOF2UML;
create OUT : UML from IN : MOF;


uses strings;


-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- This helper returns a MOF!Class that is considered as the reference Class
-- for the generation of unique target elements: the model and the possible
-- stereotypes.
-- CONTEXT: thisModule
-- RETURN:	MOF!Class
helper def: firstClass : MOF!Class =
	MOF!Class.allInstancesFrom('IN')->asSequence()->first();

-- This helper returns a clustered MOF!Import that is considered as the
-- reference Import for the generation of the 'clustered' stereotype.
-- CONTEXT: thisModule
-- RETURN:	Sequence(MOF!Import)
helper def: firstClustered : Sequence(MOF!Import) =
	Sequence{
		MOF!Import.allInstancesFrom('IN')
			->select(e | e.isClustered)
			->asSequence()->first()
	};
	
-- This helper returns an unclustered  MOF!Import that is considered as the
-- reference Import for the generation of the 'import' stereotype.
-- CONTEXT: thisModule
-- RETURN:	Set(MOF!Import)
helper def: firstImport : Sequence(MOF!Import) =
	Sequence{
		MOF!Import.allInstancesFrom('IN')
			->select(e | not e.isClustered)
			->asSequence()->first()
	};
	
-- This helper returns a MOF!Package that is considered as the reference
-- Package for the generation of the 'import' stereotype.
-- CONTEXT: thisModule
-- RETURN:	Set(MOF!Package)
helper def: firstMetamodel : Sequence(MOF!Package) =
	Sequence{
		MOF!Package.allInstancesFrom('IN')->asSequence()->first()
	};

-- This helper returns the UML!OrderingKind that corresponds to the
-- non undefined MOF!ScopeKind of the contextual MOF!ModelElement.
-- The helper returns the '#ordered' or '#unordered' value depending on the
-- value of the MOF 'isOrdered' boolean attribute.
--
-- WARNING:	the contextual MOF!ModelElement must be of either a
-- MOF!StructuralFeature or a MOF!AssociationEnd element.
--
-- CONTEXT: MOF!ModelElement
-- RETURN:	UML!OrderingKind
helper context MOF!ModelElement def: getOrdering() : UML!OrderingKind = 
	if self.multiplicity.isOrdered
	then
		#ok_ordered
	else
		#ok_unordered
	endif;

-- This helper returns the UML!OrderingKind that corresponds to the
-- MOF!ScopeKind of the contextual MOF!ModelElement.
-- If the multiplicity  attribute of the contextual ModelElement, or its
-- isOrdered attribute is undefined, the helper returns 'ok_unordered'.
-- Otherwise, the helper retuns the value computed by getOrdering().
--
-- WARNING:	the contextual MOF!ModelElement must be of either a
-- MOF!StructuralFeature or a MOF!AssociationEnd element.
--
-- CONTEXT: MOF!ModelElement
-- RETURN:	UML!OrderingKind
helper context MOF!ModelElement def: getUMLOrdering() : UML!OrderingKind = 
	if self.multiplicity.oclIsUndefined()
	then
		#ok_unordered
	else
		if self.multiplicity.isOrdered.oclIsUndefined()
		then
			#ok_unordered
		else
			self.getOrdering()
		endif
	endif;

-- This helper returns the UML!Visibility that corresponds to the
-- non undefined MOF!Visibility of the contextual MOF!ModelElement.
--
-- WARNING:	the contextual MOF!ModelElement must be of either a MOF!Feature, a
-- MOF!Import or a MOF!GeneralizableElement entity.
--
-- CONTEXT:	MOF!ModelElement
-- RETURN:	UML!Visibility
helper context MOF!ModelElement def: getVisibility() : UML!Visibility =
	let v : MOF!Visibility = self.visibility in
	if v = #public_vis
	then
		#vk_public
	else
		if v = #protected_vis
		then
			#vk_protected
		else
			if v = #private_vis
			then
				#vk_protected
			else -- default
				#vk_public 	
			endif
		endif
	endif;

-- This helper returns the UML!Visibility that corresponds to the
-- MOF!Visibility of the contextual MOF!ModelElement.
-- If the visibility of the contexual ModelElement is undefined, the helper
-- returns 'vk_public', otherwise, it returns the value provided by
-- getVisibility().
--
-- WARNING:	the contextual MOF!ModelElement must be of either a MOF!Feature, a
-- MOF!Import or a MOF!GeneralizableElement entity.
--
-- CONTEXT:	MOF!ModelElement
-- RETURN:	UML!Visibility
helper context MOF!ModelElement def: getUMLVisibility() : UML!Visibility =
	if self.visibility.oclIsUndefined()
	then
		#vk_public
	else
		self.getVisibility()
	endif;

-- This helper returns the UML!ChangeableKind that corresponds to the
-- non-undefined MOF!ChangeableKind of the contextual MOF!ModelElement.
-- The helper returns the '#ck_changable' or '#ck_frozen' value depending on
-- the value of the MOF 'isChangeable' boolean attribute.
--
-- WARNING:	the contextual MOF!ModelElement must be of either a
-- MOF!StructuralFeature or a MOF!AssociationEnd element.
--
-- CONTEXT: MOF!ModelElement
-- RETURN:	UML!ChangeableKind
helper context MOF!ModelElement def: getChangeability() : UML!ChangeableKind =
	if self.isChangeable
	then
		#ck_changeable
	else
		#ck_frozen
	endif;

-- This helper returns the UML!ChangeableKind that corresponds to the
-- MOF!ChangeableKind of the contextual MOF!ModelElement.
-- If changeability of the contextual MOF!ModelElement is undefined, the helper
-- returns the '#ck_changeable' default value. Otherwise, it returns the value
-- computes by the getChangeability helper.
--
-- WARNING:	the contextual MOF!ModelElement must be of either a
-- MOF!StructuralFeature or a MOF!AssociationEnd element.
--
-- CONTEXT: MOF!ModelElement
-- RETURN:	UML!ChangeableKind
helper context MOF!ModelElement
	def: getUMLChangeability() : UML!ChangeableKind =
	if not self.isChangeable.oclIsUndefined()
	then
		self.getChangeability()
	else
		#ck_changeable
	endif;

-- This helper returns the UML!ScopeKind that corresponds to the MOF!ScopeKind
-- of the contextual MOF!Feature.
-- CONTEXT: MOF!Feature
-- RETURN:	UML!ScopeKind
helper context MOF!Feature def: getUMLScope() : UML!ScopeKind = 
	if self.scope = #instance_level
	then
		#sk_instance
	else
		#sk_classifier
	endif;


-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'Association'
-- This rule generates a UML!Association, along with its associated
-- UML!Generalizations from a MOF!Association.
-- Most properties of the generated association are copied from the input MOF
-- association properties. Its generalizations correspond to the Generalization
-- that are generated by the rule, whereas its specializations correspond to
-- the UML!Associations that are generated for the MOF!Associations that have
-- the input association as supertype.
-- A UML!Generalization is generated fore each supertype of the input
-- MOF!Association. Its child corresponds to the generated UML association,
-- whereas its parent corresponds to the UML!Association generated for the
-- currently iterated supertype. Note that discriminator and powertype of the
-- generated Generalizations are set to default values since MOF defines no
-- corresponding properties.
rule Association {
	from
		ma : MOF!Association
	to
		ua : UML!Association (
			-- Begin bindings inherited from ModelElement
			name <- ma.name,
			constraint <- ma.constraints,
		  	namespace <- ma.container,
			visibility <- ma.getUMLVisibility(),
--			taggedValue <-,
--			asArgument <-,
--			clientDependency <-,
--			implementationLocation <-,
--			presentation <-,
--			supplierDependency <-,
--			templateParameter <-,
--			stereotype<-,
			-- End of bindings inherited from ModelElement
			
			-- Begin bindings inherited from GeneralizableElement
			isAbstract <- ma.isAbstract,
			isLeaf <- ma.isLeaf,
			isRoot <- ma.isRoot,
			generalization <- mr
			-- End of bindings inherited from GeneralizableElement
		),
		
		mr : distinct UML!Generalization foreach(e in ma.supertypes) (
			-- Begin bindings inherited from ModelElement
			name <- ma.name,
			constraint <- ma.supertypes->collect(e | e.constraints),
		  	namespace <- ma.container,
			visibility <- ma.getUMLVisibility(),
--			taggedValue <-,
--			asArgument <-,
--			clientDependency <-,
--			implementationLocation <-,
--			presentation <-,
--			supplierDependency <-,
--			templateParameter <-,
--			stereotype<-,
			-- End of bindings inherited from ModelElement
			
			child <- ua,
			parent <- e,
			discriminator <- '',
			powertype <- OclUndefined
		)
}

-- Rule 'AssociationEnd'
-- This rule generates a UML!AssociationEnd, along with its UML!Multiplicity,
-- and the MultiplicityRange of this last, from a MOF!AssociationEnd.
-- Most properties of the generated AssociationEnd are copied from those of
-- the input MOF AssociationEnd. Its multiplicity reference points to the
-- Multiplicity entity generated by the rule. The targetScope, qualifier and
-- specification properties are set to default values (MOF does not define
-- corresponding properties).
-- The range of the generated Multiplicity element is computed from the
-- multiplicity attribute of the input MOF!AssociationEnd.
rule AssociationEnd {
	from
		ma : MOF!AssociationEnd
	to
		ua : UML!AssociationEnd	(
			-- Begin bindings inherited from ModelElement
			name <- ma.name,
			constraint <- ma.constraints,
--		  	namespace <- ma.container,
--			visibility <-,
--			taggedValue <-,
--			asArgument <-,
--			clientDependency <-,
--			implementationLocation <-,
--			presentation <-,
--			supplierDependency <-,
--			templateParameter <-,
--			stereotype<-,
			-- End of bindings inherited from ModelElement

			association <- ma.container,
			aggregation <-
				if ma.aggregation = #none
				then
					#ak_none
				else
					if ma.aggregation = #shared
					then
						#ak_aggregate
					else	-- ma.aggregation = #composite
						#ak_composite
					endif
				endif,
			changeability <- ma.getUMLChangeability(),
			ordering <- ma.getUMLOrdering(),
			isNavigable <- ma.isNavigable,
			multiplicity <- um,
			targetScope <- #sk_instance,
			qualifier <- Sequence{},
			specification <- Set{},
			participant <- ma.type
		),
	
		um : UML!Multiplicity (
			range <- Set{ur}
		),
		
		ur : UML!MultiplicityRange (
			lower <- ma.multiplicity.lower,
			upper <- ma.multiplicity.upper,
			multiplicity <- um
		)
}

-- Rule 'Parameter'
-- This rule generates a UML!Parameter from a MOF!Parameter.
-- Properties of the generated Parameter are copied from those of the input
-- Parameter, except the UML defaultValue attribute which has no MOF
-- equivalent. It is therefore set to 'oclUndefined'.
rule Parameter {
	from
		mp : MOF!Parameter
	to
		up : UML!Parameter (
			-- Begin bindings inherited from ModelElement
			name <- mp.name,
			constraint <- mp.constraints,
--		  	namespace <- mp.container,
--			visibility <-,
--			taggedValue <-,
--			implementationLocation <-,
--			presentation <-,
--			supplierDependency <-,
--			templateParameter <-,
--			asArgument <-,
--			clientDependency <-,
--			stereotype<-,
			-- End of bindings inherited from ModelElement
			
			kind <-
				if mp.direction = #in_dir
				then
					#pdk_in
				else
					if mp.direction = #inout_dir
					then
						#pdk_inout
					else
						if mp.direction = #out_dir
						then
							#pdk_out
						else -- mp.direction = #return_dir
							#pdk_return
						endif
					endif
				endif,
			type <- mp.type,
			defaultValue <- OclUndefined
		)
}

-- Rule 'Attribute'
-- This rule generates a UML!Attribute, along with its UML!Multiplicity, and
-- the UML!MultiplicityRange of this last, from a MOF!Attribute.
-- Most properties of the generated Attribute are copied from those of the
-- input MOF Attribute. Its multiplicity reference points to the Multiplicity
-- entity generated by the rule. The targetScope and initialValue properties
-- are set to default values (MOF does not define corresponding properties):
-- 'sk_instance' for targetScope and 'oclUndefined' for initialValue.
-- The range of the generated Multiplicity element is computed from the
-- multiplicity attribute of the input MOF!Attribute.
rule Attribute {
	from
		ma : MOF!Attribute
	to
		ua : UML!Attribute (
			-- Begin bindings inherited from ModelElement
			name <- ma.name,
			constraint <- ma.constraints,
--		  	namespace <- ma.container,
			visibility <- ma.getUMLVisibility(),
--			taggedValue <-,
--			asArgument <-,
--			clientDependency <-,
--			implementationLocation <-,
--			presentation <-,
--			supplierDependency <-,
--			templateParameter <-,
--			stereotype<-,
			-- End of bindings inherited from ModelElement
			
			-- Begin bindings inherited from Feature
			ownerScope <- ma.getUMLScope(),
			owner <- ma.container,
			-- End of bindings inherited from Feature
			
			-- Begin bindings inherited from StructuralFeature
			changeability <- ma.getUMLChangeability(),
			multiplicity <- um,
			ordering <- ma.getUMLOrdering(),
			type <- ma.type,
			targetScope <- #sk_instance,
			-- End of bindings inherited from StructuralFeature
			
			initialValue <- OclUndefined
		),
		
		um : UML!Multiplicity (
			range <- Set{ur}
		),
		
		ur : UML!MultiplicityRange (
			lower <- ma.multiplicity.lower,
			upper <- ma.multiplicity.upper,
			multiplicity <- um
		)
}

-- Rule 'Class'
-- This rule generates a UML!Class, along with its associated
-- UML!Generalizations, the UML!Model, and the 'metamodel', 'import', and
-- 'clustering' UML!Stereotype from the reference MOF!Class provided by the
-- firstClass helper.
-- Most properties of the generated Class are copied from the input MOF!Class
-- properties. Its generalizations correspond to the Generalization that are
-- generated by the rule, whereas its specializations correspond to the
-- UML!Classes that are generated for the MOF!Classes that have the input Class
-- as supertype. The powertypeRange and isActive properties, which have no
-- equivalent in MOF, are set to default values.
-- A UML!Generalization is generated fore each supertype of the input
-- MOF!Class. Its child corresponds to the generated UML class, whereas its
-- parent corresponds to the UML!Class generated for the currently iterated
-- supertype. Note that discriminator and powertype of the generated
-- Generalizations are set to default values since MOF defines no corresponding
-- properties.
-- The generated Model is simply initialized with a default name value.
-- The different UML!Stereotype are generated if their respective reference
-- Sequences are not empty. Each stereotype is initialized with its name
-- ('clustering', 'import' or 'metamodel') and the name of the base class it is
-- associated with (respectively Dependcy for the 2 first ones, and Package).
-- Their namespace is set to the UML!Model ('mo') generated by the rule.
rule FirstClass {
	from
		mc : MOF!Class (
			mc = thisModule.firstClass
		)
	to
		uc : UML!Class (
			-- Begin bindings inherited from ModelElement
			name <- mc.name,
			constraint <- mc.constraints,
		  	namespace <- mc.container,
			visibility <- mc.getUMLVisibility(),
--			taggedValue <-,
--			asArgument <-,
--			clientDependency <-,
--			implementationLocation <-,
--			presentation <-,
--			supplierDependency <-,
--			templateParameter <-,
--			stereotype<-,
			-- End of bindings inherited from ModelElement
			
			-- Begin bindings inherited from GeneralizableElement
			isAbstract <- mc.isAbstract,
			isLeaf <- mc.isLeaf,
			isRoot <- mc.isRoot,
			generalization <- mr,
			-- End of bindings inherited from GeneralizableElement
			
			-- Begin bindings inherited from Namespace
--			ownedElement <- mc.contents,
			-- End of bindings inherited from Namespace
			
			-- Begin bindings inherited from Classifier
			feature <- mc.contents,
			powertypeRange <- Set{},
			-- End of bindings inherited from Classifier
			
			isActive <- false
		),

		mr : distinct UML!Generalization foreach(e in mc.supertypes) (
			-- Begin bindings inherited from ModelElement
			name <- mc.name,
			constraint <- mc.supertypes->collect(e | e.constraints),
		  	namespace <- mc.container,
			visibility <- mc.getUMLVisibility(),
--			taggedValue <-,
--			asArgument <-,
--			clientDependency <-,
--			implementationLocation <-,
--			presentation <-,
--			supplierDependency <-,
--			templateParameter <-,
--			stereotype<-,
			-- End of bindings inherited from ModelElement
			
			child <- uc,
			parent <- e,
			discriminator <- '',
			powertype <- OclUndefined
		),
		
		mo : UML!Model (
			-- Begin bindings inherited from ModelElement
			name <- 'Model'--,
--			constraint <- Set{},
--		  	namespace <- mp.container,
--			visibility <- mp.getUMLVisibility(),
--			taggedValue <-,
--			asArgument <-,
--			clientDependency <-,
--			implementationLocation <-,
--			presentation <-,
--			supplierDependency <-,
--			templateParameter <-,
--			stereotype <- Set{},
			-- End of bindings inherited from ModelElement

			-- Begin bindings inherited from GeneralizableElement
--			isAbstract <- mp.isAbstract,
--			isLeaf <- mp.isLeaf,
--			isRoot <- mp.isRoot,
--			generalization <- mr,
			-- End of bindings inherited from GeneralizableElement
			
			-- Begin bindings inherited from Namespace
--			ownedElement <- mp.contents,
			-- End of bindings inherited from Namespace
			
			-- Begin bindings inherited from Package
--			elementImport <- Set{}
			-- End Of bindings inherited from Package
		),
		
		cl : distinct UML!Stereotype foreach(e in thisModule.firstClustered) (
			-- Begin bindings inherited from ModelElement
			name <- 'clustering',
			constraint <- Sequence{ Set{} },
		  	namespace <- mo,
--			visibility <- mp.getUMLVisibility(),
--			taggedValue <-,
--			asArgument <-,
--			clientDependency <-,
--			implementationLocation <-,
--			presentation <-,
--			supplierDependency <-,
--			templateParameter <-,
			stereotype <- Sequence{ Set{} },
			-- End of bindings inherited from ModelElement
			
			-- Begin bindings inherited from GeneralizableElement
			isAbstract <- false,
			isLeaf <- false,
			isRoot <- false,
--			generalization <-,
			-- End of bindings inherited from GeneralizableElement
			
			stereotypeConstraint <- Sequence{ Set{} },
			definedTag <- Sequence{ Set{} },
			icon <- OclUndefined,
			baseClass <- Sequence{ Set{'Dependency'} }
		),
		
		im : distinct UML!Stereotype foreach(e in thisModule.firstImport) (
			-- Begin bindings inherited from ModelElement
			name <- 'import',
			constraint <- Sequence{ Set{} },
		  	namespace <- mo,
--			visibility <- mp.getUMLVisibility(),
--			taggedValue <-,
--			asArgument <-,
--			clientDependency <-,
--			implementationLocation <-,
--			presentation <-,
--			supplierDependency <-,
--			templateParameter <-,
			stereotype <- Sequence{ Set{} },
			-- End of bindings inherited from ModelElement
			
			-- Begin bindings inherited from GeneralizableElement
			isAbstract <- false,
			isLeaf <- false,
			isRoot <- false,
--			generalization <-,
			-- End of bindings inherited from GeneralizableElement
			
			stereotypeConstraint <- Sequence{ Set{} },
			definedTag <- Sequence{ Set{} },
			icon <- OclUndefined,
			baseClass <- Sequence{ Set{'Dependency'} }
		),
		
		mm : distinct UML!Stereotype foreach(e in thisModule.firstMetamodel) (
			-- Begin bindings inherited from ModelElement
			name <- 'metamodel',
			constraint <- Sequence{ Set{} },
		  	namespace <- mo,
--			visibility <- mp.getUMLVisibility(),
--			taggedValue <-,
--			asArgument <-,
--			clientDependency <-,
--			implementationLocation <-,
--			presentation <-,
--			supplierDependency <-,
--			templateParameter <-,
			stereotype <- Sequence{ Set{} },
			-- End of bindings inherited from ModelElement
			
			-- Begin bindings inherited from GeneralizableElement
			isAbstract <- false,
			isLeaf <- false,
			isRoot <- false,
--			generalization <-,
			-- End of bindings inherited from GeneralizableElement
			
			stereotypeConstraint <- Sequence{ Set{} },
			definedTag <- Sequence{ Set{} },
			icon <- OclUndefined,
			baseClass <- Sequence{ Set{'Package'} }
		)
}

-- Rule 'OtherClass'
-- This rule generates a UML!Class, along with its associated
-- UML!Generalizations for each MOF!Class that is distinct from the reference
-- class computed by the firstClass helper.
-- Most properties of the generated Class are copied from the input MOF!Class
-- properties. Its generalizations correspond to the Generalization that are
-- generated by the rule, whereas its specializations correspond to the
-- UML!Classes that are generated for the MOF!Classes that have the input Class
-- as supertype. The powertypeRange and isActive properties, which have no
-- equivalent in MOF, are set to default values.
-- A UML!Generalization is generated fore each supertype of the input
-- MOF!Class. Its child corresponds to the generated UML class, whereas its
-- parent corresponds to the UML!Class generated for the currently iterated
-- supertype. Note that discriminator and powertype of the generated
-- Generalizations are set to default values since MOF defines no corresponding
-- properties.
rule OtherClass {
	from
		mc : MOF!Class (
			mc <> thisModule.firstClass
		)
	to
		uc : UML!Class (
			-- Begin bindings inherited from ModelElement
			name <- mc.name,
			constraint <- mc.constraints,
		  	namespace <- mc.container,
			visibility <- mc.getUMLVisibility(),
--			taggedValue <-,
--			asArgument <-,
--			clientDependency <-,
--			implementationLocation <-,
--			presentation <-,
--			supplierDependency <-,
--			templateParameter <-,
--			stereotype<-,
			-- End of bindings inherited from ModelElement
			
			-- Begin bindings inherited from GeneralizableElement
			isAbstract <- mc.isAbstract,
			isLeaf <- mc.isLeaf,
			isRoot <- mc.isRoot,
			generalization <- mr,
			-- End of bindings inherited from GeneralizableElement
			
			-- Begin bindings inherited from Namespace
--			ownedElement <- mc.contents,
			-- End of bindings inherited from Namespace
			
			-- Begin bindings inherited from Classifier
			feature <- mc.contents,
			powertypeRange <- Set{},
			-- End of bindings inherited from Classifier
			
			isActive <- false
		),

		mr : distinct UML!Generalization foreach(e in mc.supertypes) (
			-- Begin bindings inherited from ModelElement
			name <- mc.name,
			constraint <- mc.supertypes->collect(e | e.constraints),
		  	namespace <- mc.container,
			visibility <- mc.getUMLVisibility(),
--			taggedValue <-,
--			asArgument <-,
--			clientDependency <-,
--			implementationLocation <-,
--			presentation <-,
--			supplierDependency <-,
--			templateParameter <-,
--			stereotype<-,
			-- End of bindings inherited from ModelElement
			
			child <- uc,
			parent <- e,
			discriminator <- '',
			powertype <- OclUndefined
		)
}

-- Rule 'Operation'
-- This rule generates a UML!Operation from a MOF!Operation.
-- Properties of the generated operation are copied from those of the input MOF
-- operation, except concurrency, isAbstract, isLeaf and isRoot, which are not
-- defined in MOF, and therefore set to default values.
rule Operation {
	from
		mo : MOF!Operation
	to
		uo : UML!Operation (
			-- Begin bindings inherited from ModelElement
			name <- mo.name,
			constraint <- mo.constraints,
--		  	namespace <- mo.container,
			visibility <- mo.getUMLVisibility(),
--			taggedValue <-,
--			asArgument <-,
--			clientDependency <-,
--			implementationLocation <-,
--			presentation <-,
--			supplierDependency <-,
--			templateParameter <-,
--			stereotype<-,
			-- End of bindings inherited from ModelElement

			-- Begin bindings inherited from Feature
			ownerScope <- mo.getUMLScope(),
			owner <- mo.container,
			-- End of bindings inherited from Feature
			
			-- Begin bindings inherited from BehavioralFeature
			isQuery <- mo.isQuery,
			parameter <- mo.contents,
			-- End of bindings inherited from BehavioralFeature
			
			concurrency <- #cck_guarded,
			isAbstract <- false,
			isLeaf <- false,
			isRoot <- false
		)
}

-- Rule 'Constraint'
-- This rule generates a UML!Constraint from a MOF!Constraint.
-- Properties of the generated constraint are copied from the input constraint,
-- except body which is set by default to the 'oclUndefined' value.
rule Constraint {
	from
		mc : MOF!Constraint
	to
		uc : UML!Constraint (
			-- Begin bindings inherited from ModelElement
			name <- mc.name,
			constraint <- mc.constraints,
		  	namespace <- mc.container,
--			visibility <-,
--			taggedValue <-,
--			asArgument <-,
--			clientDependency <-,
--			implementationLocation <-,
--			presentation <-,
--			supplierDependency <-,
--			templateParameter <-,
--			stereotype<-,
			-- End of bindings inherited from ModelElement
			
			constrainedElement <- mc.constrainedElements,
			body <- OclUndefined
		)
}

-- Rule 'Tag'
-- This rule generates a UML!TaggedValue from a MOF!Tag.
-- Note that the type of the generated Tag is copied from the MOF!Tag tagId
-- attribute. The model element the generated TaggedValue is attached to
-- corresponds to the first element of the elements collection of the input
-- MOF!Tag entity. Finally, as MOF only provides support for dataValues, the
-- referenceValue of the genereated UML!TaggedValue elemlent is initialized
-- with an empty set.
rule TaggedValue {
	from
		mt : MOF!Tag
	to
		ut : UML!TaggedValue (
			-- Begin bindings inherited from ModelElement
			name <- mt.name,
			constraint <- mt.constraints,
		  	namespace <- mt.container,
--			visibility <-,
--			taggedValue <-,
--			asArgument <-,
--			clientDependency <-,
--			implementationLocation <-,
--			presentation <-,
--			supplierDependency <-,
--			templateParameter <-,
--			stereotype<-,
			-- End of bindings inherited from ModelElement

			dataValue <- mt.values,
			type <- mt.tagId,
			modelElement <- mt.elements->asSequence()->first(),
			referenceValue <- Set{}
		)
}

-- Rule 'Import'
-- This rule generates a UML!Dependency from a MOF!Import entity.
-- The client of the generated Dependency corresponds to the container of the
-- input Import, whereas its supplier corresponds to the importedNamespace of
-- the Import.
-- The namespace of the generated package corresponds to the model ('mo')
-- generated by the FirstClass rule, whereas, according to the value of the
-- isClustered attribute, its stereotype corresponds either to the clustering
-- ('cl') or import ('im') stereotype generated by FirstClass.
rule Import {
	from
		mi : MOF!Import
	to
		ud : UML!Dependency (
			-- Begin bindings inherited from ModelElement
			name <- mi.name,
			constraint <- mi.constraints,
--			implementationLocation <-,
--			presentation <-,
--			supplierDependency <-,
--			templateParameter <-,
		  	namespace <- thisModule.resolveTemp(thisModule.firstClass, 'mo'),
--			visibility <-,
--			taggedValue <-,
			stereotype <-
				Set{
					if mi.isClustered
					then
						thisModule.resolveTemp(thisModule.firstClass, 'cl')
					else
						thisModule.resolveTemp(thisModule.firstClass, 'im')
					endif
				},
			-- End of bindings inherited from ModelElement
			
			client <- Sequence{mi.container},
			supplier <- Sequence{mi.importedNamespace}
		)
}

-- Rule 'Package'
-- This rule generates a UML Package with its associated Generalizations from a
-- MOF Package.
-- Most properties of the generated Package are copied from the input
-- MOF!Package properties. Its generalizations correspond to the Generalization
-- that are generated by the rule, whereas its specializations correspond to
-- the UML!Packages that are generated for the MOF!Packages that have the input
-- Package as supertype. The powertypeRange and isActive properties, which have
-- no equivalent in MOF, are set to default values. The namespace of the
-- generated package corresponds to the model ('mo') generated by the
-- FirstClass rule, whereas its stereotype corresponds to the metamodel ('mm')
-- stereotype generated by this rule.
-- A UML!Generalization is generated fore each supertype of the input
-- MOF!Package. Its child corresponds to the generated UML Package, whereas its
-- parent corresponds to the UML!Package generated for the currently iterated
-- supertype. Note that discriminator and powertype of the generated
-- Generalizations are set to default values since MOF defines no corresponding
-- properties.
rule Package {
	from
		mp : MOF!Package
	to
		up : UML!Package (
			-- Begin bindings inherited from ModelElement
			name <- mp.name,
			constraint <- mp.constraints,
		  	namespace <- thisModule.resolveTemp(thisModule.firstClass, 'mo'),
			visibility <- mp.getUMLVisibility(),
--			taggedValue <-,
--			asArgument <-,
--			clientDependency <-,
--			implementationLocation <-,
--			presentation <-,
--			supplierDependency <-,
--			templateParameter <-,
			stereotype <-
				Set{thisModule.resolveTemp(thisModule.firstClass, 'mm')},
			-- End of bindings inherited from ModelElement
			
			-- Begin bindings inherited from GeneralizableElement
			isAbstract <- mp.isAbstract,
			isLeaf <- mp.isLeaf,
			isRoot <- mp.isRoot,
			generalization <- mr,
			-- End of bindings inherited from GeneralizableElement
			
			-- Begin bindings inherited from Namespace
--			ownedElement <- ,
			-- End of bindings inherited from Namespace
			
			elementImport <- Set{}
		),
		
		mr : distinct UML!Generalization foreach(e in mp.supertypes) (
			-- Begin bindings inherited from ModelElement
			name <- mp.name,
			constraint <- mp.supertypes->collect(e | e.constraints),
		  	namespace <- mp.container,
			visibility <- mp.getUMLVisibility(),
--			taggedValue <-,
--			asArgument <-,
--			clientDependency <-,
--			implementationLocation <-,
--			presentation <-,
--			supplierDependency <-,
--			templateParameter <-,
--			stereotype<-,
			-- End of bindings inherited from ModelElement
			
			child <- up,
			parent <- e,
			discriminator <- '',
			powertype <- OclUndefined
		)
}

-- Rule 'AliasType'
--rule AliasType {
--	from
--		ma : MOF!AliasType
--	to
--		ud : UML!DataType (
--			stereotype <- 'alias'
--		)
--}

-- Rule 'CollectionType'
--rule CollectionType {
--	from
--		mc : MOF!CollectionType
--	to
--		uc : UML!Class (
--			stereotype <- 'collection',
--			type <- mc.type,
--			multiplicity <- um
--		),

--		um : UML!Multiplicity (
--			range <- Set{ur}
--		),

--		ur : UML!MultiplicityRange (
--			lower <- mc.multiplicity.lower,
--			upper <- mc.multiplicity.upper,
--			multiplicity <- um
--		)
--}
",modul mof uml creat out uml in mof use string helper this helper return mof class consid refer class generat uniqu target element model possibl stereotyp context thismodul return mof class helper def firstclass mof class mof class allinstancesfrom in assequ first this helper return cluster mof import consid refer import generat cluster stereotyp context thismodul return sequenc mof import helper def firstclust sequenc mof import sequenc mof import allinstancesfrom in select e e isclust assequ first this helper return unclust mof import consid refer import generat import stereotyp context thismodul return set mof import helper def firstimport sequenc mof import sequenc mof import allinstancesfrom in select e e isclust assequ first this helper return mof packag consid refer packag generat import stereotyp context thismodul return set mof packag helper def firstmetamodel sequenc mof packag sequenc mof packag allinstancesfrom in assequ first this helper return uml orderingkind correspond non undefin mof scopekind contextu mof modelel the helper return order unord valu depend valu mof isord boolean attribut warn contextu mof modelel must either mof structuralfeatur mof associationend element context mof modelel return uml orderingkind helper context mof modelel def getord uml orderingkind self multipl isord ok order els ok unord endif this helper return uml orderingkind correspond mof scopekind contextu mof modelel if multipl attribut contextu modelel isord attribut undefin helper return ok unord otherwis helper retun valu comput getord warn contextu mof modelel must either mof structuralfeatur mof associationend element context mof modelel return uml orderingkind helper context mof modelel def getumlord uml orderingkind self multipl oclisundefin ok unord els self multipl isord oclisundefin ok unord els self getord endif endif this helper return uml visibl correspond non undefin mof visibl contextu mof modelel warn contextu mof modelel must either mof featur mof import mof generalizableel entiti context mof modelel return uml visibl helper context mof modelel def getvis uml visibl let v mof visibl self visibl v public vis vk public els v protect vis vk protect els v privat vis vk protect els default vk public endif endif endif this helper return uml visibl correspond mof visibl contextu mof modelel if visibl contexu modelel undefin helper return vk public otherwis return valu provid getvis warn contextu mof modelel must either mof featur mof import mof generalizableel entiti context mof modelel return uml visibl helper context mof modelel def getumlvis uml visibl self visibl oclisundefin vk public els self getvis endif this helper return uml changeablekind correspond non undefin mof changeablekind contextu mof modelel the helper return ck changabl ck frozen valu depend valu mof ischang boolean attribut warn contextu mof modelel must either mof structuralfeatur mof associationend element context mof modelel return uml changeablekind helper context mof modelel def getchang uml changeablekind self ischang ck changeabl els ck frozen endif this helper return uml changeablekind correspond mof changeablekind contextu mof modelel if changeabl contextu mof modelel undefin helper return ck changeabl default valu otherwis return valu comput getchang helper warn contextu mof modelel must either mof structuralfeatur mof associationend element context mof modelel return uml changeablekind helper context mof modelel def getumlchang uml changeablekind self ischang oclisundefin self getchang els ck changeabl endif this helper return uml scopekind correspond mof scopekind contextu mof featur context mof featur return uml scopekind helper context mof featur def getumlscop uml scopekind self scope instanc level sk instanc els sk classifi endif rule rule associ this rule generat uml associ along associ uml general mof associ most properti generat associ copi input mof associ properti it general correspond general generat rule wherea special correspond uml associ generat mof associ input associ supertyp a uml general generat fore supertyp input mof associ it child correspond generat uml associ wherea parent correspond uml associ generat current iter supertyp note discrimin powertyp generat general set default valu sinc mof defin correspond properti rule associ mof associ ua uml associ begin bind inherit modelel name name constraint constraint namespac contain visibl getumlvis taggedvalu asargu clientdepend implementationloc present supplierdepend templateparamet stereotyp end bind inherit modelel begin bind inherit generalizableel isabstract isabstract isleaf isleaf isroot isroot general mr end bind inherit generalizableel mr distinct uml general foreach e supertyp begin bind inherit modelel name name constraint supertyp collect e e constraint namespac contain visibl getumlvis taggedvalu asargu clientdepend implementationloc present supplierdepend templateparamet stereotyp end bind inherit modelel child ua parent e discrimin powertyp oclundefin rule associationend this rule generat uml associationend along uml multipl multiplicityrang last mof associationend most properti generat associationend copi input mof associationend it multipl refer point multipl entiti generat rule the targetscop qualifi specif properti set default valu mof defin correspond properti the rang generat multipl element comput multipl attribut input mof associationend rule associationend mof associationend ua uml associationend begin bind inherit modelel name name constraint constraint namespac contain visibl taggedvalu asargu clientdepend implementationloc present supplierdepend templateparamet stereotyp end bind inherit modelel associ contain aggreg aggreg none ak none els aggreg share ak aggreg els aggreg composit ak composit endif endif changeabl getumlchang order getumlord isnavig isnavig multipl um targetscop sk instanc qualifi sequenc specif set particip type um uml multipl rang set ur ur uml multiplicityrang lower multipl lower upper multipl upper multipl um rule paramet this rule generat uml paramet mof paramet properti generat paramet copi input paramet except uml defaultvalu attribut mof equival it therefor set oclundefin rule paramet mp mof paramet uml paramet begin bind inherit modelel name mp name constraint mp constraint namespac mp contain visibl taggedvalu implementationloc present supplierdepend templateparamet asargu clientdepend stereotyp end bind inherit modelel kind mp direct dir pdk els mp direct inout dir pdk inout els mp direct dir pdk els mp direct return dir pdk return endif endif endif type mp type defaultvalu oclundefin rule attribut this rule generat uml attribut along uml multipl uml multiplicityrang last mof attribut most properti generat attribut copi input mof attribut it multipl refer point multipl entiti generat rule the targetscop initialvalu properti set default valu mof defin correspond properti sk instanc targetscop oclundefin initialvalu the rang generat multipl element comput multipl attribut input mof attribut rule attribut mof attribut ua uml attribut begin bind inherit modelel name name constraint constraint namespac contain visibl getumlvis taggedvalu asargu clientdepend implementationloc present supplierdepend templateparamet stereotyp end bind inherit modelel begin bind inherit featur ownerscop getumlscop owner contain end bind inherit featur begin bind inherit structuralfeatur changeabl getumlchang multipl um order getumlord type type targetscop sk instanc end bind inherit structuralfeatur initialvalu oclundefin um uml multipl rang set ur ur uml multiplicityrang lower multipl lower upper multipl upper multipl um rule class this rule generat uml class along associ uml general uml model metamodel import cluster uml stereotyp refer mof class provid firstclass helper most properti generat class copi input mof class properti it general correspond general generat rule wherea special correspond uml class generat mof class input class supertyp the powertyperang isact properti equival mof set default valu a uml general generat fore supertyp input mof class it child correspond generat uml class wherea parent correspond uml class generat current iter supertyp note discrimin powertyp generat general set default valu sinc mof defin correspond properti the generat model simpli initi default name valu the differ uml stereotyp generat respect refer sequenc empti each stereotyp initi name cluster import metamodel name base class associ respect dependci first one packag their namespac set uml model mo generat rule rule firstclass mc mof class mc thismodul firstclass uc uml class begin bind inherit modelel name mc name constraint mc constraint namespac mc contain visibl mc getumlvis taggedvalu asargu clientdepend implementationloc present supplierdepend templateparamet stereotyp end bind inherit modelel begin bind inherit generalizableel isabstract mc isabstract isleaf mc isleaf isroot mc isroot general mr end bind inherit generalizableel begin bind inherit namespac ownedel mc content end bind inherit namespac begin bind inherit classifi featur mc content powertyperang set end bind inherit classifi isact fals mr distinct uml general foreach e mc supertyp begin bind inherit modelel name mc name constraint mc supertyp collect e e constraint namespac mc contain visibl mc getumlvis taggedvalu asargu clientdepend implementationloc present supplierdepend templateparamet stereotyp end bind inherit modelel child uc parent e discrimin powertyp oclundefin mo uml model begin bind inherit modelel name model constraint set namespac mp contain visibl mp getumlvis taggedvalu asargu clientdepend implementationloc present supplierdepend templateparamet stereotyp set end bind inherit modelel begin bind inherit generalizableel isabstract mp isabstract isleaf mp isleaf isroot mp isroot general mr end bind inherit generalizableel begin bind inherit namespac ownedel mp content end bind inherit namespac begin bind inherit packag elementimport set end of bind inherit packag cl distinct uml stereotyp foreach e thismodul firstclust begin bind inherit modelel name cluster constraint sequenc set namespac mo visibl mp getumlvis taggedvalu asargu clientdepend implementationloc present supplierdepend templateparamet stereotyp sequenc set end bind inherit modelel begin bind inherit generalizableel isabstract fals isleaf fals isroot fals general end bind inherit generalizableel stereotypeconstraint sequenc set definedtag sequenc set icon oclundefin baseclass sequenc set depend im distinct uml stereotyp foreach e thismodul firstimport begin bind inherit modelel name import constraint sequenc set namespac mo visibl mp getumlvis taggedvalu asargu clientdepend implementationloc present supplierdepend templateparamet stereotyp sequenc set end bind inherit modelel begin bind inherit generalizableel isabstract fals isleaf fals isroot fals general end bind inherit generalizableel stereotypeconstraint sequenc set definedtag sequenc set icon oclundefin baseclass sequenc set depend mm distinct uml stereotyp foreach e thismodul firstmetamodel begin bind inherit modelel name metamodel constraint sequenc set namespac mo visibl mp getumlvis taggedvalu asargu clientdepend implementationloc present supplierdepend templateparamet stereotyp sequenc set end bind inherit modelel begin bind inherit generalizableel isabstract fals isleaf fals isroot fals general end bind inherit generalizableel stereotypeconstraint sequenc set definedtag sequenc set icon oclundefin baseclass sequenc set packag rule otherclass this rule generat uml class along associ uml general mof class distinct refer class comput firstclass helper most properti generat class copi input mof class properti it general correspond general generat rule wherea special correspond uml class generat mof class input class supertyp the powertyperang isact properti equival mof set default valu a uml general generat fore supertyp input mof class it child correspond generat uml class wherea parent correspond uml class generat current iter supertyp note discrimin powertyp generat general set default valu sinc mof defin correspond properti rule otherclass mc mof class mc thismodul firstclass uc uml class begin bind inherit modelel name mc name constraint mc constraint namespac mc contain visibl mc getumlvis taggedvalu asargu clientdepend implementationloc present supplierdepend templateparamet stereotyp end bind inherit modelel begin bind inherit generalizableel isabstract mc isabstract isleaf mc isleaf isroot mc isroot general mr end bind inherit generalizableel begin bind inherit namespac ownedel mc content end bind inherit namespac begin bind inherit classifi featur mc content powertyperang set end bind inherit classifi isact fals mr distinct uml general foreach e mc supertyp begin bind inherit modelel name mc name constraint mc supertyp collect e e constraint namespac mc contain visibl mc getumlvis taggedvalu asargu clientdepend implementationloc present supplierdepend templateparamet stereotyp end bind inherit modelel child uc parent e discrimin powertyp oclundefin rule oper this rule generat uml oper mof oper properti generat oper copi input mof oper except concurr isabstract isleaf isroot defin mof therefor set default valu rule oper mo mof oper uo uml oper begin bind inherit modelel name mo name constraint mo constraint namespac mo contain visibl mo getumlvis taggedvalu asargu clientdepend implementationloc present supplierdepend templateparamet stereotyp end bind inherit modelel begin bind inherit featur ownerscop mo getumlscop owner mo contain end bind inherit featur begin bind inherit behavioralfeatur isqueri mo isqueri paramet mo content end bind inherit behavioralfeatur concurr cck guard isabstract fals isleaf fals isroot fals rule constraint this rule generat uml constraint mof constraint properti generat constraint copi input constraint except bodi set default oclundefin valu rule constraint mc mof constraint uc uml constraint begin bind inherit modelel name mc name constraint mc constraint namespac mc contain visibl taggedvalu asargu clientdepend implementationloc present supplierdepend templateparamet stereotyp end bind inherit modelel constrainedel mc constrainedel bodi oclundefin rule tag this rule generat uml taggedvalu mof tag note type generat tag copi mof tag tagid attribut the model element generat taggedvalu attach correspond first element element collect input mof tag entiti final mof provid support datavalu referencevalu genereat uml taggedvalu eleml initi empti set rule taggedvalu mt mof tag ut uml taggedvalu begin bind inherit modelel name mt name constraint mt constraint namespac mt contain visibl taggedvalu asargu clientdepend implementationloc present supplierdepend templateparamet stereotyp end bind inherit modelel datavalu mt valu type mt tagid modelel mt element assequ first referencevalu set rule import this rule generat uml depend mof import entiti the client generat depend correspond contain input import wherea supplier correspond importednamespac import the namespac generat packag correspond model mo generat firstclass rule wherea accord valu isclust attribut stereotyp correspond either cluster cl import im stereotyp generat firstclass rule import mi mof import ud uml depend begin bind inherit modelel name mi name constraint mi constraint implementationloc present supplierdepend templateparamet namespac thismodul resolvetemp thismodul firstclass mo visibl taggedvalu stereotyp set mi isclust thismodul resolvetemp thismodul firstclass cl els thismodul resolvetemp thismodul firstclass im endif end bind inherit modelel client sequenc mi contain supplier sequenc mi importednamespac rule packag this rule generat uml packag associ general mof packag most properti generat packag copi input mof packag properti it general correspond general generat rule wherea special correspond uml packag generat mof packag input packag supertyp the powertyperang isact properti equival mof set default valu the namespac generat packag correspond model mo generat firstclass rule wherea stereotyp correspond metamodel mm stereotyp generat rule a uml general generat fore supertyp input mof packag it child correspond generat uml packag wherea parent correspond uml packag generat current iter supertyp note discrimin powertyp generat general set default valu sinc mof defin correspond properti rule packag mp mof packag uml packag begin bind inherit modelel name mp name constraint mp constraint namespac thismodul resolvetemp thismodul firstclass mo visibl mp getumlvis taggedvalu asargu clientdepend implementationloc present supplierdepend templateparamet stereotyp set thismodul resolvetemp thismodul firstclass mm end bind inherit modelel begin bind inherit generalizableel isabstract mp isabstract isleaf mp isleaf isroot mp isroot general mr end bind inherit generalizableel begin bind inherit namespac ownedel end bind inherit namespac elementimport set mr distinct uml general foreach e mp supertyp begin bind inherit modelel name mp name constraint mp supertyp collect e e constraint namespac mp contain visibl mp getumlvis taggedvalu asargu clientdepend implementationloc present supplierdepend templateparamet stereotyp end bind inherit modelel child parent e discrimin powertyp oclundefin rule aliastyp rule aliastyp mof aliastyp ud uml datatyp stereotyp alia rule collectiontyp rule collectiontyp mc mof collectiontyp uc uml class stereotyp collect type mc type multipl um um uml multipl rang set ur ur uml multiplicityrang lower mc multipl lower upper mc multipl upper multipl um,18
210,210,P91-UML2MOF.atl,"module UML2MOF;
create OUT : MOF from IN : UML;


uses strings;


-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- This helper computes a MOF!VisibilityKind from a UML!VisibilityKind.
-- CONTEXT: thisModule
-- IN:		UML!VisibilityKind
-- RETURN:	MOF!VisibilityKind
helper def: getVisibility(v : UML!VisibilityKind) : MOF!VisibilityKind =
	if v = #vk_public
	then
		#public_vis
	else
		if v = #vk_private
		then
			#private_vis
		else
			if v = #vk_protected
			then
				#protected_vis
			else
				#public_vis	-- default
			endif
		endif
	endif;

-- This helper computes the MOF!VisibilityKind that corresponds to the
-- UML!VisibilityKind of the contextual UML!ModelElement. If this visibility
-- kind is undefined, the helper retuns 'public_vis' as a default value.
-- CONTEXT: UML!ModelElement
-- RETURN:	MOF!VisibilityKind
helper context UML!ModelElement def: getMOFVisibility() : MOF!VisibilityKind =
	let v : UML!VisibilityKind = self.visibility in
	if not v.oclIsUndefined()
	then
		thisModule.getVisibility(v)
	else
		#public_vis
	endif;

-- This helper computes the MOF!ScopeKind that corresponds to the
-- UML!ScopeKind of the contextual UML!Feature.
-- CONTEXT: UML!Feature
-- RETURN:	MOF!ScopeKind
helper context UML!Feature def: getMOFScope() : MOF!ScopeKind =
	if self.ownerScope = #sk_instance
	then
		#instance_level
	else
		#classifier_level
	endif;

-- This helper computes the MOF isChangeable boolean attribute that corresponds
-- to the UML!Changeability of the contextual UML!ModelElement (whose
-- changeability is not undefined).
-- CONTEXT: UML!ModelElement
-- RETURN:	Boolean
helper context UML!ModelElement def: getIsChangeable() : Boolean =
	(self.changeability = #ck_changeable);

-- This helper computes the MOF isChangeable boolean attribute that corresponds
-- to the UML!Changeability of the contextual UML!ModelElement. If this
-- changeability is undefined, the helper retuns true as a default value.
-- CONTEXT: UML!ModelElement
-- RETURN:	Boolean
helper context UML!ModelElement def: getMOFIsChangeable() : Boolean =
	if not self.changeability.oclIsUndefined()
	then
		self.getIsChangeable()
	else
		true
	endif;

-- This helper computes the tuple encoding the MOF multiplicity that
-- corresponds to the UML!Multiplicity, UML!OrederingKind, and the isUnique
-- boolean provided as parameters.
-- CONTEXT: thisModule
-- IN:		UML!Multiplicity, UML!OrderingKind,	Boolean
-- RETURN:	TupleType(Integer, Integer, Boolean, Boolean)
helper def: getMultiplicity(m : UML!Multiplicity,
							o : UML!OrderingKind,
							isUnique : Boolean) :
							TupleType(lower : Integer,
									  upper : Integer,
									  isOrdered : Boolean,
									  isUnique : Boolean) =
	Tuple{
		lower = m.range->asSequence()->first().lower,
		upper = m.range->asSequence()->first().upper,
		isOrdered = (o = 'ok_ordered'),
		isUnique = isUnique
	};

-- This helper computes the tuple encoding the MOF multiplicity that
-- corresponds to the UML!Multiplicity of the contextual UML!StructuralFeature.
-- If the multiplicity of the contextual structural feature is undefined, the
-- helper returns (1,1,true,true) as a default tuple. Otherwise, it returns the
-- tuple computed by the getMultiplicity helper. Note that if the ordering of
-- the contextual structural feature is undefined, it is considered as ordered.
-- CONTEXT: UML!StructuralFeature
-- RETURN:	TupleType(Integer, Integer, Boolean, Boolean)
helper context UML!StructuralFeature def: getMOFMultiplicity() : 
						TupleType(lower : Integer, upper : Integer,
								  isOrdered : Boolean, isUnique : Boolean) =
	if not self.multiplicity.oclIsUndefined()
	then
		if not self.ordering.oclIsUndefined()
		then
			thisModule.getMultiplicity(self.multiplicity, self.ordering, false)
		else
			thisModule.getMultiplicity(self.multiplicity, 'ok_ordered', false)
		endif
	else
		Tuple{lower = 1, upper = 1, isOrdered = true, isUnique = true}
	endif;
	
-- Helper ...
-- CONTEXT: UML!ModelElement
-- RETURN:	String
--helper context UML!ModelElement def: getMOFQualifiedName() : String =
--	self.name;
	

-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'Package'
-- This rule generates a MOF package from each UML package that has a
-- stereotype named 'metamodel'.
-- Supertypes of the generated package correspond to the parent of the
-- generalization of the input UML package.
rule Package {
	from
		up : UML!Package (
			up.stereotype->exists(e | e.name = 'metamodel')
		)
	to
		mp : MOF!Package (
			-- Begin bindings inherited from ModelElement
			name <- up.name,
			annotation <- '',
			container <- up.namespace,
			constraints <- up.constraint,
--			requiredElements <-,
			-- End of bindings inherited from ModelElement
			
			-- Begin bindings inherited from Namespace
			contents <- up.ownedElement,
			-- End of bindings inherited from Namespace
			
			-- Begin bindings inherited from GeneralizableElement
			isRoot <- up.isRoot,
			isLeaf <- up.isLeaf,
			isAbstract <- up.isAbstract,
			visibility <- up.getMOFVisibility(),
			supertypes <- up.generalization->collect(e | e.parent)
			-- End of bindings inherited from GeneralizableElement
		)
}

-- Rule 'Constraint'
-- This rule generates a MOF constraint from a UML one. Properties of the
-- generated constraint, except evaluationPolicy, are copied from the input UML
-- constraint.
-- The MOF evaluationPolicy property, which has no equivalent in UML, is set to
-- the default 'immediate' value.
rule Constraint {
	from
		uc : UML!Constraint
	to
		mc : MOF!Constraint(
			-- Begin bindings inherited from ModelElement
			name <- uc.name,
			annotation <- '',
			container <- uc.namespace,
			constraints <- uc.constraint,
--			requiredElements <-,
			-- End of bindings inherited from ModelElement

			expression <- uc.body.body,
			language <- uc.body.language,
			constrainedElements <- uc.constrainedElement,
			evaluationPolicy <- #immediate
		)
}

-- Rule 'Comment'
-- This rule generates a MOF constraint from each UML Comment that has a
-- 'constraint' stereotype.
-- The content of the generated constraint corresponds to the body of the input
-- UML comment, its language is associated with the OCL default value.
rule Comment {
	from
		uc : UML!Comment (
			uc.stereotype->exists(e | e.name = 'constraint')
		)
	to
		mc : MOF!Constraint(
			-- Begin bindings inherited from ModelElement
			name <- uc.name,
			annotation <- '',
			container <- uc.namespace,
			constraints <- uc.constraint,
--			requiredElements <-,
			-- End of bindings inherited from ModelElement

			expression <- uc.body,
			language <- 'OCL',
			constrainedElements <- uc.annotatedElement
		)
}

-- Rule 'Class'
-- This rule generates a MOF class from each UML class whose namespace (which
-- expected to be a Package) has a 'metamodel' stereotype.
-- Properties of the generated class are copied from the input UML class
-- properties.
rule Class {
	from
		uc : UML!Class (
			uc.namespace.stereotype->exists(e | e.name = 'metamodel')
		)
	to
		mc : MOF!Class (
			-- Begin bindings inherited from ModelElement
			name <- uc.name,
			annotation <- '',
			container <- uc.namespace,
			constraints <- uc.constraint,
--			requiredElements <-,
			-- End of bindings inherited from ModelElement

			-- Begin bindings inherited from Namespace
			contents <- uc.ownedElement,
			-- End of bindings inherited from Namespace
			
			-- Begin bindings inherited from GeneralizableElement
			isRoot <- uc.isRoot,
			isLeaf <- uc.isLeaf,
			isAbstract <- uc.isAbstract,
			visibility <- uc.getMOFVisibility(),
			supertypes <- uc.generalization->collect(e | e.parent),
			-- End of bindings inherited from GeneralizableElement

			isSingleton <- false
		)
}

-- Rule 'Attribute'
-- This rule generates a MOF attribute from each UML attribute.
-- Properties of the generated attribute are copied from the input UML
-- attribute properties. Note that the 'isDerived' attribute is set to the
-- false default value.
rule Attribute {
	from
		ua : UML!Attribute
	to
		ma : MOF!Attribute (
			-- Begin bindings inherited from ModelElement
			name <- ua.name,
			annotation <- '',
			container <- ua.owner,
			constraints <- ua.constraint,
--			requiredElements <-,
			-- End of bindings inherited from ModelElement
			
			-- Begin bindings inherited from Feature
			scope <- ua.getMOFScope(),
			visibility <- ua.getMOFVisibility(),
			-- End of bindings inherited from Feature
			
			-- Begin bindings inherited from StructuralFeature
			multiplicity <- ua.getMOFMultiplicity(),
			isChangeable <- ua.getMOFIsChangeable(),
			-- End of bindings inherited from StructuralFeature
			
			-- Begin bindings inherited from TypedElement
			type <- ua.type,
			-- End of bindings inherited from TypedElement

			isDerived <- false
		)
}

-- Rule 'Parameter'
-- This rule generates a MOF parameter from each UML parameter.
-- Properties of the generated parameter are copied from the input UML
-- parameter properties. Note that the MOF multiplicity attribute is not set
-- since the corresponding information is not available in the UML metamodel.
-- The MOF multiplicity attribute, not encoded in UML, is left undefined.
rule Parameter {
	from
		up : UML!Parameter
	to
		mp : MOF!Parameter (
			-- Begin bindings inherited from ModelElement
			name <- up.name,
			annotation <- '',
			container <- up.namespace,
			constraints <- up.constraint,
--			requiredElements <-,
			-- End of bindings inherited from ModelElement
			
			-- Begin bindings inherited from TypedElement
			type <- up.type,
			-- End of bindings inherited from TypedElement

			direction <-
				if up.kind = #pdk_in
				then
					#in_dir
				else
					if up.kind = #pdk_inout
					then
						#inout_dir
					else
						if up.kind = #pdk_out
						then
							#out_dir
						else
							#return_dir
						endif
					endif
				endif
--			multiplicity <-
		)
}

-- Rule 'Operation'
-- This rule generates a MOF operation from each UML operation.
-- Properties of the generated operation are copied from the input UML
-- operation properties. Note that the exceptions property of the generated
-- MOF operation is set to an empty set as a default value.
rule Operation {
	from
		uo : UML!Operation
	to
		mo : MOF!Operation (
			-- Begin bindings inherited from ModelElement
			name <- uo.name,
			annotation <- '',
			container <- uo.owner,
			constraints <- uo.constraint,
--			requiredElements <-,
			-- End of bindings inherited from ModelElement

			-- Begin bindings inherited from Namespace
			contents <- uo.parameter,
			-- End of bindings inherited from Namespace

			-- Begin bindings inherited from Feature
			scope <- uo.getMOFScope(),
			visibility <- uo.getMOFVisibility(),
			-- End of bindings inherited from Feature

			isQuery <- uo.isQuery,
			exceptions <- Set{}
		)
}

-- Rule 'Association'
-- This rule generates a MOF association from each UML association.
-- Properties of the generated association are copied from the input UML
-- association properties. contents of the generated association correspond to
-- the MOF association end generated for the connection of the input UML
-- association.
rule Association {
	from
		ua : UML!Association
	to
		ma : MOF!Association (
			-- Begin bindings inherited from ModelElement
			name <- ua.name,
			annotation <- '',
			container <- ua.namespace,
			constraints <- ua.constraint,
--			requiredElements <-,
			-- End of bindings inherited from ModelElement
			
			-- Begin bindings inherited from Namespace
			contents <- ua.connection,
			-- End of bindings inherited from Namespace
			
			-- Begin bindings inherited from GeneralizableElement
			isRoot <- ua.isRoot,
			isLeaf <- ua.isLeaf,
			isAbstract <- ua.isAbstract,
			visibility <- ua.getMOFVisibility(),
			supertypes <- ua.generalization->collect(e | e.parent)
			-- End of bindings inherited from GeneralizableElement
		)
}

-- Rule 'AssociationEnd'
-- This rule generates a MOF association end, along with an optional reference,
-- from each UML association end.
-- The MOF reference is only generated from navigable UML association ends. For
-- this purpose, the rule iterates through a Sequence that contains 1 element
-- if UML association end is navigable, 0 otherwise.
-- Properties of the generated association end are copied from the input UML
-- association end properties.
-- When generated, the reference has the same name than its associated
-- association end. Its container corresponds to the class that to which is
-- associated the other association end contained by the association that also
-- contains the input UML association end.
-- Its scope and visibilty are respectively set to the 'instance_level' and
-- 'public_vis' default values. The values of its type, mutliplicity and
-- isChangeable attributes are copied from the input UML association end.
-- The constraints of the generated reference are packed within a single
-- element Sequence for the purpose of compatibility with the reference
-- sequence of the 'foreach' operator.
-- Finally, ...
rule AssociationEnd {
	from
		ua : UML!AssociationEnd
	to
		ma : MOF!AssociationEnd(
			-- Begin bindings inherited from ModelElement
			name <- ua.name,
			annotation <- '',
			container <- ua.association,
			constraints <- ua.constraint,
--			requiredElements <-,
			-- End of bindings inherited from ModelElement
			
			-- Begin bindings inherited from TypedElement
			type <- ua.participant,
			-- End of bindings inherited from TypedElement

			isNavigable <- ua.isNavigable,
			aggregation <-
				if ua.aggregation = #ak_aggregate
				then
					#shared
				else
					if ua.aggregation = #ak_composite
					then
						#composite
					else
						#none
					endif
				endif,
			multiplicity <-
				thisModule.getMultiplicity(ua.multiplicity, ua.ordering, true),
			isChangeable <- ua.getMOFIsChangeable()
		),
		
		mr : distinct MOF!Reference foreach(c in
									if ua.isNavigable
									then
										Sequence{true}
									else
										Sequence{}
									endif) (
			-- Begin bindings inherited from ModelElement
			name <- ua.name,
			annotation <- '',
			container <- ua.association.connection
							->select(e | not (e = ua))
							->first().participant,
			constraints <- Sequence{ua.constraint},
--			requiredElements <-,
			-- End of bindings inherited from ModelElement

			-- Begin bindings inherited from Feature
			scope <- #instance_level,
			visibility <- ua.getMOFVisibility(),
			-- End of bindings inherited from Feature

			-- Begin bindings inherited from StructuralFeature
			-- If the 2 following bindings are exchnaged with the referencedEnd
			-- one, an error may be raised due to MDR inconstency checkings.
			multiplicity <-
				thisModule.getMultiplicity(ua.multiplicity, ua.ordering, true),
			isChangeable <- ua.getMOFIsChangeable(),
			-- End of bindings inherited from StructuralFeature
	
			-- Begin bindings inherited from TypedElement
			type <- ua.participant,
			-- End of bindings inherited from TypedElement

			-- The Association corresponding to the Reference is derived: the
			-- exposedEnd reference should not be assigned.
--			exposedEnd <- ua.association.connection
--							->select(e | not (e = ua))->first(),
			referencedEnd <- ma
		)
}

-- Rule 'TaggedValue'
-- This rule generates a MOF tag from each UML tagged value whose type is
-- neither named 'element.uuid' nor 'isValid'.
-- Properties of the generated tag are copied from the input UML tagged value
-- properties.
rule TaggedValue {
	from
		ut : UML!TaggedValue (
			(ut.type.name <> 'element.uuid') and
			(ut.type.name <> 'isValid')
		)
	using {
		name : String = ut.type.name;
	}
	to
		ot : MOF!Tag (
			-- Begin bindings inherited from ModelElement
			name <- ut.name,
			annotation <- '',
			container <- ut.namespace,
			constraints <- ut.constraint,
--			requiredElements <-,
			-- End of bindings inherited from ModelElement

			tagId <- name,
			values <- ut.dataValue,
			elements <- Sequence{ut.modelElement}
		)
}

-- Rule 'Dependency'
-- The rule generates a MOF!Import from each input UML!Dependency that has a
-- stereotype of either 'clustering' or 'import' type. Note that input
-- dependencies can have a clustering or an import stereotype, but not both.
-- Properties of the generated import are copied from those of the input
-- dependency. Note that the isClustered attribute is set to false if the
-- input dependency has an 'import' stereotype, true otherwise (i.e. if it has
-- a 'clustering' stereotype).
rule Dependency {
	from
		ud : UML!Dependency (
			ud.stereotype
				->exists(e | e.name = 'import' or e.name = 'clustering')
		)
	using {
		importer : UML!ModelElement = ud.client->asSequence()->first();
		imported : UML!ModelElement = ud.supplier->asSequence()->first();
	}
	to
		mi : MOF!Import (
			-- Begin bindings inherited from ModelElement
			name <- imported.name,
			annotation <- '',
			container <- importer,
			constraints <- ud.constraint,
--			requiredElements <-,
			-- End of bindings inherited from ModelElement

			visibility <- #public_vis,
			isClustered <-
					if ud.stereotype->exists(e | e.name = 'import')
					then
						false
					else
						true
					endif,
			importedNamespace <- imported
		)
}


-- Rule 'DataType'
-- This rule generates a MOF datatype from each UML datatype.
-- Properties of the generated datatype are copied from the input UML datatype
-- properties. Note that the visibility of the generated MOF datatype is set to
-- the 'public_vis' default value.
rule DataType{
	from
		ud : UML!DataType
	to
		md : MOF!PrimitiveType (
			-- Begin bindings inherited from ModelElement
			name <- ud.name,
			annotation <- '',
			container <- ud.namespace,
			constraints <- ud.constraint,
--			requiredElements <-,
			-- End of bindings inherited from ModelElement

			-- Begin bindings inherited from Namespace
			contents <- ud.ownedElement,
			-- End of bindings inherited from Namespace
			
			-- Begin bindings inherited from GeneralizableElement
			isRoot <- ud.isRoot,
			isLeaf <- ud.isLeaf,
			isAbstract <- ud.isAbstract,
			visibility <- #public_vis,
			supertypes <- ud.generalization->collect(e | e.parent)
			-- End of bindings inherited from GeneralizableElement
		)
}
",modul uml mof creat out mof in uml use string helper this helper comput mof visibilitykind uml visibilitykind context thismodul in uml visibilitykind return mof visibilitykind helper def getvis v uml visibilitykind mof visibilitykind v vk public public vis els v vk privat privat vis els v vk protect protect vis els public vis default endif endif endif this helper comput mof visibilitykind correspond uml visibilitykind contextu uml modelel if visibl kind undefin helper retun public vis default valu context uml modelel return mof visibilitykind helper context uml modelel def getmofvis mof visibilitykind let v uml visibilitykind self visibl v oclisundefin thismodul getvis v els public vis endif this helper comput mof scopekind correspond uml scopekind contextu uml featur context uml featur return mof scopekind helper context uml featur def getmofscop mof scopekind self ownerscop sk instanc instanc level els classifi level endif this helper comput mof ischang boolean attribut correspond uml changeabl contextu uml modelel whose changeabl undefin context uml modelel return boolean helper context uml modelel def getischang boolean self changeabl ck changeabl this helper comput mof ischang boolean attribut correspond uml changeabl contextu uml modelel if changeabl undefin helper retun true default valu context uml modelel return boolean helper context uml modelel def getmofischang boolean self changeabl oclisundefin self getischang els true endif this helper comput tupl encod mof multipl correspond uml multipl uml orederingkind isuniqu boolean provid paramet context thismodul in uml multipl uml orderingkind boolean return tupletyp integ integ boolean boolean helper def getmultipl uml multipl uml orderingkind isuniqu boolean tupletyp lower integ upper integ isord boolean isuniqu boolean tupl lower rang assequ first lower upper rang assequ first upper isord ok order isuniqu isuniqu this helper comput tupl encod mof multipl correspond uml multipl contextu uml structuralfeatur if multipl contextu structur featur undefin helper return true true default tupl otherwis return tupl comput getmultipl helper note order contextu structur featur undefin consid order context uml structuralfeatur return tupletyp integ integ boolean boolean helper context uml structuralfeatur def getmofmultipl tupletyp lower integ upper integ isord boolean isuniqu boolean self multipl oclisundefin self order oclisundefin thismodul getmultipl self multipl self order fals els thismodul getmultipl self multipl ok order fals endif els tupl lower upper isord true isuniqu true endif helper context uml modelel return string helper context uml modelel def getmofqualifiednam string self name rule rule packag this rule generat mof packag uml packag stereotyp name metamodel supertyp generat packag correspond parent general input uml packag rule packag uml packag stereotyp exist e e name metamodel mp mof packag begin bind inherit modelel name name annot contain namespac constraint constraint requiredel end bind inherit modelel begin bind inherit namespac content ownedel end bind inherit namespac begin bind inherit generalizableel isroot isroot isleaf isleaf isabstract isabstract visibl getmofvis supertyp general collect e e parent end bind inherit generalizableel rule constraint this rule generat mof constraint uml one properti generat constraint except evaluationpolici copi input uml constraint the mof evaluationpolici properti equival uml set default immedi valu rule constraint uc uml constraint mc mof constraint begin bind inherit modelel name uc name annot contain uc namespac constraint uc constraint requiredel end bind inherit modelel express uc bodi bodi languag uc bodi languag constrainedel uc constrainedel evaluationpolici immedi rule comment this rule generat mof constraint uml comment constraint stereotyp the content generat constraint correspond bodi input uml comment languag associ ocl default valu rule comment uc uml comment uc stereotyp exist e e name constraint mc mof constraint begin bind inherit modelel name uc name annot contain uc namespac constraint uc constraint requiredel end bind inherit modelel express uc bodi languag ocl constrainedel uc annotatedel rule class this rule generat mof class uml class whose namespac expect packag metamodel stereotyp properti generat class copi input uml class properti rule class uc uml class uc namespac stereotyp exist e e name metamodel mc mof class begin bind inherit modelel name uc name annot contain uc namespac constraint uc constraint requiredel end bind inherit modelel begin bind inherit namespac content uc ownedel end bind inherit namespac begin bind inherit generalizableel isroot uc isroot isleaf uc isleaf isabstract uc isabstract visibl uc getmofvis supertyp uc general collect e e parent end bind inherit generalizableel issingleton fals rule attribut this rule generat mof attribut uml attribut properti generat attribut copi input uml attribut properti note isderiv attribut set fals default valu rule attribut ua uml attribut mof attribut begin bind inherit modelel name ua name annot contain ua owner constraint ua constraint requiredel end bind inherit modelel begin bind inherit featur scope ua getmofscop visibl ua getmofvis end bind inherit featur begin bind inherit structuralfeatur multipl ua getmofmultipl ischang ua getmofischang end bind inherit structuralfeatur begin bind inherit typedel type ua type end bind inherit typedel isderiv fals rule paramet this rule generat mof paramet uml paramet properti generat paramet copi input uml paramet properti note mof multipl attribut set sinc correspond inform avail uml metamodel the mof multipl attribut encod uml left undefin rule paramet uml paramet mp mof paramet begin bind inherit modelel name name annot contain namespac constraint constraint requiredel end bind inherit modelel begin bind inherit typedel type type end bind inherit typedel direct kind pdk dir els kind pdk inout inout dir els kind pdk dir els return dir endif endif endif multipl rule oper this rule generat mof oper uml oper properti generat oper copi input uml oper properti note except properti generat mof oper set empti set default valu rule oper uo uml oper mo mof oper begin bind inherit modelel name uo name annot contain uo owner constraint uo constraint requiredel end bind inherit modelel begin bind inherit namespac content uo paramet end bind inherit namespac begin bind inherit featur scope uo getmofscop visibl uo getmofvis end bind inherit featur isqueri uo isqueri except set rule associ this rule generat mof associ uml associ properti generat associ copi input uml associ properti content generat associ correspond mof associ end generat connect input uml associ rule associ ua uml associ mof associ begin bind inherit modelel name ua name annot contain ua namespac constraint ua constraint requiredel end bind inherit modelel begin bind inherit namespac content ua connect end bind inherit namespac begin bind inherit generalizableel isroot ua isroot isleaf ua isleaf isabstract ua isabstract visibl ua getmofvis supertyp ua general collect e e parent end bind inherit generalizableel rule associationend this rule generat mof associ end along option refer uml associ end the mof refer generat navig uml associ end for purpos rule iter sequenc contain element uml associ end navig otherwis properti generat associ end copi input uml associ end properti when generat refer name associ associ end it contain correspond class associ associ end contain associ also contain input uml associ end it scope visibilti respect set instanc level public vis default valu the valu type mutlipl ischang attribut copi input uml associ end the constraint generat refer pack within singl element sequenc purpos compat refer sequenc foreach oper final rule associationend ua uml associationend mof associationend begin bind inherit modelel name ua name annot contain ua associ constraint ua constraint requiredel end bind inherit modelel begin bind inherit typedel type ua particip end bind inherit typedel isnavig ua isnavig aggreg ua aggreg ak aggreg share els ua aggreg ak composit composit els none endif endif multipl thismodul getmultipl ua multipl ua order true ischang ua getmofischang mr distinct mof refer foreach c ua isnavig sequenc true els sequenc endif begin bind inherit modelel name ua name annot contain ua associ connect select e e ua first particip constraint sequenc ua constraint requiredel end bind inherit modelel begin bind inherit featur scope instanc level visibl ua getmofvis end bind inherit featur begin bind inherit structuralfeatur if follow bind exchnag referencedend one error may rais due mdr inconst check multipl thismodul getmultipl ua multipl ua order true ischang ua getmofischang end bind inherit structuralfeatur begin bind inherit typedel type ua particip end bind inherit typedel the associ correspond refer deriv exposedend refer assign exposedend ua associ connect select e e ua first referencedend rule taggedvalu this rule generat mof tag uml tag valu whose type neither name element uuid isvalid properti generat tag copi input uml tag valu properti rule taggedvalu ut uml taggedvalu ut type name element uuid ut type name isvalid use name string ut type name ot mof tag begin bind inherit modelel name ut name annot contain ut namespac constraint ut constraint requiredel end bind inherit modelel tagid name valu ut datavalu element sequenc ut modelel rule depend the rule generat mof import input uml depend stereotyp either cluster import type note input depend cluster import stereotyp properti generat import copi input depend note isclust attribut set fals input depend import stereotyp true otherwis e cluster stereotyp rule depend ud uml depend ud stereotyp exist e e name import e name cluster use import uml modelel ud client assequ first import uml modelel ud supplier assequ first mi mof import begin bind inherit modelel name import name annot contain import constraint ud constraint requiredel end bind inherit modelel visibl public vis isclust ud stereotyp exist e e name import fals els true endif importednamespac import rule datatyp this rule generat mof datatyp uml datatyp properti generat datatyp copi input uml datatyp properti note visibl generat mof datatyp set public vis default valu rule datatyp ud uml datatyp md mof primitivetyp begin bind inherit modelel name ud name annot contain ud namespac constraint ud constraint requiredel end bind inherit modelel begin bind inherit namespac content ud ownedel end bind inherit namespac begin bind inherit generalizableel isroot ud isroot isleaf ud isleaf isabstract ud isabstract visibl public vis supertyp ud general collect e e parent end bind inherit generalizableel,18
211,211,P92-OWL2XML.atl,"-- @atlcompiler atl2006

module OWL2XML; -- Module Template
create OUT : XML from IN : OWL;

-- =============================================================================
-- OWL2XML
-- Version 1.0
-- Release date : 20/02/2007
-- Author : Guillaume Hillairet (g.hillairet@gmail.com)
-- =============================================================================
	
helper context OWL!RDFSResource def: getURI() : String =
	let r : OWL!UniformResourceIdentifier = 
		self.uriRef->any( e | e.oclIsKindOf(OWL!URIReference)).uri
	in if not r.oclIsUndefined() then r.name else '' endif;

helper context OWL!RDFSResource def: getLabel() : String =
	let r : OWL!PlainLiteral =
		self.label->select( e | e.oclIsTypeOf( OWL!PlainLiteral ))->first()
	in if r.oclIsUndefined() then '' else r.lexicalForm endif	;

helper context OWL!CardinalityRestriction def: getDatatypeURI() : String = 
	let d : OWL!URIReference = self.OWLCardinality.datatypeURI
	in if not d.oclIsUndefined()
		then d.uri.name
		else ''
	endif;

helper context OWL!MaxCardinalityRestriction def: getDatatypeURI() : String = 
	let d : OWL!URIReference = self.OWLMaxCardinality.datatypeURI
	in if not d.oclIsUndefined()
		then d.uri.name
		else ''
	endif;

helper context OWL!MinCardinalityRestriction def: getDatatypeURI() : String = 
	let d : OWL!URIReference = self.OWLMinCardinality.datatypeURI
	in if not d.oclIsUndefined()
		then d.uri.name
		else ''
	endif;

-- =============================================================================
-- RULES
-- =============================================================================
	
rule Graph2Root {
	from
		g : OWL!OWLGraph
		
	to
		r : XML!Root (
			name <- 'rdf:RDF',
			children <- Sequence {
				att1, att2, att3, att4, att5, att6,
				g.ontology
			}
		),
		att1 : XML!Attribute (name <- 'xmlns:rdf',	value <- 'http://www.w3.org/1999/02/22-rdf-syntax-ns#'),
		att2 : XML!Attribute (name <- 'xmlns:rdfs', value <- 'http://www.w3.org/2000/01/rdf-schema#'),
		att3 : XML!Attribute (name <- 'xmlns:xsd',	value <- 'http://www.w3.org/2001/XMLSchema#'),
		att4 : XML!Attribute (name <- 'xmlns:owl',	value <- 'http://www.w3.org/2002/07/owl#'),
		att5 : XML!Attribute (name <- 'xmlns', value <- g.ontology->first().getURI() + '#'),
		att6 : XML!Attribute (name <- 'xml:base', value <- g.ontology->first().getURI())		
}

rule Ontology2Element {
	from
		o : OWL!OWLOntology
	to
		e : XML!Element ( name <- 'owl:Ontology', children <- about ),
		about : XML!Attribute ( name <- 'rdf:about', 
			value <- o.uriRef->collect( e | e.fragmentIdentifier.name )->flatten()->first() 
		)	
	do {
		for ( i in o.OWLImports ) {
			thisModule.addImports( o, i );
		}
	}
}

rule addImports( o : OWL!OWLOntology, i : OWL!OWLOntology ) {
	to
		imports : XML!Element ( parent <- o, name <- 'owl:imports', children <- imports_att ),
		imports_att : XML!Attribute ( name <- 'rdf:resource', value <- '#' + i.getURI() )
}

rule Class2Element{
	from
		c : OWL!OWLClass (
			c.oclIsTypeOf(OWL!OWLClass)
		)
	to
		e : XML!Element (
			name <- 'owl:Class',
			children <- Sequence{ID,label},
			parent <- OWL!OWLGraph.allInstances()->any( e | e.oclIsTypeOf(OWL!OWLGraph))
		),
		ID : XML!Attribute ( name <- 'rdf:ID', value <- c.getURI() ),
		label : XML!Element ( name <- 'rdfs:label', children <- label_text ),
		label_text : XML!Text ( name <- '#text', value <- c.getLabel() )
		
		do {
			 for (s in c.subClassOf ) {
		 		if (s.oclIsTypeOf(OWL!OWLClass))
					thisModule.makeSubClass(c,s);
		 		
		 		if (s.oclIsTypeOf(OWL!UnionClass))
					thisModule.makeSubClass(c,s);
		 		
				if (s.oclIsTypeOf(OWL!CardinalityRestriction))
					thisModule.makeCardinalityRestrictionSubClass(c,s);
				
				if (s.oclIsTypeOf(OWL!MaxCardinalityRestriction))
					thisModule.makeMaxCardinalityRestrictionSubClass(c,s);
				
				if (s.oclIsTypeOf(OWL!MinCardinalityRestriction))
					thisModule.makeMinCardinalityRestrictionSubClass(c,s);
			 }
		}
}

rule UnionClass2Element{
	from
		c : OWL!UnionClass (
			c.oclIsTypeOf(OWL!UnionClass)
		)
	to
		e : XML!Element (
			name <- 'owl:Class',
			children <- Sequence{ID,label,unionOf},
			parent <- OWL!OWLGraph.allInstances()->any( e | e.oclIsTypeOf(OWL!OWLGraph))
		),
		ID : XML!Attribute ( name <- 'rdf:ID', value <- c.getURI() ),
		label : XML!Element ( name <- 'rdfs:label', children <- label_text ),
		label_text : XML!Text ( name <- '#text', value <- c.getLabel() ),
		unionOf : XML!Element (
			name <- 'owl:unionOf',
			children <- Sequence{unionOf_att, c.OWLUnionOf->collect( e | 
				thisModule.makeUnionOf(e) ) 
			}
		),
		unionOf_att : XML!Attribute (
			name <- 'rdf:parseType',
			value <- 'Collection'
		)
		
		do {
			 for (s in c.subClassOf ) {
		 		if (s.oclIsKindOf(OWL!OWLClass))
					thisModule.makeSubClass(c,s);
				
				if (s.oclIsTypeOf(OWL!CardinalityRestriction))
					thisModule.makeCardinalityRestrictionSubClass(c,s);
				
				if (s.oclIsTypeOf(OWL!MaxCardinalityRestriction))
					thisModule.makeMaxCardinalityRestrictionSubClass(c,s);
				
				if (s.oclIsTypeOf(OWL!MinCardinalityRestriction))
					thisModule.makeMinCardinalityRestrictionSubClass(c,s);
			 }
		}
}

lazy rule makeUnionOf {
	from
		u : OWL!OWLClass
	to
		e : XML!Element ( name <- 'owl:Class', children <- Sequence{ e_att } ),
		e_att : XML!Attribute ( name <- 'rdf:about', value <- '#' + u.getURI() )
}

rule makeSubClass( c : OWL!OWLClass,  s : OWL!OWLClass ) {
	to
		e : XML!Element (
			name <- 'rdfs:subClassOf',
			children <-  subClassAttr,
			parent <- c
		),
		subClassAttr : XML!Attribute ( name <- 'rdf:resource', value <- '#' + s.getURI() )
}

rule makeCardinalityRestrictionSubClass( c : OWL!OWLClass,  s : OWL!CardinalityRestriction ) {
	to
		x : XML!Element (
			name <- 'rdfs:subClassOf',
			children <-  e,
			parent <- c
		),
		e : XML!Element ( name <- 'owl:Restriction', children <- Sequence{on, card} ),
		on : XML!Element (	name <- 'owl:onProperty', children <- on_attr ),
		on_attr : XML!Attribute ( name <- 'rdf:resource', value <- '#' + s.OWLOnProperty.getURI() ),
		card : XML!Element ( name <- 'owl:cardinality ', children <- Sequence{card_attr, card_text}	),
		card_attr : XML!Attribute (	name <- 'rdf:datatype', value <- s.getDatatypeURI()	),
		card_text : XML!Text ( name <- '#text',	value <- s.OWLCardinality.lexicalForm )
}

rule makeMaxCardinalityRestrictionSubClass( c : OWL!OWLClass,  s : OWL!MaxCardinalityRestriction ) {
	to
		x : XML!Element (
			name <- 'rdfs:subClassOf',
			children <-  e,
			parent <- c
		),
		e : XML!Element ( name <- 'owl:Restriction', children <- Sequence{on, card} ),
		on : XML!Element (	name <- 'owl:onProperty', children <- on_attr ),
		on_attr : XML!Attribute ( name <- 'rdf:resource', value <- '#' + s.OWLOnProperty.getURI() ),
		card : XML!Element ( name <- 'owl:maxCardinality ',	children <- Sequence{card_attr, card_text} ),
		card_attr : XML!Attribute (	name <- 'rdf:datatype', value <- s.getDatatypeURI()	),
		card_text : XML!Text ( name <- '#text',	value <- s.OWLMaxCardinality.lexicalForm )
}

rule makeMinCardinalityRestrictionSubClass( c : OWL!OWLClass,  s : OWL!MinCardinalityRestriction ) {
	to
		x : XML!Element (
			name <- 'rdfs:subClassOf',
			children <-  e,
			parent <- c
		),
		e : XML!Element (
			name <- 'owl:Restriction',
			children <- Sequence{on, card}
		),
		on : XML!Element (	name <- 'owl:onProperty', children <- on_attr ),
		on_attr : XML!Attribute ( name <- 'rdf:resource', value <- '#' + s.OWLOnProperty.getURI() ),
		card : XML!Element ( name <- 'owl:minCardinality ',	children <- Sequence{card_attr, card_text} ),
		card_attr : XML!Attribute (	name <- 'rdf:datatype', value <- s.getDatatypeURI()	),
		card_text : XML!Text ( name <- '#text',	value <- s.OWLMinCardinality.lexicalForm )
}

rule DatatypeProperty2Element {
	from
		d : OWL!OWLDatatypeProperty
	to
		e : XML!Element (
			name <- 'owl:DatatypeProperty',
			children <- Sequence{ID,domain,range},
			parent <- OWL!OWLGraph.allInstances()->any( e | e.oclIsTypeOf(OWL!OWLGraph))
		),
		ID : XML!Attribute (
			name <- 'rdf:ID',
			value <- d.getURI()
		),
		domain : XML!Element (
			name <- 'rdfs:domain',
			children <- domain_attr
		),
		domain_attr : XML!Attribute (
			name <- 'rdf:resource',
			value <- '#' + d.domain->any( c | c.oclIsKindOf(OWL!OWLClass)).getURI()
		),
		range : XML!Element (
			name <- 'rdfs:range',
			children <- range_attr
		),
		range_attr : XML!Attribute (
			name <- 'rdf:resource',
			value <-  d.range->any(c | c.oclIsKindOf(OWL!RDFSDataType)).getURI()
		)
}

rule ObjectProperty2Element {
	from
		o : OWL!OWLObjectProperty ( 
			o.oclIsTypeOf(OWL!OWLObjectProperty) 
		)
	to
		e : XML!Element (
			name <- 'owl:ObjectProperty',
			children <- Sequence{ID, domain, range},
			parent <- OWL!OWLGraph.allInstances()->any( e | e.oclIsTypeOf(OWL!OWLGraph))
		),
		ID : XML!Attribute (
			name <- 'rdf:ID',
			value <- o.getURI()
		),
		domain : XML!Element (
			name <- 'rdfs:domain',
			children <- domain_attr
		),
		domain_attr : XML!Attribute (
			name <-  'rdf:resource',
			value <- '#' + o.domain->any( c | c.oclIsKindOf(OWL!OWLClass)).getURI()
		),
		range : XML!Element (
			name <- 'rdfs:range',
			children <- range_attr
		),
		range_attr : XML!Attribute (
			name <- 'rdf:resource',
			value <- '#' + o.range->any( c | c.oclIsKindOf(OWL!OWLClass)).getURI()
		)
		
		do {
			if (not o.OWLInverseOf.oclIsUndefined())
				thisModule.addInverse(o);
			
			for (s in o.subPropertyOf ) {
		 		if (s.oclIsKindOf(OWL!OWLObjectProperty))
					thisModule.makeSubProperty(o,s);
			}
		}
}

rule makeSubProperty( c : OWL!OWLObjectProperty,  s : OWL!OWLObjectProperty ) {
	to
		e : XML!Element (
			name <- 'rdfs:subPropertyOf',
			children <-  subPropertyAttr,
			parent <- c
		),
		subPropertyAttr : XML!Attribute ( name <- 'rdf:resource', value <- '#' + s.getURI() )
}

rule addInverse( o : OWL!OWLObjectProperty ) {
	to
		e : XML!Element (
			name <- 'owl:inverseOf',
			children <- e_attr,
			parent <- o
		),
		e_attr : XML!Attribute (
			name <- 'rdf:resource',
			value <- '#' + o.OWLInverseOf.getURI()
		)
}

rule SymmetricProperty2Element {
	from
		o : OWL!SymmetricProperty ( 
			o.oclIsTypeOf(OWL!SymmetricProperty) 
		)
	to
		e : XML!Element (
			name <- 'owl:SymmetricProperty',
			children <- Sequence{ID, domain, range},
			parent <- OWL!OWLGraph.allInstances()->any( e | e.oclIsTypeOf(OWL!OWLGraph))
		),
		ID : XML!Attribute (
			name <- 'rdf:ID',
			value <- o.getURI()
		),
		domain : XML!Element (
			name <- 'rdfs:domain',
			children <- domain_attr
		),
		domain_attr : XML!Attribute (
			name <-  'rdf:resource',
			value <- '#' + o.domain->any( c | c.oclIsKindOf(OWL!OWLClass)).getURI()
		),
		range : XML!Element (
			name <- 'rdfs:range',
			children <- range_attr
		),
		range_attr : XML!Attribute (
			name <- 'rdf:resource',
			value <- '#' + o.range->any( c | c.oclIsKindOf(OWL!OWLClass)).getURI()
		)
		
		do {
			if (not o.OWLInverseOf.oclIsUndefined())
				thisModule.addInverse(o);
			
			for (s in o.subPropertyOf ) {
		 		if (s.oclIsKindOf(OWL!OWLObjectProperty))
					thisModule.makeSubProperty(o,s);
			}
		}
}

rule InverseFunctionalProperty2Element {
	from
		o : OWL!InverseFunctionalProperty ( 
			o.oclIsTypeOf(OWL!InverseFunctionalProperty) 
		)
	to
		e : XML!Element (
			name <- 'owl:InverseFunctionalProperty',
			children <- Sequence{ID, domain, range},
			parent <- OWL!OWLGraph.allInstances()->any( e | e.oclIsTypeOf(OWL!OWLGraph))
		),
		ID : XML!Attribute (
			name <- 'rdf:ID',
			value <- o.getURI()
		),
		domain : XML!Element (
			name <- 'rdfs:domain',
			children <- domain_attr
		),
		domain_attr : XML!Attribute (
			name <-  'rdf:resource',
			value <- '#' + o.domain->any( c | c.oclIsKindOf(OWL!OWLClass)).getURI()
		),
		range : XML!Element (
			name <- 'rdfs:range',
			children <- range_attr
		),
		range_attr : XML!Attribute (
			name <- 'rdf:resource',
			value <- '#' + o.range->any( c | c.oclIsKindOf(OWL!OWLClass)).getURI()
		)
		
		do {
			if (not o.OWLInverseOf.oclIsUndefined())
				thisModule.addInverse(o);
			
			for (s in o.subPropertyOf ) {
		 		if (s.oclIsKindOf(OWL!OWLObjectProperty))
					thisModule.makeSubProperty(o,s);
			}
		}
}

rule FunctionalProperty {
	from
		o : OWL!FunctionalProperty (
			o.oclIsTypeOf( OWL!FunctionalProperty )
		)
	to
		e : XML!Element (
			name <- 'owl:FunctionalProperty',
			children <- a,
			parent <- OWL!OWLGraph.allInstances()->any( e | e.oclIsTypeOf(OWL!OWLGraph))
		),
		a : XML!Attribute (
			name <- 'rdf:about',
			value <- '#' + o.isDefinedBy->asSequence()->any( e | e.oclIsKindOf(OWL!Property ) ).getURI()
		)
}

--rule DataRange2Element {
--	from
--		d : OWL!OWLDataRange
--	to
--		e : XML!Element (
--			name <- 'owl:DataRange',
--			children <- oneOf
--		),
--		oneOf : XML!Element (
--			name <- 'owl:oneOf'
--		)
--}

rule EnumeratedClass2Element {
	from
		ec : OWL!EnumeratedClass (
			ec.oclIsTypeOf( OWL!EnumeratedClass )
		)
	to
		e : XML!Element (
			name <- 'owl:Class',
			children <- Sequence{ID,label,oneOf},
			parent <- OWL!OWLGraph.allInstances()->any( e | e.oclIsTypeOf(OWL!OWLGraph))
		),
		ID : XML!Attribute (
			name <- 'rdf:ID',
			value <- ec.getURI()
		),
		label : XML!Element (
			name <- 'rdfs:label',
			children <- label_text
		),
		label_text : XML!Text (
			name <- '#text',
			value <- ec.getLabel()
		),
		oneOf : XML!Element (
			name <- 'owl:oneOf',
			children <- Sequence{ oneOf_Att, ec.OWLOneOf->collect( e | 
				thisModule.IndividualLiteral2Element( e ) )
			}
		),
		oneOf_Att : XML!Attribute (
			name <- 'rdf:parseType',
			value <- 'Collection'
		)
	
}

lazy rule IndividualLiteral2Element {
	from
		i : OWL!Individual
	to
		e : XML!Element (
			name <- 'owl:Thing',
			children <- e_att
		),
		e_att : XML!Attribute (
			name <- 'rdf:about',
			value <- i.getURI()
		)
}

rule Individual2Element {
	from
		i : OWL!Individual (
			i.type->any( c | c.oclIsKindOf(OWL!OWLClass)).oclIsTypeOf(OWL!OWLClass)
		)
	to
		e : XML!Element (
			name  <- i.type->any( c | c.oclIsKindOf(OWL!OWLClass)).getURI(),
			children <- Sequence{ e_att },
			parent <- OWL!OWLGraph.allInstances()->any( e | e.oclIsTypeOf(OWL!OWLGraph))
		),
		e_att : XML!Attribute (
			name <- 'rdf:ID',
			value <- i.getURI()
		)
}

rule StatementPredicateOfDatatype2Element {
	from
		s : OWL!OWLStatement (
			s.RDFpredicate.oclIsTypeOf(OWL!OWLDatatypeProperty)
		)
	to
		p : XML!Element (
			parent <- s.RDFsubject,
			name <- s.RDFpredicate.getURI(),
			children <- Sequence{ p_att, p_text }
		),
		p_att : XML!Attribute (
			name <- 'rdf:datatype',
			value <- s.RDFpredicate.range->any(c | c.oclIsKindOf(OWL!RDFSDataType)).getURI()
		),
		p_text : XML!Text (
			name <- '#text',
			value <- s.RDFobject.getURI()
		)	
}

rule StatementPredicateOfObjectProperty2Element {
	from
		s : OWL!OWLStatement (
			s.RDFpredicate.oclIsKindOf(OWL!OWLObjectProperty)
		)
	to
		p : XML!Element (
			parent <- s.RDFsubject,
			name <- s.RDFpredicate.getURI(),
			children <- Sequence{ p_att }
		),
		p_att : XML!Attribute (
			name <- 'rdf:resource',
			value <- '#' + s.RDFobject.getURI()
		)
}
",atlcompil atl modul owl xml modul templat creat out xml in owl owl xml version releas date author guillaum hillairet g hillairet gmail com helper context owl rdfsresourc def geturi string let r owl uniformresourceidentifi self uriref e e ocliskindof owl urirefer uri r oclisundefin r name els endif helper context owl rdfsresourc def getlabel string let r owl plainliter self label select e e oclistypeof owl plainliter first r oclisundefin els r lexicalform endif helper context owl cardinalityrestrict def getdatatypeuri string let owl urirefer self owlcardin datatypeuri oclisundefin uri name els endif helper context owl maxcardinalityrestrict def getdatatypeuri string let owl urirefer self owlmaxcardin datatypeuri oclisundefin uri name els endif helper context owl mincardinalityrestrict def getdatatypeuri string let owl urirefer self owlmincardin datatypeuri oclisundefin uri name els endif rule rule graph root g owl owlgraph r xml root name rdf rdf children sequenc att att att att att att g ontolog att xml attribut name xmlns rdf valu http www w org rdf syntax ns att xml attribut name xmlns rdfs valu http www w org rdf schema att xml attribut name xmlns xsd valu http www w org xmlschema att xml attribut name xmlns owl valu http www w org owl att xml attribut name xmlns valu g ontolog first geturi att xml attribut name xml base valu g ontolog first geturi rule ontolog element owl owlontolog e xml element name owl ontolog children xml attribut name rdf valu uriref collect e e fragmentidentifi name flatten first owlimport thismodul addimport rule addimport owl owlontolog owl owlontolog import xml element parent name owl import children import att import att xml attribut name rdf resourc valu geturi rule class element c owl owlclass c oclistypeof owl owlclass e xml element name owl class children sequenc id label parent owl owlgraph allinst e e oclistypeof owl owlgraph id xml attribut name rdf id valu c geturi label xml element name rdfs label children label text label text xml text name text valu c getlabel c subclassof oclistypeof owl owlclass thismodul makesubclass c oclistypeof owl unionclass thismodul makesubclass c oclistypeof owl cardinalityrestrict thismodul makecardinalityrestrictionsubclass c oclistypeof owl maxcardinalityrestrict thismodul makemaxcardinalityrestrictionsubclass c oclistypeof owl mincardinalityrestrict thismodul makemincardinalityrestrictionsubclass c rule unionclass element c owl unionclass c oclistypeof owl unionclass e xml element name owl class children sequenc id label unionof parent owl owlgraph allinst e e oclistypeof owl owlgraph id xml attribut name rdf id valu c geturi label xml element name rdfs label children label text label text xml text name text valu c getlabel unionof xml element name owl unionof children sequenc unionof att c owlunionof collect e thismodul makeunionof e unionof att xml attribut name rdf parsetyp valu collect c subclassof ocliskindof owl owlclass thismodul makesubclass c oclistypeof owl cardinalityrestrict thismodul makecardinalityrestrictionsubclass c oclistypeof owl maxcardinalityrestrict thismodul makemaxcardinalityrestrictionsubclass c oclistypeof owl mincardinalityrestrict thismodul makemincardinalityrestrictionsubclass c lazi rule makeunionof u owl owlclass e xml element name owl class children sequenc e att e att xml attribut name rdf valu u geturi rule makesubclass c owl owlclass owl owlclass e xml element name rdfs subclassof children subclassattr parent c subclassattr xml attribut name rdf resourc valu geturi rule makecardinalityrestrictionsubclass c owl owlclass owl cardinalityrestrict x xml element name rdfs subclassof children e parent c e xml element name owl restrict children sequenc card xml element name owl onproperti children attr attr xml attribut name rdf resourc valu owlonproperti geturi card xml element name owl cardin children sequenc card attr card text card attr xml attribut name rdf datatyp valu getdatatypeuri card text xml text name text valu owlcardin lexicalform rule makemaxcardinalityrestrictionsubclass c owl owlclass owl maxcardinalityrestrict x xml element name rdfs subclassof children e parent c e xml element name owl restrict children sequenc card xml element name owl onproperti children attr attr xml attribut name rdf resourc valu owlonproperti geturi card xml element name owl maxcardin children sequenc card attr card text card attr xml attribut name rdf datatyp valu getdatatypeuri card text xml text name text valu owlmaxcardin lexicalform rule makemincardinalityrestrictionsubclass c owl owlclass owl mincardinalityrestrict x xml element name rdfs subclassof children e parent c e xml element name owl restrict children sequenc card xml element name owl onproperti children attr attr xml attribut name rdf resourc valu owlonproperti geturi card xml element name owl mincardin children sequenc card attr card text card attr xml attribut name rdf datatyp valu getdatatypeuri card text xml text name text valu owlmincardin lexicalform rule datatypeproperti element owl owldatatypeproperti e xml element name owl datatypeproperti children sequenc id domain rang parent owl owlgraph allinst e e oclistypeof owl owlgraph id xml attribut name rdf id valu geturi domain xml element name rdfs domain children domain attr domain attr xml attribut name rdf resourc valu domain c c ocliskindof owl owlclass geturi rang xml element name rdfs rang children rang attr rang attr xml attribut name rdf resourc valu rang c c ocliskindof owl rdfsdatatyp geturi rule objectproperti element owl owlobjectproperti oclistypeof owl owlobjectproperti e xml element name owl objectproperti children sequenc id domain rang parent owl owlgraph allinst e e oclistypeof owl owlgraph id xml attribut name rdf id valu geturi domain xml element name rdfs domain children domain attr domain attr xml attribut name rdf resourc valu domain c c ocliskindof owl owlclass geturi rang xml element name rdfs rang children rang attr rang attr xml attribut name rdf resourc valu rang c c ocliskindof owl owlclass geturi owlinverseof oclisundefin thismodul addinvers subpropertyof ocliskindof owl owlobjectproperti thismodul makesubproperti rule makesubproperti c owl owlobjectproperti owl owlobjectproperti e xml element name rdfs subpropertyof children subpropertyattr parent c subpropertyattr xml attribut name rdf resourc valu geturi rule addinvers owl owlobjectproperti e xml element name owl inverseof children e attr parent e attr xml attribut name rdf resourc valu owlinverseof geturi rule symmetricproperti element owl symmetricproperti oclistypeof owl symmetricproperti e xml element name owl symmetricproperti children sequenc id domain rang parent owl owlgraph allinst e e oclistypeof owl owlgraph id xml attribut name rdf id valu geturi domain xml element name rdfs domain children domain attr domain attr xml attribut name rdf resourc valu domain c c ocliskindof owl owlclass geturi rang xml element name rdfs rang children rang attr rang attr xml attribut name rdf resourc valu rang c c ocliskindof owl owlclass geturi owlinverseof oclisundefin thismodul addinvers subpropertyof ocliskindof owl owlobjectproperti thismodul makesubproperti rule inversefunctionalproperti element owl inversefunctionalproperti oclistypeof owl inversefunctionalproperti e xml element name owl inversefunctionalproperti children sequenc id domain rang parent owl owlgraph allinst e e oclistypeof owl owlgraph id xml attribut name rdf id valu geturi domain xml element name rdfs domain children domain attr domain attr xml attribut name rdf resourc valu domain c c ocliskindof owl owlclass geturi rang xml element name rdfs rang children rang attr rang attr xml attribut name rdf resourc valu rang c c ocliskindof owl owlclass geturi owlinverseof oclisundefin thismodul addinvers subpropertyof ocliskindof owl owlobjectproperti thismodul makesubproperti rule functionalproperti owl functionalproperti oclistypeof owl functionalproperti e xml element name owl functionalproperti children parent owl owlgraph allinst e e oclistypeof owl owlgraph xml attribut name rdf valu isdefinedbi assequ e e ocliskindof owl properti geturi rule datarang element owl owldatarang e xml element name owl datarang children oneof oneof xml element name owl oneof rule enumeratedclass element ec owl enumeratedclass ec oclistypeof owl enumeratedclass e xml element name owl class children sequenc id label oneof parent owl owlgraph allinst e e oclistypeof owl owlgraph id xml attribut name rdf id valu ec geturi label xml element name rdfs label children label text label text xml text name text valu ec getlabel oneof xml element name owl oneof children sequenc oneof att ec owloneof collect e thismodul individualliter element e oneof att xml attribut name rdf parsetyp valu collect lazi rule individualliter element owl individu e xml element name owl thing children e att e att xml attribut name rdf valu geturi rule individu element owl individu type c c ocliskindof owl owlclass oclistypeof owl owlclass e xml element name type c c ocliskindof owl owlclass geturi children sequenc e att parent owl owlgraph allinst e e oclistypeof owl owlgraph e att xml attribut name rdf id valu geturi rule statementpredicateofdatatyp element owl owlstat rdfpredic oclistypeof owl owldatatypeproperti p xml element parent rdfsubject name rdfpredic geturi children sequenc p att p text p att xml attribut name rdf datatyp valu rdfpredic rang c c ocliskindof owl rdfsdatatyp geturi p text xml text name text valu rdfobject geturi rule statementpredicateofobjectproperti element owl owlstat rdfpredic ocliskindof owl owlobjectproperti p xml element parent rdfsubject name rdfpredic geturi children sequenc p att p att xml attribut name rdf resourc valu rdfobject geturi,7
212,212,P92-UML2OWL.atl,"-- @atlcompiler atl2006

module UML2OWL; -- Module Template
create OUT : OWL from IN : UML;

-- =============================================================================
-- UML2OWL
-- Version 1.0
-- Release date : 20/02/2007
-- Author : Guillaume Hillairet (g.hillairet@gmail.com)
-- =============================================================================
	
helper def: primitiveTypeMap : Map(String, String) =
	Map {
		('String', 'http://www.w3.org/2001/XMLSchema#string'),
		('Integer', 'http://www.w3.org/2001/XMLSchema#nonNegativeInteger'),
		('Boolean', 'http://www.w3.org/2001/XMLSchema#boolean'),
		('UnlimitedNatural', 'http://www.w3.org/2001/XMLSchema#integer' )
	};
	
helper def: addNamespace( s : String ) : String = 'http://example.org/' + s ;

helper context UML!uml::Association def: isBinary() : Boolean =
	self.ownedEnd->asSequence().size() = 2;

helper context UML!uml::Property def: isSymmetric() : Boolean =
	self.type = 
		self.association.ownedEnd->asSequence()->any( e | 
			e.oclIsTypeOf(UML!uml::Property) and not (e = self)).type;
			 
helper context UML!uml::Property def: isInverseFunctional() : Boolean =
	self.association.ownedEnd->asSequence()->any( e | 
		e.oclIsTypeOf(UML!uml::Property) and not (e = self)).upper = 1
	and
	self.association.ownedEnd->asSequence()->any( e | 
		e.oclIsTypeOf(UML!uml::Property) and not (e = self)).lower = 1;

helper def: sequenceOfUnionClass : Sequence( UML!uml::CLass ) =
	let s : Sequence( UML!uml::CLass ) =
	UML!uml::GeneralizationSet.allInstances()->select( e | 
		e.oclIsTypeOf(UML!uml::GeneralizationSet) and e.isCovering )
		->iterate( acc; res : Sequence(UML!uml::Class) = Sequence{} |
			res -> including( acc.powertype )
		)
	in s;

helper def: getIntegerURI() : OclAny =
	thisModule.resolveTemp( 
		UML!uml::PrimitiveType.allInstances()->any( e |
			e.oclIsTypeOf(UML!uml::PrimitiveType)  and e.name = 'Integer' ),
			'u'
	);

-- =============================================================================
-- RULES
-- =============================================================================
	
rule Model2Graph {
	from
		m : UML!uml::Model (
			m.oclIsTypeOf(UML!uml::Model)
		)
	to
		g : OWL!OWLGraph (
			ontology <- m.packagedElement->select( e | e.oclIsTypeOf(UML!uml::Package)),
			uriRef <- uri
		),
		d : OWL!Document (
			namespaceDefinition <- nd,
			localName <- ln,
			xmlBase <- xb
		),
		ln : OWL!LocalName ( name <- m.name, uriRef <- uri ),
		uri : OWL!URIReference ( uri <- u_r_i ),
		u_r_i : OWL!UniformResourceIdentifier ( name <- thisModule.addNamespace(m.name) ),
		xb : OWL!Namespace ( namespaceURIRef <- uri),
		nd : OWL!NamespaceDefinition (
			namespacePrefix <- thisModule.addNamespace(m.name),
			namespace <- xb
		)
}

rule Package2Ontology {
	from
		p : UML!uml::Package (
			p.oclIsTypeOf(UML!uml::Package)
		)
	to
		o : OWL!OWLOntology (
			uriRef <- u,
			OWLImports <- p.packageImport->collect( e | e.importedPackage ),
			owlGraph <- UML!uml::Model.allInstances()->asSequence()
					->any( m | m.oclIsTypeOf(UML!uml::Model)),
			owlUniverse <- p.packagedElement
		),
		u : OWL!URIReference ( fragmentIdentifier <- l, uri <- uri ),
		l : OWL!LocalName ( name <- p.name ),
		uri : OWL!UniformResourceIdentifier (
			name <- thisModule.addNamespace(p.name)
		)
}

rule UMLClass2OWLClass {
	from
		c : UML!uml::Class (
			c.oclIsTypeOf(UML!uml::Class) and 
				not thisModule.sequenceOfUnionClass.includes(c)
		)
	to
		oc : OWL!OWLClass (
			subClassOf <- c.general,
			uriRef <- u,
			label <- label
		),
		label : OWL!PlainLiteral ( lexicalForm <- c.name	),
		u : OWL!URIReference ( fragmentIdentifier <- l,uri <- uri 	),
		l : OWL!LocalName ( name <- c.name 	),
		uri : OWL!UniformResourceIdentifier ( name <- c.name )
}

rule AssociationClass2OWLClass {
	from
		ac : UML!uml::AssociationClass(
			ac.oclIsTypeOf(UML!uml::AssociationClass)
		)
	to
		oc : OWL!OWLClass (
			subClassOf <- ac.superClass,
			uriRef <- u,
			label <- label
		),
		label : OWL!PlainLiteral ( lexicalForm <- ac.name ),
		u : OWL!URIReference (	fragmentIdentifier <- l, uri <- uri ),
		l : OWL!LocalName ( name <- ac.name ),
		uri : OWL!UniformResourceIdentifier ( name <- ac.name )
}

rule GeneralizationSetIsCovering2Union {
	from
		g : UML!uml::GeneralizationSet (
			g.isCovering
		)
	using {
			uc : UML!uml::Class = g.powertype;		
			unions : Sequence( UML!uml::Class ) = g.generalization->collect( e | e.specific );
		}
	to
		c : OWL!UnionClass (
			OWLUnionOf <- unions,
			subClassOf <- uc.general,
			superClass <- unions,
			uriRef <- u,
			label <- label
		),
		label : OWL!PlainLiteral ( lexicalForm <- uc.name ),
		u : OWL!URIReference ( fragmentIdentifier <- l, uri <- uri ),
		l : OWL!LocalName ( name <- uc.name ),
		uri : OWL!UniformResourceIdentifier ( name <- uc.name )
}

rule PrimitiveType2RDFSDataType {
	from
		p : UML!uml::PrimitiveType
	to
		d : OWL!RDFSDataType (
			uriRef <- u
		),
		u : OWL!URIReference (
			uri <- uri
		),
		uri : OWL!UniformResourceIdentifier ( 
			name <- thisModule.primitiveTypeMap.get(p.name) 
		)
}

rule Enumeration2EnumeratedClass {
	from
		e : UML!uml::Enumeration
	to
		oe : OWL!EnumeratedClass (
			OWLOneOf <- e.ownedLiteral,
			uriRef <- u,
			label <- label
		),
		label : OWL!PlainLiteral ( lexicalForm <- e.name 	),
		u : OWL!URIReference (	fragmentIdentifier <- l, uri <- uri ),
		l : OWL!LocalName ( name <- e.name ),
		uri : OWL!UniformResourceIdentifier ( name <- e.name )
}

rule EnumLiteral2Individual {
	from
		e : UML!uml::EnumerationLiteral
	to
		oe : OWL!Individual (
			uriRef <- u
		),
		u : OWL!URIReference ( fragmentIdentifier <- l, uri <- uri ),
		l : OWL!LocalName ( name <- e.name ),
		uri : OWL!UniformResourceIdentifier ( name <- e.name )
}

rule PrimitiveProperty2DataTypeProperty {
	from
		p : UML!uml::Property
		(
			p.type.oclIsTypeOf(UML!uml::PrimitiveType)
		)
	to
		d : OWL!OWLDatatypeProperty (
			uriRef <- u,
			domain <- p.class,
			range <- p.type
		),
		u : OWL!URIReference ( fragmentIdentifier <- l, uri <- uri ),
		l : OWL!LocalName ( name <- p.class.name + '.' + p.name ),
		uri : OWL!UniformResourceIdentifier ( name <- p.class.name + '.' + p.name )
		
		do {
			if ( p.upper = p.lower )  -- [n-n]
				thisModule.addCardinalityRestriction( p );
			else
				if (( p.upper = 0-1 ) and ( p.lower >= 0 )) -- [*]
					thisModule.addMinCardinalityRestriction( p );
				else  { -- [m-n]
					thisModule.addMinCardinalityRestriction( p );
					thisModule.addMaxCardinalityRestriction( p );
				}
		}
}

rule EnumerationProperty2ObjectProperty {
	from
		p : UML!uml::Property
		(
			p.type.oclIsTypeOf(UML!uml::Enumeration)
		)
	to
		d : OWL!OWLObjectProperty (
			uriRef <- u,
			domain <- p.class,
			range <- p.type
		),
		u : OWL!URIReference ( fragmentIdentifier <- l, uri <- uri ),
		l : OWL!LocalName ( name <- p.class.name + '.' + p.name ),
		uri : OWL!UniformResourceIdentifier ( name <- p.class.name + '.' + p.name )
		
	do {
		if ( ( p.upper = 1) and ( p.lower = 1) )
				thisModule.addFunctionalProperty( p );
		if ( p.upper = p.lower )  -- [n-n]
				thisModule.addCardinality( p, p.class );
			else
				if (( p.upper = 0-1 ) and ( p.lower >= 0 )) -- [*]
					thisModule.addMinCardinality( p, p.class );
				else  {-- [m-n]
					thisModule.addMinCardinality( p, p.class );
					thisModule.addMaxCardinality( p, p.class );
				}
		
	}
}

rule addCardinalityRestriction( p : UML!uml::Property ) {
	to
		c : OWL!CardinalityRestriction (
			superClass <- p.class,
			OWLCardinality <- literal,
			OWLOnProperty <- p
		),
		literal : OWL!TypedLiteral (
			lexicalForm <- p.upper.toString(),
			datatypeURI <- thisModule.getIntegerURI()
		)
}

rule addMaxCardinalityRestriction( p : UML!uml::Property ) {
	to
		c : OWL!MaxCardinalityRestriction (
			superClass <- p.class,
			OWLMaxCardinality <- literal,
			OWLOnProperty <- p
		),
		literal : OWL!TypedLiteral (
			lexicalForm <- p.upper.toString(),
			datatypeURI <- thisModule.getIntegerURI()
		)
}

rule addMinCardinalityRestriction( p : UML!uml::Property ) {
	to
		c : OWL!MinCardinalityRestriction (
			superClass <- p.class,
			OWLMinCardinality <- literal,
			OWLOnProperty <- p
		),
		literal : OWL!TypedLiteral (
			lexicalForm <- p.lower.toString(),
			datatypeURI <- thisModule.getIntegerURI()
		)
}

rule Property2InverseObjectProperty {
	from
		p : UML!uml::Property (
			not (p.type.oclIsTypeOf(UML!uml::PrimitiveType)) 
			and if (p.association.oclIsUndefined())
					then false 
					else if (p.association.isBinary() and not (p.association.oclIsKindOf(UML!uml::Class)))
							then (not p.isSymmetric() and not p.isInverseFunctional())
							else false
						endif					
				endif
		)
		
	using {
			inverse : UML!uml::Property =
				p.association.ownedEnd->asSequence()
				->any( e | e.oclIsTypeOf(UML!uml::Property) and not (e = p));
		}

	to
		o : OWL!OWLObjectProperty (
			domain <- inverse.type,
			range <- p.type,
			OWLInverseOf <- inverse,
			uriRef <- o_u,
			subPropertyOf <- p.redefinedProperty
		),
		o_u : OWL!URIReference ( 	fragmentIdentifier <- o_l, uri <- o_uri ),
		o_l : OWL!LocalName ( name <- inverse.type.name + '.' + p.name ),
		o_uri : OWL!UniformResourceIdentifier ( name <- inverse.type.name + '.' + p.name )
		
	do {
		if ( ( p.upper = 1) and ( p.lower = 1) )
				thisModule.addFunctionalProperty( p );
		if ( p.upper = p.lower )  -- [n-n]
				thisModule.addCardinality( p, inverse.type );
			else
				if (( p.upper = 0-1 ) and ( p.lower >= 0 )) -- [*]
					thisModule.addMinCardinality( p, inverse.type );
				else  {-- [m-n]
					thisModule.addMinCardinality( p, inverse.type );
					thisModule.addMaxCardinality( p, inverse.type );
				}
		
	}
}

rule Property2SymmetricObjectProperty {
	from
		p : UML!uml::Property (
			not (p.type.oclIsTypeOf(UML!uml::PrimitiveType)) 
			and if (p.association.oclIsUndefined())
					then false 
					else if (p.association.isBinary() and not (p.association.oclIsKindOf(UML!uml::Class)))
							then (p.isSymmetric() and not p.isInverseFunctional())
							else false
						endif
				endif
			
		)
		
	using {
			inverse : UML!uml::Property =
				p.association.ownedEnd->asSequence()
				->any( e | e.oclIsTypeOf(UML!uml::Property) and not (e = p));
		}

	to
		o : OWL!SymmetricProperty (
			domain <- inverse.type, 
			range <- p.type,
			OWLInverseOf <- inverse,
			uriRef <- o_u,
			subPropertyOf <- p.redefinedProperty
		),
		o_u : OWL!URIReference ( fragmentIdentifier <- o_l, uri <- o_uri ),
		o_l : OWL!LocalName ( name <- inverse.type.name + '.' + p.name ),
		o_uri : OWL!UniformResourceIdentifier ( name <- inverse.type.name + '.' + p.name )
		
	do {
	
		if ( ( p.upper = 1) and ( p.lower = 1) )
			thisModule.addFunctionalProperty( p );
		if ( p.upper = p.lower )  -- [n-n]
				thisModule.addCardinality( p, inverse.type );
			else
				if (( p.upper = 0-1 ) and ( p.lower >= 0 )) -- [*]
					thisModule.addMinCardinality( p, inverse.type );
				else  {-- [m-n]
					thisModule.addMinCardinality( p, inverse.type );
					thisModule.addMaxCardinality( p, inverse.type );
				}
		
	}
}

rule Property2InverseFunctionalProperty {
	from
		p : UML!uml::Property (
			not (p.type.oclIsTypeOf(UML!uml::PrimitiveType)) 
			and if (p.association.oclIsUndefined())
					then false 
					else if (p.association.isBinary() and not (p.association.oclIsKindOf(UML!uml::Class)))
							then (p.isInverseFunctional() and not p.isSymmetric())
							else false
						endif
				endif
		)
		
	using {
			inverse : UML!uml::Property =
				p.association.ownedEnd->asSequence()
				->any( e | e.oclIsTypeOf(UML!uml::Property) and not (e = p));
		}

	to
		o : OWL!InverseFunctionalProperty (
			domain <- inverse.type, 
			range <- p.type,
			OWLInverseOf <- inverse,
			uriRef <- o_u,
			subPropertyOf <- p.redefinedProperty
		),
		o_u : OWL!URIReference ( fragmentIdentifier <- o_l, uri <- o_uri ),
		o_l : OWL!LocalName ( name <- inverse.type.name + '.' + p.name ),
		o_uri : OWL!UniformResourceIdentifier ( name <- inverse.type.name + '.' + p.name )
		
	do {
	
		if ( ( p.upper = 1) and ( p.lower = 1) )
			thisModule.addFunctionalProperty( p );
		if ( p.upper = p.lower )  -- [n-n]
				thisModule.addCardinality( p, inverse.type );
			else
				if (( p.upper = 0-1 ) and ( p.lower >= 0 )) -- [*]
					thisModule.addMinCardinality( p, inverse.type );
				else  {-- [m-n]
					thisModule.addMinCardinality( p, inverse.type );
					thisModule.addMaxCardinality( p, inverse.type );
				}
		
	}
}

rule PropertyFromAssociationClass2InverseObjectProperty {
	from
		p : UML!uml::Property (
			not (p.type.oclIsTypeOf(UML!uml::PrimitiveType)) 
			and if (p.association.oclIsUndefined())
					then false 
					else (p.association.isBinary() and (p.association.oclIsKindOf(UML!uml::Class)))
				endif
		)
		
	using {
			inverse : UML!uml::Property =
				p.association.ownedEnd->asSequence()
				->any( e | e.oclIsTypeOf(UML!uml::Property) and not (e = p));
		}

	to
		o : OWL!OWLObjectProperty (
			domain <- p.class,
			range <- p.type,
			OWLInverseOf <- inverse,
			uriRef <- o_u
		),
		o_u : OWL!URIReference ( fragmentIdentifier <- o_l, uri <- o_uri ),
		o_l : OWL!LocalName ( name <- p.class.name + '.' + p.name ),
		o_uri : OWL!UniformResourceIdentifier ( name <- p.class.name + '.' + p.name )
		
	do {
		if ( ( p.upper = 1) and ( p.lower = 1) )
				thisModule.addFunctionalProperty( p );
		if ( p.upper = p.lower )  -- [n-n]
				thisModule.addCardinality( p, p.class );
			else
				if (( p.upper = 0-1 ) and ( p.lower >= 0 )) -- [*]
					thisModule.addMinCardinality( p, p.class );
				else  {-- [m-n]
					thisModule.addMinCardinality( p, p.class );
					thisModule.addMaxCardinality( p, p.class );
				}
		
	}
}

rule addFunctionalProperty( p : UML!uml::Property ) {
	to
		o : OWL!FunctionalProperty (
				isDefinedBy <- p
		)
}

rule addCardinality( p : UML!uml::Property, class : UML!uml::Class ) {
	to
		c : OWL!CardinalityRestriction (
			superClass <- class,
			OWLCardinality <- literal,
			OWLOnProperty <- p
		),
		literal : OWL!TypedLiteral (
			lexicalForm <- p.upper.toString(),
			datatypeURI <- thisModule.getIntegerURI()
		)
}

rule addMinCardinality( p : UML!uml::Property, class : UML!uml::Class ) {
	to
		c : OWL!MinCardinalityRestriction (
			superClass <- class,
			OWLMinCardinality <- literal,
			OWLOnProperty <- p
		),
		literal : OWL!TypedLiteral (
			lexicalForm <- p.lower.toString(),
			datatypeURI <- thisModule.getIntegerURI()
		)
}

rule addMaxCardinality( p : UML!uml::Property, class : UML!uml::Class ) {
	to
		c : OWL!MaxCardinalityRestriction (
			superClass <- class,
			OWLMaxCardinality <- literal,
			OWLOnProperty <- p
		),
		literal : OWL!TypedLiteral (
			lexicalForm <- p.upper.toString(),
			datatypeURI <- thisModule.getIntegerURI()
		)
}

-- =============================================================================
--	RULES FOR INSTANCES
-- =============================================================================
	
rule InstanceSpecification2Individual {
	from
		i : UML!uml::InstanceSpecification (
			i.oclIsTypeOf(UML!uml::InstanceSpecification)
		)
	to
		ind : OWL!Individual (
			uriRef <- u,
			type <- i.classifier
		),
		u : OWL!URIReference ( fragmentIdentifier <- l, uri <- uri ),
		l : OWL!LocalName ( name <- i.name 	),
		uri : OWL!UniformResourceIdentifier ( name <- i.name )
}

-- A Slot serves to create statement between the instance and the slot's value 

rule SlotPrimitive2Statement {
	from
		s : UML!uml::Slot (
			-- Property Type is Primitive Datatype
			s.definingFeature.type.oclIsTypeOf(UML!uml::PrimitiveType)
		)
	to
		state : OWL!OWLStatement (
			graph <- UML!uml::Model.allInstances()->asSequence()
					->any( m | m.oclIsTypeOf(UML!uml::Model)),
			RDFsubject <- s.owningInstance,
			RDFpredicate <- s.definingFeature,
			RDFobject <- o
		),
		o : OWL!Individual (
			type <- s.definingFeature.type,
			uriRef <- u
		),
		u : OWL!URIReference ( fragmentIdentifier <- l, uri <- uri ),
		l : OWL!LocalName (
		 	name <-  s.value->asSequence()
			->any( e | e.oclIsKindOf(UML!uml::LiteralSpecification) ).value
		),
		uri : OWL!UniformResourceIdentifier (
		 	name <-  s.value->asSequence()
			->any( e | e.oclIsKindOf(UML!uml::LiteralSpecification) ).value
		)
}

rule SlotClass2Statement {
	from
		s : UML!uml::Slot (
			-- Property Type is Class
			s.definingFeature.type.oclIsTypeOf(UML!uml::Class)
			or
			s.definingFeature.type.oclIsTypeOf(UML!uml::Enumeration)
		)
	do {
		for( i in s.value ) {
			thisModule.createStatement( s, i );
		}
	}
} 

rule createStatement( s : UML!uml::Slot, i : UML!uml::InstanceValue ) {
	to
		state : OWL!OWLStatement (
			graph <- UML!uml::Model.allInstances()->asSequence()
					->any( m | m.oclIsTypeOf(UML!uml::Model)),
			RDFsubject <- s.owningInstance,
			RDFpredicate <- s.definingFeature,
			RDFobject <- i.instance
		)
}
",atlcompil atl modul uml owl modul templat creat out owl in uml uml owl version releas date author guillaum hillairet g hillairet gmail com helper def primitivetypemap map string string map string http www w org xmlschema string integ http www w org xmlschema nonnegativeinteg boolean http www w org xmlschema boolean unlimitednatur http www w org xmlschema integ helper def addnamespac string string http exampl org helper context uml uml associ def isbinari boolean self ownedend assequ size helper context uml uml properti def issymmetr boolean self type self associ ownedend assequ e e oclistypeof uml uml properti e self type helper context uml uml properti def isinversefunct boolean self associ ownedend assequ e e oclistypeof uml uml properti e self upper self associ ownedend assequ e e oclistypeof uml uml properti e self lower helper def sequenceofunionclass sequenc uml uml class let sequenc uml uml class uml uml generalizationset allinst select e e oclistypeof uml uml generalizationset e iscov iter acc res sequenc uml uml class sequenc res includ acc powertyp helper def getintegeruri oclani thismodul resolvetemp uml uml primitivetyp allinst e e oclistypeof uml uml primitivetyp e name integ u rule rule model graph uml uml model oclistypeof uml uml model g owl owlgraph ontolog packagedel select e e oclistypeof uml uml packag uriref uri owl document namespacedefinit nd localnam ln xmlbase xb ln owl localnam name name uriref uri uri owl urirefer uri u r u r owl uniformresourceidentifi name thismodul addnamespac name xb owl namespac namespaceuriref uri nd owl namespacedefinit namespaceprefix thismodul addnamespac name namespac xb rule packag ontolog p uml uml packag p oclistypeof uml uml packag owl owlontolog uriref u owlimport p packageimport collect e e importedpackag owlgraph uml uml model allinst assequ oclistypeof uml uml model owlunivers p packagedel u owl urirefer fragmentidentifi l uri uri l owl localnam name p name uri owl uniformresourceidentifi name thismodul addnamespac p name rule umlclass owlclass c uml uml class c oclistypeof uml uml class thismodul sequenceofunionclass includ c oc owl owlclass subclassof c general uriref u label label label owl plainliter lexicalform c name u owl urirefer fragmentidentifi l uri uri l owl localnam name c name uri owl uniformresourceidentifi name c name rule associationclass owlclass ac uml uml associationclass ac oclistypeof uml uml associationclass oc owl owlclass subclassof ac superclass uriref u label label label owl plainliter lexicalform ac name u owl urirefer fragmentidentifi l uri uri l owl localnam name ac name uri owl uniformresourceidentifi name ac name rule generalizationsetiscov union g uml uml generalizationset g iscov use uc uml uml class g powertyp union sequenc uml uml class g general collect e e specif c owl unionclass owlunionof union subclassof uc general superclass union uriref u label label label owl plainliter lexicalform uc name u owl urirefer fragmentidentifi l uri uri l owl localnam name uc name uri owl uniformresourceidentifi name uc name rule primitivetyp rdfsdatatyp p uml uml primitivetyp owl rdfsdatatyp uriref u u owl urirefer uri uri uri owl uniformresourceidentifi name thismodul primitivetypemap get p name rule enumer enumeratedclass e uml uml enumer oe owl enumeratedclass owloneof e ownedliter uriref u label label label owl plainliter lexicalform e name u owl urirefer fragmentidentifi l uri uri l owl localnam name e name uri owl uniformresourceidentifi name e name rule enumliter individu e uml uml enumerationliter oe owl individu uriref u u owl urirefer fragmentidentifi l uri uri l owl localnam name e name uri owl uniformresourceidentifi name e name rule primitiveproperti datatypeproperti p uml uml properti p type oclistypeof uml uml primitivetyp owl owldatatypeproperti uriref u domain p class rang p type u owl urirefer fragmentidentifi l uri uri l owl localnam name p class name p name uri owl uniformresourceidentifi name p class name p name p upper p lower n n thismodul addcardinalityrestrict p els p upper p lower thismodul addmincardinalityrestrict p els n thismodul addmincardinalityrestrict p thismodul addmaxcardinalityrestrict p rule enumerationproperti objectproperti p uml uml properti p type oclistypeof uml uml enumer owl owlobjectproperti uriref u domain p class rang p type u owl urirefer fragmentidentifi l uri uri l owl localnam name p class name p name uri owl uniformresourceidentifi name p class name p name p upper p lower thismodul addfunctionalproperti p p upper p lower n n thismodul addcardin p p class els p upper p lower thismodul addmincardin p p class els n thismodul addmincardin p p class thismodul addmaxcardin p p class rule addcardinalityrestrict p uml uml properti c owl cardinalityrestrict superclass p class owlcardin liter owlonproperti p liter owl typedliter lexicalform p upper tostr datatypeuri thismodul getintegeruri rule addmaxcardinalityrestrict p uml uml properti c owl maxcardinalityrestrict superclass p class owlmaxcardin liter owlonproperti p liter owl typedliter lexicalform p upper tostr datatypeuri thismodul getintegeruri rule addmincardinalityrestrict p uml uml properti c owl mincardinalityrestrict superclass p class owlmincardin liter owlonproperti p liter owl typedliter lexicalform p lower tostr datatypeuri thismodul getintegeruri rule properti inverseobjectproperti p uml uml properti p type oclistypeof uml uml primitivetyp p associ oclisundefin fals els p associ isbinari p associ ocliskindof uml uml class p issymmetr p isinversefunct els fals endif endif use invers uml uml properti p associ ownedend assequ e e oclistypeof uml uml properti e p owl owlobjectproperti domain invers type rang p type owlinverseof invers uriref u subpropertyof p redefinedproperti u owl urirefer fragmentidentifi l uri uri l owl localnam name invers type name p name uri owl uniformresourceidentifi name invers type name p name p upper p lower thismodul addfunctionalproperti p p upper p lower n n thismodul addcardin p invers type els p upper p lower thismodul addmincardin p invers type els n thismodul addmincardin p invers type thismodul addmaxcardin p invers type rule properti symmetricobjectproperti p uml uml properti p type oclistypeof uml uml primitivetyp p associ oclisundefin fals els p associ isbinari p associ ocliskindof uml uml class p issymmetr p isinversefunct els fals endif endif use invers uml uml properti p associ ownedend assequ e e oclistypeof uml uml properti e p owl symmetricproperti domain invers type rang p type owlinverseof invers uriref u subpropertyof p redefinedproperti u owl urirefer fragmentidentifi l uri uri l owl localnam name invers type name p name uri owl uniformresourceidentifi name invers type name p name p upper p lower thismodul addfunctionalproperti p p upper p lower n n thismodul addcardin p invers type els p upper p lower thismodul addmincardin p invers type els n thismodul addmincardin p invers type thismodul addmaxcardin p invers type rule properti inversefunctionalproperti p uml uml properti p type oclistypeof uml uml primitivetyp p associ oclisundefin fals els p associ isbinari p associ ocliskindof uml uml class p isinversefunct p issymmetr els fals endif endif use invers uml uml properti p associ ownedend assequ e e oclistypeof uml uml properti e p owl inversefunctionalproperti domain invers type rang p type owlinverseof invers uriref u subpropertyof p redefinedproperti u owl urirefer fragmentidentifi l uri uri l owl localnam name invers type name p name uri owl uniformresourceidentifi name invers type name p name p upper p lower thismodul addfunctionalproperti p p upper p lower n n thismodul addcardin p invers type els p upper p lower thismodul addmincardin p invers type els n thismodul addmincardin p invers type thismodul addmaxcardin p invers type rule propertyfromassociationclass inverseobjectproperti p uml uml properti p type oclistypeof uml uml primitivetyp p associ oclisundefin fals els p associ isbinari p associ ocliskindof uml uml class endif use invers uml uml properti p associ ownedend assequ e e oclistypeof uml uml properti e p owl owlobjectproperti domain p class rang p type owlinverseof invers uriref u u owl urirefer fragmentidentifi l uri uri l owl localnam name p class name p name uri owl uniformresourceidentifi name p class name p name p upper p lower thismodul addfunctionalproperti p p upper p lower n n thismodul addcardin p p class els p upper p lower thismodul addmincardin p p class els n thismodul addmincardin p p class thismodul addmaxcardin p p class rule addfunctionalproperti p uml uml properti owl functionalproperti isdefinedbi p rule addcardin p uml uml properti class uml uml class c owl cardinalityrestrict superclass class owlcardin liter owlonproperti p liter owl typedliter lexicalform p upper tostr datatypeuri thismodul getintegeruri rule addmincardin p uml uml properti class uml uml class c owl mincardinalityrestrict superclass class owlmincardin liter owlonproperti p liter owl typedliter lexicalform p lower tostr datatypeuri thismodul getintegeruri rule addmaxcardin p uml uml properti class uml uml class c owl maxcardinalityrestrict superclass class owlmaxcardin liter owlonproperti p liter owl typedliter lexicalform p upper tostr datatypeuri thismodul getintegeruri rule for instanc rule instancespecif individu uml uml instancespecif oclistypeof uml uml instancespecif ind owl individu uriref u type classifi u owl urirefer fragmentidentifi l uri uri l owl localnam name name uri owl uniformresourceidentifi name name a slot serv creat statement instanc slot valu rule slotprimit statement uml uml slot properti type primit datatyp definingfeatur type oclistypeof uml uml primitivetyp state owl owlstat graph uml uml model allinst assequ oclistypeof uml uml model rdfsubject owninginst rdfpredic definingfeatur rdfobject owl individu type definingfeatur type uriref u u owl urirefer fragmentidentifi l uri uri l owl localnam name valu assequ e e ocliskindof uml uml literalspecif valu uri owl uniformresourceidentifi name valu assequ e e ocliskindof uml uml literalspecif valu rule slotclass statement uml uml slot properti type class definingfeatur type oclistypeof uml uml class definingfeatur type oclistypeof uml uml enumer valu thismodul createstat rule createstat uml uml slot uml uml instancevalu state owl owlstat graph uml uml model allinst assequ oclistypeof uml uml model rdfsubject owninginst rdfpredic definingfeatur rdfobject instanc,7
213,213,P93-EMOOSE4UML2.atl,"--@atlcompiler	atl2006
--@name			EMOOSE4UML2
--@version		1.0
--@domains		UML2, MOOSE, EMOOSE, metrics
--@authors		Eric Vepa (evepa <at> sodius.com) for SODIUS (www.sodius.com)
--@date			2007/06/05
--@description	This library provides MOOSE (Metrics for Object-Oriented Software Engineering) and EMOOSE (Extended MOOSE) metrics suites on UML2 models (from Eclipse UML2 Project). The models have been extracted from Jar files using the Eclipse plug-in Jar2UML. Only the metrics that fit to UML2 models have been implemented.
--@see			Baroni, A.L.: Formal Definition of Object-Oriented Design Metrics. Master Thesis, Vrije University, Brussel, Belgium, 2002.

library EMOOSE4UML2; -- Library Template

-- ===============
-- MOOSE Metrics =
-- ===============

--@begin helper MOOSE::DIT
--@comments Depth of Inheritance Tree
--@comments The length of the longest path of inheritance from the current Class to the root of the tree.
helper context UML2!Class
def : DIT() : Integer =
	if self.isRoot
		then 0
		else if self.PARN() = 1
				then 1
				else 0
			endif + self.parents->iterate(c; acc : Integer = 0|acc + c.DIT())
	endif;
--@end helper MOOSE::DIT

--@begin helper MOOSE::NOC
--@comments Number of Children
--@comments The number of classes that inherit directly from the current Class.
helper context UML2!Class
def : NOC() : Integer =
	self.CHIN();
--@end helper MOOSE::NOC

--@begin helper MOOSE::CBO
--@comments Coupling Between Objects
--@comments The number of other Classes that are coupled to the current one. Two Classes are coupled when methods declared in one Class use Methods or instance variables defined by the other Class.
helper context UML2!Class
def : CBO() : Integer =
	self.coupledClasses->size();
--@end helper MOOSE::CBO

--@begin helper MOOSE::RFC
--@comments Response for a Class
--@comments The number of Methods in the current Class that might respond to a message received by its object, including Methods both inside and outside of this Class.
--@comments RFC = {M} âªall i {Ri} where {Ri} = set of Methods called by Method i and {M} = set of all Methods in a Class. Ri is dependent on the implementation of the Method i.
helper context UML2!Class
def : RFC() : Integer =
	self.allOperations->
		union(self.allOperations->
			collect(o|o.method->collect(m|m.allClients)->
				flatten()->asSet()->select(c|c.oclAsType(UML2!Operation))))->
					flatten()->asSet()->size();
--@end helper MOOSE::RFC


-- ================
-- EMOOSE Metrics =
-- ================

--@begin helper EMOOSE::NOM
--@comments Number of Methods
--@comments Number of Operations that are local to the Class, i.e., that can only be accessed by other Class Operations (and not in other Classes).
--@comments The Class must have some Operations.
helper context UML2!Class
def : NOM() : Integer =
	self.allOperations->select(o|o.visibility = #private)->size();
--@end helper EMOOSE::NOM

--@begin helper EMOOSE::SIZE2
--@comments Number of local Attributes and Operations defined in the Class.
helper context UML2!Class
def : SIZE2() : Integer =
	self.DON() + self.DAN();
--@end helper EMOOSE::SIZE2
",atlcompil atl name emoos uml version domain uml moos emoos metric author eric vepa evepa sodius com sodius www sodius com date descript this librari provid moos metric object orient softwar engin emoos extend moos metric suit uml model eclips uml project the model extract jar file use eclips plug jar uml onli metric fit uml model implement see baroni a l formal definit object orient design metric master thesi vrije univers brussel belgium librari emoos uml librari templat moos metric begin helper moos dit comment depth inherit tree comment the length longest path inherit current class root tree helper context uml class def dit integ self isroot els self parn els endif self parent iter c acc integ acc c dit endif end helper moos dit begin helper moos noc comment number children comment the number class inherit direct current class helper context uml class def noc integ self chin end helper moos noc begin helper moos cbo comment coupl between object comment the number class coupl current one two class coupl method declar one class use method instanc variabl defin class helper context uml class def cbo integ self coupledclass size end helper moos cbo begin helper moos rfc comment respons class comment the number method current class might respond messag receiv object includ method insid outsid class comment rfc m ri ri set method call method m set method class ri depend implement method helper context uml class def rfc integ self alloper union self alloper collect method collect allclient flatten asset select c c oclastyp uml oper flatten asset size end helper moos rfc emoos metric begin helper emoos nom comment number method comment number oper local class e access class oper class comment the class must oper helper context uml class def nom integ self alloper select visibl privat size end helper emoos nom begin helper emoos size comment number local attribut oper defin class helper context uml class def size integ self don self dan end helper emoos size,14
214,214,P93-FLAME4UML2.atl,"--@atlcompiler	atl2006
--@name			FLAME4UML2
--@version		1.1
--@domains		UML2, FLAME, metrics
--@authors		Eric Vepa (evepa <at> sodius.com) for SODIUS (www.sodius.com)
--@date			2007/08/02
--@description	This library implements a subset of FLAME (Formal Library for Aiding Metrics Extraction) functions applied on UML2 models (from Eclipse UML2 Project). These functions navigate through the UML2 metamodel and are used by other metrics libraries.
--@see			Baroni, A.L.: Formal Definition of Object-Oriented Design Metrics. Master Thesis, Vrije University, Brussel, Belgium, 2002.

library UML22Measure; -- Library Template

--@begin attribute helper coupledClasses
--@comments Set of Classs to which the current Class is coupled (excluding inheritance).
helper context UML2!Class
def : coupledClasses : Set(UML2!Class) =
    self.allAttributesTypes->union(self.allParametersTypes);
--@end attribute helper coupledClasses

--@begin attribute helper newFeatures
--@comments Sequence of Features declared in the current Class. This definition excludes inherited Features (and consequently, it excludes overridden Features).
helper context UML2!Class
def : newFeatures : Sequence(UML2!Feature) =
    self.newAttributes->union(self.newOperations);
--@end attribute helper newFeatures

--@begin attribute helper definedFeatures
--@comments Sequence of Features declared in the Class, including overridden Features.
helper context UML2!Class
def : definedFeatures : Sequence(UML2!Feature) =
    self.definedAttributes->union(self.definedOperations);
--@end attribute helper definedFeatures

--@begin attribute helper directlyInheritedFeatures
--@comments Sequence of directly inherited Features.
helper context UML2!Class
def : directlyInheritedFeatures : Sequence(UML2!Feature) =
    self.directlyInheritedAttributes->
        union(self.directlyInheritedOperations);
--@end attribute helper directlyInheritedFeatures

--@begin attribute helper allInheritedFeatures
--@comments Sequence containing all Features of the Class itself and all its inherited Features (both directly and indirectly).
helper context UML2!Class
def : allInheritedFeatures : Sequence(UML2!Feature) =
    self.allInheritedAttributes->union(self.allInheritedOperations);
--@end attribute helper allInheritedFeatures

--@begin attribute helper overriddenFeatures
--@comments Sequence of redefined Features in the Class.
helper context UML2!Class
def : overriddenFeatures : Sequence(UML2!Feature) =
    self.overriddenAttributes->union(self.overriddenOperations);
--@end attribute helper overriddenFeatures

--@begin attribute helper allFeatures
--@comments Sequence containing all Features of the Class itself and all its inherited Features.
helper context UML2!Class
def : allFeatures : Sequence(UML2!Feature) =
    self.allAttributes->union(self.allOperations);
--@end attribute helper allFeatures

--@begin attribute helper newAttributes
--@comments Sequence of Attributes declared in the current Class.
helper context UML2!Class
def : newAttributes : Sequence(UML2!Property) =
    self.definedAttributes->
        select(da|self.allInheritedAttributes->
            collect(ia|ia.name)->excludes(da.name));
--@end attribute helper newAttributes

--@begin attribute helper definedAttributes
--@comments Sequence of Properties declared in the Class, including overridden Properties.
helper context UML2!Class
def : definedAttributes : Sequence(UML2!Property) =
    self.ownedAttribute;

helper context UML2!Package
def : definedAttributes : Sequence(UML2!Property) =
    self.allClasses->collect(c|c.definedAttributes)->flatten();
--@end attribute helper definedAttributes

--@begin attribute helper directlyInheritedAttributes
--@comments Sequence of directly inherited Properties.
helper context UML2!Class
def : directlyInheritedAttributes : Sequence(UML2!Property) =
    self.parents->iterate(p; acc : Sequence(UML2!Property) = Sequence{}|
        acc->union(p.newAttributes));
--@end attribute helper directlyInheritedAttributes

--@begin attribute helper allInheritedAttributes
--@comments Sequence of all inherited Properties (both directly and indirectly).
helper context UML2!Class
def : allInheritedAttributes : Sequence(UML2!Property) =
    self.directlyInheritedAttributes->
        union(self.parents->collect(p|p.allInheritedAttributes)->flatten());
--@end attribute helper allInheritedAttributes

--@begin attribute helper overriddenAttributes
--@comments Sequence of redefined Properties in the Class.
helper context UML2!Class
def : overriddenAttributes : Sequence(UML2!Property) =
    self.definedAttributes->
        select(da|self.allInheritedAttributes->
            collect(ia|ia.name)->includes(da.name));
--@end attribute helper overriddenAttributes

--@begin attribute helper allAttributes
--@comments Sequence containing all Properties of the Class itself and all its inherited Properties (both directly and indirectly).
helper context UML2!Class
def : allAttributes : Sequence(UML2!Property) =
    self.definedAttributes->union(self.allInheritedAttributes->
        reject(ia|self.overriddenAttributes->
            collect(oa|oa.name)->includes(ia.name)));

helper context UML2!Package
def : allAttributes : Sequence(UML2!Property) =
    self.allClasses->collect(c|c.allAttributes)->flatten();
--@end attribute helper allAttributes

--@begin attribute helper allAttributesTypes
--@comments Set containing all Types of all Attribtues of the Class.
helper context UML2!Class
def : allAttributesTypes : Set(UML2!Class) =
    self.allAttributes->collect(a|a.type)->flatten()->
        select(t|t.oclIsTypeOf(UML2!Class))->asSet();
--@end attribute helper allAttributesTypes

--@begin attribute helper newOperations
--@comments Sequence of Operations declared in the current Class.
helper context UML2!Class
def : newOperations : Sequence(UML2!Operation) =
    self.definedOperations->
        select(dop|self.allInheritedOperations->
            collect(iop|iop.name)->excludes(dop.name));
--@end attribute helper newOperations

--@begin attribute helper definedOperations
--@comments Sequence of Operations declared in the Class, including overridden Operations.
helper context UML2!Class
def : definedOperations : Sequence(UML2!Operation) =
    self.ownedOperation;

helper context UML2!Package
def : definedOperations : Sequence(UML2!Operation) =
    self.allClasses->collect(c|c.definedOperations)->flatten();
--@end attribute helper definedOperations

--@begin attribute helper directlyInheritedOperations
--@comments Sequence of directly inherited Operations.
helper context UML2!Class
def : directlyInheritedOperations : Sequence(UML2!Operation) =
    self.parents->iterate(p; acc : Sequence(UML2!Operation) = Sequence{}|
        acc->union(p.newOperations));
--@end attribute helper directlyInheritedOperations

--@begin attribute helper allInheritedOperations
--@comments Sequence containing all Operations of the Class itself and all its inherited Operations (both directly and indirectly).
helper context UML2!Class
def : allInheritedOperations : Sequence(UML2!Operation) =
    self.directlyInheritedOperations->
        union(self.parents->collect(p|p.allInheritedOperations)->flatten());
--@end attribute helper allInheritedOperations

--@begin attribute helper overriddenOperations
--@comments Sequence of redefined Operations in the Class.
helper context UML2!Class
def : overriddenOperations : Sequence(UML2!Operation) =
    self.definedOperations->
        select(dop|self.allInheritedOperations->
            collect(iop|iop.name)->includes(dop.name));
--@end attribute helper overriddenOperations

--@begin attribute helper allOperations
--@comments Sequence containing all Operations of the Class itself and all its inherited Operations.
helper context UML2!Class
def : allOperations : Sequence(UML2!Operation) =
    self.definedOperations->union(self.allInheritedOperations->
            reject(iop|self.overriddenOperations->
                collect(oop|oop.name)->includes(iop.name)));

helper context UML2!Package
def : allOperations : Sequence(UML2!Operation) =
    self.allClasses->collect(c|c.allOperations)->flatten()->asSet();
--@end attribute helper allOperations

--@begin attribute helper allParameters
--@comments Set containing all Parameters of all Operations of the Class.
helper context UML2!Class
def : allParameters : Set(UML2!Parameter) =
    self.allOperations->collect(o|o.ownedParameter)->flatten()->
        select(t|t.oclIsTypeOf(UML2!Class))->asSet();
--@end attribute helper allParameters

--@begin attribute helper allParametersTypes
--@comments Set containing all Types of all Parameters of all Operations of the Class.
helper context UML2!Class
def : allParametersTypes : Set(UML2!Class) =
    self.allParameters->collect(param|param.type)->flatten()->
        select(t|t.oclIsTypeOf(UML2!Class))->asSet();

helper context UML2!Operation
def : allParametersTypes : Set(UML2!Class) =
    self.ownedParameter->collect(param|param.type)->flatten()->
        select(t|t.oclIsTypeOf(UML2!Class))->asSet();
--@end attribute helper allParametersTypes

--@begin attribute helper isRoot
--@comments Indicates whether the Class has ascendants or not. A true value indicates it has no ascendants and a false value indicates it has ascendants.
helper context UML2!Class
def : isRoot : Boolean =
    self.parents->isEmpty();
--@end attribute helper isRoot

--@begin attribute helper isLeaf
--@comments Indicates whether the Class has descendants or not. A true value indicates it has no descendants and a false value indicates it has descendants.
helper context UML2!Class
def : isLeaf : Boolean =
    self.children->isEmpty();
--@end attribute helper isLeaf

--@begin attribute helper children
--@comments Set of directly derived Classs of the current Class.
helper context UML2!Class
def : children : Set(UML2!Class) =
    UML2!Generalization.allInstances()->
        select(g|g.general = self)->
            collect(g|g.specific)->excluding(self)->asSet();
--@end attribute helper children

--@begin attribute helper descendants
--@comments Set of all derived Classs (both directly and indirectly).
helper context UML2!Class
def : descendants : Set(UML2!Class) =
    self.children->iterate(c; acc : Set(UML2!Class) = self.children|
        acc->union(c.descendants));
--@end attribute helper descendants

--@begin attribute helper parents
--@comments Set of Classs from which the current Class derives directly.
helper context UML2!Class
def : parents : Set(UML2!Class) =
    self.generalization->collect(g|g.general)->excluding(self)->asSet();
--@end attribute helper parents

--@begin attribute helper ascendants
--@comments Set of all classes from which the current Class derives (both directly and indirectly).
helper context UML2!Class
def : ascendants : Set(UML2!Class) =
    self.parents->iterate(c; acc: Set(UML2!Class) = self.parents|
        acc->union(c.ascendants));
--@end attribute helper ascendants

--@begin attribute helper client
--@comments Set containing all direct clients of the NamedElement.
helper context UML2!NamedElement
def : client : Set(UML2!NamedElement) =
    --@comments reference supplierDependency does not exist in this UML2 metamodel (using allInstances instead)
    --self.supplierDependency->collect(d|d.client)->flatten()->asSet();
    UML2!Dependency.allInstances()->
        select(d|d.supplier->includes(self))->collect(d|d.client)->
            flatten()->asSet();
--@end attribute helper client

--@begin attribute helper allClients
--@comments Set containing all the NamedElements that are clients of this NamedElement, including the clients of these NamedElements. This is the transitive closure.
helper context UML2!NamedElement
def : allClients : Set(UML2!NamedElement) =
    self.client->union(self.client->collect(ne|ne.allClients)->
        flatten())->asSet();
--@end attribute helper allClients

--@begin attribute helper contents
--@comments Sequence containing all PackageableElement contained by the Package.
helper context UML2!Package
def : contents : Sequence(UML2!PackageableElement) =
    self.packagedElement;
--@end attribute helper contents

--@begin attribute helper allClasses
--@comments Sequence of all Classes belonging to the current Package.
helper context UML2!Package
def : allClasses : Sequence(UML2!Class) =
    self.contents->select(c|c.oclIsKindOf(UML2!Class));
--@end attribute helper allClasses

--@begin attribute helper internalBaseClasses
--@comments Set of base Classes in the current Package.
helper context UML2!Package
def : internalBaseClasses : Set(UML2!Class) =
    self.allClasses->iterate(c; acc : Set(UML2!Class) = Set{}|
        acc->union(c.parents));
--@end attribute helper internalBaseClasses

--@begin attribute helper internalSupplierClasses
--@comments Set of supplier Classes in the current Package.
helper context UML2!Package
def : internalSupplierClasses : Set(UML2!Class) =
    self.supplierClasses(self);
--@end attribute helper internalSupplierClasses

--@begin attribute helper owner
--@comments This attribute helper is not include in FLAME library.
--@comments The package which contains this packageable element.
helper context UML2!PackageableElement
def : owner : UML2!Package =
    let owners : Sequence(UML2!Package) =
        UML2!Package.allInstances()->select(p|p.oclIsTypeOf(UML2!Package))->
            select(p|p.contents->includes(self)) in
    if owners->notEmpty()
        then owners->first()
        else OclUndefined
    endif;
--@end attribute helper owner

--@begin helper AUN
--@comments Attribute Use Number
--@comments Number of NamedElement that use the Property (excludes the NamedElement where the Property is declared).
helper context UML2!Property
def : AUN() : Integer =
	self.FUN();
--@end helper AUN

--@begin helper FCV
--@comments Feature to Class Visibility
--@comments Indicates if a Class can access the Feature.
helper context UML2!Class
def : FCV(f : UML2!Feature) : Boolean =
	(f.visibility = #public) or
		self.allFeatures->includes(f) or
			((f.visibility = #protected) and
				self.ascendants->exists(c|c.allFeatures->includes(f)));
--@end helper FCV

--@begin helper NAN
--@comments New Attributes Number
--@comments Number of new Properties belonging to the Class.
helper context UML2!Class
def : NAN() : Integer =
	self.newAttributes->size();
--@end helper NAN

--@begin helper DAN
--@comments Defined Attributes Number
--@comments Number of defined Properties in the Class.
helper context UML2!Class
def : DAN() : Integer =
	self.definedAttributes->size();
--@end helper DAN

--@begin helper IAN
--@comments Inherited Attributes Number
--@comments Number of inherited Properties in the Class.
helper context UML2!Class
def : IAN() : Integer =
	self.allInheritedAttributes->size();
--@end helper IAN

--@begin helper OAN
--@comments Overridden Attributes Number
--@comments Number of overridden Properties in the Class.
helper context UML2!Class
def : OAN() : Integer =
	self.overriddenAttributes->size();
--@end helper OAN

--@begin helper AAN
--@comments Available Attributes Number
--@comments Number of Properties in the Class.
helper context UML2!Class
def : AAN() : Integer =
	self.allAttributes->size();
--@end helper AAN

--@begin helper NON
--@comments New Operations Number
--@comments Number of new Operations in the Class.
helper context UML2!Class
def : NON() : Integer =
	self.newOperations->size();
--@end helper NON

--@begin helper DON
--@comments Defined Operations Number
--@comments Number of defined Operations in the Class.
helper context UML2!Class
def : DON() : Integer =
	self.definedOperations->size();
--@end helper DON

--@begin helper ION
--@comments Inherited Operations Number
--@comments Number of inherited Operations in the Class.
helper context UML2!Class
def : ION() : Integer =
	self.allInheritedOperations->size();
--@end helper ION

--@begin helper OON
--@comments Overridden Operations Number
--@comments Number of overridden Operations in the Class.
helper context UML2!Class
def : OON() : Integer =
	self.overriddenOperations->size();
--@end helper OON

--@begin helper AON
--@comments Available Operations Number
--@comments Number of Operations in the Class.
helper context UML2!Class
def : AON() : Integer =
	self.allOperations->size();
--@end helper AON

--@begin helper PRIAN
--@comments PRIvate Attributes Number
--@comments Number of private Properties in the Class.
helper context UML2!Class
def : PRIAN() : Integer =
	self.allAttributes->select(a|a.visibility = #private)->size();
--@end helper PRIAN

--@begin helper PROAN
--@comments PROtected Properties Number
--@comments Number of protected Attributes in the Class.
helper context UML2!Class
def : PROAN() : Integer =
	self.allAttributes->select(a|a.visibility = #protected)->size();
--@end helper PROAN

--@begin helper PUBAN
--@comments PUBlic Properties Number
--@comments Number of public Attributes in the Class.
helper context UML2!Class
def : PUBAN() : Integer =
	self.allAttributes->select(a|a.visibility = #public)->size();
--@end helper PUBAN

--@begin helper PRION
--@comments PRIvate Operations Number
--@comments Number of private Operations in the Class.
helper context UML2!Class
def : PRION() : Integer =
	self.allOperations->select(op|op.visibility = #private)->size();
--@end helper PRION

--@begin helper PROON
--@comments PROtected Operations Number
--@comments Number of protected Operations in the Class.
helper context UML2!Class
def : PROON() : Integer =
	self.allOperations->select(op|op.visibility = #protected)->size();
--@end helper PROON

--@begin helper PUBON
--@comments PUBlic Operations Number
--@comments Number of public Operations in the Class.
helper context UML2!Class
def : PUBON() : Integer =
	self.allOperations->select(op|op.visibility = #public)->size();
--@end helper PUBON

--@begin helper FUN
--@comments Feature Use Number
--@comments Number of NamedElement that use the Feature (excludes the NamedElement where the Feature is declared).
helper context UML2!Feature
def : FUN() : Integer =
	self.allClients->size();
--@end helper FUN

--@begin helper CHIN
--@comments CHIldren Number
--@comments Number of directly derived Classs.
helper context UML2!Class
def : CHIN() : Integer =
	self.children->size();
--@end helper CHIN

--@begin helper DESN
--@comments DEScendants Number
--@comments Number of all derived Classs (both directly and indirectly).
helper context UML2!Class
def : DESN() : Integer =
	self.descendants->size();
--@end helper DESN

--@begin helper PARN
--@comments PARents Number
--@comments Number of Classs from which the current Class derives directly.
helper context UML2!Class
def : PARN() : Integer =
	self.parents->size();
--@end helper PARN

--@begin helper ASCN
--@comments ASCendants Number
--@comments Number of Classs from which the current Class derives (both directly and indirectly).
helper context UML2!Class
def : ASCN() : Integer =
	self.ascendants->size();
--@end helper ASCN

--@begin helper OUN
--@comments Operation Use Number
--@comments Number of NamedElement that use the Operation (excludes the NamedElement where the Feature is declared).
helper context UML2!Operation
def : OUN() : Integer =
	self.FUN();
--@end helper OUN

--@begin helper isInternal
--@comments Indicates if the Class received as parameter belongs to the considered Package.
helper context UML2!Package
def : isInternal(c : UML2!Class) : Boolean =
	self.contents->includes(c);
--@end helper isInternal

--@begin helper baseClasses
--@comments Set of base Classes (from the current Package) that belong to the Package ""p"".
helper context UML2!Package
def : baseClasses(p : UML2!Package) : Set(UML2!Class) =
	self.internalBaseClasses->select(c|p.isInternal(c))->asSet();
--@end helper baseClasses

--@begin helper baseClassesInPackages
--@comments Set of base Classes in both the current Package and the one bound to the parameter.
helper context UML2!Package
def : baseClassesInPackages(p : UML2!Package) : Set(UML2!Class) =
	self.internalBaseClasses->union(p.internalBaseClasses);
--@end helper baseClassesInPackages

--@begin helper supplierClasses
--@comments Set of supplier Classes (from the current Package) that belong to the Package ""p""(excludes inheritance).
helper context UML2!Package
def : supplierClasses(p : UML2!Package) : Set(UML2!Class) =
	self.allClasses->iterate(c; acc : Set(UML2!Class)= Set{}|
		acc->union(c.coupledClasses))->select(c|p.isInternal(c))->asSet();
--@end helper supplierClasses

--@begin helper supplierClassesInPackages
--@comments Set of supplier Classes in both the current Package and the one bound to the parameter.
helper context UML2!Package
def : supplierClassesInPackages(p : UML2!Package) : Set(UML2!Class) =
	self.internalSupplierClasses->union(p.internalSupplierClasses);
--@end helper supplierClassesInPackages

--@begin helper relatedClasses
--@comments Set of Classes from the ""p"" Package that are either base or supplier Classes.
helper context UML2!Package
def : relatedClasses(p : UML2!Package) : Set(UML2!Class) =
	self.baseClasses(p)->union(self.supplierClasses(p));
--@end helper relatedClasses

--@begin helper CN
--@comments Classes Number
--@comments Number of Classes in the Package.
helper context UML2!Package
def : CN() : Integer =
	self.allClasses->size();
--@end helper CN

--@begin helper PNAN
--@comments Package New Attributes Number
--@comments Number of new Properties in the Package.
helper context UML2!Package
def : PNAN() : Integer =
	self.allClasses->iterate(c; acc : Integer = 0|acc + c.NAN);
--@end helper PNAN

--@begin helper PDAN
--@comments Package Defined Attributes Number
--@comments Number of defined Properties in the Package.
helper context UML2!Package
def : PDAN() : Integer =
	self.allClasses->iterate(c; acc : Integer = 0|acc + c.DAN());
--@end helper PDAN

--@begin helper PIAN
--@comments Package Inherited Attributes Number
--@comments Number of Properties inherited in the Package.
helper context UML2!Package
def : PIAN() : Integer =
	self.allClasses->iterate(c; acc : Integer = 0|acc + c.IAN());
--@end helper PIAN

--@begin helper POAN
--@comments Package Overridden Attributes Number
--@comments Number of overridden Properties in the Package.
helper context UML2!Package
def : POAN() : Integer =
	self.allClasses->iterate(c; acc : Integer = 0|acc + c.OAN);
--@end helper POAN

--@begin helper PAAN
--@comments Package Available Attributes Number
--@comments Number of available Properties in the Package.
helper context UML2!Package
def : PAAN() : Integer =
	self.allClasses->iterate(c; acc : Integer = 0|acc + c.AAN());
--@end helper PAAN

--@begin helper PNON
--@comments Package New Operations Number
--@comments Number of new Operations in the Package.
helper context UML2!Package
def : PNON() : Integer =
	self.allClasses->iterate(c; acc : Integer = 0|acc + c.NON());
--@end helper PNON

--@begin helper PDON
--@comments Package Defined Operations Number
--@comments Number of defined Operations in the Package.
helper context UML2!Package
def : PDON() : Integer =
	self.allClasses->iterate(c; acc : Integer = 0|acc + c.DON());
--@end helper PDON

--@begin helper PION
--@comments Package Inherited Operations Number
--@comments Number of inherited Operations in the Package.
helper context UML2!Package
def : PION() : Integer =
	self.allClasses->iterate(c; acc : Integer = 0|acc + c.ION());
--@end helper PION

--@begin helper POON
--@comments Package Overridden Operations Number
--@comments Number of overridden Operations in the Package.
helper context UML2!Package
def : POON() : Integer =
	self.allClasses->iterate(c; acc : Integer = 0|acc + c.OON());
--@end helper POON

--@begin helper PAON
--@comments Package Available Operations Number
--@comments Number of available Operations in the Package.
helper context UML2!Package
def : PAON() : Integer =
	self.allClasses->iterate(c; acc : Integer = 0|acc + c.AON());
--@end helper PAON

--@begin helper EILN
--@comments External Inheritance Links Number
--@comments Number of inheritance relations where the derived Classes belong to the current Package and the base ones belong to the Package ""p"" given as parameter.
helper context UML2!Package
def : EILN(p : UML2!Package) : Integer =
	self.allClasses->iterate(c; acc : Integer = 0|
		acc + c.parents->select(g|p.isInternal(g))->size());
--@end helper EILN

--@begin attribute helper IILN
--@comments Internal Inheritance Links Number
--@comments Number of inheritance relations where the base and derived Classes belong to the current Package.
helper context UML2!Package
def : IILN : Integer =
    self.allClasses->iterate(c; acc : Integer = 0|
        acc + c.parents->select(g|self.isInternal(g))->size());
--@end attribute helper IILN

--@begin helper PILN
--@comments Packages Inheritance Links Number
--@comments Number of inheritance relations between the current package and the one received as parameter.
helper context UML2!Package
def : PILN(p : UML2!Package) : Integer =
	self.IILN + self.EILN(p);
--@end helper PILN

--@begin helper ECLN
--@comments External Coupling Links Number
--@comments Number of coupling relations where the client Class belongs to the current Package and the supplier Class belongs to the Package ""p"" (excludes inheritance).
helper context UML2!Package
def : ECLN(p : UML2!Package) : Integer =
	self.supplierClassesInPackages(p)->size();
--@end helper ECLN

--@begin helper ICLN
--@comments Internal Coupling Links Number
--@comments Number of distinct coupling relations where both the client and the supplier Classes belong to the current Package (excludes inheritance).
helper context UML2!Package
def : ICLN() : Integer =
	self.internalSupplierClasses->size();
--@end helper ICLN

--@begin helper PCLN
--@comments Packages Coupling Links Number
--@comments Number of coupling relations between the current package and the one received as parameter.
helper context UML2!Package
def : PCLN(p : UML2!Package) : Integer =
	self.ICLN() + self.ECLN(p);
--@end helper PCLN

--@begin helper AVN
--@comments Attribute Visibility Number
--@comments Number of Classes in the considered Package where the Property can be accessed.
helper context UML2!Package
def : AVN(a : UML2!Property) : Integer =
	self.FVN(a);
--@end helper AVN

--@begin helper OVN
--@comments Operation Visibility Number
--@comments Number of Classes in the considered Package where the Operation can be accessed.
helper context UML2!Package
def : OVN(o : UML2!Operation) : Integer =
	self.FVN(o);
--@end helper OVN

--@begin helper FVN
--@comments Feature Visibility Number
--@comments Number of Classes in the considered Package where the Feature can be accessed.
helper context UML2!Package
def : FVN(f : UML2!Feature) : Integer =
	self.allClasses->iterate(c; acc : Integer = 0|
		if c.FCV(f)
			then acc + 1
			else acc
		endif);
--@end helper FVN

--@begin helper APV
--@comments Attribute to Package Visibility
--@comments Percentage of Classes in the considered Package where the Property can be accessed (excludes the Class where the Property is declared).
helper context UML2!Package
def : APV(a : UML2!Property) : Real =
	if self.CN() > 1
		then (self.AVN(a) - 1) / (self.CN() - 1)
		else 0
	endif;
--@end helper APV

--@begin helper OPV
--@comments Operation to Package Visibility
--@comments Percentage of Classes in the considered Package where the Operation can be accessed (excludes the class where the Operation is declared).
helper context UML2!Package
def : OPV(o : UML2!Operation) : Real =
	if self.CN() > 1
		then (self.OVN(o) - 1) / (self.CN() - 1)
		else 0
	endif;
--@end helper OPV

--@begin helper FPV
--@comments Feature to Package Visibility
--@comments Percentage of Classes in the considered Package where the Feature can be accessed (excludes the Class where the attribute is declared).
helper context UML2!Package
def : FPV(f : UML2!Feature) : Real =
	if self.CN() > 1
		then (self.FVN(f) - 1) / (self.CN() - 1)
		else 0
	endif;
--@end helper FPV",atlcompil atl name flame uml version domain uml flame metric author eric vepa evepa sodius com sodius www sodius com date descript this librari implement subset flame formal librari aid metric extract function appli uml model eclips uml project these function navig uml metamodel use metric librari see baroni a l formal definit object orient design metric master thesi vrije univers brussel belgium librari uml measur librari templat begin attribut helper coupledclass comment set classs current class coupl exclud inherit helper context uml class def coupledclass set uml class self allattributestyp union self allparameterstyp end attribut helper coupledclass begin attribut helper newfeatur comment sequenc featur declar current class this definit exclud inherit featur consequ exclud overridden featur helper context uml class def newfeatur sequenc uml featur self newattribut union self newoper end attribut helper newfeatur begin attribut helper definedfeatur comment sequenc featur declar class includ overridden featur helper context uml class def definedfeatur sequenc uml featur self definedattribut union self definedoper end attribut helper definedfeatur begin attribut helper directlyinheritedfeatur comment sequenc direct inherit featur helper context uml class def directlyinheritedfeatur sequenc uml featur self directlyinheritedattribut union self directlyinheritedoper end attribut helper directlyinheritedfeatur begin attribut helper allinheritedfeatur comment sequenc contain featur class inherit featur direct indirect helper context uml class def allinheritedfeatur sequenc uml featur self allinheritedattribut union self allinheritedoper end attribut helper allinheritedfeatur begin attribut helper overriddenfeatur comment sequenc redefin featur class helper context uml class def overriddenfeatur sequenc uml featur self overriddenattribut union self overriddenoper end attribut helper overriddenfeatur begin attribut helper allfeatur comment sequenc contain featur class inherit featur helper context uml class def allfeatur sequenc uml featur self allattribut union self alloper end attribut helper allfeatur begin attribut helper newattribut comment sequenc attribut declar current class helper context uml class def newattribut sequenc uml properti self definedattribut select da self allinheritedattribut collect ia ia name exclud da name end attribut helper newattribut begin attribut helper definedattribut comment sequenc properti declar class includ overridden properti helper context uml class def definedattribut sequenc uml properti self ownedattribut helper context uml packag def definedattribut sequenc uml properti self allclass collect c c definedattribut flatten end attribut helper definedattribut begin attribut helper directlyinheritedattribut comment sequenc direct inherit properti helper context uml class def directlyinheritedattribut sequenc uml properti self parent iter p acc sequenc uml properti sequenc acc union p newattribut end attribut helper directlyinheritedattribut begin attribut helper allinheritedattribut comment sequenc inherit properti direct indirect helper context uml class def allinheritedattribut sequenc uml properti self directlyinheritedattribut union self parent collect p p allinheritedattribut flatten end attribut helper allinheritedattribut begin attribut helper overriddenattribut comment sequenc redefin properti class helper context uml class def overriddenattribut sequenc uml properti self definedattribut select da self allinheritedattribut collect ia ia name includ da name end attribut helper overriddenattribut begin attribut helper allattribut comment sequenc contain properti class inherit properti direct indirect helper context uml class def allattribut sequenc uml properti self definedattribut union self allinheritedattribut reject ia self overriddenattribut collect oa oa name includ ia name helper context uml packag def allattribut sequenc uml properti self allclass collect c c allattribut flatten end attribut helper allattribut begin attribut helper allattributestyp comment set contain type attribtu class helper context uml class def allattributestyp set uml class self allattribut collect type flatten select oclistypeof uml class asset end attribut helper allattributestyp begin attribut helper newoper comment sequenc oper declar current class helper context uml class def newoper sequenc uml oper self definedoper select dop self allinheritedoper collect iop iop name exclud dop name end attribut helper newoper begin attribut helper definedoper comment sequenc oper declar class includ overridden oper helper context uml class def definedoper sequenc uml oper self ownedoper helper context uml packag def definedoper sequenc uml oper self allclass collect c c definedoper flatten end attribut helper definedoper begin attribut helper directlyinheritedoper comment sequenc direct inherit oper helper context uml class def directlyinheritedoper sequenc uml oper self parent iter p acc sequenc uml oper sequenc acc union p newoper end attribut helper directlyinheritedoper begin attribut helper allinheritedoper comment sequenc contain oper class inherit oper direct indirect helper context uml class def allinheritedoper sequenc uml oper self directlyinheritedoper union self parent collect p p allinheritedoper flatten end attribut helper allinheritedoper begin attribut helper overriddenoper comment sequenc redefin oper class helper context uml class def overriddenoper sequenc uml oper self definedoper select dop self allinheritedoper collect iop iop name includ dop name end attribut helper overriddenoper begin attribut helper alloper comment sequenc contain oper class inherit oper helper context uml class def alloper sequenc uml oper self definedoper union self allinheritedoper reject iop self overriddenoper collect oop oop name includ iop name helper context uml packag def alloper sequenc uml oper self allclass collect c c alloper flatten asset end attribut helper alloper begin attribut helper allparamet comment set contain paramet oper class helper context uml class def allparamet set uml paramet self alloper collect ownedparamet flatten select oclistypeof uml class asset end attribut helper allparamet begin attribut helper allparameterstyp comment set contain type paramet oper class helper context uml class def allparameterstyp set uml class self allparamet collect param param type flatten select oclistypeof uml class asset helper context uml oper def allparameterstyp set uml class self ownedparamet collect param param type flatten select oclistypeof uml class asset end attribut helper allparameterstyp begin attribut helper isroot comment indic whether class ascend a true valu indic ascend fals valu indic ascend helper context uml class def isroot boolean self parent isempti end attribut helper isroot begin attribut helper isleaf comment indic whether class descend a true valu indic descend fals valu indic descend helper context uml class def isleaf boolean self children isempti end attribut helper isleaf begin attribut helper children comment set direct deriv classs current class helper context uml class def children set uml class uml general allinst select g g general self collect g g specif exclud self asset end attribut helper children begin attribut helper descend comment set deriv classs direct indirect helper context uml class def descend set uml class self children iter c acc set uml class self children acc union c descend end attribut helper descend begin attribut helper parent comment set classs current class deriv direct helper context uml class def parent set uml class self general collect g g general exclud self asset end attribut helper parent begin attribut helper ascend comment set class current class deriv direct indirect helper context uml class def ascend set uml class self parent iter c acc set uml class self parent acc union c ascend end attribut helper ascend begin attribut helper client comment set contain direct client namedel helper context uml namedel def client set uml namedel comment refer supplierdepend exist uml metamodel use allinst instead self supplierdepend collect client flatten asset uml depend allinst select supplier includ self collect client flatten asset end attribut helper client begin attribut helper allclient comment set contain namedel client namedel includ client namedel this transit closur helper context uml namedel def allclient set uml namedel self client union self client collect ne ne allclient flatten asset end attribut helper allclient begin attribut helper content comment sequenc contain packageableel contain packag helper context uml packag def content sequenc uml packageableel self packagedel end attribut helper content begin attribut helper allclass comment sequenc class belong current packag helper context uml packag def allclass sequenc uml class self content select c c ocliskindof uml class end attribut helper allclass begin attribut helper internalbaseclass comment set base class current packag helper context uml packag def internalbaseclass set uml class self allclass iter c acc set uml class set acc union c parent end attribut helper internalbaseclass begin attribut helper internalsupplierclass comment set supplier class current packag helper context uml packag def internalsupplierclass set uml class self supplierclass self end attribut helper internalsupplierclass begin attribut helper owner comment this attribut helper includ flame librari comment the packag contain packag element helper context uml packageableel def owner uml packag let owner sequenc uml packag uml packag allinst select p p oclistypeof uml packag select p p content includ self owner notempti owner first els oclundefin endif end attribut helper owner begin helper aun comment attribut use number comment number namedel use properti exclud namedel properti declar helper context uml properti def aun integ self fun end helper aun begin helper fcv comment featur class visibl comment indic class access featur helper context uml class def fcv f uml featur boolean f visibl public self allfeatur includ f f visibl protect self ascend exist c c allfeatur includ f end helper fcv begin helper nan comment new attribut number comment number new properti belong class helper context uml class def nan integ self newattribut size end helper nan begin helper dan comment defin attribut number comment number defin properti class helper context uml class def dan integ self definedattribut size end helper dan begin helper ian comment inherit attribut number comment number inherit properti class helper context uml class def ian integ self allinheritedattribut size end helper ian begin helper oan comment overridden attribut number comment number overridden properti class helper context uml class def oan integ self overriddenattribut size end helper oan begin helper aan comment avail attribut number comment number properti class helper context uml class def aan integ self allattribut size end helper aan begin helper non comment new oper number comment number new oper class helper context uml class def non integ self newoper size end helper non begin helper don comment defin oper number comment number defin oper class helper context uml class def don integ self definedoper size end helper don begin helper ion comment inherit oper number comment number inherit oper class helper context uml class def ion integ self allinheritedoper size end helper ion begin helper oon comment overridden oper number comment number overridden oper class helper context uml class def oon integ self overriddenoper size end helper oon begin helper aon comment avail oper number comment number oper class helper context uml class def aon integ self alloper size end helper aon begin helper prian comment privat attribut number comment number privat properti class helper context uml class def prian integ self allattribut select visibl privat size end helper prian begin helper proan comment protect properti number comment number protect attribut class helper context uml class def proan integ self allattribut select visibl protect size end helper proan begin helper puban comment public properti number comment number public attribut class helper context uml class def puban integ self allattribut select visibl public size end helper puban begin helper prion comment privat oper number comment number privat oper class helper context uml class def prion integ self alloper select op op visibl privat size end helper prion begin helper proon comment protect oper number comment number protect oper class helper context uml class def proon integ self alloper select op op visibl protect size end helper proon begin helper pubon comment public oper number comment number public oper class helper context uml class def pubon integ self alloper select op op visibl public size end helper pubon begin helper fun comment featur use number comment number namedel use featur exclud namedel featur declar helper context uml featur def fun integ self allclient size end helper fun begin helper chin comment children number comment number direct deriv classs helper context uml class def chin integ self children size end helper chin begin helper desn comment descend number comment number deriv classs direct indirect helper context uml class def desn integ self descend size end helper desn begin helper parn comment parent number comment number classs current class deriv direct helper context uml class def parn integ self parent size end helper parn begin helper ascn comment ascend number comment number classs current class deriv direct indirect helper context uml class def ascn integ self ascend size end helper ascn begin helper oun comment oper use number comment number namedel use oper exclud namedel featur declar helper context uml oper def oun integ self fun end helper oun begin helper isintern comment indic class receiv paramet belong consid packag helper context uml packag def isintern c uml class boolean self content includ c end helper isintern begin helper baseclass comment set base class current packag belong packag p helper context uml packag def baseclass p uml packag set uml class self internalbaseclass select c p isintern c asset end helper baseclass begin helper baseclassesinpackag comment set base class current packag one bound paramet helper context uml packag def baseclassesinpackag p uml packag set uml class self internalbaseclass union p internalbaseclass end helper baseclassesinpackag begin helper supplierclass comment set supplier class current packag belong packag p exclud inherit helper context uml packag def supplierclass p uml packag set uml class self allclass iter c acc set uml class set acc union c coupledclass select c p isintern c asset end helper supplierclass begin helper supplierclassesinpackag comment set supplier class current packag one bound paramet helper context uml packag def supplierclassesinpackag p uml packag set uml class self internalsupplierclass union p internalsupplierclass end helper supplierclassesinpackag begin helper relatedclass comment set class p packag either base supplier class helper context uml packag def relatedclass p uml packag set uml class self baseclass p union self supplierclass p end helper relatedclass begin helper cn comment class number comment number class packag helper context uml packag def cn integ self allclass size end helper cn begin helper pnan comment packag new attribut number comment number new properti packag helper context uml packag def pnan integ self allclass iter c acc integ acc c nan end helper pnan begin helper pdan comment packag defin attribut number comment number defin properti packag helper context uml packag def pdan integ self allclass iter c acc integ acc c dan end helper pdan begin helper pian comment packag inherit attribut number comment number properti inherit packag helper context uml packag def pian integ self allclass iter c acc integ acc c ian end helper pian begin helper poan comment packag overridden attribut number comment number overridden properti packag helper context uml packag def poan integ self allclass iter c acc integ acc c oan end helper poan begin helper paan comment packag avail attribut number comment number avail properti packag helper context uml packag def paan integ self allclass iter c acc integ acc c aan end helper paan begin helper pnon comment packag new oper number comment number new oper packag helper context uml packag def pnon integ self allclass iter c acc integ acc c non end helper pnon begin helper pdon comment packag defin oper number comment number defin oper packag helper context uml packag def pdon integ self allclass iter c acc integ acc c don end helper pdon begin helper pion comment packag inherit oper number comment number inherit oper packag helper context uml packag def pion integ self allclass iter c acc integ acc c ion end helper pion begin helper poon comment packag overridden oper number comment number overridden oper packag helper context uml packag def poon integ self allclass iter c acc integ acc c oon end helper poon begin helper paon comment packag avail oper number comment number avail oper packag helper context uml packag def paon integ self allclass iter c acc integ acc c aon end helper paon begin helper eiln comment extern inherit link number comment number inherit relat deriv class belong current packag base one belong packag p given paramet helper context uml packag def eiln p uml packag integ self allclass iter c acc integ acc c parent select g p isintern g size end helper eiln begin attribut helper iiln comment intern inherit link number comment number inherit relat base deriv class belong current packag helper context uml packag def iiln integ self allclass iter c acc integ acc c parent select g self isintern g size end attribut helper iiln begin helper piln comment packag inherit link number comment number inherit relat current packag one receiv paramet helper context uml packag def piln p uml packag integ self iiln self eiln p end helper piln begin helper ecln comment extern coupl link number comment number coupl relat client class belong current packag supplier class belong packag p exclud inherit helper context uml packag def ecln p uml packag integ self supplierclassesinpackag p size end helper ecln begin helper icln comment intern coupl link number comment number distinct coupl relat client supplier class belong current packag exclud inherit helper context uml packag def icln integ self internalsupplierclass size end helper icln begin helper pcln comment packag coupl link number comment number coupl relat current packag one receiv paramet helper context uml packag def pcln p uml packag integ self icln self ecln p end helper pcln begin helper avn comment attribut visibl number comment number class consid packag properti access helper context uml packag def avn uml properti integ self fvn end helper avn begin helper ovn comment oper visibl number comment number class consid packag oper access helper context uml packag def ovn uml oper integ self fvn end helper ovn begin helper fvn comment featur visibl number comment number class consid packag featur access helper context uml packag def fvn f uml featur integ self allclass iter c acc integ c fcv f acc els acc endif end helper fvn begin helper apv comment attribut packag visibl comment percentag class consid packag properti access exclud class properti declar helper context uml packag def apv uml properti real self cn self avn self cn els endif end helper apv begin helper opv comment oper packag visibl comment percentag class consid packag oper access exclud class oper declar helper context uml packag def opv uml oper real self cn self ovn self cn els endif end helper opv begin helper fpv comment featur packag visibl comment percentag class consid packag featur access exclud class attribut declar helper context uml packag def fpv f uml featur real self cn self fvn f self cn els endif end helper fpv,14
215,215,P93-MOOD4UML2.atl,"--@atlcompiler	atl2006
--@name			MOOD4UML2
--@version		1.0
--@domains		UML2, MOOD, MOOD2, metrics
--@authors		Eric Vepa (evepa <at> sodius.com) for SODIUS (www.sodius.com)
--@date			2007/06/05
--@description	This library provides MOOD (Metrics for Object-Oriented Design) and MOOD2 metrics suites on UML2 models (from Eclipse UML2 Project). The models have been extracted from Jar files using the Eclipse plug-in Jar2UML. Only the metrics that fit to UML2 models have been implemented.
--@see			Baroni, A.L.: Formal Definition of Object-Oriented Design Metrics. Master Thesis, Vrije University, Brussel, Belgium, 2002.

library MOOD4UML2; -- Library Template

-- ============================================================
-- MOOD and MOOD2 Metrics : Intra-Specification Level Metrics =
-- ============================================================

--@begin helper MOOD::AIF
--@comments Attributes Inheritance Factor
--@comments Quotient between the number of inherited Properties in all Classes of the Package and the number of available Properties (locally defined plus inherited) for all Classes of the current Package.
--@comments The pre-condition states that the package must have available Properties.
--@comments AIF() = 0 means that there is no effective Property inheritance (either there are no inheritance hierarchies or all inherited Properties are redefined).
helper context UML2!Package
def : AIF() : Real =
	if self.PAAN() > 0
		then self.PIAN() / self.PAAN()
		else 0
	endif;
--@end helper MOOD::AIF

--@begin helper MOOD::OIF
--@comments Operations Inheritance Factor
--@comments Quotient between the number of inherited Operations in all Classes of the Package and the number of available Operations (locally defined plus inherited) for all Classes of the current Package.
--@comments The pre-condition states that the package must have available Operations.
--@comments OIF() = 0 means that there is no effective Operation inheritance (either there are no inheritance hierarchies or all inherited Operations are redefined).
helper context UML2!Package
def : OIF() : Real =
	if self.PAON() > 0
		then self.PION() / self.PAON()
		else 0
	endif;
--@end helper MOOD::OIF

--@begin helper MOOD2::IIF
--@comments Internal Inheritance Factor
--@comments Quotient between the number of inheritance links where both the base and derived Classes belong to the current Package and the total number of inheritance links originating in the current Package.
--@comments The pre-condition states that the package must have some inheritance links defined on it.
--@comments Inheritance links originating in the current package are those where the derived Class belongs to it.
--@comments The inheritance link is directed from the derived Class to the base one.
helper context UML2!Package
def : IIF() : Real =
	if self.IILN > 0
		then self.IILN / self.PILN(self)
		else 0
	endif;
--@end helper MOOD2::IIF

--@begin helper MOOD::AHF
--@comments Attributes Hiding Factor
--@comments Quotient between the sum of the invisibilities of all Properties defined in all Classes in the current Package and the total number of Properties defined in the Package.
--@comments The invisibility of an Property is the percentage of the Classes in the package from which this Properties is not visible and is given by 1-APV( self ), where self is the current Package.
--@comments If all Properties are private, the numerator is 0 and as such, AHF() = 0.
--@comments If all Properties are public, the numerator is 0 and as such, AHF() = 1.
--@comments The pre-condition regarding the number of Classes is required for calculating the Properties visibility (the package must have some Classes).
--@comments The second pre-condition means that Properties are necessary for calculating the metric.
helper context UML2!Package
def : AHF() : Real =
	if self.CN() > 1
		then if self.PDAN() > 0
				then self.definedAttributes->iterate(a; acc : Real = 0|
					acc + 1 - self.APV(a)) / self.PDAN()
				else 0
			endif
		else 0
	endif;
--@end helper MOOD::AHF

--@begin helper MOOD::OHF
--@comments Operations Hiding Factor
--@comments Quotient between the sum of the invisibilities of all Operations defined in all Classes in the current Package and the total number of Operations defined in the Package.
--@comments The invisibility of an Operation is the percentage of the total Classes in the package from which this Operation is not visible and is given by 1-OPV( self ), where self is the current package.
--@comments If all Operations are public the numerator equals the denominator and then OHF() = 1.
--@comments Otherwise, if all Operations are private, OHF() = 0.
--@comments The pre-condition regarding the number of Classes is required for calculating the Operations visibility (the package must have some Classes).
--@comments The second pre-condition means that Operations are necessary for calculating the metric.
helper context UML2!Package
def : OHF() : Real =
	if self.CN() > 1
		then if self.PDON() > 0
				then self.definedOperations->iterate(o; acc : Real = 0|
					acc + 1 - self.OPV(o)) / self.PDON()
				else 0
			endif
		else 0
	endif;
--@end helper MOOD::OHF

--@begin helper MOOD2::AHEF
--@comments Attributes Hiding Effectiveness Factor
--@comments Quotient between the cumulative number of the Package Classes that do access the Package Properties and the cumulative number of the Package Classes that can access the Package Properties.
helper context UML2!Package
def : AHEF() : Real =
	let avnSum : Integer =
		self.allAttributes->iterate(a; acc : Integer = 0|
			acc + self.AVN(a)) in
	if avnSum > 0
		then self.allAttributes->iterate(a; acc : Integer = 0|
			acc + a.AUN()) / avnSum
		else 0
	endif;
--@end helper MOOD2::AHEF

--@begin helper MOOD2::OHEF
--@comments Operations Hiding Effectiveness Factor 
--@comments Quotient between the cumulative number of the Package Classes that do access the Package Operations and the cumulative number of the Package Classes that can access the Package Operations.
helper context UML2!Package
def : OHEF() : Real =
	let ovnSum : Integer =
		self.allOperations->iterate(op; acc : Integer = 0|
			acc + self.OVN(op)) in
	if ovnSum > 0
		then self.allOperations->iterate(op; acc : Integer = 0|
			acc + op.OUN()) / ovnSum
		else 0
	endif;
--@end helper MOOD2::OHEF

--@begin helper MOOD::BPF
--@comments Behavioral Polymorphism Factor
--@comments Quotient between the actual number of possible different polymorphic situations within the current Package and the maximum number of possible distinct polymorphic situations (due to inheritance).
--@comments An Operation in a Class Ci can have as many shapes (""morphos"" in ancient Greek) as the number of times it is overridden (in Ci descendants).
--@comments This represents the actual number of, possible different, polymorphic situations for that Class (For this metric, the overriding of Operations is considered only when defined in the current package).
--@comments The maximum number of possible distinct polymorphic situations for Class Ci occurs if all new Operations defined in it are overridden in all of their derived Classes.
helper context UML2!Package
def : BPF() : Real =
	if self.PAON() > 0
		then self.POON() / self.PAON()
		else 0
	endif;
--@end helper MOOD::BPF

--@begin helper MOOD::CCF
--@comments Parametric Polymorphism Factor
--@comments Quotient between the actual number of coupled class-pairs within the Package and the maximum possible number of class-pair couplings in the Package. This coupling is the one not imputable to inheritance.
--@comments In a coupled class-pair one Class is the client and the other is the supplier.
--@comments These clientsupplier relations can have several shapes; see the function Class::CoupledClasses for details.
--@comments The pre-condition states that, with only one Class, there are no couplings within the package.
--@comments The square root counteracts for the fact that the couplings grow quadratically with the number of Classes.
helper context UML2!Package
def : CCF() : Real =
	if self.CN() > 1
		then (self.ICLN() / (self.CN() * self.CN() - self.CN())).sqrt()
		else 0
	endif;
--@end helper MOOD::CCF

--@begin helper MOOD::ICF
--@comments Internal Coupling Factor
--@comments Quotient between the number of coupling links where both the client and supplier Classes belong to the current Package and the total number of coupling links originating in the current Package.
--@comments Coupling links originating in the current Package are those where the client Class belongs to it.
--@comments The coupling link is directed from the client Class to the supplier one.
helper context UML2!Package
def : ICF() : Real =
	if self.ICLN() > 0
		then self.ICLN() / self.PCLN(self)
		else 0
	endif;
--@end helper MOOD::ICF
",atlcompil atl name mood uml version domain uml mood mood metric author eric vepa evepa sodius com sodius www sodius com date descript this librari provid mood metric object orient design mood metric suit uml model eclips uml project the model extract jar file use eclips plug jar uml onli metric fit uml model implement see baroni a l formal definit object orient design metric master thesi vrije univers brussel belgium librari mood uml librari templat mood mood metric intra specif level metric begin helper mood aif comment attribut inherit factor comment quotient number inherit properti class packag number avail properti local defin plus inherit class current packag comment the pre condit state packag must avail properti comment aif mean effect properti inherit either inherit hierarchi inherit properti redefin helper context uml packag def aif real self paan self pian self paan els endif end helper mood aif begin helper mood oif comment oper inherit factor comment quotient number inherit oper class packag number avail oper local defin plus inherit class current packag comment the pre condit state packag must avail oper comment oif mean effect oper inherit either inherit hierarchi inherit oper redefin helper context uml packag def oif real self paon self pion self paon els endif end helper mood oif begin helper mood iif comment intern inherit factor comment quotient number inherit link base deriv class belong current packag total number inherit link origin current packag comment the pre condit state packag must inherit link defin comment inherit link origin current packag deriv class belong comment the inherit link direct deriv class base one helper context uml packag def iif real self iiln self iiln self piln self els endif end helper mood iif begin helper mood ahf comment attribut hide factor comment quotient sum invis properti defin class current packag total number properti defin packag comment the invis properti percentag class packag properti visibl given apv self self current packag comment if properti privat numer ahf comment if properti public numer ahf comment the pre condit regard number class requir calcul properti visibl packag must class comment the second pre condit mean properti necessari calcul metric helper context uml packag def ahf real self cn self pdan self definedattribut iter acc real acc self apv self pdan els endif els endif end helper mood ahf begin helper mood ohf comment oper hide factor comment quotient sum invis oper defin class current packag total number oper defin packag comment the invis oper percentag total class packag oper visibl given opv self self current packag comment if oper public numer equal denomin ohf comment otherwis oper privat ohf comment the pre condit regard number class requir calcul oper visibl packag must class comment the second pre condit mean oper necessari calcul metric helper context uml packag def ohf real self cn self pdon self definedoper iter acc real acc self opv self pdon els endif els endif end helper mood ohf begin helper mood ahef comment attribut hide effect factor comment quotient cumul number packag class access packag properti cumul number packag class access packag properti helper context uml packag def ahef real let avnsum integ self allattribut iter acc integ acc self avn avnsum self allattribut iter acc integ acc aun avnsum els endif end helper mood ahef begin helper mood ohef comment oper hide effect factor comment quotient cumul number packag class access packag oper cumul number packag class access packag oper helper context uml packag def ohef real let ovnsum integ self alloper iter op acc integ acc self ovn op ovnsum self alloper iter op acc integ acc op oun ovnsum els endif end helper mood ohef begin helper mood bpf comment behavior polymorph factor comment quotient actual number possibl differ polymorph situat within current packag maximum number possibl distinct polymorph situat due inherit comment an oper class ci mani shape morpho ancient greek number time overridden ci descend comment this repres actual number possibl differ polymorph situat class for metric overrid oper consid defin current packag comment the maximum number possibl distinct polymorph situat class ci occur new oper defin overridden deriv class helper context uml packag def bpf real self paon self poon self paon els endif end helper mood bpf begin helper mood ccf comment parametr polymorph factor comment quotient actual number coupl class pair within packag maximum possibl number class pair coupl packag this coupl one imput inherit comment in coupl class pair one class client supplier comment these clientsuppli relat sever shape see function class coupledclass detail comment the pre condit state one class coupl within packag comment the squar root counteract fact coupl grow quadrat number class helper context uml packag def ccf real self cn self icln self cn self cn self cn sqrt els endif end helper mood ccf begin helper mood icf comment intern coupl factor comment quotient number coupl link client supplier class belong current packag total number coupl link origin current packag comment coupl link origin current packag client class belong comment the coupl link direct client class supplier one helper context uml packag def icf real self icln self icln self pcln self els endif end helper mood icf,14
216,216,P93-QMOOD4UML2.atl,"--@atlcompiler	atl2006
--@name			QMOOD4UML2
--@version		1.0
--@domains		UML2, QMOOD, metrics
--@authors		Eric Vepa (evepa <at> sodius.com) for SODIUS (www.sodius.com)
--@date			2007/06/05
--@description	This library provides QMOOD (Quality Model for Object-Oriented Design) metrics suite on UML2 models (from Eclipse UML2 Project). The models have been extracted from Jar files using the Eclipse plug-in Jar2UML. Only the metrics that fit to UML2 models have been implemented.
--@see			Baroni, A.L.: Formal Definition of Object-Oriented Design Metrics. Master Thesis, Vrije University, Brussel, Belgium, 2002.

library QMOOD4UML2; -- Library Template

uses FLAME4UML2;

-- ===============
-- QMOOD Metrics =
-- ===============

--@begin helper QMOOD::DSC
--@comments Design Size in Classes
--@comments Count of the total number of Classes in the design.
helper context UML2!Package
def : DSC() : Integer =
	self.CN();
--@end helper QMOOD::DSC

--@begin helper QMOOD::NOH
--@comments Number of Hierarchies
--@comments Count of the number of Class hierarchies in the design.
--@comments In [Abreu et al., 2000], this metric has another interpretation.
--@comments  There, hierarchies are not the number of inheritance relations but the number of inheritance trees.
--@comments  In this case, this metric is always equal to 1 for systems developed in languages that have a common super class (like Object in Smalltalk and Java).
--@comments  This case shows that the metric is centered in the language, which is considered as a potential problem (Remember QMOOD metrics were created based upon C++). 
helper context UML2!Package
def : NOH() : Integer =
	self.allClasses->collect(c|c.children)->flatten()->asSet()->size();
--@end helper QMOOD::NOH

--@begin helper QMOOD::NIC
--@comments Number of Independent Classes
--@comments Count of the number of Classes that are not inherited by any Class in the design.
helper context UML2!Package
def : NIC() : Integer =
	self.allClasses->select(c|c.isLeaf)->size();
--@end helper QMOOD::NIC

--@begin helper QMOOD::NSI
--@comments Number of Single Inheritance
--@comments Number of Classes (sub classes) that use inheritance in the design.
--@comments According to [Abreu et al., 2000], for the same reason than in NOH, this metric would be always equal to DSC (if the Classes belonging to the development environment were considered) or to DSC â 1 (in the opposite case).
--@comments This is another signal of language dependency.
helper context UML2!Package
def : NSI() : Integer =
	self.allClasses->iterate(c; acc : Integer = 0|
		if c.PARN() = 1
			then acc + 1
			else acc
		endif);
--@end helper QMOOD::NSI

--@begin helper QMOOD::NNC
--@comments Number of Internal Classes
--@comments Count of the number of internal Classes defined for creating generalization-specialization structures in Class hierarchies of the design.
--@comments In this case, why to have the same value than NOH? Has this metric another interpretation? [Abreu et al., 2000] say that this metric is always equal to DSC or DSC -1, by the reasons pointed out in NOH and NSI.
helper context UML2!Package
def : NNC() : Integer =
	self.NOH();
--@end helper QMOOD::NNC

--@begin helper QMOOD::NAC
--@comments Number of Abstract Classes
--@comments Count of the number of Classes that have been defined purely for organizing information in the design.
helper context UML2!Package
def : NAC() : Integer =
	self.allClasses->select(c|c.isAbstract)->size();
--@end helper QMOOD::NAC

--@begin helper QMOOD::NLC
--@comments Number of Leaf Classes
--@comments Count of the number of leaf Classes in the hierarchies of the design.
--@comments This metric is the same than NIC, defined above.
helper context UML2!Package
def : NLC() : Integer =
	self.allClasses->select(c|c.isLeaf)->size();
--@end helper QMOOD::NLC

--@begin helper QMOOD::ADI
--@comments Average Depth of Inheritance
--@comments The average depth of inheritance of Classes in the design. It is computed by dividing the summation of maximum path lengths to all Classes by the number of Classes. The path length for a Class is the number of edges from the root to the Class in an inheritance tree representation. 
helper context UML2!Package
def : ADI() : Real =
	self.allClasses->iterate(c; acc : Real = 0|(acc + c.DIT()) / self.CN());
--@end helper QMOOD::ADI

--@begin helper QMOOD::AWI
--@comments Average Width of Inheritance
--@comments The average number of children per Class in the design. The metric is computed by dividing the summation of the number of children over all Classes by the number of Classes in the design.
--@comments Accordingly to a different view point, [Abreu et al., 2000] say this metric is always equal to DSC or DSC - 1, when multiple inheritance is not supported by the language, as in Smalltalk, Eiffel or Java. The same happens with NOH, NSI and NNC.
helper context UML2!Package
def : AWI() : Real =
	self.allClasses->iterate(c; acc : Real = 0|(acc + c.CHIN()) / self.CN());
--@end helper QMOOD::AWI

--@begin helper QMOOD::ANA
--@comments Average Number of Ancestors
--@comments The average number of Classes from which a class inherits information.
--@comments This metric is similar to the ADI measure and differs only when there are instances of multiple inheritance in the design.
helper context UML2!Package
def : ANA() : Real =
	if self.CN() > 0
		then self.internalBaseClasses->size() / self.CN()
		else 0
	endif;
--@end helper QMOOD::ANA

--@comments This metrics is not used because result can be negative.
--@begin helper QMOOD::MFM
--@comments Measure of Functional Modularity
--@comments Computes modularity based on the deviation of the number of Methods in a Class from the average number of Methods per Class in the design.
--@comments A value closer than zero is preferred for this metric. A lower value indicates a smaller deviation among Classes in the number of services provided.
--helper context UML2!Class
--def : MFM() : Integer =
--	let owner : UML2!Package = self.owner in
--	if not owner.oclIsUndefined()
--		then if owner.CN() > 0
--				then if owner.PAON() / owner.CN() > 0
--						then (self.allOperations->size() -
--							  (owner.PAON() / owner.CN())) /
--							  	(owner.PAON() / owner.CN())
--						else 0
--					endif
--				else 0
--			endif
--		else 0
--	endif;
--@end helper QMOOD::MFM

--@begin helper QMOOD::MFA
--@comments Measure of Functional Abstraction
--@comments The ratio of the number of Methods inherited by a class to the total number of Methods accessible by members in the Class.
--@comments In order to calculate MFA, the number of Operations must be greater than zero.
helper context UML2!Class
def : MFA() : Integer =
	if self.AON() > 0
		then self.ION() / self.allOperations->iterate(o; acc : Integer = 0|
			if self.FCV(o)
				then acc + 1
				else acc
			endif)
		else 0
	endif;
--@end helper QMOOD::MFA

--@begin helper QMOOD::MAA
--@comments Measure of Attribute Abstraction
--@comments The ratio of the number of Attributes inherited by a Class to the total number of Attributes in the Class.
--@comments In order to calculate MAA, number of attributes must be greater than zero.
helper context UML2!Class
def : MAA() : Integer =
	let nbFCV : Integer =
		self.allAttributes->iterate(a; acc : Integer = 0|
			if self.FCV(a)
				then acc + 1
				else acc
			endif) in
	if nbFCV > 0
		then self.IAN() / nbFCV
		else 0
	endif;
--@end helper QMOOD::MAA

--@begin helper QMOOD::MAT
--@comments Measure of Abstraction
--@comments The average of functional and attribute abstraction measures.
helper context UML2!Class
def : MAT() : Integer =
	(self.MFA() + self.MAA()) / 2;
--@end helper QMOOD::MAT

--@begin helper QMOOD::MOA
--@comments Measure of Aggregation
--@comments Count of the number of data declarations whose types are user defined Classes.
helper context UML2!Class
def : MOA() : Integer =
	let owner : UML2!Package = self.owner in
	if not owner.oclIsUndefined()
		then self.allAttributes->iterate(a; acc: Integer = 0|
			if owner.allClasses->includes(a.type)
				then acc + 1
				else acc
			endif)
		else 0
	endif;
--@end helper QMOOD::MOA

--@begin helper QMOOD::MRM
--@comments Modeled Relationship Measure
--@comments Measure of the total number of Attribute and Parameter based relationships in a Class.
helper context UML2!Class
def : MRM() : Integer =
	self.DCC() + self.NAD();
--@end helper QMOOD::MRM

--@begin helper QMOOD::DAM
--@comments Data Access Metric
--@comments The ratio of the number of private Attributes to the total number of Attributes declared in a Class.
--@comments A high value of DAM is desired. The pre-condition states that the Class must have Attributes.
helper context UML2!Class
def : DAM() : Integer =
	if self.AAN() > 0
		then self.PRIAN() / self.AAN()
		else 0
	endif;
--@end helper QMOOD::DAM

--@begin helper QMOOD::OAM
--@comments Operation Access Metric
--@comments The ratio of the number of public Methods to the total number of Methods declared in the Class.
--@comments A high value for OAM is desired. The pre-condition states that the Class must have Operations.
helper context UML2!Class
def : OAM() : Integer =
	if self.AON() > 0
		then self.PUBON() / self.AON()
		else 0
	endif;
--@end helper QMOOD::OAM

--@begin helper QMOOD::MAM
--@comments Member Access Metric
--@comments This metric computes the access to all the members (Attributes and Methods) of a Class.
--@comments A high value for MAM is desired.
helper context UML2!Class
def : MAM() : Integer =
	((1 - self.DAM()) + self.OAM()) / 2;
--@end helper QMOOD::MAM

--@begin helper QMOOD::NOA
--@comments Number of Ancestors
--@comments Counts the number of distinct Classes which a Class inherits.
helper context UML2!Class
def : NOA() : Integer =
	self.ASCN();
--@end helper QMOOD::NOA

--@begin helper QMOOD::NOM
--@comments Number of Methods
--@comments Count of all the Methods defined in a Class.
helper context UML2!Class
def : NOM() : Integer =
	self.AON();
--@end helper QMOOD::NOM

--@begin helper QMOOD::CIS
--@comments Class Interface Size
--@comments Number of public Methods in a Class.
helper context UML2!Class
def : CIS() : Integer =
	self.PUBON();
--@end helper QMOOD::CIS

--@begin helper QMOOD::NPT
--@comments Number of Unique Parameter Types
--@comments Number of different Parameter types used in the Methods of the Class.
helper context UML2!Class
def : NPT() : Integer =
	self.allParametersTypes->size();
--@end helper QMOOD::NPT

--@begin helper QMOOD::NPM
--@comments Number of Parameters per Method
--@comments Average of the number of Parameters per Method in the Class. Computed by summing the Parameters of all Methods and dividing by the number of Methods in the Class.
--@comments The pre-condition states the Class must have some Operations.
helper context UML2!Class
def : NPM() : Integer =
	if self.AON() > 0
		then self.allParameters->size() / self.AON()
		else 0
	endif;
--@end helper QMOOD::NPM

--@begin helper QMOOD::NOD
--@comments Number of Attributes
--@comments Number of Attributes in the Class.
helper context UML2!Class
def : NOD() : Integer =
	self.AAN();
--@end helper QMOOD::NOD

--@begin helper QMOOD::NAD
--@comments Number of Abstract Data Types
--@comments Number of user defined objects (ADTs) used as Attributes in the Class and which are necessary to instantiate an object instance of the (aggregate) Class.
helper context UML2!Class
def : NAD() : Integer =
	self.allAttributesTypes->size();
--@end helper QMOOD::NAD

--@begin helper QMOOD::NPA
--@comments Number of Public Attributes
--@comments Number of Attributes that are declared as public in the Class.
helper context UML2!Class
def : NPA() : Integer =
	self.PUBAN();
--@end helper QMOOD::NPA

--@begin helper QMOOD::CSM
--@comments Class Size Metric
--@comments Sum of the number of Methods and Attributes in the Class.
helper context UML2!Class
def : CSM() : Integer =
	self.AAN() + self.AON();
--@end helper QMOOD::CSM

--@begin helper QMOOD::CAM
--@comments Cohesion Among Methods of Class
--@comments Computes the relatedness among Methods of the Class based upon the Parameter list of the Methods.
--@comments The metrics is computed using the summation of the intersection of Parameters of a Method with the maximum independent set of all Parameter types in the Class.
helper context UML2!Class
def : CAM() : Integer =
	let divisor : Integer =
		self.AON() * self.allParametersTypes->size() in
	if divisor > 0
		then self.allOperations->iterate(o; acc : Integer = 0|
			acc + o.allParametersTypes->size()) / divisor
		else 0
	endif;
--@end helper QMOOD::CAM

--@begin helper QMOOD::DCC
--@comments Direct Class Coupling
--@comments Count of the different number of Classes that a Class is directly related to. The metric includes Classes that are directly related by Attribute declarations and message passing (Parameters) in Methods.
helper context UML2!Class
def : DCC() : Integer =
	self.allAttributesTypes->union(self.allParametersTypes)->size();
--@end helper QMOOD::DCC

--@begin helper QMOOD::MCC
--@comments Maximum Class Coupling
--@comments This metric not only includes Classes that are directly related to a Class by Attributes and Methods, but also Classes that are indirectly related through the directly related Classes.
helper context UML2!Class
def : MCC() : Integer =
	self.allAttributesTypes->union(self.allParametersTypes)->
		iterate(t; acc : Sequence(UML2!Class) = Sequence{}|
			acc->union(t.allAttributesTypes)->union(t.allParametersTypes))->
				asSet()->size();
--@end helper QMOOD::MCC

--@begin helper QMOOD::DAC
--@comments Direct Attribute Based Coupling
--@comments This metric is a direct count of the number of different Class types that are declared as Attribute references inside a Class.
helper context UML2!Class
def : DAC() : Integer =
	self.allAttributesTypes->size();
--@end helper QMOOD::DAC

--@begin helper QMOOD::DPC
--@comments Direct Parameter Based Coupling
--@comments Number of Class object types that are required directly for a message passing (Parameters) to Methods in the Class.
helper context UML2!Class
def : DPC() : Integer =
	self.allParametersTypes->size();
--@end helper QMOOD::DPC

--@begin helper QMOOD::MPC
--@comments Maximum Parameter Based Coupling
--@comments Number of Class object types that are required directly and indirectly for message passing (Parameters) in the Class.
helper context UML2!Class
def : MPC() : Integer =
	self.allParametersTypes->
		iterate(t; acc : Sequence(UML2!Class) = Sequence{}|
			acc->union(t.allParametersTypes))->asSet()->size();
--@end helper QMOOD::MPC

--@begin helper QMOOD::CCD
--@comments Class Complexity Based on Data
--@comments Computes complexity based upon the number of components (Attributes) that are defined in the Class.
--@comments All component declarations are resolved to the basic primitives (integers, doubles and characters).
--@comments The metric value is a count of the number of primitives.
helper context UML2!Class
def : CCD() : Integer =
	self.AAN() + self.allAttributesTypes->iterate(t; acc : Integer = 0|
			acc + t.AAN());
--@end helper QMOOD::CCD

--@begin helper QMOOD::CCP
--@comments Class Complexity Based on Method Parameters
--@comments Estimates complexity based upon the number of Parameters required to call Methods of the Class.
--@comments Inherited Method Parameters are also included in the computation of the metric value.
helper context UML2!Class
def : CCP() : Integer =
	self.allParameters->size();
--@end helper QMOOD::CCP

--@begin helper QMOOD::CCM
--@comments Class Complexity Based on Members
--@comments This metric is an aggregate of the data and method Parameter complexities.
helper context UML2!Class
def : CCM() : Integer =
	self.CCD() + self.CCP();
--@end helper QMOOD::CCM",atlcompil atl name qmood uml version domain uml qmood metric author eric vepa evepa sodius com sodius www sodius com date descript this librari provid qmood qualiti model object orient design metric suit uml model eclips uml project the model extract jar file use eclips plug jar uml onli metric fit uml model implement see baroni a l formal definit object orient design metric master thesi vrije univers brussel belgium librari qmood uml librari templat use flame uml qmood metric begin helper qmood dsc comment design size class comment count total number class design helper context uml packag def dsc integ self cn end helper qmood dsc begin helper qmood noh comment number hierarchi comment count number class hierarchi design comment in abreu et al metric anoth interpret comment there hierarchi number inherit relat number inherit tree comment in case metric alway equal system develop languag common super class like object smalltalk java comment this case show metric center languag consid potenti problem rememb qmood metric creat base upon c helper context uml packag def noh integ self allclass collect c c children flatten asset size end helper qmood noh begin helper qmood nic comment number independ class comment count number class inherit class design helper context uml packag def nic integ self allclass select c c isleaf size end helper qmood nic begin helper qmood nsi comment number singl inherit comment number class sub class use inherit design comment accord abreu et al reason noh metric would alway equal dsc class belong develop environ consid dsc opposit case comment this anoth signal languag depend helper context uml packag def nsi integ self allclass iter c acc integ c parn acc els acc endif end helper qmood nsi begin helper qmood nnc comment number intern class comment count number intern class defin creat general special structur class hierarchi design comment in case valu noh has metric anoth interpret abreu et al say metric alway equal dsc dsc reason point noh nsi helper context uml packag def nnc integ self noh end helper qmood nnc begin helper qmood nac comment number abstract class comment count number class defin pure organ inform design helper context uml packag def nac integ self allclass select c c isabstract size end helper qmood nac begin helper qmood nlc comment number leaf class comment count number leaf class hierarchi design comment this metric nic defin helper context uml packag def nlc integ self allclass select c c isleaf size end helper qmood nlc begin helper qmood adi comment averag depth inherit comment the averag depth inherit class design it comput divid summat maximum path length class number class the path length class number edg root class inherit tree represent helper context uml packag def adi real self allclass iter c acc real acc c dit self cn end helper qmood adi begin helper qmood awi comment averag width inherit comment the averag number children per class design the metric comput divid summat number children class number class design comment accord differ view point abreu et al say metric alway equal dsc dsc multipl inherit support languag smalltalk eiffel java the happen noh nsi nnc helper context uml packag def awi real self allclass iter c acc real acc c chin self cn end helper qmood awi begin helper qmood ana comment averag number ancestor comment the averag number class class inherit inform comment this metric similar adi measur differ instanc multipl inherit design helper context uml packag def ana real self cn self internalbaseclass size self cn els endif end helper qmood ana comment this metric use result negat begin helper qmood mfm comment measur function modular comment comput modular base deviat number method class averag number method per class design comment a valu closer zero prefer metric a lower valu indic smaller deviat among class number servic provid helper context uml class def mfm integ let owner uml packag self owner owner oclisundefin owner cn owner paon owner cn self alloper size owner paon owner cn owner paon owner cn els endif els endif els endif end helper qmood mfm begin helper qmood mfa comment measur function abstract comment the ratio number method inherit class total number method access member class comment in order calcul mfa number oper must greater zero helper context uml class def mfa integ self aon self ion self alloper iter acc integ self fcv acc els acc endif els endif end helper qmood mfa begin helper qmood maa comment measur attribut abstract comment the ratio number attribut inherit class total number attribut class comment in order calcul maa number attribut must greater zero helper context uml class def maa integ let nbfcv integ self allattribut iter acc integ self fcv acc els acc endif nbfcv self ian nbfcv els endif end helper qmood maa begin helper qmood mat comment measur abstract comment the averag function attribut abstract measur helper context uml class def mat integ self mfa self maa end helper qmood mat begin helper qmood moa comment measur aggreg comment count number data declar whose type user defin class helper context uml class def moa integ let owner uml packag self owner owner oclisundefin self allattribut iter acc integ owner allclass includ type acc els acc endif els endif end helper qmood moa begin helper qmood mrm comment model relationship measur comment measur total number attribut paramet base relationship class helper context uml class def mrm integ self dcc self nad end helper qmood mrm begin helper qmood dam comment data access metric comment the ratio number privat attribut total number attribut declar class comment a high valu dam desir the pre condit state class must attribut helper context uml class def dam integ self aan self prian self aan els endif end helper qmood dam begin helper qmood oam comment oper access metric comment the ratio number public method total number method declar class comment a high valu oam desir the pre condit state class must oper helper context uml class def oam integ self aon self pubon self aon els endif end helper qmood oam begin helper qmood mam comment member access metric comment this metric comput access member attribut method class comment a high valu mam desir helper context uml class def mam integ self dam self oam end helper qmood mam begin helper qmood noa comment number ancestor comment count number distinct class class inherit helper context uml class def noa integ self ascn end helper qmood noa begin helper qmood nom comment number method comment count method defin class helper context uml class def nom integ self aon end helper qmood nom begin helper qmood cis comment class interfac size comment number public method class helper context uml class def cis integ self pubon end helper qmood cis begin helper qmood npt comment number uniqu paramet type comment number differ paramet type use method class helper context uml class def npt integ self allparameterstyp size end helper qmood npt begin helper qmood npm comment number paramet per method comment averag number paramet per method class comput sum paramet method divid number method class comment the pre condit state class must oper helper context uml class def npm integ self aon self allparamet size self aon els endif end helper qmood npm begin helper qmood nod comment number attribut comment number attribut class helper context uml class def nod integ self aan end helper qmood nod begin helper qmood nad comment number abstract data type comment number user defin object adt use attribut class necessari instanti object instanc aggreg class helper context uml class def nad integ self allattributestyp size end helper qmood nad begin helper qmood npa comment number public attribut comment number attribut declar public class helper context uml class def npa integ self puban end helper qmood npa begin helper qmood csm comment class size metric comment sum number method attribut class helper context uml class def csm integ self aan self aon end helper qmood csm begin helper qmood cam comment cohes among method class comment comput related among method class base upon paramet list method comment the metric comput use summat intersect paramet method maximum independ set paramet type class helper context uml class def cam integ let divisor integ self aon self allparameterstyp size divisor self alloper iter acc integ acc allparameterstyp size divisor els endif end helper qmood cam begin helper qmood dcc comment direct class coupl comment count differ number class class direct relat the metric includ class direct relat attribut declar messag pass paramet method helper context uml class def dcc integ self allattributestyp union self allparameterstyp size end helper qmood dcc begin helper qmood mcc comment maximum class coupl comment this metric includ class direct relat class attribut method also class indirect relat direct relat class helper context uml class def mcc integ self allattributestyp union self allparameterstyp iter acc sequenc uml class sequenc acc union allattributestyp union allparameterstyp asset size end helper qmood mcc begin helper qmood dac comment direct attribut base coupl comment this metric direct count number differ class type declar attribut refer insid class helper context uml class def dac integ self allattributestyp size end helper qmood dac begin helper qmood dpc comment direct paramet base coupl comment number class object type requir direct messag pass paramet method class helper context uml class def dpc integ self allparameterstyp size end helper qmood dpc begin helper qmood mpc comment maximum paramet base coupl comment number class object type requir direct indirect messag pass paramet class helper context uml class def mpc integ self allparameterstyp iter acc sequenc uml class sequenc acc union allparameterstyp asset size end helper qmood mpc begin helper qmood ccd comment class complex base data comment comput complex base upon number compon attribut defin class comment all compon declar resolv basic primit integ doubl charact comment the metric valu count number primit helper context uml class def ccd integ self aan self allattributestyp iter acc integ acc aan end helper qmood ccd begin helper qmood ccp comment class complex base method paramet comment estim complex base upon number paramet requir call method class comment inherit method paramet also includ comput metric valu helper context uml class def ccp integ self allparamet size end helper qmood ccp begin helper qmood ccm comment class complex base member comment this metric aggreg data method paramet complex helper context uml class def ccm integ self ccd self ccp end helper qmood ccm,14
217,217,P93-UML22Measure.atl,"--@atlcompiler	atl2006
--@name			UML22Measure
--@version		1.1
--@domains		UML2, measurement data, metrics
--@authors		Eric Vepa (evepa <at> sodius.com) for SODIUS (www.sodius.com)
--@date			2007/08/02
--@description	This transformation is used to collect measurement data on a UML2 model, using libraries implementing some metrics (MOOD, MOOD2, MOOSE, EMOOSE  and QMOOD).
--@see			Baroni, A.L.: Formal Definition of Object-Oriented Design Metrics. Master Thesis, Vrije University, Brussel, Belgium, 2002.

module UML22Measure; -- Module Template
create OUT : Measure from IN : UML2;

uses FLAME4UML2;
uses MOOD4UML2;
uses EMOOSE4UML2;
uses QMOOD4UML2;

--@begin attribute helpers measureLevel
--@comments Defines the measure level among {#package,#class}. 
--@comments The package level allows measures on packages.
--@comments The class level allows measures on packages and classes.
helper def : measureLevel : Measure!ElementKind = #class;
--@end attribute helper measureLevel

--@begin attribute helper root
--@comments The root measure set.
helper def : root : Measure!RootMeasureSet = OclUndefined;
--@end attribute helper root

--@begin attribute helper MetricByName
--@comments The map of metrics by name.
helper def : MetricByName : Map(String, Measure!Metric) = Map{};
--@end attribute helper MetricByName

--@begin helper defaultName
--@comments Returns the name of the named element or ""Anonymous"".
helper context UML2!NamedElement
def : defaultName() : String =
	if self.name.oclIsUndefined()
		then 'Anonymous'
		else self.name
	endif;
--@end helper defaultName

--@begin entrypoint rule Metrics
--@comments Registers the MOOD, MOOD2, MOOSE, EMOOSE  and QMOOD metrics implemented in libraries.
entrypoint rule Metrics() {
	to
		root : Measure!RootMeasureSet (
			modelType <- #UML2
		)
	do {
		thisModule.root <- root;
		
		if ((thisModule.measureLevel = #package) or
			(thisModule.measureLevel = #class)) {
			-- ==================================================
			-- MOOD Metrics : Intra-Specification Level Metrics =
			-- ==================================================
			root.categories <- thisModule.Category('MOOD',
					'Metrics for Object-Oriented Design');
			thisModule.Metric('MOOD','AIF','Attributes Inheritance Factor');
			thisModule.Metric('MOOD','OIF','Operations Inheritance Factor');
			thisModule.Metric('MOOD','AHF','Attributes Hiding Factor');
			thisModule.Metric('MOOD','OHF','Operations Hiding Factor');
			thisModule.Metric('MOOD','BPF','Behavioral Polymorphism Factor');
			thisModule.Metric('MOOD','CCF','Class Coupling Factor');
			thisModule.Metric('MOOD','ICF','Internal Coupling Factor');
				
			-- ===================================================
			-- MOOD2 Metrics : Intra-Specification Level Metrics =
			-- ===================================================
			root.categories <- thisModule.Category('MOOD2',
				'Metrics for Object-Oriented Design 2');
			thisModule.Metric('MOOD2','IIF','Internal Inheritance Factor');
			thisModule.Metric('MOOD2','AHEF',
				'Attributes Hiding Effectiveness Factor');
			thisModule.Metric('MOOD2','OHEF',
				'Operations Hiding Effectiveness Factor');
		}
		
		if (thisModule.measureLevel = #class) {
			-- ===============
			-- MOOSE Metrics =
			-- ===============
			root.categories <- thisModule.Category('MOOSE',
				'Metrics for Object-Oriented Software Engineering');
			thisModule.Metric('MOOSE','DIT','Depth of Inheritance Tree');
			thisModule.Metric('MOOSE','NOC','Number of Children');
			thisModule.Metric('MOOSE','CBO','Coupling Between Objects');
			thisModule.Metric('MOOSE','RFC','Response for a Class');
		
			-- ================
			-- EMOOSE Metrics =
			-- ================
			root.categories <- thisModule.Category('EMOOSE','Extended MOOSE');
			thisModule.Metric('EMOOSE','SIZE2','Number of local Attributes ' +
				'and Operations defined in the Class');
		}
		
		if ((thisModule.measureLevel = #package) or
			(thisModule.measureLevel = #class)) {
			-- ===============
			-- QMOOD Metrics =
			-- ===============
			root.categories <- thisModule.Category('QMOOD',
				'Quality Model for Object-Oriented Design');
			thisModule.Metric('QMOOD','DSC','Design Size in Classes');
			thisModule.Metric('QMOOD','NOH','Number of Hierarchies');
			thisModule.Metric('QMOOD','NIC','Number of Independent Classes');
			thisModule.Metric('QMOOD','NSI','Number of Single Inheritance');
			thisModule.Metric('QMOOD','NNC','Number of Internal Classes');
			thisModule.Metric('QMOOD','NAC','Number of Abstract Classes');
			thisModule.Metric('QMOOD','NLC','Number of Leaf Classes');
			thisModule.Metric('QMOOD','ADI','Average Depth of Inheritance');
			thisModule.Metric('QMOOD','AWI','Average Width of Inheritance');
			thisModule.Metric('QMOOD','ANA','Average Number of Ancestors');
		}			
		
		if (thisModule.measureLevel = #class) {
			thisModule.Metric('QMOOD','MFA',
				'Measure of Functional Abstraction');
			thisModule.Metric('QMOOD','MAA','Measure of Attribute Abstraction');
			thisModule.Metric('QMOOD','MAT','Measure of Abstraction');
			thisModule.Metric('QMOOD','MOA','Measure of Aggregation');
			thisModule.Metric('QMOOD','MRM','Modeled Relationship Measure');
			thisModule.MetricWithPreferredValue('QMOOD','DAM','Data Access Metric','>75');
			thisModule.MetricWithPreferredValue('QMOOD','OAM','Operation Access Metric','>75');
			thisModule.MetricWithPreferredValue('QMOOD','MAM','Member Access Metric','>75');
			thisModule.Metric('QMOOD','NOA','Number of Ancestors');
			thisModule.Metric('QMOOD','NOM','Number of Methods');
			thisModule.Metric('QMOOD','CIS','Class Interface Size');
			thisModule.Metric('QMOOD','NPT','Number of Unique Parameter Types');
			thisModule.Metric('QMOOD','NPM','Number of Parameters per Method');
			thisModule.Metric('QMOOD','NOD','Number of Attributes');
			thisModule.Metric('QMOOD','NAD','Number of Abstract Data Types');
			thisModule.Metric('QMOOD','NPA','Number of Public Attributes');
			thisModule.Metric('QMOOD','CSM','Class Size Metric');
			thisModule.Metric('QMOOD','CAM','Cohesion Among Methods of Class');
			thisModule.Metric('QMOOD','DCC','Direct Class Coupling');
			thisModule.Metric('QMOOD','MCC','Maximum Class Coupling');
			thisModule.Metric('QMOOD','DAC','Direct Attribute Based Coupling');
			thisModule.Metric('QMOOD','DPC','Direct Parameter Based Coupling');
			thisModule.Metric('QMOOD','MPC','Maximum Parameter Based Coupling');
			thisModule.Metric('QMOOD','CCD','Class Complexity Based on Data');
			thisModule.Metric('QMOOD','CCP',
				'Class Complexity Based on Method Parameters');
			thisModule.Metric('QMOOD','CCM',
				'Class Complexity Based on Members');
		}
	}
}
--@end entrypoint rule Metrics

--@begin  rule Package2MeasureSet
--@comments Collects measurement data on the model (default package) or a package (measureLevel must be set to #package or #class).
rule Package2MeasureSet {
	from
		ne : UML2!Package (
			(ne.oclIsTypeOf(UML2!Package) or ne.oclIsTypeOf(UML2!Model)) and
			((thisModule.measureLevel = #package) or
			(thisModule.measureLevel = #class))
		)
	to
		ms : Measure!MeasureSet (
			elementName <-
				if ne.CN() > 0
					then ne.defaultName().debug('Processing metrics on package')
					else ne.defaultName()
				endif,
	   		elementType <-
				if (ne.oclIsTypeOf(UML2!Model))
		   			then #model
					else #package
				endif,
			subsets <- ne.contents,
			subsets <- ne.allClasses->collect(c|thisModule.Class2MeasureSet(c))
		)
	do {
		if (ne.oclIsTypeOf(UML2!Model)) {
			thisModule.root.measureSets <- ms;
		}
		
		if (ne.CN() > 0) {
			-- ==================================================
			-- MOOD Metrics : Intra-Specification Level Metrics =
			-- ==================================================
			ms.measures <- thisModule.PercentageMeasure('AIF',ne.AIF());
			ms.measures <- thisModule.PercentageMeasure('OIF',ne.OIF());
			ms.measures <- thisModule.PercentageMeasure('AHF',ne.AHF());
			ms.measures <- thisModule.PercentageMeasure('OHF',ne.OHF());
			ms.measures <- thisModule.PercentageMeasure('BPF',ne.BPF());
			ms.measures <- thisModule.PercentageMeasure('CCF',ne.CCF());
			ms.measures <- thisModule.PercentageMeasure('ICF',ne.ICF());
				
			-- =============================================================
			-- MOOD2 Metrics : Intra and Inter-Specification Level Metrics =
			-- =============================================================
			ms.measures <- thisModule.PercentageMeasure('IIF',ne.IIF());
			ms.measures <- thisModule.PercentageMeasure('AHEF',ne.AHEF());
			ms.measures <- thisModule.PercentageMeasure('OHEF',ne.OHEF());
		
			-- ===============
			-- QMOOD Metrics =
			-- ===============
			ms.measures <- thisModule.IntegerMeasure('DSC',ne.DSC());
			ms.measures <- thisModule.IntegerMeasure('NOH',ne.NOH());
			ms.measures <- thisModule.IntegerMeasure('NIC',ne.NIC());
			ms.measures <- thisModule.IntegerMeasure('NSI',ne.NSI());
			ms.measures <- thisModule.IntegerMeasure('NNC',ne.NNC());
			ms.measures <- thisModule.IntegerMeasure('NAC',ne.NAC());
			ms.measures <- thisModule.IntegerMeasure('NLC',ne.NLC());
			ms.measures <- thisModule.DoubleMeasure('ADI',ne.ADI());
			ms.measures <- thisModule.DoubleMeasure('AWI',ne.AWI());
			ms.measures <- thisModule.DoubleMeasure('ANA',ne.ANA());
		}
	}
}
--@end rule Package2MeasureSet

--@begin lazy rule Class2MeasureSet
--@comments Collects measurement data on a class (measureLevel must be set to #class).
lazy rule Class2MeasureSet {
	from
		ne : UML2!Class (
			ne.oclIsTypeOf(UML2!Class) and
			thisModule.measureLevel = #class
		)
	to
		ms : Measure!MeasureSet (
			elementName <- ne.defaultName().debug('Processing metrics on class'),
	   		elementType <- #class,
			subsets <- ne.nestedClassifier
		)
	do {
		-- ===============
		-- MOOSE Metrics =
		-- ===============
		ms.measures <- thisModule.IntegerMeasure('DIT',ne.DIT());
		ms.measures <- thisModule.IntegerMeasure('NOC',ne.NOC());
		ms.measures <- thisModule.IntegerMeasure('CBO',ne.CBO());
		ms.measures <- thisModule.IntegerMeasure('RFC',ne.RFC());
	
		-- ================
		-- EMOOSE Metrics =
		-- ================
		ms.measures <- thisModule.IntegerMeasure('SIZE2',ne.SIZE2());
		
		-- ===============
		-- QMOOD Metrics =
		-- ===============
		ms.measures <- thisModule.PercentageMeasure('MFA',ne.MFA());
		ms.measures <- thisModule.PercentageMeasure('MAA',ne.MAA());
		ms.measures <- thisModule.PercentageMeasure('MAT',ne.MAT());
		ms.measures <- thisModule.IntegerMeasure('MOA',ne.MOA());
		ms.measures <- thisModule.IntegerMeasure('MRM',ne.MRM());
		ms.measures <- thisModule.PercentageMeasure('DAM',ne.DAM());
		ms.measures <- thisModule.PercentageMeasure('OAM',ne.OAM());
		ms.measures <- thisModule.PercentageMeasure('MAM',ne.MAM());
		ms.measures <- thisModule.IntegerMeasure('NOA',ne.NOA());
		ms.measures <- thisModule.IntegerMeasure('NOM',ne.NOM());
		ms.measures <- thisModule.IntegerMeasure('CIS',ne.CIS());
		ms.measures <- thisModule.IntegerMeasure('NPT',ne.NPT());
		ms.measures <- thisModule.DoubleMeasure('NPM',ne.NPM());
		ms.measures <- thisModule.IntegerMeasure('NOD',ne.NOD());
		ms.measures <- thisModule.IntegerMeasure('NAD',ne.NAD());
		ms.measures <- thisModule.IntegerMeasure('NPA',ne.NPA());
		ms.measures <- thisModule.IntegerMeasure('CSM',ne.CSM());
		ms.measures <- thisModule.DoubleMeasure('CAM',ne.CAM());
		ms.measures <- thisModule.IntegerMeasure('DCC',ne.DCC());
		ms.measures <- thisModule.IntegerMeasure('MCC',ne.MCC());
		ms.measures <- thisModule.IntegerMeasure('DAC',ne.DAC());
		ms.measures <- thisModule.IntegerMeasure('DPC',ne.DPC());
		ms.measures <- thisModule.IntegerMeasure('MPC',ne.MPC());
		ms.measures <- thisModule.IntegerMeasure('CCD',ne.CCD());
		ms.measures <- thisModule.IntegerMeasure('CCP',ne.CCP());
		ms.measures <- thisModule.IntegerMeasure('CCM',ne.CCM());
	}
}
--@end lazy rule Class2MeasureSet
		
--@begin called rule Category
--@comments Creates a category for metric classification with a name and a description.
rule Category(name : String, desc : String) {
	to
		cat : Measure!Category (
			name <- name,
			desc <- desc
		)
	do {
		cat;
	}
}
--@end called rule Category
		
--@begin called rule Metric
--@comments Creates a metric for a category with a name and a description (the default preferred value for the metric is set to not equal to zero ['!=0']).
rule Metric(catName : String, name : String, desc : String) {
	to
		metric : Measure!Metric (
			name <- name,
			desc <- desc,
			preferredValue <- '!=0',
			category <- thisModule.root.categories->
				select(cat|cat.name = catName)->first()
		)
	do {
		thisModule.MetricByName <-
			thisModule.MetricByName.including(metric.name,metric);
	}
}
--@end called rule Metric
		
--@begin called rule MetricWithPreferredValue
--@comments Creates a metric for a category with a name, a description and a preferred value for the metric (an operator [<, <=, =, !=, >=, >] followed by a number).
rule MetricWithPreferredValue(catName : String, name : String, desc : String, preferredValue : String) {
	to
		metric : Measure!Metric (
			name <- name,
			desc <- desc,
			preferredValue <- preferredValue,
			category <- thisModule.root.categories->
				select(cat|cat.name = catName)->first()
		)
	do {
		thisModule.MetricByName <-
			thisModule.MetricByName.including(metric.name,metric);
	}
}
--@end called rule MetricWithPreferredValue
		
--@begin called rule IntegerMeasure
--@comments Stores an Integer measure for the metric which name and value are given.
rule IntegerMeasure(name : String, value : Integer) {
	to
		meas : Measure!IntegerMeasure (
			metric <- thisModule.MetricByName.get(name),
			value <- value
		)
	do {
		meas;
	}
}
--@end called rule IntegerMeasure
		
--@begin called rule DoubleMeasure
--@comments Stores a Double measure for the metric which name and value are given.
rule DoubleMeasure(name : String, value : Real) {
	to
		meas : Measure!DoubleMeasure (
			metric <- thisModule.MetricByName.get(name),
			value <- value
		)
	do {
		meas;
	}
}
--@end called rule DoubleMeasure
		
--@begin called rule PercentageMeasure
--@comments Stores a Percentage measure for the metric which name and value are given.
rule PercentageMeasure(name : String, value : Real) {
	to
		meas : Measure!PercentageMeasure (
			metric <- thisModule.MetricByName.get(name),
			value <- value
		)
	do {
		meas;
	}
}
--@end called rule PercentageMeasure",atlcompil atl name uml measur version domain uml measur data metric author eric vepa evepa sodius com sodius www sodius com date descript this transform use collect measur data uml model use librari implement metric mood mood moos emoos qmood see baroni a l formal definit object orient design metric master thesi vrije univers brussel belgium modul uml measur modul templat creat out measur in uml use flame uml use mood uml use emoos uml use qmood uml begin attribut helper measurelevel comment defin measur level among packag class comment the packag level allow measur packag comment the class level allow measur packag class helper def measurelevel measur elementkind class end attribut helper measurelevel begin attribut helper root comment the root measur set helper def root measur rootmeasureset oclundefin end attribut helper root begin attribut helper metricbynam comment the map metric name helper def metricbynam map string measur metric map end attribut helper metricbynam begin helper defaultnam comment return name name element anonym helper context uml namedel def defaultnam string self name oclisundefin anonym els self name endif end helper defaultnam begin entrypoint rule metric comment regist mood mood moos emoos qmood metric implement librari entrypoint rule metric root measur rootmeasureset modeltyp uml thismodul root root thismodul measurelevel packag thismodul measurelevel class mood metric intra specif level metric root categori thismodul categori mood metric object orient design thismodul metric mood aif attribut inherit factor thismodul metric mood oif oper inherit factor thismodul metric mood ahf attribut hide factor thismodul metric mood ohf oper hide factor thismodul metric mood bpf behavior polymorph factor thismodul metric mood ccf class coupl factor thismodul metric mood icf intern coupl factor mood metric intra specif level metric root categori thismodul categori mood metric object orient design thismodul metric mood iif intern inherit factor thismodul metric mood ahef attribut hide effect factor thismodul metric mood ohef oper hide effect factor thismodul measurelevel class moos metric root categori thismodul categori moos metric object orient softwar engin thismodul metric moos dit depth inherit tree thismodul metric moos noc number children thismodul metric moos cbo coupl between object thismodul metric moos rfc respons class emoos metric root categori thismodul categori emoos extend moos thismodul metric emoos size number local attribut oper defin class thismodul measurelevel packag thismodul measurelevel class qmood metric root categori thismodul categori qmood qualiti model object orient design thismodul metric qmood dsc design size class thismodul metric qmood noh number hierarchi thismodul metric qmood nic number independ class thismodul metric qmood nsi number singl inherit thismodul metric qmood nnc number intern class thismodul metric qmood nac number abstract class thismodul metric qmood nlc number leaf class thismodul metric qmood adi averag depth inherit thismodul metric qmood awi averag width inherit thismodul metric qmood ana averag number ancestor thismodul measurelevel class thismodul metric qmood mfa measur function abstract thismodul metric qmood maa measur attribut abstract thismodul metric qmood mat measur abstract thismodul metric qmood moa measur aggreg thismodul metric qmood mrm model relationship measur thismodul metricwithpreferredvalu qmood dam data access metric thismodul metricwithpreferredvalu qmood oam oper access metric thismodul metricwithpreferredvalu qmood mam member access metric thismodul metric qmood noa number ancestor thismodul metric qmood nom number method thismodul metric qmood cis class interfac size thismodul metric qmood npt number uniqu paramet type thismodul metric qmood npm number paramet per method thismodul metric qmood nod number attribut thismodul metric qmood nad number abstract data type thismodul metric qmood npa number public attribut thismodul metric qmood csm class size metric thismodul metric qmood cam cohes among method class thismodul metric qmood dcc direct class coupl thismodul metric qmood mcc maximum class coupl thismodul metric qmood dac direct attribut base coupl thismodul metric qmood dpc direct paramet base coupl thismodul metric qmood mpc maximum paramet base coupl thismodul metric qmood ccd class complex base data thismodul metric qmood ccp class complex base method paramet thismodul metric qmood ccm class complex base member end entrypoint rule metric begin rule packag measureset comment collect measur data model default packag packag measurelevel must set packag class rule packag measureset ne uml packag ne oclistypeof uml packag ne oclistypeof uml model thismodul measurelevel packag thismodul measurelevel class ms measur measureset elementnam ne cn ne defaultnam debug process metric packag els ne defaultnam endif elementtyp ne oclistypeof uml model model els packag endif subset ne content subset ne allclass collect c thismodul class measureset c ne oclistypeof uml model thismodul root measureset ms ne cn mood metric intra specif level metric ms measur thismodul percentagemeasur aif ne aif ms measur thismodul percentagemeasur oif ne oif ms measur thismodul percentagemeasur ahf ne ahf ms measur thismodul percentagemeasur ohf ne ohf ms measur thismodul percentagemeasur bpf ne bpf ms measur thismodul percentagemeasur ccf ne ccf ms measur thismodul percentagemeasur icf ne icf mood metric intra inter specif level metric ms measur thismodul percentagemeasur iif ne iif ms measur thismodul percentagemeasur ahef ne ahef ms measur thismodul percentagemeasur ohef ne ohef qmood metric ms measur thismodul integermeasur dsc ne dsc ms measur thismodul integermeasur noh ne noh ms measur thismodul integermeasur nic ne nic ms measur thismodul integermeasur nsi ne nsi ms measur thismodul integermeasur nnc ne nnc ms measur thismodul integermeasur nac ne nac ms measur thismodul integermeasur nlc ne nlc ms measur thismodul doublemeasur adi ne adi ms measur thismodul doublemeasur awi ne awi ms measur thismodul doublemeasur ana ne ana end rule packag measureset begin lazi rule class measureset comment collect measur data class measurelevel must set class lazi rule class measureset ne uml class ne oclistypeof uml class thismodul measurelevel class ms measur measureset elementnam ne defaultnam debug process metric class elementtyp class subset ne nestedclassifi moos metric ms measur thismodul integermeasur dit ne dit ms measur thismodul integermeasur noc ne noc ms measur thismodul integermeasur cbo ne cbo ms measur thismodul integermeasur rfc ne rfc emoos metric ms measur thismodul integermeasur size ne size qmood metric ms measur thismodul percentagemeasur mfa ne mfa ms measur thismodul percentagemeasur maa ne maa ms measur thismodul percentagemeasur mat ne mat ms measur thismodul integermeasur moa ne moa ms measur thismodul integermeasur mrm ne mrm ms measur thismodul percentagemeasur dam ne dam ms measur thismodul percentagemeasur oam ne oam ms measur thismodul percentagemeasur mam ne mam ms measur thismodul integermeasur noa ne noa ms measur thismodul integermeasur nom ne nom ms measur thismodul integermeasur cis ne cis ms measur thismodul integermeasur npt ne npt ms measur thismodul doublemeasur npm ne npm ms measur thismodul integermeasur nod ne nod ms measur thismodul integermeasur nad ne nad ms measur thismodul integermeasur npa ne npa ms measur thismodul integermeasur csm ne csm ms measur thismodul doublemeasur cam ne cam ms measur thismodul integermeasur dcc ne dcc ms measur thismodul integermeasur mcc ne mcc ms measur thismodul integermeasur dac ne dac ms measur thismodul integermeasur dpc ne dpc ms measur thismodul integermeasur mpc ne mpc ms measur thismodul integermeasur ccd ne ccd ms measur thismodul integermeasur ccp ne ccp ms measur thismodul integermeasur ccm ne ccm end lazi rule class measureset begin call rule categori comment creat categori metric classif name descript rule categori name string desc string cat measur categori name name desc desc cat end call rule categori begin call rule metric comment creat metric categori name descript default prefer valu metric set equal zero rule metric catnam string name string desc string metric measur metric name name desc desc preferredvalu categori thismodul root categori select cat cat name catnam first thismodul metricbynam thismodul metricbynam includ metric name metric end call rule metric begin call rule metricwithpreferredvalu comment creat metric categori name descript prefer valu metric oper follow number rule metricwithpreferredvalu catnam string name string desc string preferredvalu string metric measur metric name name desc desc preferredvalu preferredvalu categori thismodul root categori select cat cat name catnam first thismodul metricbynam thismodul metricbynam includ metric name metric end call rule metricwithpreferredvalu begin call rule integermeasur comment store integ measur metric name valu given rule integermeasur name string valu integ mea measur integermeasur metric thismodul metricbynam get name valu valu mea end call rule integermeasur begin call rule doublemeasur comment store doubl measur metric name valu given rule doublemeasur name string valu real mea measur doublemeasur metric thismodul metricbynam get name valu valu mea end call rule doublemeasur begin call rule percentagemeasur comment store percentag measur metric name valu given rule percentagemeasur name string valu real mea measur percentagemeasur metric thismodul metricbynam get name valu valu mea end call rule percentagemeasur,14
218,218,P94-UmlActivityDiagram2MSProject.atl,"module UmlActivityDiagram2MSProject;
create OUT : MSProject from IN : UML;


-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- This helper stores an integer value used to assign an ID to each generated
-- Task.
-- CONTEXT: thisModule
-- RETURN:	Integer
helper def: curId : Integer = 0;

-- This helper computes the value to be assigned to the ID field of a generated
-- Task. It increments the value stored by the ""curId"" helper and returns its
-- new value as a String.
-- CONTEXT: thisModule
-- RETURN:	String
helper def: getId() : String =
	thisModule.refSetValue('curId', thisModule.curId + 1).curId.toString();


-- This helper computes the set of StateVertex that will be associated with
-- the predecessors of a Task.
-- The computed set contains all the ActionState and Pseudostate of ""initial""
-- type (ie. the initial state) that point to the current StateVertex
-- (the context one) either directly or through ""fork"" and ""join"" Pseudostate.
--
-- WARNING: this helper is not able to deal with loops. However, there shall
-- be no loops in a diagram dedicated to the representation of a project.
--
-- CONTEXT:	UML!StateVertex
-- RETURN:	Set(UML!StateVertex)
helper context UML!StateVertex def: getPredecessors() : Set(UML!StateVertex) =
	let trans : Set(UML!StateVertex) = self.incoming in
	
	if trans.isEmpty() then
		Set{}
	else trans->collect(t | t.source)
			->iterate(e; ret : Set(UML!StateVertex) = Sequence{} |
				if e.oclIsKindOf(UML!ActionState) then
					ret->including(e)
				else
					if e.oclIsKindOf(UML!Pseudostate) then
						if e.kind = #pk_initial then
							ret->including(e)
						else
							ret->including(e.getPredecessors())
						endif
					else
						ret
					endif
				endif 
			)
	endif;



-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'Main'
-- This rule generates the Project element. Contained tasks are those
-- associated with:
--  * UML Final State
--  * UML Action State
--  * UML Pseudostate of ""initial"" kind.
rule Main {
	from
		s : UML!StateMachine
	to 
		pro : MSProject!MSProject (
			tasks <- UML!StateVertex.allInstances()
		)
}

-- Rule 'Pseudostate'
-- This rule generates a Task for the Pseudostate of ""initial"" type (that is,
-- the diagram initial state).
-- The generated initial Task has no predecessors (sine it corresponds to the
-- intial state of the UML activity diagram).
rule Pseudostate {
	from
		s : UML!Pseudostate (
				s.kind = #pk_initial
		)
	to 
		t : MSProject!Task (
			UID <- thisModule.getId(),
			name <- s.name,
			predecessors <- Set{}
		)
}

-- Rule 'StateVertex'
-- This rule generates Tasks for both ActionStates and FinalStates.
-- The set of predecessors of a Task is computed by the getPredecessors helper.
-- It corresponds to the set of ActionState/""initial"" Pseudostate pointing to
-- the current state directly, or through one or several ""fork"" and ""join""
-- Pseudostates.
rule StateVertex {
	from
		s : UML!StateVertex (
				s.oclIsKindOf(UML!FinalState)
				or s.oclIsKindOf(UML!ActionState)
		)
	to 
		t : MSProject!Task (
			UID <- thisModule.getId(),
			name <- s.name,
			predecessors <- s.getPredecessors()
		)
}
",modul umlactivitydiagram msproject creat out msproject in uml helper this helper store integ valu use assign id generat task context thismodul return integ helper def curid integ this helper comput valu assign id field generat task it increment valu store curid helper return new valu string context thismodul return string helper def getid string thismodul refsetvalu curid thismodul curid curid tostr this helper comput set statevertex associ predecessor task the comput set contain actionst pseudost initi type ie initi state point current statevertex context one either direct fork join pseudost warn helper abl deal loop howev shall loop diagram dedic represent project context uml statevertex return set uml statevertex helper context uml statevertex def getpredecessor set uml statevertex let tran set uml statevertex self incom tran isempti set els tran collect sourc iter e ret set uml statevertex sequenc e ocliskindof uml actionst ret includ e els e ocliskindof uml pseudost e kind pk initi ret includ e els ret includ e getpredecessor endif els ret endif endif endif rule rule main this rule generat project element contain task associ uml final state uml action state uml pseudost initi kind rule main uml statemachin pro msproject msproject task uml statevertex allinst rule pseudost this rule generat task pseudost initi type diagram initi state the generat initi task predecessor sine correspond intial state uml activ diagram rule pseudost uml pseudost kind pk initi msproject task uid thismodul getid name name predecessor set rule statevertex this rule generat task actionst finalst the set predecessor task comput getpredecessor helper it correspond set actionst initi pseudost point current state direct one sever fork join pseudost rule statevertex uml statevertex ocliskindof uml finalst ocliskindof uml actionst msproject task uid thismodul getid name name predecessor getpredecessor,0
219,219,P95-UML2Copy.atl,"-- @atlcompiler atl2006
-- $Id$
-- Copies UML2 models
module UML2Copy;

create OUT : UML2 from IN : UML2;

helper def : inElements : Set(UML2!""ecore::EObject"") = UML2!""ecore::EObject""->allInstancesFrom('IN');

-- ======================================================================
-- Ecore copying rules begin
-- ======================================================================
-- Generated by: EModelCopyGenerator.atl 7249 2007-09-11 09:34:31Z dwagelaa

rule EAnnotation {
    from s : UML2!""ecore::EAnnotation"" (thisModule.inElements->includes(s))
    to t : UML2!""ecore::EAnnotation"" mapsTo s (
        source <- s.source,
        eAnnotations <- s.eAnnotations,
        details <- s.details,
        contents <- s.contents,
        references <- s.references)
}

rule EStringToStringMapEntry {
    from s : UML2!""ecore::EStringToStringMapEntry"" (thisModule.inElements->includes(s))
    to t : UML2!""ecore::EStringToStringMapEntry"" mapsTo s (
        key <- s.key,
        value <- s.value)
}

-- ======================================================================
-- Ecore copying rules end
-- ======================================================================

-- ======================================================================
-- UML2 copying rules begin
-- ======================================================================
-- Generated by: EModelCopyGenerator.atl 7249 2007-09-11 09:34:31Z dwagelaa

rule Comment {
    from s : UML2!""uml::Comment"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Comment"" mapsTo s (
        body <- s.body,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        annotatedElement <- s.annotatedElement)
}

rule Package {
    from s : UML2!""uml::Package"" (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!""uml::Package"")
		else false endif)
    to t : UML2!""uml::Package"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        packageMerge <- s.packageMerge,
        packagedElement <- s.packagedElement,
        profileApplication <- s.profileApplication)
}

rule Dependency {
    from s : UML2!""uml::Dependency"" (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!""uml::Dependency"")
		else false endif)
    to t : UML2!""uml::Dependency"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        client <- s.client)
}

rule ElementImport {
    from s : UML2!""uml::ElementImport"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ElementImport"" mapsTo s (
        visibility <- s.visibility,
        alias <- s.alias,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        importedElement <- s.importedElement)
}

rule PackageImport {
    from s : UML2!""uml::PackageImport"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::PackageImport"" mapsTo s (
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        importedPackage <- s.importedPackage)
}

rule Constraint {
    from s : UML2!""uml::Constraint"" (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!""uml::Constraint"")
		else false endif)
    to t : UML2!""uml::Constraint"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        constrainedElement <- s.constrainedElement,
        specification <- s.specification)
}

rule Association {
    from s : UML2!""uml::Association"" (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!""uml::Association"")
		else false endif)
    to t : UML2!""uml::Association"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isDerived <- s.isDerived,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedEnd <- s.ownedEnd,
        memberEnd <- s.memberEnd,
        navigableOwnedEnd <- s.navigableOwnedEnd)
}

rule TemplateBinding {
    from s : UML2!""uml::TemplateBinding"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::TemplateBinding"" mapsTo s (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        signature <- s.signature,
        parameterSubstitution <- s.parameterSubstitution)
}

rule TemplateSignature {
    from s : UML2!""uml::TemplateSignature"" (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!""uml::TemplateSignature"")
		else false endif)
    to t : UML2!""uml::TemplateSignature"" mapsTo s (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        parameter <- s.parameter,
        ownedParameter <- s.ownedParameter)
}

rule TemplateParameter {
    from s : UML2!""uml::TemplateParameter"" (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!""uml::TemplateParameter"")
		else false endif)
    to t : UML2!""uml::TemplateParameter"" mapsTo s (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        parameteredElement <- s.parameteredElement,
        ownedParameteredElement <- s.ownedParameteredElement,
        default <- s.default,
        ownedDefault <- s.ownedDefault)
}

rule TemplateParameterSubstitution {
    from s : UML2!""uml::TemplateParameterSubstitution"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::TemplateParameterSubstitution"" mapsTo s (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        formal <- s.formal,
        actual <- s.actual,
        ownedActual <- s.ownedActual)
}

rule Generalization {
    from s : UML2!""uml::Generalization"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Generalization"" mapsTo s (
        isSubstitutable <- s.isSubstitutable,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        general <- s.general,
        generalizationSet <- s.generalizationSet)
}

rule GeneralizationSet {
    from s : UML2!""uml::GeneralizationSet"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::GeneralizationSet"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isCovering <- s.isCovering,
        isDisjoint <- s.isDisjoint,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        powertype <- s.powertype,
        generalization <- s.generalization)
}

rule Substitution {
    from s : UML2!""uml::Substitution"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Substitution"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        client <- s.client,
        mapping <- s.mapping,
        contract <- s.contract)
}

rule Realization {
    from s : UML2!""uml::Realization"" (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!""uml::Realization"")
		else false endif)
    to t : UML2!""uml::Realization"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        client <- s.client,
        mapping <- s.mapping)
}

rule Abstraction {
    from s : UML2!""uml::Abstraction"" (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!""uml::Abstraction"")
		else false endif)
    to t : UML2!""uml::Abstraction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        client <- s.client,
        mapping <- s.mapping)
}

rule OpaqueExpression {
    from s : UML2!""uml::OpaqueExpression"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::OpaqueExpression"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        body <- s.body,
        language <- s.language,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type,
        behavior <- s.behavior)
}

rule Parameter {
    from s : UML2!""uml::Parameter"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Parameter"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        direction <- s.direction,
        isException <- s.isException,
        isStream <- s.isStream,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        type <- s.type,
        templateParameter <- s.templateParameter,
        end <- s.end,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue,
        parameterSet <- s.parameterSet,
        defaultValue <- s.defaultValue)
}

rule ConnectorEnd {
    from s : UML2!""uml::ConnectorEnd"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ConnectorEnd"" mapsTo s (
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue,
        partWithPort <- s.partWithPort,
        role <- s.role)
}

rule Property {
    from s : UML2!""uml::Property"" (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!""uml::Property"")
		else false endif)
    to t : UML2!""uml::Property"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isStatic <- s.isStatic,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        isReadOnly <- s.isReadOnly,
        isDerived <- s.isDerived,
        isDerivedUnion <- s.isDerivedUnion,
        aggregation <- s.aggregation,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        type <- s.type,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue,
        templateParameter <- s.templateParameter,
        end <- s.end,
        deployment <- s.deployment,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        redefinedProperty <- s.redefinedProperty,
        defaultValue <- s.defaultValue,
        subsettedProperty <- s.subsettedProperty,
        association <- s.association,
        qualifier <- s.qualifier)
}

rule Deployment {
    from s : UML2!""uml::Deployment"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Deployment"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        client <- s.client,
        deployedArtifact <- s.deployedArtifact,
        configuration <- s.configuration)
}

rule DeploymentSpecification {
    from s : UML2!""uml::DeploymentSpecification"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::DeploymentSpecification"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        fileName <- s.fileName,
        deploymentLocation <- s.deploymentLocation,
        executionLocation <- s.executionLocation,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        nestedArtifact <- s.nestedArtifact,
        manifestation <- s.manifestation,
        ownedOperation <- s.ownedOperation,
        ownedAttribute <- s.ownedAttribute)
}

rule Artifact {
    from s : UML2!""uml::Artifact"" (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!""uml::Artifact"")
		else false endif)
    to t : UML2!""uml::Artifact"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        fileName <- s.fileName,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        nestedArtifact <- s.nestedArtifact,
        manifestation <- s.manifestation,
        ownedOperation <- s.ownedOperation,
        ownedAttribute <- s.ownedAttribute)
}

rule Manifestation {
    from s : UML2!""uml::Manifestation"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Manifestation"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        client <- s.client,
        mapping <- s.mapping,
        utilizedElement <- s.utilizedElement)
}

rule Operation {
    from s : UML2!""uml::Operation"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Operation"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isStatic <- s.isStatic,
        isAbstract <- s.isAbstract,
        concurrency <- s.concurrency,
        isQuery <- s.isQuery,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        ownedParameter <- s.ownedParameter,
        method <- s.method,
        raisedException <- s.raisedException,
        ownedParameterSet <- s.ownedParameterSet,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        precondition <- s.precondition,
        postcondition <- s.postcondition,
        redefinedOperation <- s.redefinedOperation,
        bodyCondition <- s.bodyCondition)
}

rule Class {
    from s : UML2!""uml::Class"" (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!""uml::Class"")
		else false endif)
    to t : UML2!""uml::Class"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception)
}

rule InterfaceRealization {
    from s : UML2!""uml::InterfaceRealization"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::InterfaceRealization"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        client <- s.client,
        mapping <- s.mapping,
        contract <- s.contract)
}

rule Interface {
    from s : UML2!""uml::Interface"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Interface"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedOperation <- s.ownedOperation,
        nestedClassifier <- s.nestedClassifier,
        redefinedInterface <- s.redefinedInterface,
        ownedReception <- s.ownedReception,
        protocol <- s.protocol)
}

rule Reception {
    from s : UML2!""uml::Reception"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Reception"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isStatic <- s.isStatic,
        isAbstract <- s.isAbstract,
        concurrency <- s.concurrency,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        ownedParameter <- s.ownedParameter,
        method <- s.method,
        raisedException <- s.raisedException,
        ownedParameterSet <- s.ownedParameterSet,
        signal <- s.signal)
}

rule Signal {
    from s : UML2!""uml::Signal"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Signal"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute)
}

rule ProtocolStateMachine {
    from s : UML2!""uml::ProtocolStateMachine"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ProtocolStateMachine"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        isReentrant <- s.isReentrant,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        redefinedBehavior <- s.redefinedBehavior,
        ownedParameter <- s.ownedParameter,
        precondition <- s.precondition,
        postcondition <- s.postcondition,
        ownedParameterSet <- s.ownedParameterSet,
        specification <- s.specification,
        region <- s.region,
        submachineState <- s.submachineState,
        connectionPoint <- s.connectionPoint,
        extendedStateMachine <- s.extendedStateMachine,
        conformance <- s.conformance)
}

rule StateMachine {
    from s : UML2!""uml::StateMachine"" (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!""uml::StateMachine"")
		else false endif)
    to t : UML2!""uml::StateMachine"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        isReentrant <- s.isReentrant,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        redefinedBehavior <- s.redefinedBehavior,
        ownedParameter <- s.ownedParameter,
        precondition <- s.precondition,
        postcondition <- s.postcondition,
        ownedParameterSet <- s.ownedParameterSet,
        specification <- s.specification,
        region <- s.region,
        submachineState <- s.submachineState,
        connectionPoint <- s.connectionPoint,
        extendedStateMachine <- s.extendedStateMachine)
}

rule Region {
    from s : UML2!""uml::Region"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Region"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        subvertex <- s.subvertex,
        transition <- s.transition,
        extendedRegion <- s.extendedRegion)
}

rule Transition {
    from s : UML2!""uml::Transition"" (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!""uml::Transition"")
		else false endif)
    to t : UML2!""uml::Transition"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        kind <- s.kind,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        target <- s.target,
        redefinedTransition <- s.redefinedTransition,
        guard <- s.guard,
        effect <- s.effect,
        trigger <- s.trigger,
        source <- s.source)
}

rule Trigger {
    from s : UML2!""uml::Trigger"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Trigger"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        event <- s.event,
        port <- s.port)
}

rule Port {
    from s : UML2!""uml::Port"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Port"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isStatic <- s.isStatic,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        isReadOnly <- s.isReadOnly,
        isDerived <- s.isDerived,
        isDerivedUnion <- s.isDerivedUnion,
        aggregation <- s.aggregation,
        isBehavior <- s.isBehavior,
        isService <- s.isService,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        type <- s.type,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue,
        templateParameter <- s.templateParameter,
        end <- s.end,
        deployment <- s.deployment,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        redefinedProperty <- s.redefinedProperty,
        defaultValue <- s.defaultValue,
        subsettedProperty <- s.subsettedProperty,
        association <- s.association,
        qualifier <- s.qualifier,
        redefinedPort <- s.redefinedPort,
        protocol <- s.protocol)
}

rule State {
    from s : UML2!""uml::State"" (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!""uml::State"")
		else false endif)
    to t : UML2!""uml::State"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        submachine <- s.submachine,
        connection <- s.connection,
        connectionPoint <- s.connectionPoint,
        redefinedState <- s.redefinedState,
        stateInvariant <- s.stateInvariant,
        entry <- s.entry,
        exit <- s.exit,
        doActivity <- s.doActivity,
        deferrableTrigger <- s.deferrableTrigger,
        region <- s.region)
}

rule ConnectionPointReference {
    from s : UML2!""uml::ConnectionPointReference"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ConnectionPointReference"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        entry <- s.entry,
        exit <- s.exit)
}

rule Pseudostate {
    from s : UML2!""uml::Pseudostate"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Pseudostate"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        kind <- s.kind,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming)
}

rule ProtocolConformance {
    from s : UML2!""uml::ProtocolConformance"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ProtocolConformance"" mapsTo s (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        generalMachine <- s.generalMachine)
}

rule Connector {
    from s : UML2!""uml::Connector"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Connector"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isStatic <- s.isStatic,
        kind <- s.kind,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        type <- s.type,
        redefinedConnector <- s.redefinedConnector,
        end <- s.end,
        contract <- s.contract)
}

rule Extension {
    from s : UML2!""uml::Extension"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Extension"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isDerived <- s.isDerived,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedEnd <- s.ownedEnd,
        memberEnd <- s.memberEnd,
        navigableOwnedEnd <- s.navigableOwnedEnd)
}

rule ExtensionEnd {
    from s : UML2!""uml::ExtensionEnd"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ExtensionEnd"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isStatic <- s.isStatic,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        isReadOnly <- s.isReadOnly,
        isDerived <- s.isDerived,
        isDerivedUnion <- s.isDerivedUnion,
        aggregation <- s.aggregation,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        type <- s.type,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue,
        templateParameter <- s.templateParameter,
        end <- s.end,
        deployment <- s.deployment,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        redefinedProperty <- s.redefinedProperty,
        defaultValue <- s.defaultValue,
        subsettedProperty <- s.subsettedProperty,
        association <- s.association,
        qualifier <- s.qualifier)
}

rule Image {
    from s : UML2!""uml::Image"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Image"" mapsTo s (
        content <- s.content,
        location <- s.location,
        format <- s.format,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment)
}

rule Model {
    from s : UML2!""uml::Model"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Model"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        viewpoint <- s.viewpoint,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        packageMerge <- s.packageMerge,
        packagedElement <- s.packagedElement,
        profileApplication <- s.profileApplication)
}

rule ParameterSet {
    from s : UML2!""uml::ParameterSet"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ParameterSet"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        parameter <- s.parameter,
        condition <- s.condition)
}

rule DataType {
    from s : UML2!""uml::DataType"" (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!""uml::DataType"")
		else false endif)
    to t : UML2!""uml::DataType"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedOperation <- s.ownedOperation)
}

rule OperationTemplateParameter {
    from s : UML2!""uml::OperationTemplateParameter"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::OperationTemplateParameter"" mapsTo s (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        parameteredElement <- s.parameteredElement,
        ownedParameteredElement <- s.ownedParameteredElement,
        default <- s.default,
        ownedDefault <- s.ownedDefault)
}

rule ConnectableElementTemplateParameter {
    from s : UML2!""uml::ConnectableElementTemplateParameter"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ConnectableElementTemplateParameter"" mapsTo s (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        parameteredElement <- s.parameteredElement,
        ownedParameteredElement <- s.ownedParameteredElement,
        default <- s.default,
        ownedDefault <- s.ownedDefault)
}

rule CollaborationUse {
    from s : UML2!""uml::CollaborationUse"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::CollaborationUse"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        type <- s.type,
        roleBinding <- s.roleBinding)
}

rule Collaboration {
    from s : UML2!""uml::Collaboration"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Collaboration"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        collaborationRole <- s.collaborationRole)
}

rule UseCase {
    from s : UML2!""uml::UseCase"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::UseCase"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        include <- s.include,
        extend <- s.extend,
        extensionPoint <- s.extensionPoint,
        subject <- s.subject)
}

rule Include {
    from s : UML2!""uml::Include"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Include"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        addition <- s.addition)
}

rule Extend {
    from s : UML2!""uml::Extend"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Extend"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        extendedCase <- s.extendedCase,
        condition <- s.condition,
        extensionLocation <- s.extensionLocation)
}

rule ExtensionPoint {
    from s : UML2!""uml::ExtensionPoint"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ExtensionPoint"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression)
}

rule RedefinableTemplateSignature {
    from s : UML2!""uml::RedefinableTemplateSignature"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::RedefinableTemplateSignature"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        parameter <- s.parameter,
        ownedParameter <- s.ownedParameter,
        extendedSignature <- s.extendedSignature)
}

rule ClassifierTemplateParameter {
    from s : UML2!""uml::ClassifierTemplateParameter"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ClassifierTemplateParameter"" mapsTo s (
        allowSubstitutable <- s.allowSubstitutable,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        parameteredElement <- s.parameteredElement,
        ownedParameteredElement <- s.ownedParameteredElement,
        default <- s.default,
        ownedDefault <- s.ownedDefault,
        defaultClassifier <- s.defaultClassifier,
        constrainingClassifier <- s.constrainingClassifier)
}

rule StringExpression {
    from s : UML2!""uml::StringExpression"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::StringExpression"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        symbol <- s.symbol,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type,
        operand <- s.operand,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        subExpression <- s.subExpression)
}

rule Expression {
    from s : UML2!""uml::Expression"" (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!""uml::Expression"")
		else false endif)
    to t : UML2!""uml::Expression"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        symbol <- s.symbol,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type,
        operand <- s.operand)
}

rule PackageMerge {
    from s : UML2!""uml::PackageMerge"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::PackageMerge"" mapsTo s (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        mergedPackage <- s.mergedPackage)
}

rule ProfileApplication {
    from s : UML2!""uml::ProfileApplication"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ProfileApplication"" mapsTo s (
        isStrict <- s.isStrict,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        appliedProfile <- s.appliedProfile)
}

rule Enumeration {
    from s : UML2!""uml::Enumeration"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Enumeration"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedOperation <- s.ownedOperation,
        ownedLiteral <- s.ownedLiteral)
}

rule EnumerationLiteral {
    from s : UML2!""uml::EnumerationLiteral"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::EnumerationLiteral"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        deployment <- s.deployment,
        templateParameter <- s.templateParameter,
        classifier <- s.classifier,
        slot <- s.slot,
        specification <- s.specification)
}

rule InstanceSpecification {
    from s : UML2!""uml::InstanceSpecification"" (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!""uml::InstanceSpecification"")
		else false endif)
    to t : UML2!""uml::InstanceSpecification"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        deployment <- s.deployment,
        templateParameter <- s.templateParameter,
        classifier <- s.classifier,
        slot <- s.slot,
        specification <- s.specification)
}

rule Slot {
    from s : UML2!""uml::Slot"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Slot"" mapsTo s (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        definingFeature <- s.definingFeature,
        value <- s.value)
}

rule PrimitiveType {
    from s : UML2!""uml::PrimitiveType"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::PrimitiveType"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedOperation <- s.ownedOperation)
}

rule LiteralInteger {
    from s : UML2!""uml::LiteralInteger"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::LiteralInteger"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        value <- s.value,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type)
}

rule LiteralString {
    from s : UML2!""uml::LiteralString"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::LiteralString"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        value <- s.value,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type)
}

rule LiteralBoolean {
    from s : UML2!""uml::LiteralBoolean"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::LiteralBoolean"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        value <- s.value,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type)
}

rule LiteralNull {
    from s : UML2!""uml::LiteralNull"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::LiteralNull"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type)
}

rule InstanceValue {
    from s : UML2!""uml::InstanceValue"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::InstanceValue"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type,
        instance <- s.instance)
}

rule LiteralUnlimitedNatural {
    from s : UML2!""uml::LiteralUnlimitedNatural"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::LiteralUnlimitedNatural"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        value <- s.value,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type)
}

rule OpaqueBehavior {
    from s : UML2!""uml::OpaqueBehavior"" (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!""uml::OpaqueBehavior"")
		else false endif)
    to t : UML2!""uml::OpaqueBehavior"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        isReentrant <- s.isReentrant,
        body <- s.body,
        language <- s.language,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        redefinedBehavior <- s.redefinedBehavior,
        ownedParameter <- s.ownedParameter,
        precondition <- s.precondition,
        postcondition <- s.postcondition,
        ownedParameterSet <- s.ownedParameterSet,
        specification <- s.specification)
}

rule FunctionBehavior {
    from s : UML2!""uml::FunctionBehavior"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::FunctionBehavior"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        isReentrant <- s.isReentrant,
        body <- s.body,
        language <- s.language,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        redefinedBehavior <- s.redefinedBehavior,
        ownedParameter <- s.ownedParameter,
        precondition <- s.precondition,
        postcondition <- s.postcondition,
        ownedParameterSet <- s.ownedParameterSet,
        specification <- s.specification)
}

rule OpaqueAction {
    from s : UML2!""uml::OpaqueAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::OpaqueAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        body <- s.body,
        language <- s.language,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        inputValue <- s.inputValue,
        outputValue <- s.outputValue)
}

rule StructuredActivityNode {
    from s : UML2!""uml::StructuredActivityNode"" (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!""uml::StructuredActivityNode"")
		else false endif)
    to t : UML2!""uml::StructuredActivityNode"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        mustIsolate <- s.mustIsolate,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        variable <- s.variable,
        edge <- s.edge,
        node <- s.node)
}

rule Activity {
    from s : UML2!""uml::Activity"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Activity"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        isReentrant <- s.isReentrant,
        isReadOnly <- s.isReadOnly,
        isSingleExecution <- s.isSingleExecution,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        redefinedBehavior <- s.redefinedBehavior,
        ownedParameter <- s.ownedParameter,
        precondition <- s.precondition,
        postcondition <- s.postcondition,
        ownedParameterSet <- s.ownedParameterSet,
        specification <- s.specification,
        variable <- s.variable,
        node <- s.node,
        edge <- s.edge,
        partition <- s.partition,
        group <- s.group)
}

rule Variable {
    from s : UML2!""uml::Variable"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Variable"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        type <- s.type,
        templateParameter <- s.templateParameter,
        end <- s.end,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue)
}

rule ActivityPartition {
    from s : UML2!""uml::ActivityPartition"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ActivityPartition"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isDimension <- s.isDimension,
        isExternal <- s.isExternal,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        node <- s.node,
        subpartition <- s.subpartition,
        represents <- s.represents,
        edge <- s.edge)
}

rule InterruptibleActivityRegion {
    from s : UML2!""uml::InterruptibleActivityRegion"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::InterruptibleActivityRegion"" mapsTo s (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        node <- s.node,
        interruptingEdge <- s.interruptingEdge)
}

rule ExceptionHandler {
    from s : UML2!""uml::ExceptionHandler"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ExceptionHandler"" mapsTo s (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        handlerBody <- s.handlerBody,
        exceptionInput <- s.exceptionInput,
        exceptionType <- s.exceptionType)
}

rule OutputPin {
    from s : UML2!""uml::OutputPin"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::OutputPin"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        ordering <- s.ordering,
        isControlType <- s.isControlType,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        isControl <- s.isControl,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        type <- s.type,
        upperBound <- s.upperBound,
        inState <- s.inState,
        selection <- s.selection,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue)
}

rule Pin {
    from s : UML2!""uml::Pin"" (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!""uml::Pin"")
		else false endif)
    to t : UML2!""uml::Pin"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        ordering <- s.ordering,
        isControlType <- s.isControlType,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        isControl <- s.isControl,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        type <- s.type,
        upperBound <- s.upperBound,
        inState <- s.inState,
        selection <- s.selection,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue)
}

rule InputPin {
    from s : UML2!""uml::InputPin"" (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!""uml::InputPin"")
		else false endif)
    to t : UML2!""uml::InputPin"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        ordering <- s.ordering,
        isControlType <- s.isControlType,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        isControl <- s.isControl,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        type <- s.type,
        upperBound <- s.upperBound,
        inState <- s.inState,
        selection <- s.selection,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue)
}

rule SendSignalAction {
    from s : UML2!""uml::SendSignalAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::SendSignalAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        argument <- s.argument,
        onPort <- s.onPort,
        target <- s.target,
        signal <- s.signal)
}

rule CallOperationAction {
    from s : UML2!""uml::CallOperationAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::CallOperationAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isSynchronous <- s.isSynchronous,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        argument <- s.argument,
        onPort <- s.onPort,
        result <- s.result,
        operation <- s.operation,
        target <- s.target)
}

rule CallBehaviorAction {
    from s : UML2!""uml::CallBehaviorAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::CallBehaviorAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isSynchronous <- s.isSynchronous,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        argument <- s.argument,
        onPort <- s.onPort,
        result <- s.result,
        behavior <- s.behavior)
}

rule SequenceNode {
    from s : UML2!""uml::SequenceNode"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::SequenceNode"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        mustIsolate <- s.mustIsolate,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        variable <- s.variable,
        edge <- s.edge,
        node <- s.node,
        executableNode <- s.executableNode)
}

rule Usage {
    from s : UML2!""uml::Usage"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Usage"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        client <- s.client)
}

rule ControlFlow {
    from s : UML2!""uml::ControlFlow"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ControlFlow"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        source <- s.source,
        target <- s.target,
        redefinedEdge <- s.redefinedEdge,
        inPartition <- s.inPartition,
        guard <- s.guard,
        weight <- s.weight,
        interrupts <- s.interrupts)
}

rule InitialNode {
    from s : UML2!""uml::InitialNode"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::InitialNode"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode)
}

rule ActivityParameterNode {
    from s : UML2!""uml::ActivityParameterNode"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ActivityParameterNode"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        ordering <- s.ordering,
        isControlType <- s.isControlType,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        type <- s.type,
        upperBound <- s.upperBound,
        inState <- s.inState,
        selection <- s.selection,
        parameter <- s.parameter)
}

rule ValuePin {
    from s : UML2!""uml::ValuePin"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ValuePin"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        ordering <- s.ordering,
        isControlType <- s.isControlType,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        isControl <- s.isControl,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        type <- s.type,
        upperBound <- s.upperBound,
        inState <- s.inState,
        selection <- s.selection,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue,
        value <- s.value)
}

rule Message {
    from s : UML2!""uml::Message"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Message"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        messageSort <- s.messageSort,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        receiveEvent <- s.receiveEvent,
        sendEvent <- s.sendEvent,
        connector <- s.connector,
        argument <- s.argument)
}

rule Interaction {
    from s : UML2!""uml::Interaction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Interaction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        isReentrant <- s.isReentrant,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        redefinedBehavior <- s.redefinedBehavior,
        ownedParameter <- s.ownedParameter,
        precondition <- s.precondition,
        postcondition <- s.postcondition,
        ownedParameterSet <- s.ownedParameterSet,
        specification <- s.specification,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        lifeline <- s.lifeline,
        fragment <- s.fragment,
        action <- s.action,
        formalGate <- s.formalGate,
        message <- s.message)
}

rule Lifeline {
    from s : UML2!""uml::Lifeline"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Lifeline"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        represents <- s.represents,
        selector <- s.selector,
        decomposedAs <- s.decomposedAs,
        coveredBy <- s.coveredBy)
}

rule PartDecomposition {
    from s : UML2!""uml::PartDecomposition"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::PartDecomposition"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        refersTo <- s.refersTo,
        actualGate <- s.actualGate,
        argument <- s.argument)
}

rule InteractionUse {
    from s : UML2!""uml::InteractionUse"" (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!""uml::InteractionUse"")
		else false endif)
    to t : UML2!""uml::InteractionUse"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        refersTo <- s.refersTo,
        actualGate <- s.actualGate,
        argument <- s.argument)
}

rule Gate {
    from s : UML2!""uml::Gate"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Gate"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        message <- s.message)
}

rule GeneralOrdering {
    from s : UML2!""uml::GeneralOrdering"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::GeneralOrdering"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        before <- s.before,
        after <- s.after)
}

rule OccurrenceSpecification {
    from s : UML2!""uml::OccurrenceSpecification"" (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!""uml::OccurrenceSpecification"")
		else false endif)
    to t : UML2!""uml::OccurrenceSpecification"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        toBefore <- s.toBefore,
        event <- s.event,
        toAfter <- s.toAfter)
}

rule InteractionOperand {
    from s : UML2!""uml::InteractionOperand"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::InteractionOperand"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        guard <- s.guard,
        fragment <- s.fragment)
}

rule InteractionConstraint {
    from s : UML2!""uml::InteractionConstraint"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::InteractionConstraint"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        constrainedElement <- s.constrainedElement,
        specification <- s.specification,
        minint <- s.minint,
        maxint <- s.maxint)
}

rule StateInvariant {
    from s : UML2!""uml::StateInvariant"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::StateInvariant"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        invariant <- s.invariant)
}

rule ActionExecutionSpecification {
    from s : UML2!""uml::ActionExecutionSpecification"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ActionExecutionSpecification"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        start <- s.start,
        finish <- s.finish,
        action <- s.action)
}

rule BehaviorExecutionSpecification {
    from s : UML2!""uml::BehaviorExecutionSpecification"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::BehaviorExecutionSpecification"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        start <- s.start,
        finish <- s.finish,
        behavior <- s.behavior)
}

rule ExecutionEvent {
    from s : UML2!""uml::ExecutionEvent"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ExecutionEvent"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter)
}

rule CreationEvent {
    from s : UML2!""uml::CreationEvent"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::CreationEvent"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter)
}

rule DestructionEvent {
    from s : UML2!""uml::DestructionEvent"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::DestructionEvent"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter)
}

rule SendOperationEvent {
    from s : UML2!""uml::SendOperationEvent"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::SendOperationEvent"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        operation <- s.operation)
}

rule SendSignalEvent {
    from s : UML2!""uml::SendSignalEvent"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::SendSignalEvent"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        signal <- s.signal)
}

rule MessageOccurrenceSpecification {
    from s : UML2!""uml::MessageOccurrenceSpecification"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::MessageOccurrenceSpecification"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        toBefore <- s.toBefore,
        event <- s.event,
        toAfter <- s.toAfter,
        message <- s.message)
}

rule ExecutionOccurrenceSpecification {
    from s : UML2!""uml::ExecutionOccurrenceSpecification"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ExecutionOccurrenceSpecification"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        toBefore <- s.toBefore,
        event <- s.event,
        toAfter <- s.toAfter,
        execution <- s.execution)
}

rule ReceiveOperationEvent {
    from s : UML2!""uml::ReceiveOperationEvent"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ReceiveOperationEvent"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        operation <- s.operation)
}

rule ReceiveSignalEvent {
    from s : UML2!""uml::ReceiveSignalEvent"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ReceiveSignalEvent"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        signal <- s.signal)
}

rule Actor {
    from s : UML2!""uml::Actor"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Actor"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger)
}

rule CallEvent {
    from s : UML2!""uml::CallEvent"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::CallEvent"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        operation <- s.operation)
}

rule ChangeEvent {
    from s : UML2!""uml::ChangeEvent"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ChangeEvent"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        changeExpression <- s.changeExpression)
}

rule SignalEvent {
    from s : UML2!""uml::SignalEvent"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::SignalEvent"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        signal <- s.signal)
}

rule AnyReceiveEvent {
    from s : UML2!""uml::AnyReceiveEvent"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::AnyReceiveEvent"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter)
}

rule ForkNode {
    from s : UML2!""uml::ForkNode"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ForkNode"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode)
}

rule FlowFinalNode {
    from s : UML2!""uml::FlowFinalNode"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::FlowFinalNode"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode)
}

rule CentralBufferNode {
    from s : UML2!""uml::CentralBufferNode"" (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!""uml::CentralBufferNode"")
		else false endif)
    to t : UML2!""uml::CentralBufferNode"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        ordering <- s.ordering,
        isControlType <- s.isControlType,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        type <- s.type,
        upperBound <- s.upperBound,
        inState <- s.inState,
        selection <- s.selection)
}

rule MergeNode {
    from s : UML2!""uml::MergeNode"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::MergeNode"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode)
}

rule DecisionNode {
    from s : UML2!""uml::DecisionNode"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::DecisionNode"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        decisionInput <- s.decisionInput)
}

rule ActivityFinalNode {
    from s : UML2!""uml::ActivityFinalNode"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ActivityFinalNode"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode)
}

rule ComponentRealization {
    from s : UML2!""uml::ComponentRealization"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ComponentRealization"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        client <- s.client,
        mapping <- s.mapping,
        realizingClassifier <- s.realizingClassifier)
}

rule Component {
    from s : UML2!""uml::Component"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Component"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        isIndirectlyInstantiated <- s.isIndirectlyInstantiated,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        packagedElement <- s.packagedElement,
        realization <- s.realization)
}

rule Node {
    from s : UML2!""uml::Node"" (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!""uml::Node"")
		else false endif)
    to t : UML2!""uml::Node"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        deployment <- s.deployment,
        nestedNode <- s.nestedNode)
}

rule Device {
    from s : UML2!""uml::Device"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Device"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        deployment <- s.deployment,
        nestedNode <- s.nestedNode)
}

rule ExecutionEnvironment {
    from s : UML2!""uml::ExecutionEnvironment"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ExecutionEnvironment"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        deployment <- s.deployment,
        nestedNode <- s.nestedNode)
}

rule CommunicationPath {
    from s : UML2!""uml::CommunicationPath"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::CommunicationPath"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isDerived <- s.isDerived,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedEnd <- s.ownedEnd,
        memberEnd <- s.memberEnd,
        navigableOwnedEnd <- s.navigableOwnedEnd)
}

rule CombinedFragment {
    from s : UML2!""uml::CombinedFragment"" (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!""uml::CombinedFragment"")
		else false endif)
    to t : UML2!""uml::CombinedFragment"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        interactionOperator <- s.interactionOperator,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        operand <- s.operand,
        cfragmentGate <- s.cfragmentGate)
}

rule Continuation {
    from s : UML2!""uml::Continuation"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Continuation"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        setting <- s.setting,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering)
}

rule ConsiderIgnoreFragment {
    from s : UML2!""uml::ConsiderIgnoreFragment"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ConsiderIgnoreFragment"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        interactionOperator <- s.interactionOperator,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        operand <- s.operand,
        cfragmentGate <- s.cfragmentGate,
        message <- s.message)
}

rule CreateObjectAction {
    from s : UML2!""uml::CreateObjectAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::CreateObjectAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        classifier <- s.classifier,
        result <- s.result)
}

rule DestroyObjectAction {
    from s : UML2!""uml::DestroyObjectAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::DestroyObjectAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isDestroyLinks <- s.isDestroyLinks,
        isDestroyOwnedObjects <- s.isDestroyOwnedObjects,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        target <- s.target)
}

rule TestIdentityAction {
    from s : UML2!""uml::TestIdentityAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::TestIdentityAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        first <- s.first,
        second <- s.second,
        result <- s.result)
}

rule ReadSelfAction {
    from s : UML2!""uml::ReadSelfAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ReadSelfAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        result <- s.result)
}

rule ReadStructuralFeatureAction {
    from s : UML2!""uml::ReadStructuralFeatureAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ReadStructuralFeatureAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        structuralFeature <- s.structuralFeature,
        object <- s.object,
        result <- s.result)
}

rule ClearStructuralFeatureAction {
    from s : UML2!""uml::ClearStructuralFeatureAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ClearStructuralFeatureAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        structuralFeature <- s.structuralFeature,
        object <- s.object)
}

rule RemoveStructuralFeatureValueAction {
    from s : UML2!""uml::RemoveStructuralFeatureValueAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::RemoveStructuralFeatureValueAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isRemoveDuplicates <- s.isRemoveDuplicates,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        structuralFeature <- s.structuralFeature,
        object <- s.object,
        value <- s.value,
        removeAt <- s.removeAt)
}

rule AddStructuralFeatureValueAction {
    from s : UML2!""uml::AddStructuralFeatureValueAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::AddStructuralFeatureValueAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isReplaceAll <- s.isReplaceAll,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        structuralFeature <- s.structuralFeature,
        object <- s.object,
        value <- s.value,
        insertAt <- s.insertAt)
}

rule LinkEndData {
    from s : UML2!""uml::LinkEndData"" (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!""uml::LinkEndData"")
		else false endif)
    to t : UML2!""uml::LinkEndData"" mapsTo s (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        value <- s.value,
        end <- s.end,
        qualifier <- s.qualifier)
}

rule QualifierValue {
    from s : UML2!""uml::QualifierValue"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::QualifierValue"" mapsTo s (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        qualifier <- s.qualifier,
        value <- s.value)
}

rule ReadLinkAction {
    from s : UML2!""uml::ReadLinkAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ReadLinkAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        endData <- s.endData,
        inputValue <- s.inputValue,
        result <- s.result)
}

rule LinkEndCreationData {
    from s : UML2!""uml::LinkEndCreationData"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::LinkEndCreationData"" mapsTo s (
        isReplaceAll <- s.isReplaceAll,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        value <- s.value,
        end <- s.end,
        qualifier <- s.qualifier,
        insertAt <- s.insertAt)
}

rule CreateLinkAction {
    from s : UML2!""uml::CreateLinkAction"" (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!""uml::CreateLinkAction"")
		else false endif)
    to t : UML2!""uml::CreateLinkAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        endData <- s.endData,
        inputValue <- s.inputValue)
}

rule DestroyLinkAction {
    from s : UML2!""uml::DestroyLinkAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::DestroyLinkAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        endData <- s.endData,
        inputValue <- s.inputValue)
}

rule LinkEndDestructionData {
    from s : UML2!""uml::LinkEndDestructionData"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::LinkEndDestructionData"" mapsTo s (
        isDestroyDuplicates <- s.isDestroyDuplicates,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        value <- s.value,
        end <- s.end,
        qualifier <- s.qualifier,
        destroyAt <- s.destroyAt)
}

rule ClearAssociationAction {
    from s : UML2!""uml::ClearAssociationAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ClearAssociationAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        object <- s.object,
        association <- s.association)
}

rule BroadcastSignalAction {
    from s : UML2!""uml::BroadcastSignalAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::BroadcastSignalAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        argument <- s.argument,
        onPort <- s.onPort,
        signal <- s.signal)
}

rule SendObjectAction {
    from s : UML2!""uml::SendObjectAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::SendObjectAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        argument <- s.argument,
        onPort <- s.onPort,
        target <- s.target,
        request <- s.request)
}

rule ValueSpecificationAction {
    from s : UML2!""uml::ValueSpecificationAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ValueSpecificationAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        value <- s.value,
        result <- s.result)
}

rule TimeExpression {
    from s : UML2!""uml::TimeExpression"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::TimeExpression"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type,
        expr <- s.expr,
        observation <- s.observation)
}

rule Duration {
    from s : UML2!""uml::Duration"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Duration"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type,
        expr <- s.expr,
        observation <- s.observation)
}

rule DurationInterval {
    from s : UML2!""uml::DurationInterval"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::DurationInterval"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type,
        min <- s.min,
        max <- s.max)
}

rule Interval {
    from s : UML2!""uml::Interval"" (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!""uml::Interval"")
		else false endif)
    to t : UML2!""uml::Interval"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type,
        min <- s.min,
        max <- s.max)
}

rule TimeConstraint {
    from s : UML2!""uml::TimeConstraint"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::TimeConstraint"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        firstEvent <- s.firstEvent,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        constrainedElement <- s.constrainedElement,
        specification <- s.specification)
}

rule IntervalConstraint {
    from s : UML2!""uml::IntervalConstraint"" (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!""uml::IntervalConstraint"")
		else false endif)
    to t : UML2!""uml::IntervalConstraint"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        constrainedElement <- s.constrainedElement,
        specification <- s.specification)
}

rule TimeInterval {
    from s : UML2!""uml::TimeInterval"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::TimeInterval"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type,
        min <- s.min,
        max <- s.max)
}

rule DurationConstraint {
    from s : UML2!""uml::DurationConstraint"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::DurationConstraint"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        firstEvent <- s.firstEvent,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        constrainedElement <- s.constrainedElement,
        specification <- s.specification)
}

rule TimeObservation {
    from s : UML2!""uml::TimeObservation"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::TimeObservation"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        firstEvent <- s.firstEvent,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        event <- s.event)
}

rule DurationObservation {
    from s : UML2!""uml::DurationObservation"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::DurationObservation"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        firstEvent <- s.firstEvent,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        event <- s.event)
}

rule FinalState {
    from s : UML2!""uml::FinalState"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::FinalState"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        submachine <- s.submachine,
        connection <- s.connection,
        connectionPoint <- s.connectionPoint,
        redefinedState <- s.redefinedState,
        stateInvariant <- s.stateInvariant,
        entry <- s.entry,
        exit <- s.exit,
        doActivity <- s.doActivity,
        deferrableTrigger <- s.deferrableTrigger,
        region <- s.region)
}

rule TimeEvent {
    from s : UML2!""uml::TimeEvent"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::TimeEvent"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isRelative <- s.isRelative,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        when <- s.when)
}

rule ReadVariableAction {
    from s : UML2!""uml::ReadVariableAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ReadVariableAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        variable <- s.variable,
        result <- s.result)
}

rule ClearVariableAction {
    from s : UML2!""uml::ClearVariableAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ClearVariableAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        variable <- s.variable)
}

rule AddVariableValueAction {
    from s : UML2!""uml::AddVariableValueAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::AddVariableValueAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isReplaceAll <- s.isReplaceAll,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        variable <- s.variable,
        value <- s.value,
        insertAt <- s.insertAt)
}

rule RemoveVariableValueAction {
    from s : UML2!""uml::RemoveVariableValueAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::RemoveVariableValueAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isRemoveDuplicates <- s.isRemoveDuplicates,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        variable <- s.variable,
        value <- s.value,
        removeAt <- s.removeAt)
}

rule RaiseExceptionAction {
    from s : UML2!""uml::RaiseExceptionAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::RaiseExceptionAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        exception <- s.exception)
}

rule ActionInputPin {
    from s : UML2!""uml::ActionInputPin"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ActionInputPin"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        ordering <- s.ordering,
        isControlType <- s.isControlType,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        isControl <- s.isControl,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        type <- s.type,
        upperBound <- s.upperBound,
        inState <- s.inState,
        selection <- s.selection,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue,
        fromAction <- s.fromAction)
}

rule InformationItem {
    from s : UML2!""uml::InformationItem"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::InformationItem"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        represented <- s.represented)
}

rule InformationFlow {
    from s : UML2!""uml::InformationFlow"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::InformationFlow"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        realization <- s.realization,
        conveyed <- s.conveyed,
        informationSource <- s.informationSource,
        informationTarget <- s.informationTarget,
        realizingActivityEdge <- s.realizingActivityEdge,
        realizingConnector <- s.realizingConnector,
        realizingMessage <- s.realizingMessage)
}

rule ReadExtentAction {
    from s : UML2!""uml::ReadExtentAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ReadExtentAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        result <- s.result,
        classifier <- s.classifier)
}

rule ReclassifyObjectAction {
    from s : UML2!""uml::ReclassifyObjectAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ReclassifyObjectAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isReplaceAll <- s.isReplaceAll,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        oldClassifier <- s.oldClassifier,
        newClassifier <- s.newClassifier,
        object <- s.object)
}

rule ReadIsClassifiedObjectAction {
    from s : UML2!""uml::ReadIsClassifiedObjectAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ReadIsClassifiedObjectAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isDirect <- s.isDirect,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        classifier <- s.classifier,
        result <- s.result,
        object <- s.object)
}

rule StartClassifierBehaviorAction {
    from s : UML2!""uml::StartClassifierBehaviorAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::StartClassifierBehaviorAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        object <- s.object)
}

rule ReadLinkObjectEndAction {
    from s : UML2!""uml::ReadLinkObjectEndAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ReadLinkObjectEndAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        object <- s.object,
        end <- s.end,
        result <- s.result)
}

rule ReadLinkObjectEndQualifierAction {
    from s : UML2!""uml::ReadLinkObjectEndQualifierAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ReadLinkObjectEndQualifierAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        object <- s.object,
        result <- s.result,
        qualifier <- s.qualifier)
}

rule CreateLinkObjectAction {
    from s : UML2!""uml::CreateLinkObjectAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::CreateLinkObjectAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        endData <- s.endData,
        inputValue <- s.inputValue,
        result <- s.result)
}

rule AcceptEventAction {
    from s : UML2!""uml::AcceptEventAction"" (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!""uml::AcceptEventAction"")
		else false endif)
    to t : UML2!""uml::AcceptEventAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isUnmarshall <- s.isUnmarshall,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        result <- s.result,
        trigger <- s.trigger)
}

rule AcceptCallAction {
    from s : UML2!""uml::AcceptCallAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::AcceptCallAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isUnmarshall <- s.isUnmarshall,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        result <- s.result,
        trigger <- s.trigger,
        returnInformation <- s.returnInformation)
}

rule ReplyAction {
    from s : UML2!""uml::ReplyAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ReplyAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        replyToCall <- s.replyToCall,
        returnInformation <- s.returnInformation,
        replyValue <- s.replyValue)
}

rule UnmarshallAction {
    from s : UML2!""uml::UnmarshallAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::UnmarshallAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        result <- s.result,
        unmarshallType <- s.unmarshallType,
        object <- s.object)
}

rule ReduceAction {
    from s : UML2!""uml::ReduceAction"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ReduceAction"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isOrdered <- s.isOrdered,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        reducer <- s.reducer,
        result <- s.result,
        collection <- s.collection)
}

rule JoinNode {
    from s : UML2!""uml::JoinNode"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::JoinNode"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isCombineDuplicate <- s.isCombineDuplicate,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        joinSpec <- s.joinSpec)
}

rule DataStoreNode {
    from s : UML2!""uml::DataStoreNode"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::DataStoreNode"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        ordering <- s.ordering,
        isControlType <- s.isControlType,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        type <- s.type,
        upperBound <- s.upperBound,
        inState <- s.inState,
        selection <- s.selection)
}

rule ObjectFlow {
    from s : UML2!""uml::ObjectFlow"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ObjectFlow"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isMulticast <- s.isMulticast,
        isMultireceive <- s.isMultireceive,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        source <- s.source,
        target <- s.target,
        redefinedEdge <- s.redefinedEdge,
        inPartition <- s.inPartition,
        guard <- s.guard,
        weight <- s.weight,
        interrupts <- s.interrupts,
        transformation <- s.transformation,
        selection <- s.selection)
}

rule ConditionalNode {
    from s : UML2!""uml::ConditionalNode"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ConditionalNode"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        mustIsolate <- s.mustIsolate,
        isDeterminate <- s.isDeterminate,
        isAssured <- s.isAssured,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        variable <- s.variable,
        edge <- s.edge,
        node <- s.node,
        clause <- s.clause,
        result <- s.result)
}

rule Clause {
    from s : UML2!""uml::Clause"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::Clause"" mapsTo s (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        test <- s.test,
        body <- s.body,
        predecessorClause <- s.predecessorClause,
        successorClause <- s.successorClause,
        decider <- s.decider,
        bodyOutput <- s.bodyOutput)
}

rule LoopNode {
    from s : UML2!""uml::LoopNode"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::LoopNode"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        mustIsolate <- s.mustIsolate,
        isTestedFirst <- s.isTestedFirst,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        variable <- s.variable,
        edge <- s.edge,
        node <- s.node,
        bodyPart <- s.bodyPart,
        setupPart <- s.setupPart,
        decider <- s.decider,
        test <- s.test,
        result <- s.result,
        loopVariable <- s.loopVariable,
        bodyOutput <- s.bodyOutput,
        loopVariableInput <- s.loopVariableInput)
}

rule ExpansionNode {
    from s : UML2!""uml::ExpansionNode"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ExpansionNode"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        ordering <- s.ordering,
        isControlType <- s.isControlType,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        type <- s.type,
        upperBound <- s.upperBound,
        inState <- s.inState,
        selection <- s.selection,
        regionAsOutput <- s.regionAsOutput,
        regionAsInput <- s.regionAsInput)
}

rule ExpansionRegion {
    from s : UML2!""uml::ExpansionRegion"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ExpansionRegion"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        mustIsolate <- s.mustIsolate,
        mode <- s.mode,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        variable <- s.variable,
        edge <- s.edge,
        node <- s.node,
        inputElement <- s.inputElement,
        outputElement <- s.outputElement)
}

rule ProtocolTransition {
    from s : UML2!""uml::ProtocolTransition"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::ProtocolTransition"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        kind <- s.kind,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        target <- s.target,
        redefinedTransition <- s.redefinedTransition,
        guard <- s.guard,
        effect <- s.effect,
        trigger <- s.trigger,
        source <- s.source,
        postCondition <- s.postCondition,
        preCondition <- s.preCondition)
}

rule AssociationClass {
    from s : UML2!""uml::AssociationClass"" (thisModule.inElements->includes(s))
    to t : UML2!""uml::AssociationClass"" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        isDerived <- s.isDerived,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        ownedEnd <- s.ownedEnd,
        memberEnd <- s.memberEnd,
        navigableOwnedEnd <- s.navigableOwnedEnd)
}

-- ======================================================================
-- UML2 copying rules end
-- ======================================================================
	
endpoint rule end() {
	do {

	}
}",atlcompil atl id copi uml model modul uml copi creat out uml in uml helper def inel set uml ecor eobject uml ecor eobject allinstancesfrom in ecor copi rule begin generat emodelcopygener atl z dwagelaa rule eannot uml ecor eannot thismodul inel includ uml ecor eannot mapsto sourc sourc eannot eannot detail detail content content refer refer rule estringtostringmapentri uml ecor estringtostringmapentri thismodul inel includ uml ecor estringtostringmapentri mapsto key key valu valu ecor copi rule end uml copi rule begin generat emodelcopygener atl z dwagelaa rule comment uml uml comment thismodul inel includ uml uml comment mapsto bodi bodi eannot eannot ownedcom ownedcom annotatedel annotatedel rule packag uml uml packag thismodul inel includ oclistypeof uml uml packag els fals endif uml uml packag mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul templateparamet templateparamet templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur packagemerg packagemerg packagedel packagedel profileappl profileappl rule depend uml uml depend thismodul inel includ oclistypeof uml uml depend els fals endif uml uml depend mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet supplier supplier client client rule elementimport uml uml elementimport thismodul inel includ uml uml elementimport mapsto visibl visibl alia alia eannot eannot ownedcom ownedcom importedel importedel rule packageimport uml uml packageimport thismodul inel includ uml uml packageimport mapsto visibl visibl eannot eannot ownedcom ownedcom importedpackag importedpackag rule constraint uml uml constraint thismodul inel includ oclistypeof uml uml constraint els fals endif uml uml constraint mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet constrainedel constrainedel specif specif rule associ uml uml associ thismodul inel includ oclistypeof uml uml associ els fals endif uml uml associ mapsto name name visibl visibl isleaf isleaf isabstract isabstract isderiv isderiv eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul templateparamet templateparamet templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur general general powertypeext powertypeext redefinedclassifi redefinedclassifi substitut substitut represent represent collaborationus collaborationus ownedusecas ownedusecas usecas usecas ownedend ownedend memberend memberend navigableownedend navigableownedend rule templatebind uml uml templatebind thismodul inel includ uml uml templatebind mapsto eannot eannot ownedcom ownedcom signatur signatur parametersubstitut parametersubstitut rule templatesignatur uml uml templatesignatur thismodul inel includ oclistypeof uml uml templatesignatur els fals endif uml uml templatesignatur mapsto eannot eannot ownedcom ownedcom paramet paramet ownedparamet ownedparamet rule templateparamet uml uml templateparamet thismodul inel includ oclistypeof uml uml templateparamet els fals endif uml uml templateparamet mapsto eannot eannot ownedcom ownedcom parameteredel parameteredel ownedparameteredel ownedparameteredel default default owneddefault owneddefault rule templateparametersubstitut uml uml templateparametersubstitut thismodul inel includ uml uml templateparametersubstitut mapsto eannot eannot ownedcom ownedcom formal formal actual actual ownedactu ownedactu rule general uml uml general thismodul inel includ uml uml general mapsto issubstitut issubstitut eannot eannot ownedcom ownedcom general general generalizationset generalizationset rule generalizationset uml uml generalizationset thismodul inel includ uml uml generalizationset mapsto name name visibl visibl iscov iscov isdisjoint isdisjoint eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet powertyp powertyp general general rule substitut uml uml substitut thismodul inel includ uml uml substitut mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet supplier supplier client client map map contract contract rule realize uml uml realize thismodul inel includ oclistypeof uml uml realize els fals endif uml uml realize mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet supplier supplier client client map map rule abstract uml uml abstract thismodul inel includ oclistypeof uml uml abstract els fals endif uml uml abstract mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet supplier supplier client client map map rule opaqueexpress uml uml opaqueexpress thismodul inel includ uml uml opaqueexpress mapsto name name visibl visibl bodi bodi languag languag eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet type type behavior behavior rule paramet uml uml paramet thismodul inel includ uml uml paramet mapsto name name visibl visibl isord isord isuniqu isuniqu direct direct isexcept isexcept isstream isstream effect effect eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress type type templateparamet templateparamet end end uppervalu uppervalu lowervalu lowervalu parameterset parameterset defaultvalu defaultvalu rule connectorend uml uml connectorend thismodul inel includ uml uml connectorend mapsto isord isord isuniqu isuniqu eannot eannot ownedcom ownedcom uppervalu uppervalu lowervalu lowervalu partwithport partwithport role role rule properti uml uml properti thismodul inel includ oclistypeof uml uml properti els fals endif uml uml properti mapsto name name visibl visibl isleaf isleaf isstat isstat isord isord isuniqu isuniqu isreadon isreadon isderiv isderiv isderivedunion isderivedunion aggreg aggreg eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress type type uppervalu uppervalu lowervalu lowervalu templateparamet templateparamet end end deploy deploy templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur redefinedproperti redefinedproperti defaultvalu defaultvalu subsettedproperti subsettedproperti associ associ qualifi qualifi rule deploy uml uml deploy thismodul inel includ uml uml deploy mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet supplier supplier client client deployedartifact deployedartifact configur configur rule deploymentspecif uml uml deploymentspecif thismodul inel includ uml uml deploymentspecif mapsto name name visibl visibl isleaf isleaf isabstract isabstract filenam filenam deploymentloc deploymentloc executionloc executionloc eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul templateparamet templateparamet templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur general general powertypeext powertypeext redefinedclassifi redefinedclassifi substitut substitut represent represent collaborationus collaborationus ownedusecas ownedusecas usecas usecas nestedartifact nestedartifact manifest manifest ownedoper ownedoper ownedattribut ownedattribut rule artifact uml uml artifact thismodul inel includ oclistypeof uml uml artifact els fals endif uml uml artifact mapsto name name visibl visibl isleaf isleaf isabstract isabstract filenam filenam eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul templateparamet templateparamet templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur general general powertypeext powertypeext redefinedclassifi redefinedclassifi substitut substitut represent represent collaborationus collaborationus ownedusecas ownedusecas usecas usecas nestedartifact nestedartifact manifest manifest ownedoper ownedoper ownedattribut ownedattribut rule manifest uml uml manifest thismodul inel includ uml uml manifest mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet supplier supplier client client map map utilizedel utilizedel rule oper uml uml oper thismodul inel includ uml uml oper mapsto name name visibl visibl isleaf isleaf isstat isstat isabstract isabstract concurr concurr isqueri isqueri eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul ownedparamet ownedparamet method method raisedexcept raisedexcept ownedparameterset ownedparameterset templateparamet templateparamet templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur precondit precondit postcondit postcondit redefinedoper redefinedoper bodycondit bodycondit rule class uml uml class thismodul inel includ oclistypeof uml uml class els fals endif uml uml class mapsto name name visibl visibl isleaf isleaf isabstract isabstract isact isact eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul templateparamet templateparamet templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur general general powertypeext powertypeext redefinedclassifi redefinedclassifi substitut substitut represent represent collaborationus collaborationus ownedusecas ownedusecas usecas usecas ownedattribut ownedattribut ownedconnector ownedconnector ownedbehavior ownedbehavior classifierbehavior classifierbehavior interfacer interfacer ownedtrigg ownedtrigg nestedclassifi nestedclassifi ownedoper ownedoper ownedrecept ownedrecept rule interfacer uml uml interfacer thismodul inel includ uml uml interfacer mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet supplier supplier client client map map contract contract rule interfac uml uml interfac thismodul inel includ uml uml interfac mapsto name name visibl visibl isleaf isleaf isabstract isabstract eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul templateparamet templateparamet templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur general general powertypeext powertypeext redefinedclassifi redefinedclassifi substitut substitut represent represent collaborationus collaborationus ownedusecas ownedusecas usecas usecas ownedattribut ownedattribut ownedoper ownedoper nestedclassifi nestedclassifi redefinedinterfac redefinedinterfac ownedrecept ownedrecept protocol protocol rule recept uml uml recept thismodul inel includ uml uml recept mapsto name name visibl visibl isleaf isleaf isstat isstat isabstract isabstract concurr concurr eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul ownedparamet ownedparamet method method raisedexcept raisedexcept ownedparameterset ownedparameterset signal signal rule signal uml uml signal thismodul inel includ uml uml signal mapsto name name visibl visibl isleaf isleaf isabstract isabstract eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul templateparamet templateparamet templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur general general powertypeext powertypeext redefinedclassifi redefinedclassifi substitut substitut represent represent collaborationus collaborationus ownedusecas ownedusecas usecas usecas ownedattribut ownedattribut rule protocolstatemachin uml uml protocolstatemachin thismodul inel includ uml uml protocolstatemachin mapsto name name visibl visibl isleaf isleaf isabstract isabstract isact isact isreentr isreentr eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul templateparamet templateparamet templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur general general powertypeext powertypeext redefinedclassifi redefinedclassifi substitut substitut represent represent collaborationus collaborationus ownedusecas ownedusecas usecas usecas ownedattribut ownedattribut ownedconnector ownedconnector ownedbehavior ownedbehavior classifierbehavior classifierbehavior interfacer interfacer ownedtrigg ownedtrigg nestedclassifi nestedclassifi ownedoper ownedoper ownedrecept ownedrecept redefinedbehavior redefinedbehavior ownedparamet ownedparamet precondit precondit postcondit postcondit ownedparameterset ownedparameterset specif specif region region submachinest submachinest connectionpoint connectionpoint extendedstatemachin extendedstatemachin conform conform rule statemachin uml uml statemachin thismodul inel includ oclistypeof uml uml statemachin els fals endif uml uml statemachin mapsto name name visibl visibl isleaf isleaf isabstract isabstract isact isact isreentr isreentr eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul templateparamet templateparamet templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur general general powertypeext powertypeext redefinedclassifi redefinedclassifi substitut substitut represent represent collaborationus collaborationus ownedusecas ownedusecas usecas usecas ownedattribut ownedattribut ownedconnector ownedconnector ownedbehavior ownedbehavior classifierbehavior classifierbehavior interfacer interfacer ownedtrigg ownedtrigg nestedclassifi nestedclassifi ownedoper ownedoper ownedrecept ownedrecept redefinedbehavior redefinedbehavior ownedparamet ownedparamet precondit precondit postcondit postcondit ownedparameterset ownedparameterset specif specif region region submachinest submachinest connectionpoint connectionpoint extendedstatemachin extendedstatemachin rule region uml uml region thismodul inel includ uml uml region mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul subvertex subvertex transit transit extendedregion extendedregion rule transit uml uml transit thismodul inel includ oclistypeof uml uml transit els fals endif uml uml transit mapsto name name visibl visibl isleaf isleaf kind kind eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul target target redefinedtransit redefinedtransit guard guard effect effect trigger trigger sourc sourc rule trigger uml uml trigger thismodul inel includ uml uml trigger mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress event event port port rule port uml uml port thismodul inel includ uml uml port mapsto name name visibl visibl isleaf isleaf isstat isstat isord isord isuniqu isuniqu isreadon isreadon isderiv isderiv isderivedunion isderivedunion aggreg aggreg isbehavior isbehavior isservic isservic eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress type type uppervalu uppervalu lowervalu lowervalu templateparamet templateparamet end end deploy deploy templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur redefinedproperti redefinedproperti defaultvalu defaultvalu subsettedproperti subsettedproperti associ associ qualifi qualifi redefinedport redefinedport protocol protocol rule state uml uml state thismodul inel includ oclistypeof uml uml state els fals endif uml uml state mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul outgo outgo incom incom submachin submachin connect connect connectionpoint connectionpoint redefinedst redefinedst stateinvari stateinvari entri entri exit exit doactiv doactiv deferrabletrigg deferrabletrigg region region rule connectionpointrefer uml uml connectionpointrefer thismodul inel includ uml uml connectionpointrefer mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom entri entri exit exit rule pseudost uml uml pseudost thismodul inel includ uml uml pseudost mapsto name name visibl visibl kind kind eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom rule protocolconform uml uml protocolconform thismodul inel includ uml uml protocolconform mapsto eannot eannot ownedcom ownedcom generalmachin generalmachin rule connector uml uml connector thismodul inel includ uml uml connector mapsto name name visibl visibl isleaf isleaf isstat isstat kind kind eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress type type redefinedconnector redefinedconnector end end contract contract rule extens uml uml extens thismodul inel includ uml uml extens mapsto name name visibl visibl isleaf isleaf isabstract isabstract isderiv isderiv eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul templateparamet templateparamet templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur general general powertypeext powertypeext redefinedclassifi redefinedclassifi substitut substitut represent represent collaborationus collaborationus ownedusecas ownedusecas usecas usecas ownedend ownedend memberend memberend navigableownedend navigableownedend rule extensionend uml uml extensionend thismodul inel includ uml uml extensionend mapsto name name visibl visibl isleaf isleaf isstat isstat isord isord isuniqu isuniqu isreadon isreadon isderiv isderiv isderivedunion isderivedunion aggreg aggreg eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress type type uppervalu uppervalu lowervalu lowervalu templateparamet templateparamet end end deploy deploy templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur redefinedproperti redefinedproperti defaultvalu defaultvalu subsettedproperti subsettedproperti associ associ qualifi qualifi rule imag uml uml imag thismodul inel includ uml uml imag mapsto content content locat locat format format eannot eannot ownedcom ownedcom rule model uml uml model thismodul inel includ uml uml model mapsto name name visibl visibl viewpoint viewpoint eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul templateparamet templateparamet templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur packagemerg packagemerg packagedel packagedel profileappl profileappl rule parameterset uml uml parameterset thismodul inel includ uml uml parameterset mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress paramet paramet condit condit rule datatyp uml uml datatyp thismodul inel includ oclistypeof uml uml datatyp els fals endif uml uml datatyp mapsto name name visibl visibl isleaf isleaf isabstract isabstract eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul templateparamet templateparamet templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur general general powertypeext powertypeext redefinedclassifi redefinedclassifi substitut substitut represent represent collaborationus collaborationus ownedusecas ownedusecas usecas usecas ownedattribut ownedattribut ownedoper ownedoper rule operationtemplateparamet uml uml operationtemplateparamet thismodul inel includ uml uml operationtemplateparamet mapsto eannot eannot ownedcom ownedcom parameteredel parameteredel ownedparameteredel ownedparameteredel default default owneddefault owneddefault rule connectableelementtemplateparamet uml uml connectableelementtemplateparamet thismodul inel includ uml uml connectableelementtemplateparamet mapsto eannot eannot ownedcom ownedcom parameteredel parameteredel ownedparameteredel ownedparameteredel default default owneddefault owneddefault rule collaborationus uml uml collaborationus thismodul inel includ uml uml collaborationus mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress type type rolebind rolebind rule collabor uml uml collabor thismodul inel includ uml uml collabor mapsto name name visibl visibl isleaf isleaf isabstract isabstract eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul templateparamet templateparamet templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur general general powertypeext powertypeext redefinedclassifi redefinedclassifi substitut substitut represent represent collaborationus collaborationus ownedusecas ownedusecas usecas usecas ownedbehavior ownedbehavior classifierbehavior classifierbehavior interfacer interfacer ownedtrigg ownedtrigg ownedattribut ownedattribut ownedconnector ownedconnector collaborationrol collaborationrol rule usecas uml uml usecas thismodul inel includ uml uml usecas mapsto name name visibl visibl isleaf isleaf isabstract isabstract eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul templateparamet templateparamet templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur general general powertypeext powertypeext redefinedclassifi redefinedclassifi substitut substitut represent represent collaborationus collaborationus ownedusecas ownedusecas usecas usecas ownedbehavior ownedbehavior classifierbehavior classifierbehavior interfacer interfacer ownedtrigg ownedtrigg includ includ extend extend extensionpoint extensionpoint subject subject rule includ uml uml includ thismodul inel includ uml uml includ mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress addit addit rule extend uml uml extend thismodul inel includ uml uml extend mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress extendedcas extendedcas condit condit extensionloc extensionloc rule extensionpoint uml uml extensionpoint thismodul inel includ uml uml extensionpoint mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress rule redefinabletemplatesignatur uml uml redefinabletemplatesignatur thismodul inel includ uml uml redefinabletemplatesignatur mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress paramet paramet ownedparamet ownedparamet extendedsignatur extendedsignatur rule classifiertemplateparamet uml uml classifiertemplateparamet thismodul inel includ uml uml classifiertemplateparamet mapsto allowsubstitut allowsubstitut eannot eannot ownedcom ownedcom parameteredel parameteredel ownedparameteredel ownedparameteredel default default owneddefault owneddefault defaultclassifi defaultclassifi constrainingclassifi constrainingclassifi rule stringexpress uml uml stringexpress thismodul inel includ uml uml stringexpress mapsto name name visibl visibl symbol symbol eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet type type operand operand templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur subexpress subexpress rule express uml uml express thismodul inel includ oclistypeof uml uml express els fals endif uml uml express mapsto name name visibl visibl symbol symbol eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet type type operand operand rule packagemerg uml uml packagemerg thismodul inel includ uml uml packagemerg mapsto eannot eannot ownedcom ownedcom mergedpackag mergedpackag rule profileappl uml uml profileappl thismodul inel includ uml uml profileappl mapsto isstrict isstrict eannot eannot ownedcom ownedcom appliedprofil appliedprofil rule enumer uml uml enumer thismodul inel includ uml uml enumer mapsto name name visibl visibl isleaf isleaf isabstract isabstract eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul templateparamet templateparamet templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur general general powertypeext powertypeext redefinedclassifi redefinedclassifi substitut substitut represent represent collaborationus collaborationus ownedusecas ownedusecas usecas usecas ownedattribut ownedattribut ownedoper ownedoper ownedliter ownedliter rule enumerationliter uml uml enumerationliter thismodul inel includ uml uml enumerationliter mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress deploy deploy templateparamet templateparamet classifi classifi slot slot specif specif rule instancespecif uml uml instancespecif thismodul inel includ oclistypeof uml uml instancespecif els fals endif uml uml instancespecif mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress deploy deploy templateparamet templateparamet classifi classifi slot slot specif specif rule slot uml uml slot thismodul inel includ uml uml slot mapsto eannot eannot ownedcom ownedcom definingfeatur definingfeatur valu valu rule primitivetyp uml uml primitivetyp thismodul inel includ uml uml primitivetyp mapsto name name visibl visibl isleaf isleaf isabstract isabstract eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul templateparamet templateparamet templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur general general powertypeext powertypeext redefinedclassifi redefinedclassifi substitut substitut represent represent collaborationus collaborationus ownedusecas ownedusecas usecas usecas ownedattribut ownedattribut ownedoper ownedoper rule literalinteg uml uml literalinteg thismodul inel includ uml uml literalinteg mapsto name name visibl visibl valu valu eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet type type rule literalstr uml uml literalstr thismodul inel includ uml uml literalstr mapsto name name visibl visibl valu valu eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet type type rule literalboolean uml uml literalboolean thismodul inel includ uml uml literalboolean mapsto name name visibl visibl valu valu eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet type type rule literalnul uml uml literalnul thismodul inel includ uml uml literalnul mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet type type rule instancevalu uml uml instancevalu thismodul inel includ uml uml instancevalu mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet type type instanc instanc rule literalunlimitednatur uml uml literalunlimitednatur thismodul inel includ uml uml literalunlimitednatur mapsto name name visibl visibl valu valu eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet type type rule opaquebehavior uml uml opaquebehavior thismodul inel includ oclistypeof uml uml opaquebehavior els fals endif uml uml opaquebehavior mapsto name name visibl visibl isleaf isleaf isabstract isabstract isact isact isreentr isreentr bodi bodi languag languag eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul templateparamet templateparamet templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur general general powertypeext powertypeext redefinedclassifi redefinedclassifi substitut substitut represent represent collaborationus collaborationus ownedusecas ownedusecas usecas usecas ownedattribut ownedattribut ownedconnector ownedconnector ownedbehavior ownedbehavior classifierbehavior classifierbehavior interfacer interfacer ownedtrigg ownedtrigg nestedclassifi nestedclassifi ownedoper ownedoper ownedrecept ownedrecept redefinedbehavior redefinedbehavior ownedparamet ownedparamet precondit precondit postcondit postcondit ownedparameterset ownedparameterset specif specif rule functionbehavior uml uml functionbehavior thismodul inel includ uml uml functionbehavior mapsto name name visibl visibl isleaf isleaf isabstract isabstract isact isact isreentr isreentr bodi bodi languag languag eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul templateparamet templateparamet templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur general general powertypeext powertypeext redefinedclassifi redefinedclassifi substitut substitut represent represent collaborationus collaborationus ownedusecas ownedusecas usecas usecas ownedattribut ownedattribut ownedconnector ownedconnector ownedbehavior ownedbehavior classifierbehavior classifierbehavior interfacer interfacer ownedtrigg ownedtrigg nestedclassifi nestedclassifi ownedoper ownedoper ownedrecept ownedrecept redefinedbehavior redefinedbehavior ownedparamet ownedparamet precondit precondit postcondit postcondit ownedparameterset ownedparameterset specif specif rule opaqueact uml uml opaqueact thismodul inel includ uml uml opaqueact mapsto name name visibl visibl isleaf isleaf bodi bodi languag languag eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit inputvalu inputvalu outputvalu outputvalu rule structuredactivitynod uml uml structuredactivitynod thismodul inel includ oclistypeof uml uml structuredactivitynod els fals endif uml uml structuredactivitynod mapsto name name visibl visibl isleaf isleaf mustisol mustisol eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit elementimport elementimport packageimport packageimport ownedrul ownedrul variabl variabl edg edg node node rule activ uml uml activ thismodul inel includ uml uml activ mapsto name name visibl visibl isleaf isleaf isabstract isabstract isact isact isreentr isreentr isreadon isreadon issingleexecut issingleexecut eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul templateparamet templateparamet templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur general general powertypeext powertypeext redefinedclassifi redefinedclassifi substitut substitut represent represent collaborationus collaborationus ownedusecas ownedusecas usecas usecas ownedattribut ownedattribut ownedconnector ownedconnector ownedbehavior ownedbehavior classifierbehavior classifierbehavior interfacer interfacer ownedtrigg ownedtrigg nestedclassifi nestedclassifi ownedoper ownedoper ownedrecept ownedrecept redefinedbehavior redefinedbehavior ownedparamet ownedparamet precondit precondit postcondit postcondit ownedparameterset ownedparameterset specif specif variabl variabl node node edg edg partit partit group group rule variabl uml uml variabl thismodul inel includ uml uml variabl mapsto name name visibl visibl isord isord isuniqu isuniqu eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress type type templateparamet templateparamet end end uppervalu uppervalu lowervalu lowervalu rule activitypartit uml uml activitypartit thismodul inel includ uml uml activitypartit mapsto name name visibl visibl isdimens isdimens isextern isextern eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress node node subpartit subpartit repres repres edg edg rule interruptibleactivityregion uml uml interruptibleactivityregion thismodul inel includ uml uml interruptibleactivityregion mapsto eannot eannot ownedcom ownedcom node node interruptingedg interruptingedg rule exceptionhandl uml uml exceptionhandl thismodul inel includ uml uml exceptionhandl mapsto eannot eannot ownedcom ownedcom handlerbodi handlerbodi exceptioninput exceptioninput exceptiontyp exceptiontyp rule outputpin uml uml outputpin thismodul inel includ uml uml outputpin mapsto name name visibl visibl isleaf isleaf order order iscontroltyp iscontroltyp isord isord isuniqu isuniqu iscontrol iscontrol eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod type type upperbound upperbound instat instat select select uppervalu uppervalu lowervalu lowervalu rule pin uml uml pin thismodul inel includ oclistypeof uml uml pin els fals endif uml uml pin mapsto name name visibl visibl isleaf isleaf order order iscontroltyp iscontroltyp isord isord isuniqu isuniqu iscontrol iscontrol eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod type type upperbound upperbound instat instat select select uppervalu uppervalu lowervalu lowervalu rule inputpin uml uml inputpin thismodul inel includ oclistypeof uml uml inputpin els fals endif uml uml inputpin mapsto name name visibl visibl isleaf isleaf order order iscontroltyp iscontroltyp isord isord isuniqu isuniqu iscontrol iscontrol eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod type type upperbound upperbound instat instat select select uppervalu uppervalu lowervalu lowervalu rule sendsignalact uml uml sendsignalact thismodul inel includ uml uml sendsignalact mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit argument argument onport onport target target signal signal rule calloperationact uml uml calloperationact thismodul inel includ uml uml calloperationact mapsto name name visibl visibl isleaf isleaf issynchron issynchron eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit argument argument onport onport result result oper oper target target rule callbehavioract uml uml callbehavioract thismodul inel includ uml uml callbehavioract mapsto name name visibl visibl isleaf isleaf issynchron issynchron eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit argument argument onport onport result result behavior behavior rule sequencenod uml uml sequencenod thismodul inel includ uml uml sequencenod mapsto name name visibl visibl isleaf isleaf mustisol mustisol eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit elementimport elementimport packageimport packageimport ownedrul ownedrul variabl variabl edg edg node node executablenod executablenod rule usag uml uml usag thismodul inel includ uml uml usag mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet supplier supplier client client rule controlflow uml uml controlflow thismodul inel includ uml uml controlflow mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress sourc sourc target target redefinededg redefinededg inpartit inpartit guard guard weight weight interrupt interrupt rule initialnod uml uml initialnod thismodul inel includ uml uml initialnod mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod rule activityparameternod uml uml activityparameternod thismodul inel includ uml uml activityparameternod mapsto name name visibl visibl isleaf isleaf order order iscontroltyp iscontroltyp eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod type type upperbound upperbound instat instat select select paramet paramet rule valuepin uml uml valuepin thismodul inel includ uml uml valuepin mapsto name name visibl visibl isleaf isleaf order order iscontroltyp iscontroltyp isord isord isuniqu isuniqu iscontrol iscontrol eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod type type upperbound upperbound instat instat select select uppervalu uppervalu lowervalu lowervalu valu valu rule messag uml uml messag thismodul inel includ uml uml messag mapsto name name visibl visibl messagesort messagesort eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress receiveev receiveev sendev sendev connector connector argument argument rule interact uml uml interact thismodul inel includ uml uml interact mapsto name name visibl visibl isleaf isleaf isabstract isabstract isact isact isreentr isreentr eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul templateparamet templateparamet templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur general general powertypeext powertypeext redefinedclassifi redefinedclassifi substitut substitut represent represent collaborationus collaborationus ownedusecas ownedusecas usecas usecas ownedattribut ownedattribut ownedconnector ownedconnector ownedbehavior ownedbehavior classifierbehavior classifierbehavior interfacer interfacer ownedtrigg ownedtrigg nestedclassifi nestedclassifi ownedoper ownedoper ownedrecept ownedrecept redefinedbehavior redefinedbehavior ownedparamet ownedparamet precondit precondit postcondit postcondit ownedparameterset ownedparameterset specif specif cover cover generalord generalord lifelin lifelin fragment fragment action action formalg formalg messag messag rule lifelin uml uml lifelin thismodul inel includ uml uml lifelin mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress repres repres selector selector decomposeda decomposeda coveredbi coveredbi rule partdecomposit uml uml partdecomposit thismodul inel includ uml uml partdecomposit mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress cover cover generalord generalord refersto refersto actualg actualg argument argument rule interactionus uml uml interactionus thismodul inel includ oclistypeof uml uml interactionus els fals endif uml uml interactionus mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress cover cover generalord generalord refersto refersto actualg actualg argument argument rule gate uml uml gate thismodul inel includ uml uml gate mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress messag messag rule generalord uml uml generalord thismodul inel includ uml uml generalord mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress rule occurrencespecif uml uml occurrencespecif thismodul inel includ oclistypeof uml uml occurrencespecif els fals endif uml uml occurrencespecif mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress cover cover generalord generalord tobefor tobefor event event toafter toafter rule interactionoperand uml uml interactionoperand thismodul inel includ uml uml interactionoperand mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul cover cover generalord generalord guard guard fragment fragment rule interactionconstraint uml uml interactionconstraint thismodul inel includ uml uml interactionconstraint mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet constrainedel constrainedel specif specif minint minint maxint maxint rule stateinvari uml uml stateinvari thismodul inel includ uml uml stateinvari mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress cover cover generalord generalord invari invari rule actionexecutionspecif uml uml actionexecutionspecif thismodul inel includ uml uml actionexecutionspecif mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress cover cover generalord generalord start start finish finish action action rule behaviorexecutionspecif uml uml behaviorexecutionspecif thismodul inel includ uml uml behaviorexecutionspecif mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress cover cover generalord generalord start start finish finish behavior behavior rule executionev uml uml executionev thismodul inel includ uml uml executionev mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet rule creationev uml uml creationev thismodul inel includ uml uml creationev mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet rule destructionev uml uml destructionev thismodul inel includ uml uml destructionev mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet rule sendoperationev uml uml sendoperationev thismodul inel includ uml uml sendoperationev mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet oper oper rule sendsignalev uml uml sendsignalev thismodul inel includ uml uml sendsignalev mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet signal signal rule messageoccurrencespecif uml uml messageoccurrencespecif thismodul inel includ uml uml messageoccurrencespecif mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress cover cover generalord generalord tobefor tobefor event event toafter toafter messag messag rule executionoccurrencespecif uml uml executionoccurrencespecif thismodul inel includ uml uml executionoccurrencespecif mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress cover cover generalord generalord tobefor tobefor event event toafter toafter execut execut rule receiveoperationev uml uml receiveoperationev thismodul inel includ uml uml receiveoperationev mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet oper oper rule receivesignalev uml uml receivesignalev thismodul inel includ uml uml receivesignalev mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet signal signal rule actor uml uml actor thismodul inel includ uml uml actor mapsto name name visibl visibl isleaf isleaf isabstract isabstract eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul templateparamet templateparamet templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur general general powertypeext powertypeext redefinedclassifi redefinedclassifi substitut substitut represent represent collaborationus collaborationus ownedusecas ownedusecas usecas usecas ownedbehavior ownedbehavior classifierbehavior classifierbehavior interfacer interfacer ownedtrigg ownedtrigg rule callev uml uml callev thismodul inel includ uml uml callev mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet oper oper rule changeev uml uml changeev thismodul inel includ uml uml changeev mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet changeexpress changeexpress rule signalev uml uml signalev thismodul inel includ uml uml signalev mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet signal signal rule anyreceiveev uml uml anyreceiveev thismodul inel includ uml uml anyreceiveev mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet rule forknod uml uml forknod thismodul inel includ uml uml forknod mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod rule flowfinalnod uml uml flowfinalnod thismodul inel includ uml uml flowfinalnod mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod rule centralbuffernod uml uml centralbuffernod thismodul inel includ oclistypeof uml uml centralbuffernod els fals endif uml uml centralbuffernod mapsto name name visibl visibl isleaf isleaf order order iscontroltyp iscontroltyp eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod type type upperbound upperbound instat instat select select rule mergenod uml uml mergenod thismodul inel includ uml uml mergenod mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod rule decisionnod uml uml decisionnod thismodul inel includ uml uml decisionnod mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod decisioninput decisioninput rule activityfinalnod uml uml activityfinalnod thismodul inel includ uml uml activityfinalnod mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod rule componentr uml uml componentr thismodul inel includ uml uml componentr mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet supplier supplier client client map map realizingclassifi realizingclassifi rule compon uml uml compon thismodul inel includ uml uml compon mapsto name name visibl visibl isleaf isleaf isabstract isabstract isact isact isindirectlyinstanti isindirectlyinstanti eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul templateparamet templateparamet templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur general general powertypeext powertypeext redefinedclassifi redefinedclassifi substitut substitut represent represent collaborationus collaborationus ownedusecas ownedusecas usecas usecas ownedattribut ownedattribut ownedconnector ownedconnector ownedbehavior ownedbehavior classifierbehavior classifierbehavior interfacer interfacer ownedtrigg ownedtrigg nestedclassifi nestedclassifi ownedoper ownedoper ownedrecept ownedrecept packagedel packagedel realize realize rule node uml uml node thismodul inel includ oclistypeof uml uml node els fals endif uml uml node mapsto name name visibl visibl isleaf isleaf isabstract isabstract isact isact eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul templateparamet templateparamet templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur general general powertypeext powertypeext redefinedclassifi redefinedclassifi substitut substitut represent represent collaborationus collaborationus ownedusecas ownedusecas usecas usecas ownedattribut ownedattribut ownedconnector ownedconnector ownedbehavior ownedbehavior classifierbehavior classifierbehavior interfacer interfacer ownedtrigg ownedtrigg nestedclassifi nestedclassifi ownedoper ownedoper ownedrecept ownedrecept deploy deploy nestednod nestednod rule devic uml uml devic thismodul inel includ uml uml devic mapsto name name visibl visibl isleaf isleaf isabstract isabstract isact isact eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul templateparamet templateparamet templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur general general powertypeext powertypeext redefinedclassifi redefinedclassifi substitut substitut represent represent collaborationus collaborationus ownedusecas ownedusecas usecas usecas ownedattribut ownedattribut ownedconnector ownedconnector ownedbehavior ownedbehavior classifierbehavior classifierbehavior interfacer interfacer ownedtrigg ownedtrigg nestedclassifi nestedclassifi ownedoper ownedoper ownedrecept ownedrecept deploy deploy nestednod nestednod rule executionenviron uml uml executionenviron thismodul inel includ uml uml executionenviron mapsto name name visibl visibl isleaf isleaf isabstract isabstract isact isact eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul templateparamet templateparamet templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur general general powertypeext powertypeext redefinedclassifi redefinedclassifi substitut substitut represent represent collaborationus collaborationus ownedusecas ownedusecas usecas usecas ownedattribut ownedattribut ownedconnector ownedconnector ownedbehavior ownedbehavior classifierbehavior classifierbehavior interfacer interfacer ownedtrigg ownedtrigg nestedclassifi nestedclassifi ownedoper ownedoper ownedrecept ownedrecept deploy deploy nestednod nestednod rule communicationpath uml uml communicationpath thismodul inel includ uml uml communicationpath mapsto name name visibl visibl isleaf isleaf isabstract isabstract isderiv isderiv eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul templateparamet templateparamet templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur general general powertypeext powertypeext redefinedclassifi redefinedclassifi substitut substitut represent represent collaborationus collaborationus ownedusecas ownedusecas usecas usecas ownedend ownedend memberend memberend navigableownedend navigableownedend rule combinedfrag uml uml combinedfrag thismodul inel includ oclistypeof uml uml combinedfrag els fals endif uml uml combinedfrag mapsto name name visibl visibl interactionoper interactionoper eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress cover cover generalord generalord operand operand cfragmentg cfragmentg rule continu uml uml continu thismodul inel includ uml uml continu mapsto name name visibl visibl set set eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress cover cover generalord generalord rule considerignorefrag uml uml considerignorefrag thismodul inel includ uml uml considerignorefrag mapsto name name visibl visibl interactionoper interactionoper eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress cover cover generalord generalord operand operand cfragmentg cfragmentg messag messag rule createobjectact uml uml createobjectact thismodul inel includ uml uml createobjectact mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit classifi classifi result result rule destroyobjectact uml uml destroyobjectact thismodul inel includ uml uml destroyobjectact mapsto name name visibl visibl isleaf isleaf isdestroylink isdestroylink isdestroyownedobject isdestroyownedobject eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit target target rule testidentityact uml uml testidentityact thismodul inel includ uml uml testidentityact mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit first first second second result result rule readselfact uml uml readselfact thismodul inel includ uml uml readselfact mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit result result rule readstructuralfeatureact uml uml readstructuralfeatureact thismodul inel includ uml uml readstructuralfeatureact mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit structuralfeatur structuralfeatur object object result result rule clearstructuralfeatureact uml uml clearstructuralfeatureact thismodul inel includ uml uml clearstructuralfeatureact mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit structuralfeatur structuralfeatur object object rule removestructuralfeaturevalueact uml uml removestructuralfeaturevalueact thismodul inel includ uml uml removestructuralfeaturevalueact mapsto name name visibl visibl isleaf isleaf isremovedupl isremovedupl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit structuralfeatur structuralfeatur object object valu valu removeat removeat rule addstructuralfeaturevalueact uml uml addstructuralfeaturevalueact thismodul inel includ uml uml addstructuralfeaturevalueact mapsto name name visibl visibl isleaf isleaf isreplaceal isreplaceal eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit structuralfeatur structuralfeatur object object valu valu insertat insertat rule linkenddata uml uml linkenddata thismodul inel includ oclistypeof uml uml linkenddata els fals endif uml uml linkenddata mapsto eannot eannot ownedcom ownedcom valu valu end end qualifi qualifi rule qualifiervalu uml uml qualifiervalu thismodul inel includ uml uml qualifiervalu mapsto eannot eannot ownedcom ownedcom qualifi qualifi valu valu rule readlinkact uml uml readlinkact thismodul inel includ uml uml readlinkact mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit enddata enddata inputvalu inputvalu result result rule linkendcreationdata uml uml linkendcreationdata thismodul inel includ uml uml linkendcreationdata mapsto isreplaceal isreplaceal eannot eannot ownedcom ownedcom valu valu end end qualifi qualifi insertat insertat rule createlinkact uml uml createlinkact thismodul inel includ oclistypeof uml uml createlinkact els fals endif uml uml createlinkact mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit enddata enddata inputvalu inputvalu rule destroylinkact uml uml destroylinkact thismodul inel includ uml uml destroylinkact mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit enddata enddata inputvalu inputvalu rule linkenddestructiondata uml uml linkenddestructiondata thismodul inel includ uml uml linkenddestructiondata mapsto isdestroydupl isdestroydupl eannot eannot ownedcom ownedcom valu valu end end qualifi qualifi destroyat destroyat rule clearassociationact uml uml clearassociationact thismodul inel includ uml uml clearassociationact mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit object object associ associ rule broadcastsignalact uml uml broadcastsignalact thismodul inel includ uml uml broadcastsignalact mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit argument argument onport onport signal signal rule sendobjectact uml uml sendobjectact thismodul inel includ uml uml sendobjectact mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit argument argument onport onport target target request request rule valuespecificationact uml uml valuespecificationact thismodul inel includ uml uml valuespecificationact mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit valu valu result result rule timeexpress uml uml timeexpress thismodul inel includ uml uml timeexpress mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet type type expr expr observ observ rule durat uml uml durat thismodul inel includ uml uml durat mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet type type expr expr observ observ rule durationinterv uml uml durationinterv thismodul inel includ uml uml durationinterv mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet type type min min max max rule interv uml uml interv thismodul inel includ oclistypeof uml uml interv els fals endif uml uml interv mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet type type min min max max rule timeconstraint uml uml timeconstraint thismodul inel includ uml uml timeconstraint mapsto name name visibl visibl firstev firstev eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet constrainedel constrainedel specif specif rule intervalconstraint uml uml intervalconstraint thismodul inel includ oclistypeof uml uml intervalconstraint els fals endif uml uml intervalconstraint mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet constrainedel constrainedel specif specif rule timeinterv uml uml timeinterv thismodul inel includ uml uml timeinterv mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet type type min min max max rule durationconstraint uml uml durationconstraint thismodul inel includ uml uml durationconstraint mapsto name name visibl visibl firstev firstev eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet constrainedel constrainedel specif specif rule timeobserv uml uml timeobserv thismodul inel includ uml uml timeobserv mapsto name name visibl visibl firstev firstev eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet event event rule durationobserv uml uml durationobserv thismodul inel includ uml uml durationobserv mapsto name name visibl visibl firstev firstev eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet event event rule finalst uml uml finalst thismodul inel includ uml uml finalst mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul outgo outgo incom incom submachin submachin connect connect connectionpoint connectionpoint redefinedst redefinedst stateinvari stateinvari entri entri exit exit doactiv doactiv deferrabletrigg deferrabletrigg region region rule timeev uml uml timeev thismodul inel includ uml uml timeev mapsto name name visibl visibl isrel isrel eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet rule readvariableact uml uml readvariableact thismodul inel includ uml uml readvariableact mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit variabl variabl result result rule clearvariableact uml uml clearvariableact thismodul inel includ uml uml clearvariableact mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit variabl variabl rule addvariablevalueact uml uml addvariablevalueact thismodul inel includ uml uml addvariablevalueact mapsto name name visibl visibl isleaf isleaf isreplaceal isreplaceal eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit variabl variabl valu valu insertat insertat rule removevariablevalueact uml uml removevariablevalueact thismodul inel includ uml uml removevariablevalueact mapsto name name visibl visibl isleaf isleaf isremovedupl isremovedupl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit variabl variabl valu valu removeat removeat rule raiseexceptionact uml uml raiseexceptionact thismodul inel includ uml uml raiseexceptionact mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit except except rule actioninputpin uml uml actioninputpin thismodul inel includ uml uml actioninputpin mapsto name name visibl visibl isleaf isleaf order order iscontroltyp iscontroltyp isord isord isuniqu isuniqu iscontrol iscontrol eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod type type upperbound upperbound instat instat select select uppervalu uppervalu lowervalu lowervalu fromact fromact rule informationitem uml uml informationitem thismodul inel includ uml uml informationitem mapsto name name visibl visibl isleaf isleaf isabstract isabstract eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul templateparamet templateparamet templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur general general powertypeext powertypeext redefinedclassifi redefinedclassifi substitut substitut represent represent collaborationus collaborationus ownedusecas ownedusecas usecas usecas repres repres rule informationflow uml uml informationflow thismodul inel includ uml uml informationflow mapsto name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress templateparamet templateparamet realize realize convey convey informationsourc informationsourc informationtarget informationtarget realizingactivityedg realizingactivityedg realizingconnector realizingconnector realizingmessag realizingmessag rule readextentact uml uml readextentact thismodul inel includ uml uml readextentact mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit result result classifi classifi rule reclassifyobjectact uml uml reclassifyobjectact thismodul inel includ uml uml reclassifyobjectact mapsto name name visibl visibl isleaf isleaf isreplaceal isreplaceal eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit oldclassifi oldclassifi newclassifi newclassifi object object rule readisclassifiedobjectact uml uml readisclassifiedobjectact thismodul inel includ uml uml readisclassifiedobjectact mapsto name name visibl visibl isleaf isleaf isdirect isdirect eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit classifi classifi result result object object rule startclassifierbehavioract uml uml startclassifierbehavioract thismodul inel includ uml uml startclassifierbehavioract mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit object object rule readlinkobjectendact uml uml readlinkobjectendact thismodul inel includ uml uml readlinkobjectendact mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit object object end end result result rule readlinkobjectendqualifieract uml uml readlinkobjectendqualifieract thismodul inel includ uml uml readlinkobjectendqualifieract mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit object object result result qualifi qualifi rule createlinkobjectact uml uml createlinkobjectact thismodul inel includ uml uml createlinkobjectact mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit enddata enddata inputvalu inputvalu result result rule accepteventact uml uml accepteventact thismodul inel includ oclistypeof uml uml accepteventact els fals endif uml uml accepteventact mapsto name name visibl visibl isleaf isleaf isunmarshal isunmarshal eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit result result trigger trigger rule acceptcallact uml uml acceptcallact thismodul inel includ uml uml acceptcallact mapsto name name visibl visibl isleaf isleaf isunmarshal isunmarshal eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit result result trigger trigger returninform returninform rule replyact uml uml replyact thismodul inel includ uml uml replyact mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit replytocal replytocal returninform returninform replyvalu replyvalu rule unmarshallact uml uml unmarshallact thismodul inel includ uml uml unmarshallact mapsto name name visibl visibl isleaf isleaf eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit result result unmarshalltyp unmarshalltyp object object rule reduceact uml uml reduceact thismodul inel includ uml uml reduceact mapsto name name visibl visibl isleaf isleaf isord isord eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit reduc reduc result result collect collect rule joinnod uml uml joinnod thismodul inel includ uml uml joinnod mapsto name name visibl visibl isleaf isleaf iscombinedupl iscombinedupl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod joinspec joinspec rule datastorenod uml uml datastorenod thismodul inel includ uml uml datastorenod mapsto name name visibl visibl isleaf isleaf order order iscontroltyp iscontroltyp eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod type type upperbound upperbound instat instat select select rule objectflow uml uml objectflow thismodul inel includ uml uml objectflow mapsto name name visibl visibl isleaf isleaf ismulticast ismulticast ismultirec ismultirec eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress sourc sourc target target redefinededg redefinededg inpartit inpartit guard guard weight weight interrupt interrupt transform transform select select rule conditionalnod uml uml conditionalnod thismodul inel includ uml uml conditionalnod mapsto name name visibl visibl isleaf isleaf mustisol mustisol isdetermin isdetermin isassur isassur eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit elementimport elementimport packageimport packageimport ownedrul ownedrul variabl variabl edg edg node node claus claus result result rule claus uml uml claus thismodul inel includ uml uml claus mapsto eannot eannot ownedcom ownedcom test test bodi bodi predecessorclaus predecessorclaus successorclaus successorclaus decid decid bodyoutput bodyoutput rule loopnod uml uml loopnod thismodul inel includ uml uml loopnod mapsto name name visibl visibl isleaf isleaf mustisol mustisol istestedfirst istestedfirst eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit elementimport elementimport packageimport packageimport ownedrul ownedrul variabl variabl edg edg node node bodypart bodypart setuppart setuppart decid decid test test result result loopvari loopvari bodyoutput bodyoutput loopvariableinput loopvariableinput rule expansionnod uml uml expansionnod thismodul inel includ uml uml expansionnod mapsto name name visibl visibl isleaf isleaf order order iscontroltyp iscontroltyp eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod type type upperbound upperbound instat instat select select regionasoutput regionasoutput regionasinput regionasinput rule expansionregion uml uml expansionregion thismodul inel includ uml uml expansionregion mapsto name name visibl visibl isleaf isleaf mustisol mustisol mode mode eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress outgo outgo incom incom inpartit inpartit ininterruptibleregion ininterruptibleregion redefinednod redefinednod handler handler localprecondit localprecondit localpostcondit localpostcondit elementimport elementimport packageimport packageimport ownedrul ownedrul variabl variabl edg edg node node inputel inputel outputel outputel rule protocoltransit uml uml protocoltransit thismodul inel includ uml uml protocoltransit mapsto name name visibl visibl isleaf isleaf kind kind eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul target target redefinedtransit redefinedtransit guard guard effect effect trigger trigger sourc sourc postcondit postcondit precondit precondit rule associationclass uml uml associationclass thismodul inel includ uml uml associationclass mapsto name name visibl visibl isleaf isleaf isabstract isabstract isact isact isderiv isderiv eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul templateparamet templateparamet templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur general general powertypeext powertypeext redefinedclassifi redefinedclassifi substitut substitut represent represent collaborationus collaborationus ownedusecas ownedusecas usecas usecas ownedattribut ownedattribut ownedconnector ownedconnector ownedbehavior ownedbehavior classifierbehavior classifierbehavior interfacer interfacer ownedtrigg ownedtrigg nestedclassifi nestedclassifi ownedoper ownedoper ownedrecept ownedrecept ownedend ownedend memberend memberend navigableownedend navigableownedend uml copi rule end endpoint rule end,18
220,220,P95-UMLCD2UMLProfile.atl,"-- @atlcompiler atl2006
-- @nsURI UML2=http://www.eclipse.org/uml2/2.1.0/UML
-- @description	In this transformation, a class diagram will be transformed in a UML profile
module UMLCD2UMLProfile;
create OUT : UML2 from IN : UML2, UMLCD : UML2, PRO_STD : UML2;

-- Rule Stereotype to Class
-- @description	This rule transforms each UML Class in a UML Stereotype. A UML property and extension are added ""containing"" the link with the metaclass (on which this stereotype will be applicable).
-- (Stereotype extends Class)
rule Class {
    from s : UML2!""uml::Class"" in IN
    to t : UML2!""uml::Stereotype"" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
		ownedAttribute <- Set {s.ownedAttribute->flatten(), base_element},
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception
	),
    base_element : UML2!Property (
        name <- 'base_Element_' + s.name,
        isUnique <- false
		, type <- thisModule.resolveTemp(UML2!Model.allInstancesFrom('IN')->any(e | e.oclIsTypeOf(UML2!""uml::Model"")), 'elementImport').importedElement
        , association <- extension
	),
	extension : UML2!Extension (
		name <- 'Extension_' + s.name
		, memberEnd <- Set { extensionEnd, base_element }
		, ownedEnd <- Set { extensionEnd }
	),
	extensionEnd : UML2!ExtensionEnd (
		name <- 'extension_' + s.name,
		aggregation <- #composite,
		type <- t,
		association <- extension
	)
}

-- Rule Model to Profile
-- @description	This rule transforms each UML Model in a UML Profile. An element import is created and will be used to add notion of metaclass.
rule Model {
	from s : UML2!""uml::Model"" in IN (s.oclIsTypeOf(UML2!""uml::Model""))
	to t : UML2!""uml::Profile"" (
		name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        packageMerge <- s.packageMerge,
        packagedElement <- Set {
			s.packagedElement, 
			UML2!Class.allInstancesFrom('IN')->collect(e | thisModule.resolveTemp(e, 'extension'))
		},
        profileApplication <- s.profileApplication,
		metaclassReference <- Set { elementImport }
        , ownedStereotype <- s.packagedElement->select(e | e.oclIsTypeOf(UML2!""uml::Class""))
	)
	, elementImport : UML2!ElementImport (
		alias <- 'Class',
		visibility <- #public
		, importedElement <- UML2!Class.allInstancesFrom('UMLCD')->any(e|e.name = 'Class')
	)
}

-- Rule Package to Profile
-- @description	This rule transforms each UML Package in a UML Profile.
rule Package {
    from s : UML2!""uml::Package"" in IN (s.oclIsTypeOf(UML2!""uml::Package""))
    to t : UML2!""uml::Profile"" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        packageMerge <- s.packageMerge,
        packagedElement <- s.packagedElement,
        profileApplication <- s.profileApplication
	)
}

-- Profile and Stereotype applications will be done at the end of the transformation
endpoint rule end() {
	do {
		for	(elm in UML2!Property.allInstancesFrom('OUT')->select(e | e.name.startsWith('base_Element_'))) {
			elm.type <- thisModule.resolveTemp(UML2!Model.allInstancesFrom('IN')->any(e | e.oclIsTypeOf(UML2!""uml::Model"")), 'elementImport').importedElement;
		}
	}
}",atlcompil atl nsuri uml http www eclips org uml uml descript in transform class diagram transform uml profil modul umlcd umlprofil creat out uml in uml umlcd uml pro std uml rule stereotyp class descript this rule transform uml class uml stereotyp a uml properti extens ad contain link metaclass stereotyp applic stereotyp extend class rule class uml uml class in uml uml stereotyp name name visibl visibl isleaf isleaf isabstract isabstract isact isact eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul templateparamet templateparamet templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur general general powertypeext powertypeext redefinedclassifi redefinedclassifi substitut substitut represent represent collaborationus collaborationus ownedusecas ownedusecas usecas usecas ownedattribut set ownedattribut flatten base element ownedconnector ownedconnector ownedbehavior ownedbehavior classifierbehavior classifierbehavior interfacer interfacer ownedtrigg ownedtrigg nestedclassifi nestedclassifi ownedoper ownedoper ownedrecept ownedrecept base element uml properti name base element name isuniqu fals type thismodul resolvetemp uml model allinstancesfrom in e e oclistypeof uml uml model elementimport importedel associ extens extens uml extens name extens name memberend set extensionend base element ownedend set extensionend extensionend uml extensionend name extens name aggreg composit type associ extens rule model profil descript this rule transform uml model uml profil an element import creat use add notion metaclass rule model uml uml model in oclistypeof uml uml model uml uml profil name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul templateparamet templateparamet templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur packagemerg packagemerg packagedel set packagedel uml class allinstancesfrom in collect e thismodul resolvetemp e extens profileappl profileappl metaclassrefer set elementimport ownedstereotyp packagedel select e e oclistypeof uml uml class elementimport uml elementimport alia class visibl public importedel uml class allinstancesfrom umlcd e e name class rule packag profil descript this rule transform uml packag uml profil rule packag uml uml packag in oclistypeof uml uml packag uml uml profil name name visibl visibl eannot eannot ownedcom ownedcom clientdepend clientdepend nameexpress nameexpress elementimport elementimport packageimport packageimport ownedrul ownedrul templateparamet templateparamet templatebind templatebind ownedtemplatesignatur ownedtemplatesignatur packagemerg packagemerg packagedel packagedel profileappl profileappl profil stereotyp applic done end transform endpoint rule end elm uml properti allinstancesfrom out select e e name startswith base element elm type thismodul resolvetemp uml model allinstancesfrom in e e oclistypeof uml uml model elementimport importedel,12
221,221,P96-SVG2XML.atl,"module SVG2XML;
create OUT : XML from IN : SVG;

-- HELPERS
helper context SVG!Element def : hasAttribute(attrName : String) : Boolean =
	if not self.attribute->isEmpty() then
		self.attribute->exists( e | e.oclIsKindOf(attrName))
	else
		false
	endif;

--helper context SVG!Element def : getAttribute(attrName : String) : SVG!Element =
--		self.attribute->select( e | e.oclIsKindOf(SVG!attrName))->first();

-- End HELPERS

rule SVG2Root {
	from
		s : SVG!Svg
	to
		out : XML!Root (
			name <- 'svg',
			children <- Sequence {namespace, x, y, s.children}->flatten() 
		),
		namespace : XML!Attribute (
			name <- 'xmlns',
			value <- s.namespace
		),
		x : XML!Attribute (
			name <- 'x',
			value <- s.position.x.toString()
		),
		y : XML!Attribute (
			name <- 'y',
			value <- s.position.y.toString()
		)
}

rule Groups {
	from
		g : SVG!G (
			g.drawsMarker.oclIsUndefined()	
		)
	to
		out : XML!Element (
			name <- 'g',
			children <- g.groupContent
		)
}

rule MarkerGroups {
	from
		g : SVG!G (
			not(g.drawsMarker.oclIsUndefined())
		)
	to
		out : XML!Element (
			name <- 'g',
			children <- g.groupContent,
			parent <- g.drawsMarker
		)
}

rule defs {
	from
		d : SVG!Defs
	to
		out : XML!Element (
			name <- 'defs',
			children <- d.groupContent
		)
}

rule Marker {
	from
		m : SVG!Marker
	to
		out : XML!Element (
			name <- 'marker',
			children <- Sequence {RefX, RefY, id, markerWidth, markerHeight, orient, fill, viewBox}
		),
			RefX : XML!Attribute (
				name <- 'refX',
				value <- m.refX.toString()
			),
			RefY : XML!Attribute (
				name <- 'refY',
				value <- m.refY.toString()
			),
			id : XML!Attribute (
				name <- 'id',
				value <- m.identifier
			),
			markerWidth : XML!Attribute (
				name <- 'markerWidth',
				value <- m.markerWidth.toString()
			),
			markerHeight : XML!Attribute (
				name <- 'markerHeight',
				value <- m.markerHeight.toString()
			),
			orient : XML!Attribute (
				name <- 'orient',
				value <- m.orient
			),
			fill : XML!Attribute (
				name <- 'fill',
				value <- m.fill
			),
			viewBox : XML!Attribute (
				name <- 'viewBox',
				value <- m.viewBox
			)
}

rule Rect {
	from
		r : SVG!Rect
	to
		out : XML!Element (
			name <- 'rect',
			children <- Sequence {x,y,width,height,fill, stroke}
		),
		x : XML!Attribute (
			name <- 'x',
			value <- r.position.x.toString()
		),
		y : XML!Attribute (
			name <- 'y',
			value <- r.position.y.toString()
		),
		width : XML!Attribute (
			name <- 'width',
			value <- r.size.width.toString()
		),
		height : XML!Attribute (
			name <- 'height',
			value <- r.size.height.toString()
		),
		fill : XML!Attribute (
			name <- 'fill',
			value <- r.fill
		),
		stroke : XML!Attribute (
			name <- 'stroke',
			value <- r.stroke
		)
}

rule Line {
	from
		l : SVG!Line
	to
		out : XML!Element (
			name <- 'line',
			children <- Sequence {x1, y1, x2, y2, stroke}
		),
		x1 : XML!Attribute (
			name <- 'x1',
			value <- l.between.first().position.x.toString()
		),
		y1 : XML!Attribute (
			name <- 'y1',
			value <- l.between.first().position.y.toString()
		),
		x2 : XML!Attribute (
			name <- 'x2',
			value <- l.between.last().position.x.toString()
		),
		y2 : XML!Attribute (
			name <- 'y2',
			value <- l.between.last().position.y.toString()
		),
		stroke : XML!Attribute (
			name <- 'stroke',
			value <- l.stroke
		)
}

helper context SVG!Polyline def : toPoints() : String =
	self.waypoints->iterate( e; acc : String = '' |
	acc + e.position.x.toString() + ',' + e.position.y.toString() + ' ');

rule PlainUnmarkedPolyline {
	from
		p : SVG!Polyline (
			p.strokeDashArray.oclIsUndefined() and p.markerEnd.oclIsUndefined()
		)
	to
		out : XML!Element (
			name <- 'polyline',
			children <- Sequence {points, stroke, fill}
		),
		points : XML!Attribute (
			name <- 'points',
			value <- p.toPoints()
		),
		stroke : XML!Attribute (
			name <- 'stroke',
			value <- p.stroke
		),
		fill : XML!Attribute (
			name <- 'fill',
			value <- p.fill
		)
}

rule DashedUnmarkedPolyline {
	from
		p : SVG!Polyline (
			not p.strokeDashArray.oclIsUndefined() and p.markerEnd.oclIsUndefined()
		)
	to
		out : XML!Element (
			name <- 'polyline',
			children <- Sequence {points, stroke, fill, dashArray}
		),
		points : XML!Attribute (
			name <- 'points',
			value <- p.toPoints()
		),
		stroke : XML!Attribute (
			name <- 'stroke',
			value <- p.stroke
		),
		fill : XML!Attribute (
			name <- 'fill',
			value <- p.fill
		),
		dashArray : XML!Attribute (
			name <- 'stroke-dasharray',
			value <- p.strokeDashArray
		)
}

rule PlainMarkedESPolyline {
	from
		p : SVG!Polyline (
			p.strokeDashArray.oclIsUndefined() and not(p.markerEnd.oclIsUndefined()) and not(p.markerStart.oclIsUndefined())
		)
	to
		out : XML!Element (
			name <- 'polyline',
			children <- Sequence {points, stroke, fill, markerE, markerS}
		),
		points : XML!Attribute (
			name <- 'points',
			value <- p.toPoints()
		),
		stroke : XML!Attribute (
			name <- 'stroke',
			value <- p.stroke
		),
		fill : XML!Attribute (
			name <- 'fill',
			value <- p.fill
		),
		markerE : XML!Attribute (
			name <- 'marker-end',
			value <- p.markerEnd
		),
		markerS : XML!Attribute (
			name <- 'marker-start',
			value <- p.markerStart
		)
}

rule DashedMarkedPolyline {
	from
		p : SVG!Polyline (
			not p.strokeDashArray.oclIsUndefined() and not(p.markerEnd.oclIsUndefined())
		)
	to
		out : XML!Element (
			name <- 'polyline',
			children <- Sequence {points, stroke, fill, dashArray, marker}
		),
		points : XML!Attribute (
			name <- 'points',
			value <- p.toPoints()
		),
		stroke : XML!Attribute (
			name <- 'stroke',
			value <- p.stroke
		),
		fill : XML!Attribute (
			name <- 'fill',
			value <- p.fill
		),
		dashArray : XML!Attribute (
			name <- 'stroke-dasharray',
			value <- p.strokeDashArray
		),
		marker : XML!Attribute (
			name <- 'marker-end',
			value <- p.markerEnd
		)
}



helper context SVG!Text def: isBold() : Boolean =
	if self.hasAttribute(SVG!FontWeight) then
		self.attribute->select( e | e.oclIsKindOf(SVG!FontWeight))->first().bold
	else
		false
	endif;
	
helper context SVG!Text def: isItalic() : Boolean =
	if self.hasAttribute(SVG!FontStyle) then
		self.attribute->select( e | e.oclIsKindOf(SVG!FontStyle))->first().italic
	else
		false
	endif;

rule TextNotBoldNotItalic {
	from
		t : SVG!Text (
			not(t.isBold()) and not(t.isItalic())
		)
	to
		out : XML!Element (
			name <- 'text',
			children <- Sequence {x, y, text, fill, fontSize}
		),
		x : XML!Attribute (
			name <- 'x',
			value <- t.position.x.toString()
		),
		y : XML!Attribute (
			name <- 'y',
			value <- t.position.y.toString()
		),
		text : XML!Text (
			value <- t.content
		),
		fill : XML!Attribute (
			name <- 'fill',
			value <- t.fill
		),
		fontSize : XML!Attribute (
			name <- 'font-size',
			value <- t.fontSize
		)
}

rule TextNotBoldItalic {
	from
		t : SVG!Text (
			not(t.isBold()) and t.isItalic()
		)
	to
		out : XML!Element (
			name <- 'text',
			children <- Sequence {x, y, text, fill, fontSize, fontStyle}
		),
		x : XML!Attribute (
			name <- 'x',
			value <- t.position.x.toString()
		),
		y : XML!Attribute (
			name <- 'y',
			value <- t.position.y.toString()
		),
		text : XML!Text (
			value <- t.content
		),
		fill : XML!Attribute (
			name <- 'fill',
			value <- t.fill
		),
		fontSize : XML!Attribute (
			name <- 'font-size',
			value <- t.fontSize
		),
		fontStyle : XML!Attribute (
			name <- 'font-style',
			value <- 'italic'
		)
}

rule TextBoldItalic {
	from
		t : SVG!Text (
			t.isBold() and t.isItalic()
		)
	to
		out : XML!Element (
			name <- 'text',
			children <- Sequence {x, y, text, fill, fontSize, fontWeight, fontStyle}
		),
		x : XML!Attribute (
			name <- 'x',
			value <- t.position.x.toString()
		),
		y : XML!Attribute (
			name <- 'y',
			value <- t.position.y.toString()
		),
		text : XML!Text (
			value <- t.content
		),
		fill : XML!Attribute (
			name <- 'fill',
			value <- t.fill
		),
		fontSize : XML!Attribute (
			name <- 'font-size',
			value <- t.fontSize
		),
		fontWeight : XML!Attribute (
			name <- 'font-weight',
			value <- 'bold'
		),
		fontStyle : XML!Attribute (
			name <- 'font-style',
			value <- 'italic'
		)
}

rule TextBoldNotItalic {
	from
		t : SVG!Text (
			t.isBold() and not(t.isItalic())
		)
	to
		out : XML!Element (
			name <- 'text',
			children <- Sequence {x, y, text, fill, fontSize, fontWeight}
		),
		x : XML!Attribute (
			name <- 'x',
			value <- t.position.x.toString()
		),
		y : XML!Attribute (
			name <- 'y',
			value <- t.position.y.toString()
		),
		text : XML!Text (
			value <- t.content
		),
		fill : XML!Attribute (
			name <- 'fill',
			value <- t.fill
		),
		fontSize : XML!Attribute (
			name <- 'font-size',
			value <- t.fontSize
		),
		fontWeight : XML!Attribute (
			name <- 'font-weight',
			value <- 'bold'
		)
}


rule Path {
	from
		p : SVG!Path
	to
		out : XML!Element (
			name <- 'path',
			parent <- p.group,
			children <- Sequence {data, strok}
		),
			data : XML!Attribute (
				name <- 'd',
				value <- p.d
			),
			strok : XML!Attribute (
				name <- 'stroke',
				value <- p.stroke
			)
}
",modul svg xml creat out xml in svg helper helper context svg element def hasattribut attrnam string boolean self attribut isempti self attribut exist e e ocliskindof attrnam els fals endif helper context svg element def getattribut attrnam string svg element self attribut select e e ocliskindof svg attrnam first end helper rule svg root svg svg xml root name svg children sequenc namespac x children flatten namespac xml attribut name xmlns valu namespac x xml attribut name x valu posit x tostr xml attribut name valu posit tostr rule group g svg g g drawsmark oclisundefin xml element name g children g groupcont rule markergroup g svg g g drawsmark oclisundefin xml element name g children g groupcont parent g drawsmark rule def svg def xml element name def children groupcont rule marker svg marker xml element name marker children sequenc refx refi id markerwidth markerheight orient fill viewbox refx xml attribut name refx valu refx tostr refi xml attribut name refi valu refi tostr id xml attribut name id valu identifi markerwidth xml attribut name markerwidth valu markerwidth tostr markerheight xml attribut name markerheight valu markerheight tostr orient xml attribut name orient valu orient fill xml attribut name fill valu fill viewbox xml attribut name viewbox valu viewbox rule rect r svg rect xml element name rect children sequenc x width height fill stroke x xml attribut name x valu r posit x tostr xml attribut name valu r posit tostr width xml attribut name width valu r size width tostr height xml attribut name height valu r size height tostr fill xml attribut name fill valu r fill stroke xml attribut name stroke valu r stroke rule line l svg line xml element name line children sequenc x x stroke x xml attribut name x valu l first posit x tostr xml attribut name valu l first posit tostr x xml attribut name x valu l last posit x tostr xml attribut name valu l last posit tostr stroke xml attribut name stroke valu l stroke helper context svg polylin def topoint string self waypoint iter e acc string acc e posit x tostr e posit tostr rule plainunmarkedpolylin p svg polylin p strokedasharray oclisundefin p markerend oclisundefin xml element name polylin children sequenc point stroke fill point xml attribut name point valu p topoint stroke xml attribut name stroke valu p stroke fill xml attribut name fill valu p fill rule dashedunmarkedpolylin p svg polylin p strokedasharray oclisundefin p markerend oclisundefin xml element name polylin children sequenc point stroke fill dasharray point xml attribut name point valu p topoint stroke xml attribut name stroke valu p stroke fill xml attribut name fill valu p fill dasharray xml attribut name stroke dasharray valu p strokedasharray rule plainmarkedespolylin p svg polylin p strokedasharray oclisundefin p markerend oclisundefin p markerstart oclisundefin xml element name polylin children sequenc point stroke fill marker marker point xml attribut name point valu p topoint stroke xml attribut name stroke valu p stroke fill xml attribut name fill valu p fill marker xml attribut name marker end valu p markerend marker xml attribut name marker start valu p markerstart rule dashedmarkedpolylin p svg polylin p strokedasharray oclisundefin p markerend oclisundefin xml element name polylin children sequenc point stroke fill dasharray marker point xml attribut name point valu p topoint stroke xml attribut name stroke valu p stroke fill xml attribut name fill valu p fill dasharray xml attribut name stroke dasharray valu p strokedasharray marker xml attribut name marker end valu p markerend helper context svg text def isbold boolean self hasattribut svg fontweight self attribut select e e ocliskindof svg fontweight first bold els fals endif helper context svg text def isital boolean self hasattribut svg fontstyl self attribut select e e ocliskindof svg fontstyl first ital els fals endif rule textnotboldnotital svg text isbold isital xml element name text children sequenc x text fill fontsiz x xml attribut name x valu posit x tostr xml attribut name valu posit tostr text xml text valu content fill xml attribut name fill valu fill fontsiz xml attribut name font size valu fontsiz rule textnotboldital svg text isbold isital xml element name text children sequenc x text fill fontsiz fontstyl x xml attribut name x valu posit x tostr xml attribut name valu posit tostr text xml text valu content fill xml attribut name fill valu fill fontsiz xml attribut name font size valu fontsiz fontstyl xml attribut name font style valu ital rule textboldital svg text isbold isital xml element name text children sequenc x text fill fontsiz fontweight fontstyl x xml attribut name x valu posit x tostr xml attribut name valu posit tostr text xml text valu content fill xml attribut name fill valu fill fontsiz xml attribut name font size valu fontsiz fontweight xml attribut name font weight valu bold fontstyl xml attribut name font style valu ital rule textboldnotital svg text isbold isital xml element name text children sequenc x text fill fontsiz fontweight x xml attribut name x valu posit x tostr xml attribut name valu posit tostr text xml text valu content fill xml attribut name fill valu fill fontsiz xml attribut name font size valu fontsiz fontweight xml attribut name font weight valu bold rule path p svg path xml element name path parent p group children sequenc data strok data xml attribut name valu p strok xml attribut name stroke valu p stroke,5
222,222,P96-UMLDI2SVG.atl,"module UMLDI2SVG;
create OUT: SVG from IN: UMLDI;


-- HELPERS
	-- Boolean Helpers
		
		-- HELPER isOfKind
		-- Returns true if the node is of kind (OCL way) of the input
		-- For example if the element is a UML Class
			-- CONTEXT: 	UMLDI!GraphElement
			-- IN:			kind: String
			-- RETURN:		Boolean
helper context UMLDI!GraphElement def: isOfKind(kind: String): Boolean =
	if self.semanticModel.oclIsKindOf(UMLDI!Uml1SemanticModelBridge) then
		self.semanticModel.element.oclIsKindOf(kind)
	else
		false
	endif;

		-- HELPER isOfType
		-- Returns true if the element is of the input type
			-- CONTEXT: 	UMLDI!GraphNode
			-- IN:			N/A
			-- RETURN:		Boolean
helper context UMLDI!GraphNode def: isOfType(testType: String): Boolean =
	if self.semanticModel.oclIsKindOf(UMLDI!SimpleSemanticModelElement) then
		self.semanticModel.typeInfo = testType
	else
		false
	endif;
		
		-- HELPER hasAttributes
		-- Returns true if the current class node has some attributes
			-- CONTEXT: 	UMLDI!GraphNode
			-- IN:			N/A
			-- RETURN:		Boolean
			-- CALLS:		isOfType
helper context UMLDI!GraphNode def: hasAttributes(): Boolean =
	if self.contained->exists( e | e.isOfType('AttributeCompartment')) then
		self.contained->select( e | e.isOfType('AttributeCompartment'))->
			first().contained->exists( e | e.isOfType('DelimitedSection'))
	else
		false
	endif;
	
		-- HELPER hasMethods
		-- Returns true if the current class node has some methods
			-- CONTEXT: 	UMLDI!GraphNode
			-- IN:			N/A
			-- RETURN:		Boolean
			-- CALLS:		isOfType
helper context UMLDI!GraphNode def: hasMethods(): Boolean =
	if self.contained->exists( e | e.isOfType('OperationCompartment')) then
		self.contained->select( e | e.isOfType('OperationCompartment'))->
			first().contained->exists( e | e.isOfType('DelimitedSection'))
	else
		false
	endif;

		-- HELPER hasAttSeparator
		-- Returns true if the current class node has a seaparator between the
		-- attributes and methods compartments
			-- CONTEXT: 	UMLDI!GraphNode
			-- IN:			N/A
			-- RETURN:		Boolean
			-- CALLS:		isOfType
helper context UMLDI!GraphNode def: hasAttSeparator(): Boolean =
	self.contained->select( e | e.isOfType('CompartmentSeparator'))->size() = 2;

		-- HELPER isNamed
		-- Checks whether the association is named.
			-- CONTEXT: 	UMLDI!GraphEdge
			-- IN:			N/A
			-- RETURN:		Boolean
helper context UMLDI!GraphEdge def: isNamed(): Boolean =
	not self.semanticModel.element.name.oclIsUndefined();

helper context UMLDI!GraphEdge def: isStereotypeNamed(): Boolean =
	not self.contained->select( e |
		e .isOfType('StereotypeCompartment'))->
			first().contained->select( e |
				e.isOfKind(UMLDI!Stereotype))->
				first().semanticModel.element.name.oclIsUndefined();

		-- HELPER hasLeftRole
		-- Checks whether the association has a role on
		-- its first connection.
			-- CONTEXT: 	UMLDI!GraphEdge
			-- IN:			N/A
			-- RETURN:		Boolean
helper context UMLDI!GraphEdge def: hasLeftRole(): Boolean =
	not self.semanticModel.element.connection->
		first().name.oclIsUndefined();

		-- HELPER hasRightRole
		-- Checks whether the association has a role on
		-- its last connection.
			-- CONTEXT: 	UMLDI!GraphEdge
			-- IN:			N/A
			-- RETURN:		Boolean
helper context UMLDI!GraphEdge def: hasRightRole(): Boolean =
	not self.semanticModel.element.connection->
		last().name.oclIsUndefined();

		-- HELPER hasLeftMultiplicity
		-- Checks whether the association has a multiplicity fifferent
		-- from 1-1 on it first connection.
			-- CONTEXT: 	UMLDI!GraphEdge
			-- IN:			N/A
			-- RETURN:		Boolean
helper context UMLDI!GraphEdge def: hasLeftMultiplicity(): Boolean =
	self.semanticModel.element.connection->first().multiplicity.range->
		asSequence()->first().lower <> 1 or
	self.semanticModel.element.connection->first().multiplicity.range->
		asSequence()->last().upper <> 1;

		-- HELPER hasRightMultiplicity
		-- Checks whether the association has a multiplicity fifferent
		-- from 1-1 on it last connection.
			-- CONTEXT: 	UMLDI!GraphEdge
			-- IN:			N/A
			-- RETURN:		Boolean
helper context UMLDI!GraphEdge def: hasRightMultiplicity(): Boolean =
	self.semanticModel.element.connection->last().multiplicity.range->
		asSequence()->first().lower <> 1 or
	self.semanticModel.element.connection->last().multiplicity.range->
		asSequence()->last().upper <> 1;

		-- HELPER hasMarkerStart
		-- Checks whether the association has a marker,
		-- ie when it is either a one way association or
		-- a composition or aggregation one (or maybe both), and
		-- that it should be on the first side of the association.
			-- CONTEXT: 	UMLDI!GraphEdge
			-- IN:			N/A
			-- RETURN:		Boolean
helper context UMLDI!GraphEdge def: hasMarkerStart(): Boolean =
	(self.semanticModel.element.connection->first().isNavigable and
	not(self.semanticModel.element.connection->last().isNavigable))
	or self.semanticModel.element <> 'none';

		-- HELPER hasMarkerEnd
		-- Checks whether the association has a marker,
		-- ie when it is either a one way association or
		-- a composition or aggregation one (or maybe both), and
		-- that it should be on the last side of the association.
			-- CONTEXT: 	UMLDI!GraphEdge
			-- IN:			N/A
			-- RETURN:		Boolean
helper context UMLDI!GraphEdge def: hasMarkerEnd(): Boolean =
	(not(self.semanticModel.element.connection->first().isNavigable) and
	self.semanticModel.element.connection->last().isNavigable)
	or self.semanticModel.element <> 'none';

	-- End Boolean Helpers

	-- Coordinates Helpers
	
		-- HELPER getAbsoluteNoOffsetX
		-- Returns the absolute horizontal coordinate computed by
		-- getting the position of the current node and by
		-- recursively adding it to its parent's (XML way)
			-- CONTEXT:	UMLDI!GraphElement
			-- IN:			N/A
			-- RETURN: 	Real
helper context UMLDI!GraphElement def: getAbsoluteNoOffsetX(): Real =
	if not self.oclIsKindOf(UMLDI!Diagram) then
		self.position.x + self.container.getAbsoluteNoOffsetX()
	else
		self.position.x
	endif;

		-- HELPER getAbsoluteNoOffsetY
		-- Returns the absolute vertical coordinate computed by
		-- getting the position of the current node and by
		-- recursively adding it to its parent's (XML way)
			-- CONTEXT:	UMLDI!GraphElement
			-- IN:			N/A
			-- RETURN: 	Real
helper context UMLDI!GraphElement def: getAbsoluteNoOffsetY(): Real =
	if not self.oclIsKindOf(UMLDI!Diagram) then
		self.position.y + self.container.getAbsoluteNoOffsetY()
	else
		self.position.y
	endif;

		-- HELPER offset
		-- Returns a tuple containing the smallest absolute horizontal
		-- coordinate and the smallest vertical one. This helper is
		-- computed only once. 0 is added so that the minimum is
		-- always negative or null.
		-- Another offset called viewOffset is added so as to have some
		-- margin
			-- CONTEXT:	thisModule
			-- IN: 		N/A
			-- RETURN:		Tuple (minX: Real, minY: Real)
			-- CALLS:		getAbsoluteNoOffsetX
			--				getAbsoluteNoOffsetY
helper def: offset: TupleType (minX: Real, minY: Real) =
	let leaves: Sequence(UMLDI!GraphElement) = 
		UMLDI!GraphElement.allInstances()->select( e | e.contained->
			isEmpty()) in
	let setMinX: Set (Real) = leaves->iterate( e; acc: Set (Real) =
		Set {} |
		acc->including(e.getAbsoluteNoOffsetX())) in
	let setMinY: Set (Real) = leaves->iterate( e; acc: Set (Real) =
		Set {} |
		acc->including(e.getAbsoluteNoOffsetY())) in
	let viewOffset: Real = 20.0 in
	Tuple { x = setMinX->iterate(e; acc: Real = 0 |
		if e < acc then e else acc endif) - viewOffset,
		y = setMinY->iterate(e; acc: Real = 0 |
		if e < acc then e else acc endif) - viewOffset };

		-- HELPER getAbsoluteX
		-- Returns the absolute X coordinate corrected with the X offset
			-- CONTEXT: 	UMLDI!GraphElement
			-- IN:			N/A
			-- RETURN:		Real
			-- CALLS:		getAbsoluteNoOffsetX
			--				offset
helper context UMLDI!GraphElement def: getAbsoluteX(): Real =
	self.getAbsoluteNoOffsetX() - thisModule.offset.x;

		-- HELPER getAbsoluteY
		-- Returns the absolute Y coordinate corrected with the Y offset
			-- CONTEXT: 	UMLDI!GraphElement
			-- IN:			N/A
			-- RETURN:		Real
			-- CALLS:		getAbsoluteNoOffsetY
			--				offset
helper context UMLDI!GraphElement def: getAbsoluteY(): Real =
	self.getAbsoluteNoOffsetY() - thisModule.offset.y;

	-- End coordinates helpers
	
	-- HELPER diagram
	-- Returns the diagram element of the UMLDI model
		-- CONTEXT:		thisModule
		-- IN:			N/A
		-- RETURN:		UMLDI!Diagram
helper def: diagram: UMLDI!Diagram =
	UMLDI!Diagram.allInstances()->asSequence()->first();
	
	-- UMLDI information helpers
	
		-- HELPER mult
		-- Checks whether the attribute has a multiplicity. If so,
		-- proceeds to getMultiplicity.
			-- CONTEXT:	UMLDI!GraphNode
			-- IN: 		N/A
			-- RETURN:		String (multiplicity)
			-- CALLS: 		getMultiplicity
helper context UMLDI!GraphNode def: mult(): String =
	if self.semanticModel.element.multiplicity.oclIsUndefined() then
		''
	else
		self.semanticModel.element.multiplicity.getMultiplicity()
	endif;

		-- HELPER getMultiplicity
		-- Returns either an empty string (multiplicity 1-1) or
		-- the corresponding multiplicity.
			-- CONTEXT:	UMLDI!Multiplicity
			-- IN:			N/A
			-- RETURN:		String
helper context UMLDI!Multiplicity def: getMultiplicity(): String =
	let lower: String = self.range->asSequence()->first().lower in
	let upper: String = self.range->asSequence()->last().upper in
	if lower = 0 and upper = 0-1 then
		'*'
	else
		if lower = 0 then
			lower.toString() + '..' + upper.toString()
		else
			if upper = 0-1 then
				lower.toString() + '..' + '*'
			else
				lower.toString() + '..' + upper.toString()
			endif
		endif
	endif;

		-- HELPER getInitialValue
		-- Returns if it exists the initial value for the caller
		-- attribute.
			-- CONTEXT:	UMLDI!GraphNode
			-- IN:			N/A
			-- RETURN:		String
helper context UMLDI!GraphNode def: getInitialValue(): String =
	let elt: UMLDI!Attribute = self.semanticModel.element in
	if not elt.initialValue.oclIsUndefined() then
		if elt.initialValue <> '' then
			'= ' + elt.initialValue.body
		else
			''
		endif
	else
		''
	endif;

		-- HELPER getVisibility
		-- Returns the visibility of the current attribute/operation.
			-- CONTEXT:	UMLDI!GraphNode
			-- IN:			N/A
			-- RETURN:		String
helper context UMLDI!GraphNode def: getVisibility(): String =
	let visibility: String = self.semanticModel.element.visibility in
	if visibility = #vk_public then
		'+'
	else
		if visibility = #vk_package then
			'~'
		else if visibility = #vk_private then
				'-'
			else
				'#'
			endif
		endif
	endif;

		-- HELPER getParameters
		-- Returns the parameters of the current attribute/operation,
		-- with their type.
			-- CONTEXT:	UMLDI!GraphNode
			-- IN:			N/A
			-- RETURN:		String
helper context UMLDI!GraphNode def: getParameters(): String =
	let element: UMLDI!Operation = self.semanticModel.element in
	let end: Integer = element.parameter->size() in
	if end <> 1 then
		element.parameter->iterate( e; acc: String = '' |
			if e.kind <> #pdk_return then
				if e.name = element.parameter->last().name then
					acc + e.name + ':' + e.type.name
				else
					acc + e.name + ':' + e.type.name + ','
				endif
			else
				''
			endif)
	else
		''
	endif;

		-- HELPER getReturnParameter
		-- Returns the return type of the current operation.
			-- CONTEXT:	UMLDI!GraphNode
			-- IN:			N/A
			-- RETURN:		String
helper context UMLDI!GraphNode def: getReturnParameter(): String =
	self.semanticModel.element.parameter->
		select( p | p.kind = #pdk_return)->first().type.name;

		-- HELPER getName
		-- Returns the name of the current association.
			-- CONTEXT:	UMLDI!GraphEdge
			-- IN:			N/A
			-- RETURN:		String
helper context UMLDI!GraphEdge def: getName(): String =
	if self.isNamed() then
		self.semanticModel.element.name
	else
		''
	endif;

		-- HELPER getMarker
		-- Returns the marker type for this part of the association
		-- or 'none' if there is none.
			-- CONTEXT:	UMLDI!GraphNode
			-- IN:			position: String (start|end)
			-- RETURN:		String
helper context UMLDI!GraphEdge def: getMarker(position: String): String =
	let element: UMLDI!Association = 
		self.semanticModel.element in
	let connection1: UMLDI!AssociationEnd = 
		element.connection->first() in
	let connection2: UMLDI!AssociationEnd = 
		element.connection->last() in
	if position = 'start' then
		if self.hasMarkerStart() then
			if connection1.isNavigable and
				not connection2.isNavigable then
				'url(#Association)'
			else
				if connection1.aggregation = #ak_composite then
					'url(#Composition)'
				else
					if connection1.aggregation = #ak_none then
						'none'
					else
						'url(#Aggregation)'
					endif
				endif
			endif
		else
			'none'
		endif
	else
		if self.hasMarkerEnd() then
			if not(connection1.isNavigable) and
				connection2.isNavigable then
				'url(#Association)'
			else
				if connection2.aggregation = #ak_composite then
					'url(#Composition)'
				else
					if connection2.aggregation = #ak_none then
						'none'
					else
						'url(#Aggregation)'
					endif
				endif
			endif
		else
			'none'
		endif
	endif;

-- End Helpers

-- Rules
	-- RULE Diagram2SVG
	-- Creates the SVG element with its definition element
	-- which contains all the different marker symbols that
	-- can be found in a class diagram. That part is static,
	-- whereas size and position are computed.
rule Diagram2SVG {
	from
		d: UMLDI!Diagram
	to
		out: SVG!Svg (
			namespace <- 'http://www.w3.org/2000/svg',
			version <- '1.0',
			position <- abs,
			size <- dim,
			children <- Sequence {definitions}
			),
			abs: SVG!AbsoluteCoord (
				x <- d.getAbsoluteX(),
				y <- d.getAbsoluteY()
			),
			dim: SVG!Dimension (
				width <- d.size.width,
				height <- d.size.height
			),
			definitions: SVG!Defs (
				groupContent <- 
					Sequence {Association, Generalization, Dependency,
						Aggregation, Composition}
			),
				Association: SVG!Marker (
					identifier <- 'Association',
					refX <- 10.0,
					refY <- 5.0,
					markerWidth <- 11.0,
					markerHeight <- 11.0,
					orient <- 'auto',
					fill <- 'none',
					viewBox <- '0 0 10 10',
					drawing <- associationPathGroup
				),
					associationPathGroup: SVG!G (
						groupContent <- associationPath	
					),
						associationPath: SVG!Path (
							stroke <- 'black',
							d <- 'M 0 0 L 10 5 L 0 10'
						),
				Generalization: SVG!Marker (
					identifier <- 'Generalization',
					refX <- 10.0,
					refY <- 5.0,
					markerWidth <- 11.0,
					markerHeight <- 11.0,
					orient <- 'auto',
					fill <- 'white',
					viewBox <- '0 0 10 10',
					drawing <- generalizationPathGroup
				),
					generalizationPathGroup: SVG!G (
						groupContent <- 
							Sequence {generalizationPath1, generalizationPath2}
					),
						generalizationPath1: SVG!Path (
							stroke <- 'black',
							d <- 'M 0 0 L 10 5 L 0 10'
						),
						generalizationPath2: SVG!Path (
							stroke <- 'black',
							d <- 'M 0.05 0.2 L 0.2 9.95'
						),
				Dependency: SVG!Marker (
					identifier <- 'Dependency',
					refX <- 10.0,
					refY <- 5.0,
					markerWidth <- 11.0,
					markerHeight <- 11.0,
					orient <- 'auto',
					fill <- 'none',
					viewBox <- '0 0 10 10',
					drawing <- dependencyPathGroup
				),
					dependencyPathGroup: SVG!G (
						groupContent <- dependencyPath	
					),
						dependencyPath: SVG!Path (
							stroke <- 'black',
							d <- 'M 0 0 L 10 5 L 0 10'
						),
				Aggregation: SVG!Marker (
					identifier <- 'Aggregation',
					refX <- 10.0,
					refY <- 5.0,
					markerWidth <- 11.0,
					markerHeight <- 11.0,
					orient <- '180',
					fill <- 'white',
					viewBox <- '0 0 10 10',
					drawing <- aggregationPathGroup
				),
					aggregationPathGroup: SVG!G (
						groupContent <- aggregationPath	
					),
						aggregationPath: SVG!Path (
							stroke <- 'black',
							d <- 'M 0 5 L 5 10 L 10 5 L 5 0 L 0 5'
						),
				Composition: SVG!Marker (
					identifier <- 'Composition',
					refX <- 10.0,
					refY <- 5.0,
					markerWidth <- 11.0,
					markerHeight <- 11.0,
					orient <- '180',
					fill <- 'black',
					viewBox <- '0 0 10 10',
					drawing <- compositionPathGroup
				),
					compositionPathGroup: SVG!G (
						groupContent <- compositionPath	
					),
						compositionPath: SVG!Path (
							stroke <- 'black',
							d <- 'M 0 5 L 5 10 L 10 5 L 5 0 L 0 5'
						)
}

	-- Classes matching
	-- All these rules return a Group containing:
	-- 		+ the rectangle drawing the class
	-- 		+ the name of the class
	--		+ the line under the name
	-- Attributes and methods, if they exist, are treated in other rules,
	-- and are put in a group each. This in fine gives a structured class.
	
		-- RULE FullClassBox
		-- Matches classes that do contain attributes and methods.
rule FullClassBox {
	from 
		n: UMLDI!GraphNode (
			if n.isOfKind(UMLDI!Class) or n.isOfKind(UMLDI!Interface) then
				n.hasAttributes() and n.hasMethods() and n.hasAttSeparator()
			else
				false
			endif
		)
	to
		-- The group element that structures the class
		out: SVG!G (
			name <- 'Class_' + n.semanticModel.element.name,
			groupContent <- 
				Sequence {rect, nameSep, name, attlist, attSep,
					methodlist},
			root <- thisModule.diagram
		),
		
		-- The rectangle that draws the outline of the class
		-- with its size and its position
		rect: SVG!Rect (
			fill <- 'white',
			stroke <- 'black',
			position <- rectpos,
			size <- rectdim
		),
		rectpos: SVG!AbsoluteCoord (
			x <- n.getAbsoluteX(),
			y <- n.getAbsoluteY()
		),
		rectdim: SVG!Dimension (
			width <- n.size.width,
			height <- n.size.height
		),
		
		-- The separator that is drawn below the name of the class
		-- with its origin and its end
		nameSep: SVG!Line (
			between <- Sequence {origin1, end1},
			stroke <- 'black'
		),
		origin1: SVG!Point (
			position <- origin1Pos
		),
		origin1Pos: SVG!AbsoluteCoord (
			x <- n.getAbsoluteX(),
			y <- n.contained->select( e |
				e.semanticModel.typeInfo = 'CompartmentSeparator')->
				first().size.height + n.getAbsoluteY() +
				n.contained->select( e |
					e.isOfType('NameCompartment'))->
					first().contained->select( e |
						e.isOfType('Name'))->first().size.height
		),
		end1: SVG!Point (
			position <- end1Pos
		),
		end1Pos: SVG!AbsoluteCoord (
			x <- n.getAbsoluteX() + n.size.width,
			y <- n.contained->select( e |
				e.semanticModel.typeInfo = 'CompartmentSeparator')->
				first().size.height +
				n.getAbsoluteY() +
				n.contained->select( e |
					e.isOfType('NameCompartment'))->
					first().contained->select( e |
						e.isOfType('Name'))->first().size.height
		),
		
		-- The name of the class, with its weight, style, and position
		name: SVG!Text (
			content <- n.semanticModel.element.name,
			position <- textPos,
			attribute <- Sequence {fontWeight, fontStyle},
			fill <- 'black',
			fontSize <- '11px'
		),
		textPos: SVG!AbsoluteCoord (
			x <- n.contained->select( e |
				e.semanticModel.typeInfo = 'NameCompartment')->
				first().contained->first().getAbsoluteX(),
			y <- n.contained->select( e |
				e.semanticModel.typeInfo = 'NameCompartment')->
				first().contained->first().getAbsoluteY() + 
				n.contained->select( e |
					e.semanticModel.typeInfo = 'NameCompartment')->
					first().size.height/2
		),
		fontWeight: SVG!FontWeight (
			bold <- true	
		),
		fontStyle: SVG!FontStyle (
			italic <- n.semanticModel.element.isAbstract	
		),
		
		-- The group that will contain and thus structure the attributes
		-- of the class
		attlist: SVG!G (
			name <- 'Attributes of Class_' + n.semanticModel.element.name,
			groupContent <- n.contained->select( e |
				e.isOfType('AttributeCompartment'))->first().contained->
				select( e | e.isOfType('DelimitedSection'))->first().contained
		),
		
		-- The separator between attributes and methods
		-- with its origin and its end
		attSep: SVG!Line (
			between <- Sequence {origin2, end2},
			stroke <- 'black'
		),
		origin2: SVG!Point (
			position <- origin2Pos
		),
		origin2Pos: SVG!AbsoluteCoord (
			x <- n.getAbsoluteX(),
			y <- n.contained->select( e |
				e.semanticModel.typeInfo = 'NameCompartment')->
				last().size.height + n.getAbsoluteY() +
				n.contained->select( e |
					e.isOfType('AttributeCompartment'))->
					first().size.height
		),
		end2: SVG!Point (
			position <- end2Pos
		),
		end2Pos: SVG!AbsoluteCoord (
			x <- n.getAbsoluteX() + n.size.width,
			y <- n.contained->select( e |
				e.semanticModel.typeInfo = 'NameCompartment')->
				last().size.height + n.getAbsoluteY() +
				n.contained->select( e |
					e.isOfType('AttributeCompartment'))->
					first().size.height
		),
		
		-- The group that will contain and thus structure the methods
		-- of the class
		methodlist: SVG!G (
			name <- 'Operations of Class_' + n.semanticModel.element.name,
			groupContent <- n.contained->select( e |
				e.isOfType('OperationCompartment'))->first().contained->
				select( e | e.isOfType('DelimitedSection'))->first().contained
		)		
}

		-- RULE EmptyClassBoxNoSeparator
		-- Matches classes that do not have attributes, methods nor separator
		-- (the line that separates attributes from methods)
rule EmptyClassBoxNoSeparator {
	from
		n: UMLDI!GraphNode (
			if n.isOfKind(UMLDI!Class) or n.isOfKind(UMLDI!Interface) then
				not(n.hasAttributes()) and not(n.hasMethods()) 
				and not(n.hasAttSeparator())
			else
				false
			endif
		)
	to
		-- The group element that structures the class
		out: SVG!G (
			name <- 'Class_' + n.semanticModel.element.name,
			groupContent <- Sequence {rect, nameSep, name},
			root <- thisModule.diagram
		),
		
		-- The rectangle that draws the outline of the class
		-- with its size and its position
		rect: SVG!Rect (
			fill <- 'white',
			stroke <- 'black',
			position <- rectpos,
			size <- rectdim
		),
		rectpos: SVG!AbsoluteCoord (
			x <- n.getAbsoluteX(),
			y <- n.getAbsoluteY()
		),
		rectdim: SVG!Dimension (
			width <- n.size.width,
			height <- n.size.height
		),
			
		-- The separator that is drawn below the name of the class
		-- with its origin and its end
		nameSep: SVG!Line (
			between <- Sequence {origin1, end1},
			stroke <- 'black'
		),
		origin1: SVG!Point (
			position <- origin1Pos
		),
		origin1Pos: SVG!AbsoluteCoord (
			x <- n.getAbsoluteX(),
			y <- n.contained->select( e |
				e.semanticModel.typeInfo = 'CompartmentSeparator')->
				first().size.height +
				n.getAbsoluteY() +
				n.contained->select( e |
					e.isOfType('NameCompartment'))->
					first().contained->select( e |
						e.isOfType('Name'))->first().size.height
		),
		end1: SVG!Point (
			position <- end1Pos
		),
		end1Pos: SVG!AbsoluteCoord (
			x <- n.getAbsoluteX() + n.size.width,
			y <- n.contained->select( e |
				e.semanticModel.typeInfo = 'CompartmentSeparator')->
				first().size.height +
				n.getAbsoluteY() +
				n.contained->select( e |
					e.isOfType('NameCompartment'))->
					first().contained->select( e |
						e.isOfType('Name'))->first().size.height
		),
		
		-- The name of the class, with its weight, style, and position
		name: SVG!Text (
			content <- n.semanticModel.element.name,
			position <- textPos,
			attribute <- Sequence {fontWeight},
			fill <- 'black',
			fontSize <- '11px'
		),
		textPos: SVG!AbsoluteCoord (
			x <- n.contained->select( e |
				e.semanticModel.typeInfo = 'NameCompartment')->
				first().contained->first().getAbsoluteX(),
			y <- n.contained->select( e |
				e.semanticModel.typeInfo = 'NameCompartment')->
				first().contained->first().getAbsoluteY() +
				n.contained->select( e |
					e.semanticModel.typeInfo = 'NameCompartment')->
					first().size.height/2
		),
		fontWeight: SVG!FontWeight (
			bold <- true	
		)
}
		
		-- RULE EmptyClassBoxWithSeparator
		-- Matches classes that do not have attributes nor methods but do
		-- have a separator.
rule EmptyClassBoxWithSeparator {
	from 
		n: UMLDI!GraphNode (
			if n.isOfKind(UMLDI!Class) or n.isOfKind(UMLDI!Interface) then 
				not(n.hasAttributes()) and not(n.hasMethods())
				and n.hasAttSeparator()
			else
				false
			endif
		)
	to
		-- The group element that structures the class
		out: SVG!G (
			name <- 'Class_' + n.semanticModel.element.name,
			groupContent <- Sequence {rect, nameSep, name, attSep},
			root <- thisModule.diagram
		),
		
		-- The rectangle that draws the outline of the class
		-- with its size and its position
		rect: SVG!Rect (
			fill <- 'white',
			stroke <- 'black',
			position <- rectpos,
			size <- rectdim
		),
		rectpos: SVG!AbsoluteCoord (
			x <- n.getAbsoluteX(),
			y <- n.getAbsoluteY()
		),
		rectdim: SVG!Dimension (
			width <- n.size.width,
			height <- n.size.height
		),
		
		-- The separator that is drawn below the name of the class
		-- with its origin and its end
		nameSep: SVG!Line (
			between <- Sequence {origin1, end1},
			stroke <- 'black'
		),
		origin1: SVG!Point (
			position <- origin1Pos
		),
		origin1Pos: SVG!AbsoluteCoord (
			x <- n.getAbsoluteX(),
			y <- n.contained->select( e |
				e.semanticModel.typeInfo = 'CompartmentSeparator')->
				first().size.height +
				n.getAbsoluteY() +
				n.contained->select( e |
					e.isOfType('NameCompartment'))->
					first().contained->select( e |
						e.isOfType('Name'))->first().size.height
		),
		end1: SVG!Point (
			position <- end1Pos
		),
		end1Pos: SVG!AbsoluteCoord (
			x <- n.getAbsoluteX() + n.size.width,
			y <- n.contained->select( e |
				e.semanticModel.typeInfo = 'CompartmentSeparator')->
				first().size.height +
				n.getAbsoluteY() +
				n.contained->select( e |
					e.isOfType('NameCompartment'))->
					first().contained->select( e |
						e.isOfType('Name'))->first().size.height
		),
				
		-- The name of the class, with its weight, style, and position
		name: SVG!Text (
			content <- n.semanticModel.element.name,
			position <- textPos,
			attribute <- Sequence {fontWeight},
			fill <- 'black',
			fontSize <- '11px'
		),
		textPos: SVG!AbsoluteCoord (
			x <- n.contained->select( e |
				e.semanticModel.typeInfo = 'NameCompartment')->
				first().contained->first().getAbsoluteX(),
			y <- n.contained->select( e |
				e.semanticModel.typeInfo = 'NameCompartment')->
				first().contained->first().getAbsoluteY() +
				n.contained->select( e |
					e.semanticModel.typeInfo = 'NameCompartment')->
					first().size.height/2
		),
		fontWeight: SVG!FontWeight (
			bold <- true	
		),
			
		-- The separator between attributes and methods
		-- with its origin and its end
		attSep: SVG!Line (
			between <- Sequence {origin2, end2},
			stroke <- 'black'
		),
		origin2: SVG!Point (
			position <- origin2Pos
		),
		origin2Pos: SVG!AbsoluteCoord (
			x <- n.getAbsoluteX(),
			y <- n.contained->select( e |
				e.semanticModel.typeInfo = 'NameCompartment')->
				last().size.height +
				n.getAbsoluteY() +
				n.contained->select( e |
					e.isOfType('AttributeCompartment'))->
					first().size.height
		),
		end2: SVG!Point (
			position <- end2Pos
		),
		end2Pos: SVG!AbsoluteCoord (
			x <- n.getAbsoluteX() + n.size.width,
			y <- n.contained->select( e |
				e.semanticModel.typeInfo = 'NameCompartment')->
				last().size.height +
				n.getAbsoluteY() +
				n.contained->select( e |
					e.isOfType('AttributeCompartment'))->
					first().size.height
		)
}

		-- RULE AttributeOnlyClassBoxWithSeparator
		-- Matches classes that do have attributes, a separator
		-- but no methods.
rule AttributeOnlyClassBoxWithSeparator {
	from 
		n: UMLDI!GraphNode (
			if n.isOfKind(UMLDI!Class) or n.isOfKind(UMLDI!Interface) then
				n.hasAttributes() and not(n.hasMethods()) and 
				n.hasAttSeparator()
			else
				false
			endif
		)
	to
		-- The group element that structures the class
		out: SVG!G (
			name <- 'Class_' + n.semanticModel.element.name,
			groupContent <- Sequence {rect, nameSep, name, attlist, attSep},
			root <- thisModule.diagram
		),
		
		-- The rectangle that draws the outline of the class
		-- with its size and its position
		rect: SVG!Rect (
			fill <- 'white',
			stroke <- 'black',
			position <- rectpos,
			size <- rectdim
		),
		rectpos: SVG!AbsoluteCoord (
			x <- n.getAbsoluteX(),
			y <- n.getAbsoluteY()
		),
		rectdim: SVG!Dimension (
			width <- n.size.width,
			height <- n.size.height
		),
		
		-- The separator that is drawn below the name of the class
		-- with its origin and its end
		nameSep: SVG!Line (
			between <- Sequence {origin1, end1},
			stroke <- 'black'
		),
		origin1: SVG!Point (
			position <- origin1Pos
		),
		origin1Pos: SVG!AbsoluteCoord (
			x <- n.getAbsoluteX(),
			y <- n.contained->select( e | 
				e.semanticModel.typeInfo = 'CompartmentSeparator')->
				first().size.height +
				n.getAbsoluteY() +
				n.contained->select( e |
					e.isOfType('NameCompartment'))->
					first().contained->select( e |
						e.isOfType('Name'))->first().size.height
		),
		end1: SVG!Point (
			position <- end1Pos
		),
		end1Pos: SVG!AbsoluteCoord (
			x <- n.getAbsoluteX() + n.size.width,
			y <- n.contained->select( e |
				e.semanticModel.typeInfo = 'CompartmentSeparator')->
				first().size.height +
				n.getAbsoluteY() +
				n.contained->select( e |
					e.isOfType('NameCompartment'))->
					first().contained->select( e |
						e.isOfType('Name'))->first().size.height
		),
				
		-- The name of the class, with its weight, style, and position
		name: SVG!Text (
			content <- n.semanticModel.element.name,
			position <- textPos,
			attribute <- Sequence {fontWeight},
			fill <- 'black',
			fontSize <- '11px'
		),
		textPos: SVG!AbsoluteCoord (
			x <- n.contained->select( e |
				e.semanticModel.typeInfo = 'NameCompartment')->
				first().contained->first().getAbsoluteX(),
			y <- n.contained->select( e |
				e.semanticModel.typeInfo = 'NameCompartment')->
				first().contained->first().getAbsoluteY() +
				n.contained->select( e |
					e.semanticModel.typeInfo = 'NameCompartment')->
					first().size.height/2
		),
		fontWeight: SVG!FontWeight (
			bold <- true	
		),
			
		-- The group that will contain and thus structure the attributes
		-- of the class
		attlist: SVG!G (
			name <- 'Attributes of Class_' + n.semanticModel.element.name,
			groupContent <- n.contained->select( e |
				e.isOfType('AttributeCompartment'))->
				first().contained->select( e |
					e.isOfType('DelimitedSection'))->first().contained
		),
		
		-- The separator between attributes and methods
		-- with its origin and its end
		attSep: SVG!Line (
			between <- Sequence {origin2, end2},
			stroke <- 'black'
		),
		origin2: SVG!Point (
			position <- origin2Pos
		),
		origin2Pos: SVG!AbsoluteCoord (
			x <- n.getAbsoluteX(),
			y <- n.contained->select( e |
				e.semanticModel.typeInfo = 'NameCompartment')->
				last().size.height +
				n.getAbsoluteY() +
				n.contained->select( e |
					e.isOfType('AttributeCompartment'))->
					first().size.height
		),
		end2: SVG!Point (
			position <- end2Pos
		),
		end2Pos: SVG!AbsoluteCoord (
			x <- n.getAbsoluteX() + n.size.width,
			y <- n.contained->select( e |
				e.semanticModel.typeInfo = 'NameCompartment')->
				last().size.height +
				n.getAbsoluteY() +
				n.contained->select( e |
					e.isOfType('AttributeCompartment'))->
					first().size.height
		)	
}

		-- RULE AttributeOnlyClassBoxNoSeparator
		-- Matches classes that do have attributes, no separator
		-- and no methods.
rule AttributeOnlyClassBoxNoSeparator {
	from 
		n: UMLDI!GraphNode (
			if n.isOfKind(UMLDI!Class) or n.isOfKind(UMLDI!Interface) then
				n.hasAttributes() and not(n.hasMethods()) and 
				not(n.hasAttSeparator())
			else
				false
			endif
		)
	to
		-- The group element that structures the class
		out: SVG!G (
			name <- 'Class_' + n.semanticModel.element.name,
			groupContent <- Sequence {rect, nameSep, name, attlist},
			root <- thisModule.diagram
		),
		
		-- The rectangle that draws the outline of the class
		-- with its size and its position
		rect: SVG!Rect (
			fill <- 'white',
			stroke <- 'black',
			position <- rectpos,
			size <- rectdim
		),
		rectpos: SVG!AbsoluteCoord (
			x <- n.getAbsoluteX(),
			y <- n.getAbsoluteY()
		),
		rectdim: SVG!Dimension (
			width <- n.size.width,
			height <- n.size.height
		),
		
		-- The separator that is drawn below the name of the class
		-- with its origin and its end
		nameSep: SVG!Line (
			between <- Sequence {origin1, end1},
			stroke <- 'black'
		),
		origin1: SVG!Point (
			position <- origin1Pos
		),
		origin1Pos: SVG!AbsoluteCoord (
			x <- n.getAbsoluteX(),
			y <- n.contained->select( e |
				e.semanticModel.typeInfo = 'CompartmentSeparator')->
				first().size.height +
				n.getAbsoluteY() +
				n.contained->select( e |
					e.isOfType('NameCompartment'))->
					first().contained->select( e |
						e.isOfType('Name'))->first().size.height
		),
		end1: SVG!Point (
			position <- end1Pos
		),
		end1Pos: SVG!AbsoluteCoord (
			x <- n.getAbsoluteX() + n.size.width,
			y <- n.contained->select( e |
				e.semanticModel.typeInfo = 'CompartmentSeparator')->
				first().size.height +
				n.getAbsoluteY() +
				n.contained->select( e |
					e.isOfType('NameCompartment'))->
					first().contained->select( e |
						e.isOfType('Name'))->first().size.height
		),
				
		-- The name of the class, with its weight, style, and position
		name: SVG!Text (
			content <- n.semanticModel.element.name,
			position <- textPos,
			attribute <- Sequence {fontWeight},
			fill <- 'black',
			fontSize <- '11px'
		),
		textPos: SVG!AbsoluteCoord (
			x <- n.contained->select( e |
				e.semanticModel.typeInfo = 'NameCompartment')->
				first().contained->first().getAbsoluteX(),
			y <- n.contained->select( e |
				e.semanticModel.typeInfo = 'NameCompartment')->
				first().contained->first().getAbsoluteY() +
				n.contained->select( e |
					e.semanticModel.typeInfo = 'NameCompartment')->
					first().size.height/2
		),
		fontWeight: SVG!FontWeight (
			bold <- true	
		),
			
		-- The group that will contain and thus structure the attributes
		-- of the class
		attlist: SVG!G (
			name <- 'Attributes of Class_' + n.semanticModel.element.name,
			groupContent <- n.contained->select( e |
				e.isOfType('AttributeCompartment'))->
				first().contained->select( e |
					e.isOfType('DelimitedSection'))->first().contained
		)
}

		-- RULE MethodOnlyClassBoxWithSeparator
		-- Matches classes that do have methods, a separator
		-- and no attributes.
rule MethodOnlyClassBoxWithSeparator {
	from 
		n: UMLDI!GraphNode (
			if n.isOfKind(UMLDI!Class) or n.isOfKind(UMLDI!Interface) then
				not(n.hasAttributes()) and n.hasMethods()
				and n.hasAttSeparator()
			else
				false
			endif
		)
	to
		-- The group element that structures the class
		out: SVG!G (
			name <- 'Class_' + n.semanticModel.element.name,
			groupContent <- Sequence {rect, nameSep, name, attSep, methodlist},
			root <- thisModule.diagram
		),
		
		-- The rectangle that draws the outline of the class
		-- with its size and its position
		rect: SVG!Rect (
			fill <- 'white',
			stroke <- 'black',
			position <- rectpos,
			size <- rectdim
		),
		rectpos: SVG!AbsoluteCoord (
			x <- n.getAbsoluteX(),
			y <- n.getAbsoluteY()
		),
		rectdim: SVG!Dimension (
			width <- n.size.width,
			height <- n.size.height
		),
		
		-- The separator that is drawn below the name of the class
		-- with its origin and its end
		nameSep: SVG!Line (
			between <- Sequence {origin1, end1},
			stroke <- 'black'
		),
		origin1: SVG!Point (
			position <- origin1Pos
		),
		origin1Pos: SVG!AbsoluteCoord (
			x <- n.getAbsoluteX(),
			y <- n.contained->select( e |
				e.semanticModel.typeInfo = 'CompartmentSeparator')->
				first().size.height +
				n.getAbsoluteY() +
				n.contained->select( e |
					e.isOfType('NameCompartment'))->
					first().contained->select( e |
						e.isOfType('Name'))->first().size.height
		),
		end1: SVG!Point (
			position <- end1Pos
		),
		end1Pos: SVG!AbsoluteCoord (
			x <- n.getAbsoluteX() + n.size.width,
			y <- n.contained->select( e |
				e.semanticModel.typeInfo = 'CompartmentSeparator')->
				first().size.height +
				n.getAbsoluteY() +
				n.contained->select( e |
					e.isOfType('NameCompartment'))->
					first().contained->select( e |
						e.isOfType('Name'))->first().size.height
		),
				
		-- The name of the class, with its weight, style, and position
		name: SVG!Text (
			content <- n.semanticModel.element.name,
			position <- textPos,
			attribute <- Sequence {fontWeight},
			fill <- 'black',
			fontSize <- '11px'
		),
		textPos: SVG!AbsoluteCoord (
			x <- n.contained->select( e |
				e.semanticModel.typeInfo = 'NameCompartment')->
				first().contained->first().getAbsoluteX(),
			y <- n.contained->select( e |
				e.semanticModel.typeInfo = 'NameCompartment')->
				first().contained->first().getAbsoluteY() +
				n.contained->select( e |
					e.semanticModel.typeInfo = 'NameCompartment')->
					first().size.height/2
		),
		fontWeight: SVG!FontWeight (
			bold <- true	
		),
			
		-- The separator between attributes and methods
		-- with its origin and its end
		attSep: SVG!Line (
			between <- Sequence {origin2, end2},
			stroke <- 'black'
		),
		origin2: SVG!Point (
			position <- origin2Pos
		),
		origin2Pos: SVG!AbsoluteCoord (
			x <- n.getAbsoluteX(),
			y <- n.contained->select( e |
				e.semanticModel.typeInfo = 'NameCompartment')->
				last().size.height +
				n.getAbsoluteY() +
				n.contained->select( e |
					e.isOfType('AttributeCompartment'))->
					first().size.height
		),
		end2: SVG!Point (
			position <- end2Pos
		),
		end2Pos: SVG!AbsoluteCoord (
			x <- n.getAbsoluteX() + n.size.width,
			y <- n.contained->select( e |
				e.semanticModel.typeInfo = 'NameCompartment')->
				last().size.height + n.getAbsoluteY()
		),
				
		-- The group that will contain and thus structure the methods
		-- of the class
		methodlist: SVG!G (
			name <- 'Operations of Class_' + n.semanticModel.element.name,
			groupContent <- n.contained->select( e |
				e.isOfType('OperationCompartment'))->
				first().contained->select( e |
					e.isOfType('DelimitedSection'))->first().contained
		)
}

		-- RULE MethodOnlyClassBoxNoSeparator
		-- Matches classes that do have methods, no separator
		-- and no attributes.
rule MethodOnlyClassBoxNoSeparator {
	from 
		n: UMLDI!GraphNode (
			if n.isOfKind(UMLDI!Class) or n.isOfKind(UMLDI!Interface) then
				not(n.hasAttributes()) and n.hasMethods() and
				not(n.hasAttSeparator())
			else
				false
			endif
		)
	to
		-- The group element that structures the class
		out: SVG!G (
			name <- 'Class_' + n.semanticModel.element.name,
			groupContent <- Sequence {rect, nameSep, name, methodlist},
			root <- thisModule.diagram
		),
		
		-- The rectangle that draws the outline of the class
		-- with its size and its position
		rect: SVG!Rect (
			fill <- 'white',
			stroke <- 'black',
			position <- rectpos,
			size <- rectdim
		),
		rectpos: SVG!AbsoluteCoord (
			x <- n.getAbsoluteX(),
			y <- n.getAbsoluteY()
		),
		rectdim: SVG!Dimension (
			width <- n.size.width,
			height <- n.size.height
		),
			
		-- The separator that is drawn below the name of the class
		-- with its origin and its end
		nameSep: SVG!Line (
			between <- Sequence {origin1, end1},
			stroke <- 'black'
		),
		origin1: SVG!Point (
			position <- origin1Pos
		),
		origin1Pos: SVG!AbsoluteCoord (
			x <- n.getAbsoluteX(),
			y <- n.contained->select( e |
				e.semanticModel.typeInfo = 'CompartmentSeparator')->
				first().size.height +
				n.getAbsoluteY() +
				n.contained->select( e |
					e.isOfType('NameCompartment'))->
					first().contained->select( e |
						e.isOfType('Name'))->first().size.height
		),
		end1: SVG!Point (
			position <- end1Pos
		),
		end1Pos: SVG!AbsoluteCoord (
			x <- n.getAbsoluteX() + n.size.width,
			y <- n.contained->select( e |
				e.semanticModel.typeInfo = 'CompartmentSeparator')->
				first().size.height +
				n.getAbsoluteY() +
				n.contained->select( e |
					e.isOfType('NameCompartment'))->
					first().contained->select( e |
						e.isOfType('Name'))->first().size.height
		),
				
		-- The name of the class, with its weight, style, and position
		name: SVG!Text (
			content <- n.semanticModel.element.name,
			position <- textPos,
			attribute <- Sequence {fontWeight},
			fill <- 'black',
			fontSize <- '11px'
		),
		textPos: SVG!AbsoluteCoord (
			x <- n.contained->select( e |
				e.semanticModel.typeInfo = 'NameCompartment')->
				first().contained->first().getAbsoluteX(),
			y <- n.contained->select( e |
				e.semanticModel.typeInfo = 'NameCompartment')->
				first().contained->first().getAbsoluteY() +
				n.contained->select( e |
					e.semanticModel.typeInfo = 'NameCompartment')->
					first().size.height/2
		),
		fontWeight: SVG!FontWeight (
			bold <- true	
		),
			
		-- The group that will contain and thus structure the methods
		-- of the class
		methodlist: SVG!G (
			name <- 'Operations of Class_' + n.semanticModel.element.name,
			groupContent <- n.contained->select( e |
				e.isOfType('OperationCompartment'))->
				first().contained->select( e |
					e.isOfType('DelimitedSection'))->first().contained
		)
}		

	-- End classes matching
	
	-- Attributes and Methods
	
		-- RULE Attributes
		-- Matches attributes and returns the corresponding text with:
		-- 		+ the visibility
		-- 		+ the name of the attribute
		--		+ its type
		-- 		+ its multiplicity
		-- 		+ its initial value
rule Attributes {
	from
		a: UMLDI!GraphNode (
			a.isOfKind(UMLDI!Attribute)
		)
	to
		out: SVG!Text (
			content <- a.getVisibility() +
				a.semanticModel.element.name + ':' +
				a.semanticModel.element.type.name +
				a.mult() +
				a.getInitialValue(),
			fill <- 'black',
			position <- atPos,
			fontSize <- '11px'
		),
		atPos: SVG!AbsoluteCoord (
			x <- a.getAbsoluteX(),
			y <- a.getAbsoluteY() + a.contained->select( e |
				e.isOfType('Name'))->first().size.height/2
		)
}
	
		-- RULE Methods
		-- Matches attributes and returns the corresponding text with:
		-- 		+ the visibility
		-- 		+ the name of the method
		-- 		+ its parameters with their types
		--		+ its return type
rule Methods {
	from
		m: UMLDI!GraphNode (
			m.isOfKind(UMLDI!Operation)
		)
	to
		out: SVG!Text (
			content <- m.getVisibility() +
				m.semanticModel.element.name +
				'(' + m.getParameters() + ')' + ':' +
				m.getReturnParameter(),
			fill <- 'black',
			position <- OpPos,
			fontSize <- '11px',
			attribute <- Sequence {fontStyle}
		),
		OpPos: SVG!AbsoluteCoord (
			x <- m.getAbsoluteX(),
			y <- m.getAbsoluteY() + m.contained->select( e |
				e.isOfType('Name'))->first().size.height/2
		),
		fontStyle: SVG!FontStyle (
			italic <- m.semanticModel.element.isAbstract	
		)
}

	-- End Attributes and Methods

	-- Association, dependencies, etc
	
		-- RULE GraphEdge2Association
		-- Creates an association
rule GraphEdge2Association {
	from
		ge: UMLDI!GraphEdge (
			ge.isOfKind(UMLDI!Association)
		)
	to
		-- The group that will contain:
		-- 		+ the line
		--		+ the name
		--		+ the multiplicities
		-- 		+ the roles
		out: SVG!G (
			name <- ge.semanticModel.element.name,
			groupContent <- Sequence {polyline, name, leftMultiplicity,
				rightMultiplicity, leftRole, rightRole},
			root <- thisModule.diagram
		),
		
		-- The line, with its position, markers, and waypoints
		polyline: SVG!Polyline (
			waypoints <- Sequence {wps}->flatten(),
			stroke <- 'black',
			fill <- 'white',
			markerEnd <- ge.getMarker('end'),
			markerStart <- ge.getMarker('start')
		),
		wps: distinct SVG!Point foreach (Point in ge.waypoints) (
			position <- PPos
		),
		PPos: distinct SVG!AbsoluteCoord foreach(Point in ge.waypoints) (
			x <- Point.base.x - thisModule.offset.x,
			y <- Point.base.y - thisModule.offset.y
		),
		
		-- The name of the association, with its position
		name: SVG!Text (
			content <- ge.getName(),
			fill <- 'black',
			position <- namePos,
			fontSize <- '10px'
		),
		namePos: SVG!AbsoluteCoord (
			x <- if ge.isNamed() then
					ge.contained->select( e |
					e.isOfType('DirectedName'))->first().getAbsoluteX()
				else 0.0 endif,
			y <- if ge.isNamed() then
					ge.contained->select( e |
					e.isOfType('DirectedName'))->first().getAbsoluteY()
				else 0.0 endif
		),
		
		-- The first multiplicity
		leftMultiplicity: SVG!Text (
			content <- if ge.hasLeftMultiplicity() then
					ge.semanticModel.element.connection->
					first().multiplicity.getMultiplicity()
				else '' endif,
			fill <- 'black',
			position <- leftMultPos,
			fontSize <- '10px'
		),
		leftMultPos: SVG!AbsoluteCoord (
				x <- if ge.hasLeftMultiplicity() then
					ge.contained->select( e |
						e.isOfKind(UMLDI!AssociationEnd))->
						first().contained->select( e |
							e.isOfType('Multiplicity'))->first().getAbsoluteX()
					else 0.0 endif,
				y <- if ge.hasLeftMultiplicity() then
					ge.contained->select( e |
						e.isOfKind(UMLDI!AssociationEnd))->
						first().contained->select( e |
							e.isOfType('Multiplicity'))->
							first().getAbsoluteY() +
							ge.contained->select( e |
								e.isOfKind(UMLDI!AssociationEnd))->
								first().contained->select( e |
									e.isOfType('Multiplicity'))->
									first().size.height
					else 0.0 endif
		),
		
		-- The second multiplicity
		rightMultiplicity: SVG!Text (
			content <- if ge.hasRightMultiplicity() then
				ge.semanticModel.element.connection->
					last().multiplicity.getMultiplicity()
				else '' endif,
			fill <- 'black',
			position <- rightMultPos,
			fontSize <- '10px'
		),
		rightMultPos: SVG!AbsoluteCoord (
			x <- if ge.hasRightMultiplicity() then
				ge.contained->select( e |
					e.isOfKind(UMLDI!AssociationEnd))->
					last().contained->select( e |
						e.isOfType('Multiplicity'))->last().getAbsoluteX()
				else 0.0 endif,
			y <- if ge.hasRightMultiplicity() then
				ge.contained->select( e |
					e.isOfKind(UMLDI!AssociationEnd))->
					last().contained->select( e |
						e.isOfType('Multiplicity'))->last().getAbsoluteY() +
						ge.contained->select( e |
							e.isOfKind(UMLDI!AssociationEnd))->
							last().contained->select( e |
								e.isOfType('Multiplicity'))->last().size.height
				else 0.0 endif
		),
		
		-- The first role
		leftRole: SVG!Text (
			content <- if ge.hasLeftRole() then
					ge.semanticModel.element.connection->first().name
				else '' endif,
			fill <- 'black',
			position <- leftRolePos,
			fontSize <- '10px'
		),
		leftRolePos: SVG!AbsoluteCoord (
			x <- if ge.hasLeftRole() then
				ge.contained->select( e |
					e.isOfKind(UMLDI!AssociationEnd))->
					first().contained->select( e |
						e.isOfType('Name'))->first().getAbsoluteX()
				else 0.0 endif,
			y <- if ge.hasLeftRole() then
				ge.contained->select( e |
					e.isOfKind(UMLDI!AssociationEnd))->
					first().contained->select( e |
						e.isOfType('Name'))->first().getAbsoluteY() +
						ge.contained->select( e |
							e.isOfKind(UMLDI!AssociationEnd))->
							first().contained->select( e |
								e.isOfType('Name'))->first().size.height
				else 0.0 endif
		),
		
		-- The second role
		rightRole: SVG!Text (
			content <- if ge.hasRightRole() then
					ge.semanticModel.element.connection->last().name
				else '' endif,
			fill <- 'black',
			position <- rightRolePos,
			fontSize <- '10px'
		),
		rightRolePos: SVG!AbsoluteCoord (
			x <- if ge.hasRightRole() then
				ge.contained->select( e |
					e.isOfKind(UMLDI!AssociationEnd))->
					last().contained->select( e |
						e.isOfType('Name'))->first().getAbsoluteX()
				else 0.0 endif,
			y <- if ge.hasRightRole() then
				ge.contained->select( e |
					e.isOfKind(UMLDI!AssociationEnd))->
					last().contained->select( e |
						e.isOfType('Name'))->first().getAbsoluteY() +
						ge.contained->select( e |
							e.isOfKind(UMLDI!AssociationEnd))->
							last().contained->select( e |
								e.isOfType('Name'))->first().size.height
				else 0.0 endif
		)
}

		-- RULE GraphEdge2Dependency
		-- Creates a group containing:
		--		+ the line that draws the dependency, with its marker
		-- 		+ the name of the dependency
rule GraphEdge2Dependency {
	from
		ge: UMLDI!GraphEdge (
			ge.isOfKind(UMLDI!Dependency)
		)
	to
		-- The group element that will contain:
		-- 		+ the line
		--		+ the name
		out: SVG!G (
			name <- ge.semanticModel.element.name,
			root <- thisModule.diagram,
			groupContent <- Sequence {polyline, name}
		),
		
		-- The line, with its marker, style, and waypoints
		polyline: SVG!Polyline(
			waypoints <- Sequence {wps}->flatten(),
			stroke <- 'black',
			fill <- 'white',
			strokeDashArray <- '5,5',
			markerEnd <- 'url(#Dependency)',
			markerStart <- 'none'
		),
		wps: distinct SVG!Point foreach (Point in ge.waypoints) (
			position <- PPos
		),
		PPos: distinct SVG!AbsoluteCoord foreach(Point in ge.waypoints) (
			x <- Point.base.x - thisModule.offset.x,
			y <- Point.base.y - thisModule.offset.y
		),
		
		-- The name of the Dependency
		name: SVG!Text (
			content <- ge.getName(),
			fill <- 'black',
			position <- namePos,
			fontSize <- '10px'
		),
		namePos: SVG!AbsoluteCoord (
			x <- if ge.isNamed() then
				ge.contained->select( e |
					e.isOfType('DirectedName'))->first().contained->select( e |
						e.isOfType('Name'))->first().getAbsoluteX()
				else 0.0 endif,
			y <- if ge.isNamed() then
				ge.contained->select( e |
					e.isOfType('DirectedName'))->first().contained->select( e |
						e.isOfType('Name'))->first().getAbsoluteY()
				else 0.0 endif
		)
}

		-- RULE GraphEdge2Generalization
		-- Creates a group containing:
		--		+ the line that draws the generalization,
		--			with its marker
		-- 		+ the name of the generalization
rule GraphEdge2Generalization {
	from
		ge: UMLDI!GraphEdge (
			ge.isOfKind(UMLDI!Generalization)
			)
	to
		-- The group element that will contain:
		--		+ the line
		-- 		+ the name
		out: SVG!G (
			name <- ge.semanticModel.element.name,
			root <- thisModule.diagram,
			groupContent <- Sequence {polyline, name}
		),
		
		-- The line, with its marker and its position
		polyline: SVG!Polyline(
			waypoints <- Sequence {wps}->flatten(),
			stroke <- 'black',
			fill <- 'white',
			markerEnd <- 'url(#Generalization)',
			markerStart <- 'none'
		),
		wps: distinct SVG!Point foreach (Point in ge.waypoints) (
			position <- PPos
		),
		PPos: distinct SVG!AbsoluteCoord foreach(Point in ge.waypoints) (
			x <- Point.base.x - thisModule.offset.x,
			y <- Point.base.y - thisModule.offset.y
		),
		
		-- The name, with its position
		name: SVG!Text (
			content <- ge.getName(),
			fill <- 'black',
			position <- namePos,
			fontSize <- '10px'
		),
		namePos: SVG!AbsoluteCoord (
			x <- if ge.isNamed() then
				ge.contained->select( e |
					e.isOfType('DirectedName'))->first().contained->select( e |
						e.isOfType('Name'))->first().getAbsoluteX()
				else 0.0 endif,
			y <- if ge.isNamed() then
				ge.contained->select( e |
					e.isOfType('DirectedName'))->first().contained->select( e |
						e.isOfType('Name'))->first().getAbsoluteY()
				else 0.0 endif
		)
}

		-- RULE GraphEdge2Abstraction
		-- Creates a group containing:
		--		+ the line that draws the abstraction,
		--			with its marker
		-- 		+ the name of the abstraction
rule GraphEdge2Abstraction {
	from
		ge: UMLDI!GraphEdge (
			ge.isOfKind(UMLDI!Abstraction)
		)
	to
		-- The group element that will contain:
		--		+ the line
		-- 		+ the name
		out: SVG!G (
			name <- ge.semanticModel.element.name,
			root <- thisModule.diagram,
			groupContent <- Sequence {polyline, name}
		),
		
		-- The line, with its marker, its style and its position
		polyline: SVG!Polyline(
			waypoints <- Sequence {wps}->flatten(),
			stroke <- 'black',
			fill <- 'white',
			strokeDashArray <- '5,5',
			markerEnd <- 'url(#Generalization)',
			markerStart <- 'none'
		),
		wps: distinct SVG!Point foreach (Point in ge.waypoints) (
			position <- PPos
		),
		PPos: distinct SVG!AbsoluteCoord foreach(Point in ge.waypoints) (
			x <- Point.base.x - thisModule.offset.x,
			y <- Point.base.y - thisModule.offset.y
		),
		
		-- The name, with its position
		name: SVG!Text (
			content <- if ge.isStereotypeNamed() then
				'&#171; ' +
					ge.contained->select( e |
					e .isOfType('StereotypeCompartment'))->
						first().contained->select( e |
							e.isOfKind(UMLDI!Stereotype))->
							first().semanticModel.element.name +
				' &#187;'
				else '' endif,
			fill <- 'black',
			position <- namePos,
			fontSize <- '10px'
		),
		namePos: SVG!AbsoluteCoord (
			x <- if ge.isStereotypeNamed() then
				ge.contained->select( e |
					e .isOfType('StereotypeCompartment'))->
					first().contained->select( e |
						e.isOfKind(UMLDI!Stereotype))->first().getAbsoluteX()
				else 0.0 endif,
			y <- if ge.isStereotypeNamed() then
				ge.contained->select( e |
					e .isOfType('StereotypeCompartment'))->
					first().contained->select( e |
						e.isOfKind(UMLDI!Stereotype))->first().getAbsoluteY()
				else 0.0 endif
		)
}

	-- End Association, dependencies, etc
		
-- End rules",modul umldi svg creat out svg in umldi helper boolean helper helper isofkind return true node kind ocl way input for exampl element uml class context umldi graphel in kind string return boolean helper context umldi graphel def isofkind kind string boolean self semanticmodel ocliskindof umldi uml semanticmodelbridg self semanticmodel element ocliskindof kind els fals endif helper isoftyp return true element input type context umldi graphnod in n a return boolean helper context umldi graphnod def isoftyp testtyp string boolean self semanticmodel ocliskindof umldi simplesemanticmodelel self semanticmodel typeinfo testtyp els fals endif helper hasattribut return true current class node attribut context umldi graphnod in n a return boolean call isoftyp helper context umldi graphnod def hasattribut boolean self contain exist e e isoftyp attributecompart self contain select e e isoftyp attributecompart first contain exist e e isoftyp delimitedsect els fals endif helper hasmethod return true current class node method context umldi graphnod in n a return boolean call isoftyp helper context umldi graphnod def hasmethod boolean self contain exist e e isoftyp operationcompart self contain select e e isoftyp operationcompart first contain exist e e isoftyp delimitedsect els fals endif helper hasattsepar return true current class node seapar attribut method compart context umldi graphnod in n a return boolean call isoftyp helper context umldi graphnod def hasattsepar boolean self contain select e e isoftyp compartmentsepar size helper isnam check whether associ name context umldi graphedg in n a return boolean helper context umldi graphedg def isnam boolean self semanticmodel element name oclisundefin helper context umldi graphedg def isstereotypenam boolean self contain select e e isoftyp stereotypecompart first contain select e e isofkind umldi stereotyp first semanticmodel element name oclisundefin helper hasleftrol check whether associ role first connect context umldi graphedg in n a return boolean helper context umldi graphedg def hasleftrol boolean self semanticmodel element connect first name oclisundefin helper hasrightrol check whether associ role last connect context umldi graphedg in n a return boolean helper context umldi graphedg def hasrightrol boolean self semanticmodel element connect last name oclisundefin helper hasleftmultipl check whether associ multipl fiffer first connect context umldi graphedg in n a return boolean helper context umldi graphedg def hasleftmultipl boolean self semanticmodel element connect first multipl rang assequ first lower self semanticmodel element connect first multipl rang assequ last upper helper hasrightmultipl check whether associ multipl fiffer last connect context umldi graphedg in n a return boolean helper context umldi graphedg def hasrightmultipl boolean self semanticmodel element connect last multipl rang assequ first lower self semanticmodel element connect last multipl rang assequ last upper helper hasmarkerstart check whether associ marker ie either one way associ composit aggreg one mayb first side associ context umldi graphedg in n a return boolean helper context umldi graphedg def hasmarkerstart boolean self semanticmodel element connect first isnavig self semanticmodel element connect last isnavig self semanticmodel element none helper hasmarkerend check whether associ marker ie either one way associ composit aggreg one mayb last side associ context umldi graphedg in n a return boolean helper context umldi graphedg def hasmarkerend boolean self semanticmodel element connect first isnavig self semanticmodel element connect last isnavig self semanticmodel element none end boolean helper coordin helper helper getabsolutenooffsetx return absolut horizont coordin comput get posit current node recurs ad parent xml way context umldi graphel in n a return real helper context umldi graphel def getabsolutenooffsetx real self ocliskindof umldi diagram self posit x self contain getabsolutenooffsetx els self posit x endif helper getabsolutenooffseti return absolut vertic coordin comput get posit current node recurs ad parent xml way context umldi graphel in n a return real helper context umldi graphel def getabsolutenooffseti real self ocliskindof umldi diagram self posit self contain getabsolutenooffseti els self posit endif helper offset return tupl contain smallest absolut horizont coordin smallest vertic one this helper comput ad minimum alway negat null anoth offset call viewoffset ad margin context thismodul in n a return tupl minx real mini real call getabsolutenooffsetx getabsolutenooffseti helper def offset tupletyp minx real mini real let leav sequenc umldi graphel umldi graphel allinst select e e contain isempti let setminx set real leav iter e acc set real set acc includ e getabsolutenooffsetx let setmini set real leav iter e acc set real set acc includ e getabsolutenooffseti let viewoffset real tupl x setminx iter e acc real e acc e els acc endif viewoffset setmini iter e acc real e acc e els acc endif viewoffset helper getabsolutex return absolut x coordin correct x offset context umldi graphel in n a return real call getabsolutenooffsetx offset helper context umldi graphel def getabsolutex real self getabsolutenooffsetx thismodul offset x helper getabsolutey return absolut y coordin correct y offset context umldi graphel in n a return real call getabsolutenooffseti offset helper context umldi graphel def getabsolutey real self getabsolutenooffseti thismodul offset end coordin helper helper diagram return diagram element umldi model context thismodul in n a return umldi diagram helper def diagram umldi diagram umldi diagram allinst assequ first umldi inform helper helper mult check whether attribut multipl if proceed getmultipl context umldi graphnod in n a return string multipl call getmultipl helper context umldi graphnod def mult string self semanticmodel element multipl oclisundefin els self semanticmodel element multipl getmultipl endif helper getmultipl return either empti string multipl correspond multipl context umldi multipl in n a return string helper context umldi multipl def getmultipl string let lower string self rang assequ first lower let upper string self rang assequ last upper lower upper els lower lower tostr upper tostr els upper lower tostr els lower tostr upper tostr endif endif endif helper getinitialvalu return exist initi valu caller attribut context umldi graphnod in n a return string helper context umldi graphnod def getinitialvalu string let elt umldi attribut self semanticmodel element elt initialvalu oclisundefin elt initialvalu elt initialvalu bodi els endif els endif helper getvis return visibl current attribut oper context umldi graphnod in n a return string helper context umldi graphnod def getvis string let visibl string self semanticmodel element visibl visibl vk public els visibl vk packag els visibl vk privat els endif endif endif helper getparamet return paramet current attribut oper type context umldi graphnod in n a return string helper context umldi graphnod def getparamet string let element umldi oper self semanticmodel element let end integ element paramet size end element paramet iter e acc string e kind pdk return e name element paramet last name acc e name e type name els acc e name e type name endif els endif els endif helper getreturnparamet return return type current oper context umldi graphnod in n a return string helper context umldi graphnod def getreturnparamet string self semanticmodel element paramet select p p kind pdk return first type name helper getnam return name current associ context umldi graphedg in n a return string helper context umldi graphedg def getnam string self isnam self semanticmodel element name els endif helper getmark return marker type part associ none none context umldi graphnod in posit string start end return string helper context umldi graphedg def getmark posit string string let element umldi associ self semanticmodel element let connect umldi associationend element connect first let connect umldi associationend element connect last posit start self hasmarkerstart connect isnavig connect isnavig url associ els connect aggreg ak composit url composit els connect aggreg ak none none els url aggreg endif endif endif els none endif els self hasmarkerend connect isnavig connect isnavig url associ els connect aggreg ak composit url composit els connect aggreg ak none none els url aggreg endif endif endif els none endif endif end helper rule rule diagram svg creat svg element definit element contain differ marker symbol found class diagram that part static wherea size posit comput rule diagram svg umldi diagram svg svg namespac http www w org svg version posit ab size dim children sequenc definit ab svg absolutecoord x getabsolutex getabsolutey dim svg dimens width size width height size height definit svg def groupcont sequenc associ general depend aggreg composit associ svg marker identifi associ refx refi markerwidth markerheight orient auto fill none viewbox draw associationpathgroup associationpathgroup svg g groupcont associationpath associationpath svg path stroke black m l l general svg marker identifi general refx refi markerwidth markerheight orient auto fill white viewbox draw generalizationpathgroup generalizationpathgroup svg g groupcont sequenc generalizationpath generalizationpath generalizationpath svg path stroke black m l l generalizationpath svg path stroke black m l depend svg marker identifi depend refx refi markerwidth markerheight orient auto fill none viewbox draw dependencypathgroup dependencypathgroup svg g groupcont dependencypath dependencypath svg path stroke black m l l aggreg svg marker identifi aggreg refx refi markerwidth markerheight orient fill white viewbox draw aggregationpathgroup aggregationpathgroup svg g groupcont aggregationpath aggregationpath svg path stroke black m l l l l composit svg marker identifi composit refx refi markerwidth markerheight orient fill black viewbox draw compositionpathgroup compositionpathgroup svg g groupcont compositionpath compositionpath svg path stroke black m l l l l class match all rule return group contain rectangl draw class name class line name attribut method exist treat rule put group this fine give structur class rule fullclassbox match class contain attribut method rule fullclassbox n umldi graphnod n isofkind umldi class n isofkind umldi interfac n hasattribut n hasmethod n hasattsepar els fals endif the group element structur class svg g name class n semanticmodel element name groupcont sequenc rect namesep name attlist attsep methodlist root thismodul diagram the rectangl draw outlin class size posit rect svg rect fill white stroke black posit rectpo size rectdim rectpo svg absolutecoord x n getabsolutex n getabsolutey rectdim svg dimens width n size width height n size height the separ drawn name class origin end namesep svg line sequenc origin end stroke black origin svg point posit origin pos origin pos svg absolutecoord x n getabsolutex n contain select e e semanticmodel typeinfo compartmentsepar first size height n getabsolutey n contain select e e isoftyp namecompart first contain select e e isoftyp name first size height end svg point posit end pos end pos svg absolutecoord x n getabsolutex n size width n contain select e e semanticmodel typeinfo compartmentsepar first size height n getabsolutey n contain select e e isoftyp namecompart first contain select e e isoftyp name first size height the name class weight style posit name svg text content n semanticmodel element name posit textpo attribut sequenc fontweight fontstyl fill black fontsiz px textpo svg absolutecoord x n contain select e e semanticmodel typeinfo namecompart first contain first getabsolutex n contain select e e semanticmodel typeinfo namecompart first contain first getabsolutey n contain select e e semanticmodel typeinfo namecompart first size height fontweight svg fontweight bold true fontstyl svg fontstyl ital n semanticmodel element isabstract the group contain thus structur attribut class attlist svg g name attribut class n semanticmodel element name groupcont n contain select e e isoftyp attributecompart first contain select e e isoftyp delimitedsect first contain the separ attribut method origin end attsep svg line sequenc origin end stroke black origin svg point posit origin pos origin pos svg absolutecoord x n getabsolutex n contain select e e semanticmodel typeinfo namecompart last size height n getabsolutey n contain select e e isoftyp attributecompart first size height end svg point posit end pos end pos svg absolutecoord x n getabsolutex n size width n contain select e e semanticmodel typeinfo namecompart last size height n getabsolutey n contain select e e isoftyp attributecompart first size height the group contain thus structur method class methodlist svg g name oper class n semanticmodel element name groupcont n contain select e e isoftyp operationcompart first contain select e e isoftyp delimitedsect first contain rule emptyclassboxnosepar match class attribut method separ line separ attribut method rule emptyclassboxnosepar n umldi graphnod n isofkind umldi class n isofkind umldi interfac n hasattribut n hasmethod n hasattsepar els fals endif the group element structur class svg g name class n semanticmodel element name groupcont sequenc rect namesep name root thismodul diagram the rectangl draw outlin class size posit rect svg rect fill white stroke black posit rectpo size rectdim rectpo svg absolutecoord x n getabsolutex n getabsolutey rectdim svg dimens width n size width height n size height the separ drawn name class origin end namesep svg line sequenc origin end stroke black origin svg point posit origin pos origin pos svg absolutecoord x n getabsolutex n contain select e e semanticmodel typeinfo compartmentsepar first size height n getabsolutey n contain select e e isoftyp namecompart first contain select e e isoftyp name first size height end svg point posit end pos end pos svg absolutecoord x n getabsolutex n size width n contain select e e semanticmodel typeinfo compartmentsepar first size height n getabsolutey n contain select e e isoftyp namecompart first contain select e e isoftyp name first size height the name class weight style posit name svg text content n semanticmodel element name posit textpo attribut sequenc fontweight fill black fontsiz px textpo svg absolutecoord x n contain select e e semanticmodel typeinfo namecompart first contain first getabsolutex n contain select e e semanticmodel typeinfo namecompart first contain first getabsolutey n contain select e e semanticmodel typeinfo namecompart first size height fontweight svg fontweight bold true rule emptyclassboxwithsepar match class attribut method separ rule emptyclassboxwithsepar n umldi graphnod n isofkind umldi class n isofkind umldi interfac n hasattribut n hasmethod n hasattsepar els fals endif the group element structur class svg g name class n semanticmodel element name groupcont sequenc rect namesep name attsep root thismodul diagram the rectangl draw outlin class size posit rect svg rect fill white stroke black posit rectpo size rectdim rectpo svg absolutecoord x n getabsolutex n getabsolutey rectdim svg dimens width n size width height n size height the separ drawn name class origin end namesep svg line sequenc origin end stroke black origin svg point posit origin pos origin pos svg absolutecoord x n getabsolutex n contain select e e semanticmodel typeinfo compartmentsepar first size height n getabsolutey n contain select e e isoftyp namecompart first contain select e e isoftyp name first size height end svg point posit end pos end pos svg absolutecoord x n getabsolutex n size width n contain select e e semanticmodel typeinfo compartmentsepar first size height n getabsolutey n contain select e e isoftyp namecompart first contain select e e isoftyp name first size height the name class weight style posit name svg text content n semanticmodel element name posit textpo attribut sequenc fontweight fill black fontsiz px textpo svg absolutecoord x n contain select e e semanticmodel typeinfo namecompart first contain first getabsolutex n contain select e e semanticmodel typeinfo namecompart first contain first getabsolutey n contain select e e semanticmodel typeinfo namecompart first size height fontweight svg fontweight bold true the separ attribut method origin end attsep svg line sequenc origin end stroke black origin svg point posit origin pos origin pos svg absolutecoord x n getabsolutex n contain select e e semanticmodel typeinfo namecompart last size height n getabsolutey n contain select e e isoftyp attributecompart first size height end svg point posit end pos end pos svg absolutecoord x n getabsolutex n size width n contain select e e semanticmodel typeinfo namecompart last size height n getabsolutey n contain select e e isoftyp attributecompart first size height rule attributeonlyclassboxwithsepar match class attribut separ method rule attributeonlyclassboxwithsepar n umldi graphnod n isofkind umldi class n isofkind umldi interfac n hasattribut n hasmethod n hasattsepar els fals endif the group element structur class svg g name class n semanticmodel element name groupcont sequenc rect namesep name attlist attsep root thismodul diagram the rectangl draw outlin class size posit rect svg rect fill white stroke black posit rectpo size rectdim rectpo svg absolutecoord x n getabsolutex n getabsolutey rectdim svg dimens width n size width height n size height the separ drawn name class origin end namesep svg line sequenc origin end stroke black origin svg point posit origin pos origin pos svg absolutecoord x n getabsolutex n contain select e e semanticmodel typeinfo compartmentsepar first size height n getabsolutey n contain select e e isoftyp namecompart first contain select e e isoftyp name first size height end svg point posit end pos end pos svg absolutecoord x n getabsolutex n size width n contain select e e semanticmodel typeinfo compartmentsepar first size height n getabsolutey n contain select e e isoftyp namecompart first contain select e e isoftyp name first size height the name class weight style posit name svg text content n semanticmodel element name posit textpo attribut sequenc fontweight fill black fontsiz px textpo svg absolutecoord x n contain select e e semanticmodel typeinfo namecompart first contain first getabsolutex n contain select e e semanticmodel typeinfo namecompart first contain first getabsolutey n contain select e e semanticmodel typeinfo namecompart first size height fontweight svg fontweight bold true the group contain thus structur attribut class attlist svg g name attribut class n semanticmodel element name groupcont n contain select e e isoftyp attributecompart first contain select e e isoftyp delimitedsect first contain the separ attribut method origin end attsep svg line sequenc origin end stroke black origin svg point posit origin pos origin pos svg absolutecoord x n getabsolutex n contain select e e semanticmodel typeinfo namecompart last size height n getabsolutey n contain select e e isoftyp attributecompart first size height end svg point posit end pos end pos svg absolutecoord x n getabsolutex n size width n contain select e e semanticmodel typeinfo namecompart last size height n getabsolutey n contain select e e isoftyp attributecompart first size height rule attributeonlyclassboxnosepar match class attribut separ method rule attributeonlyclassboxnosepar n umldi graphnod n isofkind umldi class n isofkind umldi interfac n hasattribut n hasmethod n hasattsepar els fals endif the group element structur class svg g name class n semanticmodel element name groupcont sequenc rect namesep name attlist root thismodul diagram the rectangl draw outlin class size posit rect svg rect fill white stroke black posit rectpo size rectdim rectpo svg absolutecoord x n getabsolutex n getabsolutey rectdim svg dimens width n size width height n size height the separ drawn name class origin end namesep svg line sequenc origin end stroke black origin svg point posit origin pos origin pos svg absolutecoord x n getabsolutex n contain select e e semanticmodel typeinfo compartmentsepar first size height n getabsolutey n contain select e e isoftyp namecompart first contain select e e isoftyp name first size height end svg point posit end pos end pos svg absolutecoord x n getabsolutex n size width n contain select e e semanticmodel typeinfo compartmentsepar first size height n getabsolutey n contain select e e isoftyp namecompart first contain select e e isoftyp name first size height the name class weight style posit name svg text content n semanticmodel element name posit textpo attribut sequenc fontweight fill black fontsiz px textpo svg absolutecoord x n contain select e e semanticmodel typeinfo namecompart first contain first getabsolutex n contain select e e semanticmodel typeinfo namecompart first contain first getabsolutey n contain select e e semanticmodel typeinfo namecompart first size height fontweight svg fontweight bold true the group contain thus structur attribut class attlist svg g name attribut class n semanticmodel element name groupcont n contain select e e isoftyp attributecompart first contain select e e isoftyp delimitedsect first contain rule methodonlyclassboxwithsepar match class method separ attribut rule methodonlyclassboxwithsepar n umldi graphnod n isofkind umldi class n isofkind umldi interfac n hasattribut n hasmethod n hasattsepar els fals endif the group element structur class svg g name class n semanticmodel element name groupcont sequenc rect namesep name attsep methodlist root thismodul diagram the rectangl draw outlin class size posit rect svg rect fill white stroke black posit rectpo size rectdim rectpo svg absolutecoord x n getabsolutex n getabsolutey rectdim svg dimens width n size width height n size height the separ drawn name class origin end namesep svg line sequenc origin end stroke black origin svg point posit origin pos origin pos svg absolutecoord x n getabsolutex n contain select e e semanticmodel typeinfo compartmentsepar first size height n getabsolutey n contain select e e isoftyp namecompart first contain select e e isoftyp name first size height end svg point posit end pos end pos svg absolutecoord x n getabsolutex n size width n contain select e e semanticmodel typeinfo compartmentsepar first size height n getabsolutey n contain select e e isoftyp namecompart first contain select e e isoftyp name first size height the name class weight style posit name svg text content n semanticmodel element name posit textpo attribut sequenc fontweight fill black fontsiz px textpo svg absolutecoord x n contain select e e semanticmodel typeinfo namecompart first contain first getabsolutex n contain select e e semanticmodel typeinfo namecompart first contain first getabsolutey n contain select e e semanticmodel typeinfo namecompart first size height fontweight svg fontweight bold true the separ attribut method origin end attsep svg line sequenc origin end stroke black origin svg point posit origin pos origin pos svg absolutecoord x n getabsolutex n contain select e e semanticmodel typeinfo namecompart last size height n getabsolutey n contain select e e isoftyp attributecompart first size height end svg point posit end pos end pos svg absolutecoord x n getabsolutex n size width n contain select e e semanticmodel typeinfo namecompart last size height n getabsolutey the group contain thus structur method class methodlist svg g name oper class n semanticmodel element name groupcont n contain select e e isoftyp operationcompart first contain select e e isoftyp delimitedsect first contain rule methodonlyclassboxnosepar match class method separ attribut rule methodonlyclassboxnosepar n umldi graphnod n isofkind umldi class n isofkind umldi interfac n hasattribut n hasmethod n hasattsepar els fals endif the group element structur class svg g name class n semanticmodel element name groupcont sequenc rect namesep name methodlist root thismodul diagram the rectangl draw outlin class size posit rect svg rect fill white stroke black posit rectpo size rectdim rectpo svg absolutecoord x n getabsolutex n getabsolutey rectdim svg dimens width n size width height n size height the separ drawn name class origin end namesep svg line sequenc origin end stroke black origin svg point posit origin pos origin pos svg absolutecoord x n getabsolutex n contain select e e semanticmodel typeinfo compartmentsepar first size height n getabsolutey n contain select e e isoftyp namecompart first contain select e e isoftyp name first size height end svg point posit end pos end pos svg absolutecoord x n getabsolutex n size width n contain select e e semanticmodel typeinfo compartmentsepar first size height n getabsolutey n contain select e e isoftyp namecompart first contain select e e isoftyp name first size height the name class weight style posit name svg text content n semanticmodel element name posit textpo attribut sequenc fontweight fill black fontsiz px textpo svg absolutecoord x n contain select e e semanticmodel typeinfo namecompart first contain first getabsolutex n contain select e e semanticmodel typeinfo namecompart first contain first getabsolutey n contain select e e semanticmodel typeinfo namecompart first size height fontweight svg fontweight bold true the group contain thus structur method class methodlist svg g name oper class n semanticmodel element name groupcont n contain select e e isoftyp operationcompart first contain select e e isoftyp delimitedsect first contain end class match attribut method rule attribut match attribut return correspond text visibl name attribut type multipl initi valu rule attribut umldi graphnod isofkind umldi attribut svg text content getvis semanticmodel element name semanticmodel element type name mult getinitialvalu fill black posit atpo fontsiz px atpo svg absolutecoord x getabsolutex getabsolutey contain select e e isoftyp name first size height rule method match attribut return correspond text visibl name method paramet type return type rule method umldi graphnod isofkind umldi oper svg text content getvis semanticmodel element name getparamet getreturnparamet fill black posit oppo fontsiz px attribut sequenc fontstyl oppo svg absolutecoord x getabsolutex getabsolutey contain select e e isoftyp name first size height fontstyl svg fontstyl ital semanticmodel element isabstract end attribut method associ depend etc rule graphedg associ creat associ rule graphedg associ ge umldi graphedg ge isofkind umldi associ the group contain line name multipl role svg g name ge semanticmodel element name groupcont sequenc polylin name leftmultipl rightmultipl leftrol rightrol root thismodul diagram the line posit marker waypoint polylin svg polylin waypoint sequenc wps flatten stroke black fill white markerend ge getmark end markerstart ge getmark start wps distinct svg point foreach point ge waypoint posit ppos ppos distinct svg absolutecoord foreach point ge waypoint x point base x thismodul offset x point base thismodul offset the name associ posit name svg text content ge getnam fill black posit namepo fontsiz px namepo svg absolutecoord x ge isnam ge contain select e e isoftyp directednam first getabsolutex els endif ge isnam ge contain select e e isoftyp directednam first getabsolutey els endif the first multipl leftmultipl svg text content ge hasleftmultipl ge semanticmodel element connect first multipl getmultipl els endif fill black posit leftmultpo fontsiz px leftmultpo svg absolutecoord x ge hasleftmultipl ge contain select e e isofkind umldi associationend first contain select e e isoftyp multipl first getabsolutex els endif ge hasleftmultipl ge contain select e e isofkind umldi associationend first contain select e e isoftyp multipl first getabsolutey ge contain select e e isofkind umldi associationend first contain select e e isoftyp multipl first size height els endif the second multipl rightmultipl svg text content ge hasrightmultipl ge semanticmodel element connect last multipl getmultipl els endif fill black posit rightmultpo fontsiz px rightmultpo svg absolutecoord x ge hasrightmultipl ge contain select e e isofkind umldi associationend last contain select e e isoftyp multipl last getabsolutex els endif ge hasrightmultipl ge contain select e e isofkind umldi associationend last contain select e e isoftyp multipl last getabsolutey ge contain select e e isofkind umldi associationend last contain select e e isoftyp multipl last size height els endif the first role leftrol svg text content ge hasleftrol ge semanticmodel element connect first name els endif fill black posit leftrolepo fontsiz px leftrolepo svg absolutecoord x ge hasleftrol ge contain select e e isofkind umldi associationend first contain select e e isoftyp name first getabsolutex els endif ge hasleftrol ge contain select e e isofkind umldi associationend first contain select e e isoftyp name first getabsolutey ge contain select e e isofkind umldi associationend first contain select e e isoftyp name first size height els endif the second role rightrol svg text content ge hasrightrol ge semanticmodel element connect last name els endif fill black posit rightrolepo fontsiz px rightrolepo svg absolutecoord x ge hasrightrol ge contain select e e isofkind umldi associationend last contain select e e isoftyp name first getabsolutex els endif ge hasrightrol ge contain select e e isofkind umldi associationend last contain select e e isoftyp name first getabsolutey ge contain select e e isofkind umldi associationend last contain select e e isoftyp name first size height els endif rule graphedg depend creat group contain line draw depend marker name depend rule graphedg depend ge umldi graphedg ge isofkind umldi depend the group element contain line name svg g name ge semanticmodel element name root thismodul diagram groupcont sequenc polylin name the line marker style waypoint polylin svg polylin waypoint sequenc wps flatten stroke black fill white strokedasharray markerend url depend markerstart none wps distinct svg point foreach point ge waypoint posit ppos ppos distinct svg absolutecoord foreach point ge waypoint x point base x thismodul offset x point base thismodul offset the name depend name svg text content ge getnam fill black posit namepo fontsiz px namepo svg absolutecoord x ge isnam ge contain select e e isoftyp directednam first contain select e e isoftyp name first getabsolutex els endif ge isnam ge contain select e e isoftyp directednam first contain select e e isoftyp name first getabsolutey els endif rule graphedg general creat group contain line draw general marker name general rule graphedg general ge umldi graphedg ge isofkind umldi general the group element contain line name svg g name ge semanticmodel element name root thismodul diagram groupcont sequenc polylin name the line marker posit polylin svg polylin waypoint sequenc wps flatten stroke black fill white markerend url general markerstart none wps distinct svg point foreach point ge waypoint posit ppos ppos distinct svg absolutecoord foreach point ge waypoint x point base x thismodul offset x point base thismodul offset the name posit name svg text content ge getnam fill black posit namepo fontsiz px namepo svg absolutecoord x ge isnam ge contain select e e isoftyp directednam first contain select e e isoftyp name first getabsolutex els endif ge isnam ge contain select e e isoftyp directednam first contain select e e isoftyp name first getabsolutey els endif rule graphedg abstract creat group contain line draw abstract marker name abstract rule graphedg abstract ge umldi graphedg ge isofkind umldi abstract the group element contain line name svg g name ge semanticmodel element name root thismodul diagram groupcont sequenc polylin name the line marker style posit polylin svg polylin waypoint sequenc wps flatten stroke black fill white strokedasharray markerend url general markerstart none wps distinct svg point foreach point ge waypoint posit ppos ppos distinct svg absolutecoord foreach point ge waypoint x point base x thismodul offset x point base thismodul offset the name posit name svg text content ge isstereotypenam ge contain select e e isoftyp stereotypecompart first contain select e e isofkind umldi stereotyp first semanticmodel element name els endif fill black posit namepo fontsiz px namepo svg absolutecoord x ge isstereotypenam ge contain select e e isoftyp stereotypecompart first contain select e e isofkind umldi stereotyp first getabsolutex els endif ge isstereotypenam ge contain select e e isoftyp stereotypecompart first contain select e e isofkind umldi stereotyp first getabsolutey els endif end associ depend etc end rule,0
223,223,P96-XML2Text.atl,"query XML2Text = XML!Root.allInstances()->asSequence()->first().toString2('').writeTo('./runtime-workbench-workspace/uml2svg/example.svg');

helper context XML!Element def: toString2(indent : String) : String =
       let na : Sequence(XML!Node) = self.children->select(e | not e.oclIsKindOf(XML!Attribute)) in
       let a : Sequence(XML!Node) = self.children->select(e | e.oclIsKindOf(XML!Attribute)) in
       indent + '<' + self.name +
       a->iterate(e; acc : String = '' |
               acc + ' ' + e.toString2()
       ) +
       if na->size() > 0
               then '>'
                       + na->iterate(e; acc : String = '' |
                                               acc +
                                               if e.oclIsKindOf(XML!Text)
                                                       then ''
                                                       else '\r\n'
                                               endif +
                                               e.toString2(indent + '  ')
                                               )
                       + if na->first().oclIsKindOf(XML!Text)
                               then '</' + self.name + '>'
                               else '\r\n' + indent + '</' + self.name + '>'
                         endif
               else '/>'
       endif;

helper context XML!Attribute def: toString2() : String =
       self.name + '=\""' + self.value + '\""';

helper context XML!Text def: toString2() : String =
       self.value;",queri xml text xml root allinst assequ first tostr writeto runtim workbench workspac uml svg exampl svg helper context xml element def tostr indent string string let na sequenc xml node self children select e e ocliskindof xml attribut let sequenc xml node self children select e e ocliskindof xml attribut indent self name iter e acc string acc e tostr na size na iter e acc string acc e ocliskindof xml text els r n endif e tostr indent na first ocliskindof xml text self name els r n indent self name endif els endif helper context xml attribut def tostr string self name self valu helper context xml text def tostr string self valu,5
224,224,P97-addHierarchy.atl,"-- title: UMLSD2STMD
-- release: 0.1
-- date: 18 oktober 2006

-- author:      Bas Graaf
--                      SWERL SoftWare Evolution Research Lab
--                      Delft University of Technology
--                      b.s.graaf@tudelft.nl

module addHierarchy; -- Module Template
create OUT : UML from IN : UML;

helper def: allAttributes: Set(UML!Attribute) =
	UML!Attribute->allInstances()
;
helper def: allStateMachines: Set(UML!StateMachine) =
	UML!StateMachine->allInstances()
;
helper def: allSimpleStates: Set(UML!SimpleState) =
	UML!SimpleState->allInstances()
;
helper def: equals(cs1:Set(UML!Constraint),cs2:Set(UML!Constraint)): Boolean =
	cs1->includesAll(cs2) and cs2->includesAll(cs1)
;
helper context UML!Class def :stateVectorPartition: Sequence(UML!Attribute) =
	self.feature->select(f|f.oclIsTypeOf(UML!Attribute))->select(a|a.visibility=#vk_public)
;
helper context UML!Constraint def: stateVariable: UML!Attribute =
	thisModule.allAttributes->select(a|a.name=self.stateVariableName)->asSequence()->first()
;
helper context UML!Constraint def: stateVariableName: String =
	self.body.body->substring(self.body.body.indexOf('.')+2,self.body.body.indexOf('='))
;
helper context UML!Constraint def: stateValue: String =
	self.body.body->substring(self.body.body.indexOf('=')+2,self.body.body.size())
;
helper context UML!StateMachine def: leastSignificant(cseq:Set(UML!Constraint)): UML!Constraint =
	let sap:Sequence(UML!Attribute) = self.""context"".stateVectorPartition in
		sap->iterate(a;c:UML!Constraint=Sequence{}->first()|
			if cseq->collect(c|c.stateVariable)->includes(a) then
				cseq->select(c|c.stateVariable=a)->asSequence()->first()
			else
				c
			endif)
;
helper context UML!StateMachine def: mostSignificant(cseq:Set(UML!Constraint)): UML!Constraint =
	let sap:Sequence(UML!Attribute) = self.""context"".stateVectorPartition in
		sap->iterate(a;c:UML!Constraint=Sequence{}->first()|
			if cseq->collect(c|c.stateVariable)->includes(a) and c.oclIsUndefined() then
				cseq->select(c|c.stateVariable=a)->asSequence()->first()
			else
				c
			endif)
;
helper context UML!StateMachine def: compositeStateConstraintSeqsAt(cseq:Set(UML!Constraint)): Set(Set(UML!Constraint)) =
	-- select all States that include all of cseq and collect their constraints,
	-- collect those sequences without all constraints in cseq,
	-- collect those sequences with all constraints related to the state attribute vector partition
	-- select those sequence that are not empty, and collect the most significant constraints as a set
	-- finally collect a sequence for every constraint consisting of cseq and that constraint
	let sap:Sequence(UML!Attribute) = self.""context"".stateVectorPartition in
		self.top.subvertex->select(s|s.constraint->includesAll(cseq))->collect(s|s.constraint)
		->collect(cs|cs->select(c|cseq->excludes(c)))
		->collect(cs|cs->select(e|sap->includes(e.stateVariable)))
		->select(cs|cs->notEmpty())->collect(cs|self.mostSignificant(cs))->asSet()
		->collect(c|cseq->including(c))
		->select(cs|not thisModule.allSimpleStates->select(s|s.name='default')->exists(s|thisModule.equals(s.constraint,cs)))
;
helper context UML!StateMachine def: simpleStateStatesAt(cseq:Set(UML!Constraint)): Set(UML!SimpleState) =
	let sap:Sequence(UML!Attribute) = self.""context"".stateVectorPartition in
		self.top.subvertex->select(s|
			thisModule.equals(s.constraint->select(c|sap->includes(c.stateVariable)),cseq))->select(s|s.name<>'default')
			->union(thisModule.allSimpleStates->select(s|s.name='default')->select(s|s.constraint->includesAll(cseq) and s.constraint.size()=cseq.size()+1))
;
rule Model {
	from m_in:UML!Model
	to m_out:UML!Model (
		name <- m_in.name,
		ownedElement <- m_in.ownedElement->select(e|e.oclIsTypeOf(UML!StateMachine) or e.oclIsTypeOf(UML!CallEvent)))
}
rule StateMachine {
	from sm_in:UML!StateMachine
	to sm_out:UML!StateMachine(
		name <- sm_in.name,
		top <- sm_in.top,
		transitions <- sm_in.transitions)
}
rule TopCompositeState {
	from cs_in:UML!CompositeState
	using {
		sm:UML!StateMachine=thisModule.allStateMachines->select(sm|sm.top=cs_in)->asSequence()->first();
	}
	to cs_out:UML!CompositeState (
		name <- cs_in.name,
		subvertex <- sm.simpleStateStatesAt(Set{})
		->union(sm.compositeStateConstraintSeqsAt(Set{})
			->collect(cs|thisModule.CompositeState(sm,cs)))
		->union(sm.top.subvertex->select(s|s.oclIsTypeOf(UML!Pseudostate))))
}
rule Pseudostate {
	from s_in:UML!Pseudostate
	to s_out:UML!Pseudostate
}
rule CompositeState{
	from s_in:UML!SimpleState(
		s_in.name = 'default')
	using {
		sm:UML!StateMachine=thisModule.allStateMachines->select(sm|sm.top.subvertex->includes(s_in))->asSequence()->first();
	}	
	to cs_out:UML!CompositeState(
		name <- sm.leastSignificant(s_in.constraint).body.body,
		subvertex <- sm.simpleStateStatesAt(s_in.constraint)
			->union(sm.compositeStateConstraintSeqsAt(s_in.constraint)->collect(cs|thisModule.CompositeState(sm,cs))))		
}
rule SimpleState {
	from s_in:UML!SimpleState(
		s_in.name<>'default')
	to s_out:UML!SimpleState(
		name <- s_in.name,
		constraint <- s_in.constraint)
}
rule Transition {
	from t_in:UML!Transition
	to t_out:UML!Transition(
		source <- t_in.source,
		target <- t_in.target,
		trigger <- t_in.trigger,
		effect <- t_in.effect)
}
rule CallAction {
	from ca_in:UML!CallAction
	to ca_out:UML!CallAction(
		script <- ca_in.script)
}
rule ActionExpression {
	from ae_in:UML!ActionExpression
	to ae_out:UML!ActionExpression(
		body <- ae_in.body)
}
rule CallEvent {
	from ce_in:UML!CallEvent
	to ce_out:UML!CallEvent(
		name <- ce_in.name)
}
rule BooleanExpression {
	from b_in:UML!BooleanExpression
	to b_out:UML!BooleanExpression(
		body <- b_in.body)
}
rule Constraint {
	from c_in:UML!Constraint
	to c_out:UML!Constraint(
		body <- c_in.body)		
}
rule CompositeState (sm:UML!StateMachine, cseq:Set(UML!Constraint)) {
	to cs:UML!CompositeState(
		name <- sm.leastSignificant(cseq).body.body,
		subvertex <- sm.simpleStateStatesAt(cseq)
		->union(sm.compositeStateConstraintSeqsAt(cseq)->collect(cs|thisModule.CompositeState(sm,cs))))
	do{cs;}
}",titl umlsd stmd releas date oktob author bas graaf swerl softwar evolut research lab delft univers technolog b graaf tudelft nl modul addhierarchi modul templat creat out uml in uml helper def allattribut set uml attribut uml attribut allinst helper def allstatemachin set uml statemachin uml statemachin allinst helper def allsimplest set uml simplest uml simplest allinst helper def equal cs set uml constraint cs set uml constraint boolean cs includesal cs cs includesal cs helper context uml class def statevectorpartit sequenc uml attribut self featur select f f oclistypeof uml attribut select visibl vk public helper context uml constraint def statevari uml attribut thismodul allattribut select name self statevariablenam assequ first helper context uml constraint def statevariablenam string self bodi bodi substr self bodi bodi indexof self bodi bodi indexof helper context uml constraint def statevalu string self bodi bodi substr self bodi bodi indexof self bodi bodi size helper context uml statemachin def leastsignific cseq set uml constraint uml constraint let sap sequenc uml attribut self context statevectorpartit sap iter c uml constraint sequenc first cseq collect c c statevari includ cseq select c c statevari assequ first els c endif helper context uml statemachin def mostsignific cseq set uml constraint uml constraint let sap sequenc uml attribut self context statevectorpartit sap iter c uml constraint sequenc first cseq collect c c statevari includ c oclisundefin cseq select c c statevari assequ first els c endif helper context uml statemachin def compositestateconstraintseqsat cseq set uml constraint set set uml constraint select state includ cseq collect constraint collect sequenc without constraint cseq collect sequenc constraint relat state attribut vector partit select sequenc empti collect signific constraint set final collect sequenc everi constraint consist cseq constraint let sap sequenc uml attribut self context statevectorpartit self top subvertex select constraint includesal cseq collect constraint collect cs cs select c cseq exclud c collect cs cs select e sap includ e statevari select cs cs notempti collect cs self mostsignific cs asset collect c cseq includ c select cs thismodul allsimplest select name default exist thismodul equal constraint cs helper context uml statemachin def simplestatestatesat cseq set uml constraint set uml simplest let sap sequenc uml attribut self context statevectorpartit self top subvertex select thismodul equal constraint select c sap includ c statevari cseq select name default union thismodul allsimplest select name default select constraint includesal cseq constraint size cseq size rule model uml model uml model name name ownedel ownedel select e e oclistypeof uml statemachin e oclistypeof uml callev rule statemachin sm uml statemachin sm uml statemachin name sm name top sm top transit sm transit rule topcompositest cs uml compositest use sm uml statemachin thismodul allstatemachin select sm sm top cs assequ first cs uml compositest name cs name subvertex sm simplestatestatesat set union sm compositestateconstraintseqsat set collect cs thismodul compositest sm cs union sm top subvertex select oclistypeof uml pseudost rule pseudost uml pseudost uml pseudost rule compositest uml simplest name default use sm uml statemachin thismodul allstatemachin select sm sm top subvertex includ assequ first cs uml compositest name sm leastsignific constraint bodi bodi subvertex sm simplestatestatesat constraint union sm compositestateconstraintseqsat constraint collect cs thismodul compositest sm cs rule simplest uml simplest name default uml simplest name name constraint constraint rule transit uml transit uml transit sourc sourc target target trigger trigger effect effect rule callact ca uml callact ca uml callact script ca script rule actionexpress ae uml actionexpress ae uml actionexpress bodi ae bodi rule callev ce uml callev ce uml callev name ce name rule booleanexpress b uml booleanexpress b uml booleanexpress bodi b bodi rule constraint c uml constraint c uml constraint bodi c bodi rule compositest sm uml statemachin cseq set uml constraint cs uml compositest name sm leastsignific cseq bodi bodi subvertex sm simplestatestatesat cseq union sm compositestateconstraintseqsat cseq collect cs thismodul compositest sm cs cs,16
225,225,P97-applyDomainTheory.atl,"-- title: UMLSD2STMD
-- release: 0.1
-- date: 18 oktober 2006

-- author:      Bas Graaf
--                      SWERL SoftWare Evolution Research Lab
--                      Delft University of Technology
--                      b.s.graaf@tudelft.nl

module applyDomainTheory; -- Module Template
create  OUT : UML refining IN : UML;

helper def: constrainedCallActions: Set(UML!CallAction) =
	UML!CallAction->allInstances()->select(ca|ca.operation->asSequence()->first().constraint->notEmpty())
;
rule Diagram {
	from d_in:UML!Diagram
	to d_out:UML!Diagram(
		name <- d_in.name,
		zoom <- d_in.zoom,
		isVisible <- d_in.isVisible,
		position <- d_in.position,
		size <- d_in.size,
		viewport <- d_in.viewport,
		semanticModel <- d_in.semanticModel,
		contained <- d_in.contained,
		owner <- d_in.owner)
}

rule Model {
	from m_in:UML!Model
	to m_out: UML!Model (
		name <- m_in.name,
		ownedElement <- m_in.ownedElement)
}
rule ConstrainedCallAction {
	from ca_in:UML!CallAction(
		thisModule.constrainedCallActions->includes(ca_in))
	to ca_out:UML!CallAction(
		operation <- ca_in.operation,
		constraint <- ca_in.operation->asSequence()->first().constraint->union(ca_in.constraint))
}",titl umlsd stmd releas date oktob author bas graaf swerl softwar evolut research lab delft univers technolog b graaf tudelft nl modul applydomaintheori modul templat creat out uml refin in uml helper def constrainedcallact set uml callact uml callact allinst select ca ca oper assequ first constraint notempti rule diagram uml diagram uml diagram name name zoom zoom isvis isvis posit posit size size viewport viewport semanticmodel semanticmodel contain contain owner owner rule model uml model uml model name name ownedel ownedel rule constrainedcallact ca uml callact thismodul constrainedcallact includ ca ca uml callact oper ca oper constraint ca oper assequ first constraint union ca constraint,16
226,226,P97-mergeflatSTMD.atl,"-- title: UMLSD2STMD
-- release: 0.1
-- date: 18 oktober 2006

-- author:      Bas Graaf
--                      SWERL SoftWare Evolution Research Lab
--                      Delft University of Technology
--                      b.s.graaf@tudelft.nl

module mergeflatSTMD;
create OUT : UML from IN : UML;

helper def: allSimpleStates: Set(UML!SimpleState) =
	UML!SimpleState->allInstances()
;
helper def: allPseudostates: Set(UML!Pseudostate) =
	UML!Pseudostate->allInstances()
;
helper def: allTransitions: Set(UML!Transitions) =
	UML!Transition->allInstances()
;
helper def: allClasses: Set(UML!Class) =
	UML!Class->allInstances()
;
helper def: allAttributes: Set(UML!Attribute) =
	UML!Attribute->allInstances()
;
helper context UML!Constraint def: stateVariableName: String =
	self.body.body->substring(self.body.body.indexOf('.')+2,self.body.body.indexOf('='))
;
helper context UML!Constraint def: stateVariable: UML!Attribute =
	thisModule.allAttributes->select(a|a.name=self.stateVariableName)->asSequence()->first()
;
helper context UML!Object def: stateVariables: Set(UML!Attribute) =
	self.classifier->asSequence()->first().feature->select(f|f.oclIsTypeOf(UML!Attribute))
;
helper context UML!StateVertex def: mergeable(s:UML!StateVertex): Boolean =
	thisModule.unifiable(self.constraint,s.constraint) and self.name=s.name
;
helper def: unifiable(cseq1:Sequence(UML!Constraint),cseq2:Sequence(UML!Constraint)): Boolean =
	cseq1->includesAll(cseq2->select(c|cseq1->collect(e|e.stateVariable)->includes(c.stateVariable)))
;
helper def: mergedStates: Set(UML!StateVertex) =
	thisModule.allSimpleStates->union(thisModule.allPseudostates)
	->iterate(s; mss:Set(UML!StateVertex)=Set{} |
		if mss->exists(e|(e.mergeable(s)) and e.oclType()=s.oclType()) then
			mss
		else
			mss->including(s)
		endif)
;
helper def: transitionTransitions: Set(UML!Transition) =
	thisModule.allTransitions->iterate(t; ts:Set(UML!Transition)=Set{} |
		if ts->exists(e|(e.source.mergeable(t.source)) and
		(e.target.mergeable(t.target))) then
			ts
		else
			ts->including(t)
		endif)
;
rule Class {
	from c_in:UML!Class
	to c_out:UML!Class(
		name <- c_in.name,
		isActive <- c_in.isActive,
		feature <- c_in.feature)
}
rule Operation {
	from o_in:UML!Operation
	to o_out:UML!Operation(
		name <- o_in.name,
		constraint <- o_in.constraint)
}
rule Method {
	from m_in:UML!Method
	to m_out:UML!Method(
		name <- m_in.name,
		body <- m_in.body,
		specification <- m_in.specification)
}
rule Attribute {
	from a_in:UML!Attribute
	to a_out:UML!Attribute(
		name <- a_in.name,
		visibility <- a_in.visibility,
		type <- a_in.type)
}
rule Package {
	from p_in:UML!Package(
		not(p_in.oclIsTypeOf(UML!Model)))		
	to p_out:UML!Package(
		name <- p_in.name,
		ownedElement <- p_in.ownedElement)
}
rule Stereotype {
	from s:UML!Stereotype
	to s_out:UML!Stereotype(
		name<-s.name,
		baseClass<-s.baseClass)
}

rule Model {
	from m_in:UML!Model
	to cs:UML!CompositeState(
		subvertex<-thisModule.mergedStates),
	sm:UML!StateMachine(
		transitions<-thisModule.transitionTransitions,
		top<-cs,
		""context"" <- thisModule.allClasses->select(c|c.isActive)->asSequence()->first()),
	m_out:UML!Model(
		ownedElement<-Set{sm}
		->union(thisModule.transitionTransitions->collect(e|e.trigger)
		->union(m_in.ownedElement->select(e|e.oclIsTypeOf(UML!Package) or e.oclIsTypeOf(UML!Class)))))
}
rule BooleanExpression {
	from b_in:UML!BooleanExpression
	to b_out:UML!BooleanExpression(
		body <- b_in.body)
}
rule Constraint {
	from c_in:UML!Constraint
	to c_out:UML!Constraint(
		body <- c_in.body)		
}
rule MergedPseudostate {
	from s_in:UML!Pseudostate (
		thisModule.mergedStates->includes(s_in))
	to s_out:UML!Pseudostate(
		name<-s_in.name,
		kind <- #pk_initial)
}
rule MergedSimpleState {
	from s_in:UML!SimpleState (
		thisModule.mergedStates->includes(s_in))
	to s_out:UML!SimpleState(
		name<-s_in.name,
		constraint <- s_in.constraint)
}
rule Transition {
	from t_in:UML!Transition(
		thisModule.transitionTransitions->includes(t_in))
	to t_out:UML!Transition(
		name <- t_in.name,
		trigger <- t_in.trigger,
		effect <- t_in.effect,
		target <- thisModule.mergedStates->select(s|
			s.mergeable(t_in.target))->asSequence()->first(),		
		source <- thisModule.mergedStates->select(s|s.mergeable(t_in.source))->asSequence()->first())
}
rule Effect {
	from ca_in:UML!CallAction(
		thisModule.transitionTransitions->collect(e|
			e.effect)->includes(ca_in))
	to ca_out:UML!CallAction(
		script<-ae),
	ae:UML!ActionExpression(
		body<-ca_in.script.body)
}
rule Trigger {
	from ce_in:UML!CallEvent(
		thisModule.transitionTransitions->collect(e|
			e.trigger)->includes(ce_in))
	to ce_out:UML!CallEvent(
		name <- ce_in.name)
}",titl umlsd stmd releas date oktob author bas graaf swerl softwar evolut research lab delft univers technolog b graaf tudelft nl modul mergeflatstmd creat out uml in uml helper def allsimplest set uml simplest uml simplest allinst helper def allpseudost set uml pseudost uml pseudost allinst helper def alltransit set uml transit uml transit allinst helper def allclass set uml class uml class allinst helper def allattribut set uml attribut uml attribut allinst helper context uml constraint def statevariablenam string self bodi bodi substr self bodi bodi indexof self bodi bodi indexof helper context uml constraint def statevari uml attribut thismodul allattribut select name self statevariablenam assequ first helper context uml object def statevari set uml attribut self classifi assequ first featur select f f oclistypeof uml attribut helper context uml statevertex def mergeabl uml statevertex boolean thismodul unifi self constraint constraint self name name helper def unifi cseq sequenc uml constraint cseq sequenc uml constraint boolean cseq includesal cseq select c cseq collect e e statevari includ c statevari helper def mergedst set uml statevertex thismodul allsimplest union thismodul allpseudost iter mss set uml statevertex set mss exist e e mergeabl e ocltyp ocltyp mss els mss includ endif helper def transitiontransit set uml transit thismodul alltransit iter ts set uml transit set ts exist e e sourc mergeabl sourc e target mergeabl target ts els ts includ endif rule class c uml class c uml class name c name isact c isact featur c featur rule oper uml oper uml oper name name constraint constraint rule method uml method uml method name name bodi bodi specif specif rule attribut uml attribut uml attribut name name visibl visibl type type rule packag p uml packag p oclistypeof uml model p uml packag name p name ownedel p ownedel rule stereotyp uml stereotyp uml stereotyp name name baseclass baseclass rule model uml model cs uml compositest subvertex thismodul mergedst sm uml statemachin transit thismodul transitiontransit top cs context thismodul allclass select c c isact assequ first uml model ownedel set sm union thismodul transitiontransit collect e e trigger union ownedel select e e oclistypeof uml packag e oclistypeof uml class rule booleanexpress b uml booleanexpress b uml booleanexpress bodi b bodi rule constraint c uml constraint c uml constraint bodi c bodi rule mergedpseudost uml pseudost thismodul mergedst includ uml pseudost name name kind pk initi rule mergedsimplest uml simplest thismodul mergedst includ uml simplest name name constraint constraint rule transit uml transit thismodul transitiontransit includ uml transit name name trigger trigger effect effect target thismodul mergedst select mergeabl target assequ first sourc thismodul mergedst select mergeabl sourc assequ first rule effect ca uml callact thismodul transitiontransit collect e e effect includ ca ca uml callact script ae ae uml actionexpress bodi ca script bodi rule trigger ce uml callev thismodul transitiontransit collect e e trigger includ ce ce uml callev name ce name,16
227,227,P97-SD2flatSTMD.atl,"-- title: UMLSD2STMD
-- release: 0.1
-- date: 18 oktober 2006

-- author:      Bas Graaf
--                      SWERL SoftWare Evolution Research Lab
--                      Delft University of Technology
--                      b.s.graaf@tudelft.nl

module SD2flatSTMD;
create OUT : UML from IN : UML;

helper def: allConstraints: Set(UML!Constraint) =
	UML!Constraint->allInstances()
;
helper def: allMessages: Set(UML!Message) =
	UML!Message->allInstances()
;
helper def: allClasses: Set(UML!Class) =
	UML!Class->allInstances()
;
helper def: allAttributes: Set(UML!Attribute) =
	UML!Attribute->allInstances()
;
helper def: allObjects: Set(UML!Object) =
	UML!Object->allInstances()
;
helper def: allStereotypes: Set(UML!Stereotype) =
	UML!Stereotype->allInstances()
;
helper def: allCollaborationInstanceSets: Set(UML!CollaborationInstanceSet) =
	UML!CollaborationInstanceSet->allInstances()
;
helper def: constraintConstraints: Set(UML!Constraint) = 
	thisModule.allConstraints->iterate(c; cs:Set(UML!Constraint)=Set{} |
		if cs->exists(e|e.equals(c)) then
			cs
		else
			cs->including(c)
		endif)
;
helper def: frame(frame:Set(UML!Constraint), framed:Set(UML!Constraint)): Set(UML!Constraint) =
	frame->iterate(c; cs:Set(UML!Constraint)=framed |
		if cs->exists(e|e.stateVariable=c.stateVariable) then
			cs
		else
			cs->including(c)
		endif)
;
helper def: unifiable(cseq1:Sequence(UML!Constraint),cseq2:Sequence(UML!Constraint)): Boolean =
	cseq1->forAll(c|cseq2->exists(e|e.stateVariable=c.stateVariable) implies cseq2->exists(e|e.body.body=c.body.body))
;
helper context UML!Constraint def: equals(c:UML!Constraint): Boolean =
	self.body.body=c.body.body
;
helper context UML!Constraint def: getUnique: UML!Constraint = 
	thisModule.constraintConstraints->select(c|c.equals(self))->asSequence()->first()
;	
helper context UML!Constraint def: isPrecondition: Boolean = 
	self.stereotype->asSequence()
	->first().name='precondition'
;
helper context UML!Constraint def: stateVariable: UML!Attribute =
	thisModule.allAttributes->select(a|a.name=self.stateVariableName)->asSequence()->first()
;
helper context UML!Constraint def: stateVariableName: String =
	self.body.body->substring(self.body.body.indexOf('.')+2,self.body.body.indexOf('='))
;
helper context UML!Constraint def: isStateInvariantFor(o:UML!Object): Boolean =
	o.stateVariables->includes(self.stateVariable)
;
helper context UML!CollaborationInstanceSet def: useCaseName: String =
	UML!Diagram->allInstances()->select(d|
		d.owner.element=self)->asSequence()
	->first().name
;
helper context UML!Object def: stateVariables: Set(UML!Attribute) =
	self.classifier->asSequence()->first().feature->select(f|f.oclIsTypeOf(UML!Attribute))
;
helper context UML!Object def: initialStateVector : Set(UML!Constraint) =
	let mseq:Sequence(UML!Message) = thisModule.allMessages->select(m|
		m.conformingStimulus->asSequence()->first().sender=self or
		m.conformingStimulus->asSequence()->first().receiver=self) in
		mseq->select(m|m.predecessor.isEmpty())->asSequence()->first().preconditions
;		
helper context UML!Object def: isActive: Boolean =
	self.classifier->asSequence()->first().isActive
;
helper context UML!Object def: messages : Set(UML!Message) =
	self.incomingMessages->union(self.outgoingMessages)
;
helper context UML!Object def: incomingMessages : Set(UML!Message) =
	thisModule.allMessages->select(m|
		m.conformingStimulus->asSequence()
		->first().receiver=self and not(m.is2Self))
;
helper context UML!Object def: outgoingMessages : Set(UML!Message) =
	thisModule.allMessages->select(m|
		m.conformingStimulus->asSequence()
		->first().sender=self)
;
helper context UML!Message def: activeObject : UML!Object =
	let s:UML!Object = self.conformingStimulus->asSequence()->first().sender in
	let r:UML!Object = self.conformingStimulus->asSequence()->first().receiver in
		if s.isActive then
			s
		else
			r
		endif
;
helper context UML!Message def: stateVector : Set(UML!Constraint) =
	let stateVectorPrev:Set(UML!Constraint) = 
		if self.getLocalPredecessor.oclIsUndefined() then
			self.preconditions->select(c|c.isStateInvariantFor(self.activeObject))
		else 
			self.getLocalPredecessor.stateVector
		endif in
	let pres:Set(UML!Constraint) = self.preconditions->select(c|c.isStateInvariantFor(self.activeObject)) in
	let posts:Set(UML!Constraint) = self.postconditions->select(c|c.isStateInvariantFor(self.activeObject)) in
	let sv:Set(UML!Constraint) = thisModule.frame(stateVectorPrev,thisModule.frame(pres,posts))->collect(c|c.getUnique)->asSet() in
		if thisModule.unifiable(stateVectorPrev,pres) then
			sv
		else
			sv.debug('INCONSISTENCY DETECTED!')
		endif
;
helper context UML!Message def: stateVectorFor(o:UML!Object) : Set(UML!Constraint) =
	let presNext:Set(UML!Constraint) = 
		if self.getLocalSuccessor(o).oclIsUndefined() then
			Set{}
		else
			self.getLocalSuccessor(o).preconditions->select(c|c.isStateInvariantFor(o))
		endif in
	let stateVectorPrev:Set(UML!Constraint) = 
		if self.getLocalPredecessorFor(o).oclIsUndefined() then
			self.preconditions->select(c|c.isStateInvariantFor(o))
		else 
			self.getLocalPredecessorFor(o).stateVectorFor(o)
		endif in
	let stateVectorPresNext:Set(UML!Constaint) = Set{} in
		thisModule.frame(stateVectorPresNext,
		thisModule.frame(stateVectorPrev,
		thisModule.frame(presNext,
			self.postconditions->select(c|c.isStateInvariantFor(o)))))->collect(c|c.getUnique)->asSet()
;
helper context UML!Message def: preconditions: Set(UML!Constraint) =
	self.conformingStimulus->asSequence()
	->first().dispatchAction.constraint
	->select(c|c.stereotype->exists(s|
		s.name='precondition'))
;
helper context UML!Message def: postconditions: Set(UML!Constraint) =
	self.conformingStimulus->asSequence()
	->first().dispatchAction.constraint
	->select(c|c.stereotype->exists(s|
		s.name='postcondition'))
;
helper context UML!Message def: is2Self: Boolean = 
	self.conformingStimulus->asSequence()
	->first().sender = self.conformingStimulus
		->asSequence()->first().receiver
;
helper context UML!Message def: getLocalPredecessorFor(o: UML!Object) : UML!Message =
	if self.predecessor.isEmpty() then
		self.predecessor->asSequence()->first()
	else
		let s: UML!Stimulus = self.predecessor
			->asSequence()->first().conformingStimulus
			->asSequence()->first() in
			if s.sender=o or s.receiver=o then
				self.predecessor->asSequence()->first()
			else
				self.predecessor->asSequence()
				->first().getLocalPredecessorFor(o)
			endif
	endif
;
helper context UML!Message def: getLocalPredecessor: UML!Message =
	if self.predecessor.isEmpty() then
		Sequence{}->first()
	else
		let s: UML!Stimulus = self.predecessor
			->asSequence()->first().conformingStimulus
			->asSequence()->first() in
			if s.sender.isActive or s.receiver.isActive then
				self.predecessor->asSequence()->first()
			else
				self.predecessor->asSequence()
				->first().getLocalPredecessor
			endif
	endif
;
helper context UML!Message def: getLocalSuccessorFor(o:UML!Object) : UML!Message =
	thisModule.allMessages->select(m|m.getLocalPredecessor(o)=self)->asSequence()->first()
;
helper context UML!Message def: getLocalSuccessor : UML!Message =
	thisModule.allMessages->select(m|m.getLocalPredecessor=self)->asSequence()->first()
;
rule Class {
	from c_in:UML!Class
	to c_out:UML!Class(
		name <- c_in.name,
		isActive <- c_in.isActive,
		feature <- c_in.feature)
}
rule Operation {
	from o_in:UML!Operation
	to o_out:UML!Operation(
		name <- o_in.name,
		constraint <- o_in.constraint)
}
rule Method {
	from m_in:UML!Method
	to m_out:UML!Method(
		name <- m_in.name,
		body <- m_in.body,
		specification <- m_in.specification)
}
rule Attribute {
	from a_in:UML!Attribute
	to a_out:UML!Attribute(
		name <- a_in.name,
		visibility <- a_in.visibility,
		type <- a_in.type)
}
rule Package {
	from p_in:UML!Package(
		not(p_in.oclIsTypeOf(UML!Model)))		
	to p_out:UML!Package(
		name <- p_in.name,
		ownedElement <- p_in.ownedElement)
}
rule Constraint {
	from c:UML!Constraint(
		thisModule.constraintConstraints->includes(c))
	to c_out:UML!Constraint(
		name<-c.name,
		body<-be,
		stereotype<-c.stereotype),
	be:UML!BooleanExpression(
		body<-c.body.body)
}
rule Stereotype {
	from s:UML!Stereotype
	to s_out:UML!Stereotype(
		name<-s.name,
		baseClass<-s.baseClass)
}
rule Model {
	from m_in:UML!Model
	to m_out:UML!Model (
		ownedElement <- m_in.ownedElement->select(e|e.oclIsTypeOf(UML!Package))
		->union(thisModule.allClasses
		->union(thisModule.allObjects->select(o|o.isActive)
		->union(thisModule.allMessages->select(m|
			not(m.is2Self))->select(m|m.conformingStimulus
				->asSequence()->first().receiver.isActive)
				->collect(e|thisModule.resolveTemp(e,'ce'))
		->union(thisModule.allStereotypes)))))
}	

rule Statemachine {
	from o:UML!Object(
		o.isActive)
	to sm:UML!StateMachine (
		name <- o.name + ' in ' + 	
			thisModule.allCollaborationInstanceSets->select(c|
				c.participatingInstance->includes(o))
			->asSequence()->first().useCaseName,
		transitions <- Set{t}->union(o.outgoingMessages->union(
				o.incomingMessages)),
		""context"" <- o.classifier->asSequence()->first(),
		top <- cs),
	cs:UML!CompositeState (
		subvertex <- Set{is,ss}
			->union(o.messages->collect(e|
				thisModule.resolveTemp(e,'trgt')))),
	is:UML!Pseudostate (
		kind <- #pk_initial),
	ss:UML!SimpleState (
		name <- 'default',
		constraint <- o.initialStateVector->collect(c|c.getUnique)),
	t:UML!Transition (
		name <- 'default',
		source <- is,
		target <- ss)
}
rule EffectTransition {
	from m:UML!Message (
		m.conformingStimulus->asSequence()
		->first().sender.isActive)
	to
	t_effect: UML!Transition(
		name <- m.name,
		effect <- ca,
		target <- trgt,
		source <- if m.getLocalPredecessor.oclIsUndefined() then
				thisModule.resolveTemp(m.conformingStimulus
					->asSequence()->first().sender,'ss')
			else 
				thisModule.resolveTemp(
					m.getLocalPredecessor,'trgt')
			endif),
	ae:UML!ActionExpression (
		body <- m.conformingStimulus->asSequence()
		->first().dispatchAction.operation.name+
			if m.conformingStimulus->asSequence()
			->first().dispatchAction.actualArgument
			->isEmpty() then
				''
			else
				'('+m.conformingStimulus->asSequence()
					->first().dispatchAction.actualArgument
					->asSequence()->first().value.body+')'
			endif),
	ca:UML!CallAction (
		script <- ae),
	trgt:UML!SimpleState (
		name <- ae.body+'_sent',
		constraint <- m.stateVector)
}
rule TriggerTransition {
	from m:UML!Message (
		m.conformingStimulus->asSequence()
		->first().receiver.isActive and	not (m.is2Self))
	to
	t_trigger:UML!Transition (
		name <- m.conformingStimulus->asSequence()
			->first().name,
		trigger <- ce,
		target <- trgt,
		source <- if m.getLocalPredecessor.oclIsUndefined() then
				thisModule.resolveTemp(m.conformingStimulus
					->asSequence()->first().receiver,'ss')
			else 
				thisModule.resolveTemp(m.getLocalPredecessor,'trgt')
			endif),
	ce:UML!CallEvent (
		name <- m.conformingStimulus->asSequence()
			->first().dispatchAction.operation.name+
			if m.conformingStimulus->asSequence()
			->first().dispatchAction.actualArgument
			->isEmpty() then
				''
			else
				'('+m.conformingStimulus->asSequence()
						->first().dispatchAction.actualArgument
						->asSequence()->first().value.body+')'
			endif),
	trgt:UML!SimpleState(
		name <- ce.name+'_received',
		constraint <- m.stateVector)
}",titl umlsd stmd releas date oktob author bas graaf swerl softwar evolut research lab delft univers technolog b graaf tudelft nl modul sd flatstmd creat out uml in uml helper def allconstraint set uml constraint uml constraint allinst helper def allmessag set uml messag uml messag allinst helper def allclass set uml class uml class allinst helper def allattribut set uml attribut uml attribut allinst helper def allobject set uml object uml object allinst helper def allstereotyp set uml stereotyp uml stereotyp allinst helper def allcollaborationinstanceset set uml collaborationinstanceset uml collaborationinstanceset allinst helper def constraintconstraint set uml constraint thismodul allconstraint iter c cs set uml constraint set cs exist e e equal c cs els cs includ c endif helper def frame frame set uml constraint frame set uml constraint set uml constraint frame iter c cs set uml constraint frame cs exist e e statevari c statevari cs els cs includ c endif helper def unifi cseq sequenc uml constraint cseq sequenc uml constraint boolean cseq foral c cseq exist e e statevari c statevari impli cseq exist e e bodi bodi c bodi bodi helper context uml constraint def equal c uml constraint boolean self bodi bodi c bodi bodi helper context uml constraint def getuniqu uml constraint thismodul constraintconstraint select c c equal self assequ first helper context uml constraint def isprecondit boolean self stereotyp assequ first name precondit helper context uml constraint def statevari uml attribut thismodul allattribut select name self statevariablenam assequ first helper context uml constraint def statevariablenam string self bodi bodi substr self bodi bodi indexof self bodi bodi indexof helper context uml constraint def isstateinvariantfor uml object boolean statevari includ self statevari helper context uml collaborationinstanceset def usecasenam string uml diagram allinst select owner element self assequ first name helper context uml object def statevari set uml attribut self classifi assequ first featur select f f oclistypeof uml attribut helper context uml object def initialstatevector set uml constraint let mseq sequenc uml messag thismodul allmessag select conformingstimulus assequ first sender self conformingstimulus assequ first receiv self mseq select predecessor isempti assequ first precondit helper context uml object def isact boolean self classifi assequ first isact helper context uml object def messag set uml messag self incomingmessag union self outgoingmessag helper context uml object def incomingmessag set uml messag thismodul allmessag select conformingstimulus assequ first receiv self self helper context uml object def outgoingmessag set uml messag thismodul allmessag select conformingstimulus assequ first sender self helper context uml messag def activeobject uml object let uml object self conformingstimulus assequ first sender let r uml object self conformingstimulus assequ first receiv isact els r endif helper context uml messag def statevector set uml constraint let statevectorprev set uml constraint self getlocalpredecessor oclisundefin self precondit select c c isstateinvariantfor self activeobject els self getlocalpredecessor statevector endif let pres set uml constraint self precondit select c c isstateinvariantfor self activeobject let post set uml constraint self postcondit select c c isstateinvariantfor self activeobject let sv set uml constraint thismodul frame statevectorprev thismodul frame pres post collect c c getuniqu asset thismodul unifi statevectorprev pres sv els sv debug inconsist detect endif helper context uml messag def statevectorfor uml object set uml constraint let presnext set uml constraint self getlocalsuccessor oclisundefin set els self getlocalsuccessor precondit select c c isstateinvariantfor endif let statevectorprev set uml constraint self getlocalpredecessorfor oclisundefin self precondit select c c isstateinvariantfor els self getlocalpredecessorfor statevectorfor endif let statevectorpresnext set uml constaint set thismodul frame statevectorpresnext thismodul frame statevectorprev thismodul frame presnext self postcondit select c c isstateinvariantfor collect c c getuniqu asset helper context uml messag def precondit set uml constraint self conformingstimulus assequ first dispatchact constraint select c c stereotyp exist name precondit helper context uml messag def postcondit set uml constraint self conformingstimulus assequ first dispatchact constraint select c c stereotyp exist name postcondit helper context uml messag def self boolean self conformingstimulus assequ first sender self conformingstimulus assequ first receiv helper context uml messag def getlocalpredecessorfor uml object uml messag self predecessor isempti self predecessor assequ first els let uml stimulus self predecessor assequ first conformingstimulus assequ first sender receiv self predecessor assequ first els self predecessor assequ first getlocalpredecessorfor endif endif helper context uml messag def getlocalpredecessor uml messag self predecessor isempti sequenc first els let uml stimulus self predecessor assequ first conformingstimulus assequ first sender isact receiv isact self predecessor assequ first els self predecessor assequ first getlocalpredecessor endif endif helper context uml messag def getlocalsuccessorfor uml object uml messag thismodul allmessag select getlocalpredecessor self assequ first helper context uml messag def getlocalsuccessor uml messag thismodul allmessag select getlocalpredecessor self assequ first rule class c uml class c uml class name c name isact c isact featur c featur rule oper uml oper uml oper name name constraint constraint rule method uml method uml method name name bodi bodi specif specif rule attribut uml attribut uml attribut name name visibl visibl type type rule packag p uml packag p oclistypeof uml model p uml packag name p name ownedel p ownedel rule constraint c uml constraint thismodul constraintconstraint includ c c uml constraint name c name bodi stereotyp c stereotyp uml booleanexpress bodi c bodi bodi rule stereotyp uml stereotyp uml stereotyp name name baseclass baseclass rule model uml model uml model ownedel ownedel select e e oclistypeof uml packag union thismodul allclass union thismodul allobject select isact union thismodul allmessag select self select conformingstimulus assequ first receiv isact collect e thismodul resolvetemp e ce union thismodul allstereotyp rule statemachin uml object isact sm uml statemachin name name thismodul allcollaborationinstanceset select c c participatinginst includ assequ first usecasenam transit set union outgoingmessag union incomingmessag context classifi assequ first top cs cs uml compositest subvertex set ss union messag collect e thismodul resolvetemp e trgt uml pseudost kind pk initi ss uml simplest name default constraint initialstatevector collect c c getuniqu uml transit name default sourc target ss rule effecttransit uml messag conformingstimulus assequ first sender isact effect uml transit name name effect ca target trgt sourc getlocalpredecessor oclisundefin thismodul resolvetemp conformingstimulus assequ first sender ss els thismodul resolvetemp getlocalpredecessor trgt endif ae uml actionexpress bodi conformingstimulus assequ first dispatchact oper name conformingstimulus assequ first dispatchact actualargu isempti els conformingstimulus assequ first dispatchact actualargu assequ first valu bodi endif ca uml callact script ae trgt uml simplest name ae bodi sent constraint statevector rule triggertransit uml messag conformingstimulus assequ first receiv isact self trigger uml transit name conformingstimulus assequ first name trigger ce target trgt sourc getlocalpredecessor oclisundefin thismodul resolvetemp conformingstimulus assequ first receiv ss els thismodul resolvetemp getlocalpredecessor trgt endif ce uml callev name conformingstimulus assequ first dispatchact oper name conformingstimulus assequ first dispatchact actualargu isempti els conformingstimulus assequ first dispatchact actualargu assequ first valu bodi endif trgt uml simplest name ce name receiv constraint statevector,16
228,228,P98-CloneDr2CodeClone.atl,"--@atlcompiler	atl2006
--@name			CloneDr2CodeClone
--@version		1.0
--@domains		CloneDr, CodeClone
--@authors		Yu Sun
--@email        yusun@cis.uab.edu
--@date			2007/12/02
--@description	This transformation is used to transform the output of CloneDr into generic Code Clone DSL model.


module CloneDr2CodeClone; -- Module Template
create OUT : CodeClone from IN : CloneDr, IN2 : FileInfo;

helper context CloneDr!CDUnit
def : getFile() : CodeClone!File = 
	(
			CodeClone!File.allInstances() -> flatten() -> select(e | e.fileName = self.fileName) -> first()
	);

rule FileInfo2FileList {
	from 
		fi : FileInfo!FileInfo
	to
		fl : CodeClone!FileList (
			files <- fi.file
		)
}

rule File2File {
	from 
		f : FileInfo!File
	to
		ff : CodeClone!File (
			fileName <- f.name,
			totalFileLines <- f.totallines
		)
}

rule CloneDr2CodeClone {
	from
		ss : CloneDr!CloneDr
	to
		codeClone : CodeClone!CodeClone (
			sourceToolName <- 'CloneDr.',
			groups <- ss.groups
		)
}

rule CDGroup2CloneGroup {
	from
		ssg : CloneDr!CDGroup
	to
		cloneGroup : CodeClone!CloneGroup (
			totalUnits <- ssg.units -> size(),
			units <- ssg.units
		)
}

rule CDUnit2CloneUnit {
	from
		ssu : CloneDr!CDUnit
	to
		cloneUnit : CodeClone!CloneUnit (
			startLine <- ssu.startLine.toInteger(),
			endLine <- ssu.endLine.toInteger(),
			file <- ssu.getFile()
		)
}
",atlcompil atl name clonedr codeclon version domain clonedr codeclon author yu sun email yusun cis uab edu date descript this transform use transform output clonedr generic code clone dsl model modul clonedr codeclon modul templat creat out codeclon in clonedr in fileinfo helper context clonedr cdunit def getfil codeclon file codeclon file allinst flatten select e e filenam self filenam first rule fileinfo filelist fi fileinfo fileinfo fl codeclon filelist file fi file rule file file f fileinfo file ff codeclon file filenam f name totalfilelin f totallin rule clonedr codeclon ss clonedr clonedr codeclon codeclon codeclon sourcetoolnam clonedr group ss group rule cdgroup clonegroup ssg clonedr cdgroup clonegroup codeclon clonegroup totalunit ssg unit size unit ssg unit rule cdunit cloneunit ssu clonedr cdunit cloneunit codeclon cloneunit startlin ssu startlin tointeg endlin ssu endlin tointeg file ssu getfil,15
229,229,P98-CodeClone2SVG.atl,"--@atlcompiler	atl2006
--@name			CodeClone2SVG
--@version		1.0
--@domains		CodeClone, SVG
--@authors		Yu Sun
--@email        yusun@cis.uab.edu
--@date			2007/10/10
--@description	This transformation is used to transform the generic Code Clone DSL model to SVG model.

module CodeClone2SVG; -- Module Template
create OUT : SVG  from IN : CodeClone;

helper context CodeClone!CloneUnit
def : maxLine() : Integer = 
	(
	    CodeClone!CloneUnit.allInstances()->flatten()->iterate(e; res : Integer = -1 |
	    											if e.file.totalFileLines > res then e.file.totalFileLines
													   else res 
													   endif)
	);


rule CodeClone2Svg {
	from
		cc : CodeClone!CodeClone
	to
		s : SVG!Svg (
			width <- 1000,              
     	    height <- cc.groups -> flatten() -> iterate(e; res : Integer = 0 |
     	    										res + e.totalUnits) * 90 + 
				      cc.groups -> size() * 80 + 100,  
			version <- '1.1',              
			standalone <- 'no',  
			children <- group,
			children <- cc.groups
		),
		
		group : SVG!Group (
			translate_x <- 0,
			translate_y <- 0,
			components <- text
		),
			
		text : SVG!Text (	
			x <- 220,                    
			y <- 20,                             
			font_family <- 'Arial Black',             
			font_size <- 16,                             
			contend <- 'Code Clone Analysis Result by ' + cc.sourceToolName    
		)
}


rule CloneGroup2Group {
	from 
		 cg : CodeClone!CloneGroup
	to 
		g : SVG!Group (
			translate_x <- 0,
			translate_y <- (cg.parent.groups.subSequence(1,cg.parent.groups.indexOf(cg)-1)->size()) * 80 + 90 * (cg.parent.groups.subSequence(1,cg.parent.groups.indexOf(cg)-1) -> flatten() -> iterate(e; res : Integer = 0 | res + e.totalUnits)),             
			components <- text,
			components <- cg.units,
			components <- rect
		),
		
		text : SVG!Text (
			x <- 20,         
			y <- 45,            
			font_size <- 16,          
			font_family <- 'Arial',             
			fill <- 'blue',                             
			contend <- 'Clone Group ' + cg.parent.groups -> indexOf(cg)  -> toString()                  
		),
		
		rect : SVG!Rect (
			x <- 1,                 
			y <- 50,                 
			rx <- 10,              
			ry <- 10,                
			width <- 998,          
			height <- 25 + 90 * cg.units->size()    ,      
			fill <- 'none',            
			stroke <- 'blue',          
			stroke_width <- 2          
		)	
}

rule CloneUint2Shape {
	from
		 cu : CodeClone!CloneUnit
	to
		g : SVG!Group (			
			translate_x <- 0,           
			translate_y <- (cu.parent.units -> indexOf(cu) - 1) * 90,                          
			components <- text,       
			components <- rect,         
			components <- rect2            
		),
		
		text : SVG!Text (
			x <- 25,             
			y <- 75,              
			font_size <- 12,     
			fill <- 'blue',              
			font_family <- 'Arial',    
			contend <- cu.file.fileName  + '  (Total Lines: ' + cu.file.totalFileLines -> toString() + ')'
		),
		
		rect : SVG!Rect (
				x <- 20,        
				y <- 80,         
				rx <- 10,        
				ry <- 10,         
				width <- (950 / cu.maxLine() * cu.file.totalFileLines).floor(),       
				height <- 60,         
				fill <- 'yellow',         
				stroke <- 'blue',            
				stroke_width <- 3,           
				opacity <- 0.5,                  
				title <- cu.file.fileName
		),
		
		rect2 : SVG!Rect (
				x <- 20 + (950 / cu.maxLine() * cu.startLine).floor(),              
				y <- 83,            
				width <- (950 / cu.maxLine() * (cu.endLine - cu.startLine)).floor(),          
				height <- 54,       
				fill <- 'red',      
				opacity <- 0.75,    
				title <- 'Line ' + cu.startLine->toString() + ' to ' + cu.endLine->toString() + ' (' + (cu.endLine - cu.startLine + 1)->toString() + ' lines)'
		)
}

",atlcompil atl name codeclon svg version domain codeclon svg author yu sun email yusun cis uab edu date descript this transform use transform generic code clone dsl model svg model modul codeclon svg modul templat creat out svg in codeclon helper context codeclon cloneunit def maxlin integ codeclon cloneunit allinst flatten iter e res integ e file totalfilelin res e file totalfilelin els res endif rule codeclon svg cc codeclon codeclon svg svg width height cc group flatten iter e res integ res e totalunit cc group size version standalon children group children cc group group svg group translat x translat compon text text svg text x font famili arial black font size contend code clone analysi result cc sourcetoolnam rule clonegroup group cg codeclon clonegroup g svg group translat x translat cg parent group subsequ cg parent group indexof cg size cg parent group subsequ cg parent group indexof cg flatten iter e res integ res e totalunit compon text compon cg unit compon rect text svg text x font size font famili arial fill blue contend clone group cg parent group indexof cg tostr rect svg rect x rx ry width height cg unit size fill none stroke blue stroke width rule cloneuint shape cu codeclon cloneunit g svg group translat x translat cu parent unit indexof cu compon text compon rect compon rect text svg text x font size fill blue font famili arial contend cu file filenam total line cu file totalfilelin tostr rect svg rect x rx ry width cu maxlin cu file totalfilelin floor height fill yellow stroke blue stroke width opac titl cu file filenam rect svg rect x cu maxlin cu startlin floor width cu maxlin cu endlin cu startlin floor height fill red opac titl line cu startlin tostr cu endlin tostr cu endlin cu startlin tostr line,15
230,230,P98-CodeClone2SVG2.atl,"--@atlcompiler	atl2006
--@name			CodeClone2SVG2
--@version		1.0
--@domains		CodeClone, SVG2
--@authors		Yu Sun
--@email        yusun@cis.uab.edu
--@date			2007/11/05
--@description	This transformation is used to transform the generic Code Clone DSL model to SVG model in a different format.

module CodeClone2SVG2; -- Module Template
create OUT : SVG from IN : CodeClone;

helper context CodeClone!CloneUnit 
def : firstOne(p : CodeClone!CloneUnit) : Integer =
	(
		CodeClone!CloneUnit.allInstances()->indexOf(CodeClone!CloneUnit.allInstances()->select(e | e.file.fileName = self.file.fileName)->first())
	);

helper context CodeClone!CloneUnit 
def : getColor() : String =
	(
		Sequence{'red', 'green', 'blue', 'yellow', 'pink', 'gold', 'brown', 'cyan', 'honeydew', 'lime', 'purple', 'sienna', 'springgreen', 'black', 'dark'} -> at(self.parent.parent.groups.indexOf(self.parent))
	);

helper context CodeClone!CloneUnit
def : getPos(p : String) : Integer =
	(
		CodeClone!CloneUnit.allInstances()->iterate(e; acc : OrderedSet(String) = OrderedSet{}|
																			acc->including(e.file.fileName)) -> indexOf(p)
	);

helper context CodeClone!CloneUnit
def : maxLine() : Integer = 
	(
	    CodeClone!CloneUnit.allInstances()->flatten()->iterate(e; res : Integer = -1 |
	    											if e.file.totalFileLines > res then e.file.totalFileLines
													   else res
													   endif)
	);

rule CodeClone2Svg {
	from
		cc : CodeClone!CodeClone
	to
		s : SVG!Svg (
			width <- 1000,                
     	    height <- CodeClone!CloneUnit.allInstances()->collect(e | e.file.fileName)-> asSet() -> size() * 90 + 100,

			version <- '1.1',     
			standalone <- 'no',   
			children <- group,
			children <- CodeClone!CloneUnit.allInstances()
		),
		
		group : SVG!Group (
			translate_x <- 0,
			translate_y <- 0,
			components <- text
		),
			
		text : SVG!Text (	
			x <- 220,                             
			y <- 20,                              
			font_family <- 'Arial Black',           
			font_size <- 16,                            
			contend <- 'Code Clone Analysis Result by ' + cc.sourceToolName              
		)
}


rule CloneUnit2Group {
	from 
		 cu : CodeClone!CloneUnit(
		 	CodeClone!CloneUnit.allInstances()->flatten()->indexOf(cu) = cu.firstOne(cu)
			)
	to 
		g : SVG!Group (
			translate_x <- 0,
			translate_y <- 90 * (cu.getPos(cu.file.fileName) - 1),
			components <- text,
			components <- rect,
			components <- rect2
		),
		
		text : SVG!Text (
			x <- 25,
			y <- 75,           
			font_size <- 12,   
			font_family <- 'Arial',             
			fill <- 'blue',                     
			contend <- cu.file.fileName + '  (Total Lines: ' + cu.file.totalFileLines -> toString() + ')'        
		),
		
		rect : SVG!Rect (
			x <- 20,
			y <- 80,                
			rx <- 10,               
			ry <- 10,                
			width <- (950 / cu.maxLine() * cu.file.totalFileLines).floor(),      
			height <- 60,     
			fill <- 'white',        
			stroke <- 'brown',      
			stroke_width <- 3,      
			title <- cu.file.fileName + 'Test Test again',
			opacity <- 0.8
		),
		
		rect2 : SVG!Rect (
				x <- 20 + (950 / cu.maxLine() * cu.startLine).floor(),   
				y <- 83,           
				rx <- 0,
				ry <- 0,
				width <- (950 / cu.maxLine() * (cu.endLine - cu.startLine)).floor(),        
				height <- 54,      
				fill <- cu.getColor(),              
				opacity <- 0.75,          
				title <- 'Line ' + cu.startLine->toString() + ' to ' + cu.endLine->toString() + ' (' + (cu.endLine - cu.startLine + 1)->toString() + ' lines)'
		)
}

rule CloneUnit22Group {
	from 
		 cu : CodeClone!CloneUnit(
		 	 not (CodeClone!CloneUnit.allInstances()->flatten()->indexOf(cu) = cu.firstOne(cu))
			)
	to 
		g : SVG!Group (
			translate_x <- 0,
			translate_y <- 90 * (cu.getPos(cu.file.fileName) - 1),
			components <- rect2
		),
		
		rect2 : SVG!Rect (
				x <- 20 + (950 / cu.maxLine() * cu.startLine).floor(),              
				y <- 83,            
				rx <- 0,
				ry <- 0,
				width <- (950 / cu.maxLine() * (cu.endLine - cu.startLine)).floor(),
				height <- 54,       
				fill <- cu.getColor(),             
				opacity <- 0.75,           
				title <- 'Line ' + cu.startLine->toString() + ' to ' + cu.endLine->toString() + ' (' + (cu.endLine - cu.startLine + 1)->toString() + ' lines)'
		)
}
",atlcompil atl name codeclon svg version domain codeclon svg author yu sun email yusun cis uab edu date descript this transform use transform generic code clone dsl model svg model differ format modul codeclon svg modul templat creat out svg in codeclon helper context codeclon cloneunit def firston p codeclon cloneunit integ codeclon cloneunit allinst indexof codeclon cloneunit allinst select e e file filenam self file filenam first helper context codeclon cloneunit def getcolor string sequenc red green blue yellow pink gold brown cyan honeydew lime purpl sienna springgreen black dark self parent parent group indexof self parent helper context codeclon cloneunit def getpo p string integ codeclon cloneunit allinst iter e acc orderedset string orderedset acc includ e file filenam indexof p helper context codeclon cloneunit def maxlin integ codeclon cloneunit allinst flatten iter e res integ e file totalfilelin res e file totalfilelin els res endif rule codeclon svg cc codeclon codeclon svg svg width height codeclon cloneunit allinst collect e e file filenam asset size version standalon children group children codeclon cloneunit allinst group svg group translat x translat compon text text svg text x font famili arial black font size contend code clone analysi result cc sourcetoolnam rule cloneunit group cu codeclon cloneunit codeclon cloneunit allinst flatten indexof cu cu firston cu g svg group translat x translat cu getpo cu file filenam compon text compon rect compon rect text svg text x font size font famili arial fill blue contend cu file filenam total line cu file totalfilelin tostr rect svg rect x rx ry width cu maxlin cu file totalfilelin floor height fill white stroke brown stroke width titl cu file filenam test test opac rect svg rect x cu maxlin cu startlin floor rx ry width cu maxlin cu endlin cu startlin floor height fill cu getcolor opac titl line cu startlin tostr cu endlin tostr cu endlin cu startlin tostr line rule cloneunit group cu codeclon cloneunit codeclon cloneunit allinst flatten indexof cu cu firston cu g svg group translat x translat cu getpo cu file filenam compon rect rect svg rect x cu maxlin cu startlin floor rx ry width cu maxlin cu endlin cu startlin floor height fill cu getcolor opac titl line cu startlin tostr cu endlin tostr cu endlin cu startlin tostr line,15
231,231,P98-Simian2CodeClone.atl,"--@atlcompiler	atl2006
--@name			Simian2CodeClone
--@version		1.0
--@domains		Simian, CodeClone
--@authors		Yu Sun
--@email        yusun@cis.uab.edu
--@date			2007/10/04
--@description	This transformation is used to transform the output of Simian into generic Code Clone DSL model.


module Simian2CodeClone; -- Module Template
create OUT : CodeClone from IN : Simian, IN2 : FileInfo;

helper context Simian!Clone
def : getFile() : CodeClone!File = 
	(
			CodeClone!File.allInstances() -> flatten() -> select(e | e.fileName = self.file) -> first()
	);

rule FileInfo2FileList {
	from 
		fi : FileInfo!FileInfo
	to
		fl : CodeClone!FileList (
			files <- fi.file
		)
}

rule File2File {
	from 
		f : FileInfo!File
	to
		ff : CodeClone!File (
			fileName <- f.name,
			totalFileLines <- f.totallines
		)
}

rule ClonePairs2CodeClone {
	from 
		clonePairs : Simian!ClonePairs,
		fi : FileInfo!FileInfo
	to
		codeClone : CodeClone!CodeClone (
			sourceToolName <- 'Simian',
			groups <- clonePairs.clonepart
		)
}



rule ClonePair2CloneGroup {
	from 
		clonepair : Simian!ClonePair
	to 
		cloneGroup : CodeClone!CloneGroup (
			totalUnits <- clonepair.clonesubpart -> size(),
			units <- clonepair.clonesubpart
		)
}

rule Clone2CloneUnit {
	from 
		clone : Simian!Clone
	to 
		cloneUnit : CodeClone!CloneUnit (
			startLine <- clone.start_line,
			endLine <- clone.end_line,
			file <- clone.getFile()
		)
}

",atlcompil atl name simian codeclon version domain simian codeclon author yu sun email yusun cis uab edu date descript this transform use transform output simian generic code clone dsl model modul simian codeclon modul templat creat out codeclon in simian in fileinfo helper context simian clone def getfil codeclon file codeclon file allinst flatten select e e filenam self file first rule fileinfo filelist fi fileinfo fileinfo fl codeclon filelist file fi file rule file file f fileinfo file ff codeclon file filenam f name totalfilelin f totallin rule clonepair codeclon clonepair simian clonepair fi fileinfo fileinfo codeclon codeclon codeclon sourcetoolnam simian group clonepair clonepart rule clonepair clonegroup clonepair simian clonepair clonegroup codeclon clonegroup totalunit clonepair clonesubpart size unit clonepair clonesubpart rule clone cloneunit clone simian clone cloneunit codeclon cloneunit startlin clone start line endlin clone end line file clone getfil,15
232,232,P98-SimScan2CodeClone.atl,"--@atlcompiler	atl2006
--@name			SimScan2CodeClone
--@version		1.0
--@domains		SimScan, CodeClone
--@authors		Yu Sun
--@email        yusun@cis.uab.edu
--@date			2007/11/02
--@description	This transformation is used to transform the output of SimScan into generic Code Clone DSL model.


module SimScan2CodeClone; -- Module Template
create OUT : CodeClone from IN : SimScan, IN2 : FileInfo;

helper context SimScan!SSUnit
def : getFile() : CodeClone!File = 
	(
			CodeClone!File.allInstances() -> flatten() -> select(e | e.fileName = self.drive + ':\\' + self.fileName) -> first()
	);

rule FileInfo2FileList {
	from 
		fi : FileInfo!FileInfo
	to
		fl : CodeClone!FileList (
			files <- fi.file
		)
}

rule File2File {
	from 
		f : FileInfo!File
	to
		ff : CodeClone!File (
			fileName <- f.name,
			totalFileLines <- f.totallines
		)
}

rule SimScan2CodeClone {
	from
		ss : SimScan!SimScan
	to
		codeClone : CodeClone!CodeClone (
			sourceToolName <- 'SimScan',
			groups <- ss.groups
		)
}

rule SSGroup2CloneGroup {
	from
		ssg : SimScan!SSGroup
	to
		cloneGroup : CodeClone!CloneGroup (
			totalUnits <- ssg.units -> size(),
			units <- ssg.units
		)
}

rule SSUnit2CloneUnit {
	from
		ssu : SimScan!SSUnit
	to
		cloneUnit : CodeClone!CloneUnit (
			startLine <- ssu.startLine,
			endLine <- ssu.endLine,
			file <- ssu.getFile()
		)
}
",atlcompil atl name simscan codeclon version domain simscan codeclon author yu sun email yusun cis uab edu date descript this transform use transform output simscan generic code clone dsl model modul simscan codeclon modul templat creat out codeclon in simscan in fileinfo helper context simscan ssunit def getfil codeclon file codeclon file allinst flatten select e e filenam self drive self filenam first rule fileinfo filelist fi fileinfo fileinfo fl codeclon filelist file fi file rule file file f fileinfo file ff codeclon file filenam f name totalfilelin f totallin rule simscan codeclon ss simscan simscan codeclon codeclon codeclon sourcetoolnam simscan group ss group rule ssgroup clonegroup ssg simscan ssgroup clonegroup codeclon clonegroup totalunit ssg unit size unit ssg unit rule ssunit cloneunit ssu simscan ssunit cloneunit codeclon cloneunit startlin ssu startlin endlin ssu endlin file ssu getfil,15
233,233,P98-SVG2XML.atl,"--@atlcompiler	atl2006
--@name			SVG2XML
--@version		1.0
--@domains		SVG, XML
--@authors		Yu Sun
--@email        yusun@cis.uab.edu
--@date			2007/11/02
--@description	This transformation is used to transform the SVG model to XML model.

module SVG2XML; -- Module Template
create OUT : XML from IN : SVG;

rule Svg {
	from 
		svg : SVG!Svg
	to
		root : XML!Root (
			name <- 'svg',
			children <- xmlns,
			children <- version,
			children <- width,
			children <- height,
			children <- standalone,
			children <- svg.children
		),
		
		xmlns : XML!Attribute (
			name <- 'xmlns',
			value <- 'http://www.w3.org/2000/svg'
		),
		
		version : XML!Attribute (
			name <- 'version',
			value <- svg.version 
		),
		
		width : XML!Attribute (
			name <- 'width',
			value <- svg.width -> toString()
		),
		
		height : XML!Attribute (
			name <- 'height',
			value <- svg.height -> toString()
		),
		
		standalone : XML!Attribute (
			name <- 'standalone',
			value <- svg.standalone 
		)
}

rule G {
	from 
		g : SVG!Group
	to
		elmt : XML!Element (
			name <- 'g',
			children <- transform,
			children <- g.components
		),
		
		transform : XML!Attribute (
			name <- 'transform',
			value <- 'translate(' + g.translate_x -> toString() + ',' + g.translate_y -> toString() + ')'
		)
}

rule Text {
	from 
		t : SVG!Text
	to
		elmt : XML!Element (
			name <- 'text',
			children <- thisModule.Attribute('x', t.x->toString()),
			children <- thisModule.Attribute('y', t.y->toString()),
			children <- thisModule.Attribute('font-size', t.font_size -> toString()),
			children <- txt
		),
		
		txt : XML!Text (
			value <- t.contend
		)
	do {
		if (not t.fill.oclIsUndefined()) {
			elmt.children <- thisModule.Attribute('fill', t.fill);
		}
		if (not t.font_family.oclIsUndefined()) {
			elmt.children <- thisModule.Attribute('font-family', t.font_family);
		}
	}
}

rule Rect {
	from 
		r : SVG!Rect
	to 
		elmt : XML!Element (
			name <- 'rect',
			children <- thisModule.Attribute('x', r.x -> toString()),
			children <- thisModule.Attribute('y', r.y -> toString()),
			children <- thisModule.Attribute('width', r.width ->toString()),
			children <- thisModule.Attribute('height', r.height->toString()),
			children <- thisModule.Attribute('fill', r.fill)
		)
	do {
		
		if (not r.rx.oclIsUndefined()) {
			elmt.children <- thisModule.Attribute('rx', r.rx -> toString());
		}
		if (not r.ry.oclIsUndefined()) {
			elmt.children <- thisModule.Attribute('ry', r.ry -> toString());
		}
		if (not r.stroke_width.oclIsUndefined()) {
			elmt.children <- thisModule.Attribute('stroke-width', r.stroke_width -> toString());
		}
		if (not r.stroke.oclIsUndefined()) {
			elmt.children <- thisModule.Attribute('stroke', r.stroke);
		} 
		if (not r.opacity.oclIsUndefined()) {
			elmt.children <- thisModule.Attribute('opacity', r.opacity -> toString());
		}
		if (not r.title.oclIsUndefined()) {
			elmt.children <- thisModule.Attribute('title', r.title -> toString());
		}
	}
}

--@begin called rule Attribute
rule Attribute(attrName : String, attrValue : String) {
	to
		attr : XML!Attribute (
			name <- attrName,
			value <- attrValue
		)
	do {
		attr;
	}
}	
--@end called rule Attribute
",atlcompil atl name svg xml version domain svg xml author yu sun email yusun cis uab edu date descript this transform use transform svg model xml model modul svg xml modul templat creat out xml in svg rule svg svg svg svg root xml root name svg children xmlns children version children width children height children standalon children svg children xmlns xml attribut name xmlns valu http www w org svg version xml attribut name version valu svg version width xml attribut name width valu svg width tostr height xml attribut name height valu svg height tostr standalon xml attribut name standalon valu svg standalon rule g g svg group elmt xml element name g children transform children g compon transform xml attribut name transform valu translat g translat x tostr g translat tostr rule text svg text elmt xml element name text children thismodul attribut x x tostr children thismodul attribut tostr children thismodul attribut font size font size tostr children txt txt xml text valu contend fill oclisundefin elmt children thismodul attribut fill fill font famili oclisundefin elmt children thismodul attribut font famili font famili rule rect r svg rect elmt xml element name rect children thismodul attribut x r x tostr children thismodul attribut r tostr children thismodul attribut width r width tostr children thismodul attribut height r height tostr children thismodul attribut fill r fill r rx oclisundefin elmt children thismodul attribut rx r rx tostr r ry oclisundefin elmt children thismodul attribut ry r ry tostr r stroke width oclisundefin elmt children thismodul attribut stroke width r stroke width tostr r stroke oclisundefin elmt children thismodul attribut stroke r stroke r opac oclisundefin elmt children thismodul attribut opac r opac tostr r titl oclisundefin elmt children thismodul attribut titl r titl tostr begin call rule attribut rule attribut attrnam string attrvalu string attr xml attribut name attrnam valu attrvalu attr end call rule attribut,9
234,234,P99-R2ML2WSDL.atl,"--@atlcompiler atl2006

--------------------------------------------------------------------------------
-- Transforms a R2ML metamodel into WSDL metamodel.
-- Created as part of M.Sc. theses at GOOD OLD AI Research Group
-- Author: Marko Ribaric
-- Works for R2ML v0.5-beta
--------------------------------------------------------------------------------
-- Version: 0.1 - 10.06.2007.
--
-- TODO:
--	1) add binding
--  2) add additional MEPs
--  3) add infault
--
-- ANNOTATION: With MDR, Enumerations must be located in top-most package
--------------------------------------------------------------------------------

module R2ML2WSDL; 					-- Module Template
create OUT : WSDL from IN : R2ML;

-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- HELPER:	setElemName
-- Returns the name of the element (Interface or Endpoint) from the name of the service
-- (service name is baseName + ""Service"", and interface name is baseName + ""Interface"")
-- CONTEXT:	thisModule
-- IN1:	String - the name of the service
-- IN2:	String - ""Interface"" or ""Endpoint""
-- OUT:	String	- baseName + IN2
helper def: setElemName(serviceName : String, elemName : String) : String =
	if serviceName.endsWith('Service') then
	    let fromIndex : Integer = 1  in
		let toIndex : Integer = serviceName.lastIndexOf('Service')  in	
		serviceName.substring(fromIndex, toIndex).concat(elemName)
	else OclUndefined
	endif ;

-- HELPER:	getAllRRWithThisGroupID
-- Returns all ReactionRules with the same groupID
-- CONTEXT:	thisModule
-- IN1:	String - name of the groipID
-- OUT:	Sequence(R2ML!ReactionRule)
helper def: getAllRRWithThisGroupID(value : String) : Sequence(R2ML!ReactionRule) =
	R2ML!ReactionRule.allInstances()->asSequence()->select(c| c.groupID = value);
	
-- HELPER:	getClassWithThisName
-- Returns R2ML!Class with name same as the name attribute of self
-- CONTEXT:	R2ML!Type
-- OUT: R2ML!Class
helper context R2ML!Type def: getClassWithThisName() : R2ML!Class =
	R2ML!Class.allInstances()->asSequence()->select(c| c.name = self.name)->first();

-- HELPER:	getMessageTypeWithThisName
-- Returns R2ML!MessageType with name same as the name attribute of self
-- CONTEXT:	R2ML!Type
-- OUT: R2ML!MessageType
helper context R2ML!Type def: getMessageTypeWithThisName() : R2ML!MessageType =
	R2ML!MessageType.allInstances()->asSequence()->select(c| c.name = self.name)->first();

-- HELPER:	getFaultMessageTypeWithThisName
-- Returns R2ML!FaultMessageType with name same as the name attribute of self
-- CONTEXT:	R2ML!Type
-- OUT: R2ML!FaultMessageType
helper context R2ML!Type def: getFaultMessageTypeWithThisName() : R2ML!FaultMessageType =
	R2ML!FaultMessageType.allInstances()->asSequence()->select(c| c.name = self.name)->first();


-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'Description'
-- Creates WSDL!Description element from an R2ML!RuleBase. These are root elements.
rule Description {
	from i : R2ML!RuleBase ( 
				i.oclIsTypeOf(R2ML!RuleBase)
			)
	to o : WSDL!Description (
				types <- i.vocabularies,
				service <- i.rules->select(c| c.oclIsTypeOf(R2ML!ReactionRuleSet)), 
				interface <- i.rules->select(c| c.oclIsTypeOf(R2ML!ReactionRuleSet))->collect( e | thisModule.resolveTemp(e, 'inter'))
			)
}

-- Rule 'ElementType'
-- Creates WSDL!ElementType element from an R2ML!Vocabulary
rule ElementType {
	from i : R2ML!Vocabulary (
				i.oclIsTypeOf(R2ML!Vocabulary)
			)
	to o : WSDL!ElementType (
				schema <- schema
			),
	schema : WSDL!XsSchema (
			    schemaLocation <- 'http://www.w3.org/2006/01/wsdl',
				targetNamespace <- 'http://www.bookingservice.com/?wsdl',
				elementDeclarations <- i.entries
			)
}

-- Rule 'XsElementDeclarationCL'
-- Creates WSDL!XsElementDeclaration element from an R2ML!Class.
rule XsElementDeclarationCL {
	from i : R2ML!Class (
				i.oclIsTypeOf(R2ML!Class)
			)		
	to ele : WSDL!XsElementDeclaration (
				name <- i.name,
				typeDefinition <- complex
			),
		complex : WSDL!XsComplexTypeDefinition (                 
				content <- con
			),
		con : WSDL!XsParticle (
				term <- ter
			),
		ter : WSDL!XsModelGroup (
				compositor <- #sequence,
				particles <- Sequence { i.attributes,
										if not i.referencePropertyRef.oclIsUndefined() then
											i.referencePropertyRef
										else OclUndefined
										endif
									   }
			)
}

-- Rule 'XsElementDeclarationMT'
-- Creates WSDL!XsElementDeclaration element from an R2ML!MessageType.
rule XsElementDeclarationMT {
	from i : R2ML!MessageType (
				i.oclIsTypeOf(R2ML!MessageType)
			)		
	to ele : WSDL!XsElementDeclaration (
				name <- i.name,
				typeDefinition <- complex
			),
		complex : WSDL!XsComplexTypeDefinition (                 
				content <- con
			),
		con : WSDL!XsParticle (
				term <- ter
			),
		ter : WSDL!XsModelGroup (
				compositor <- #sequence,
				particles <- Sequence { i.attributes,
										if not i.referencePropertyRef.oclIsUndefined() then
											i.referencePropertyRef
										else OclUndefined
										endif
									  }
			)
}

-- Rule 'XsElementDeclarationFMT'
-- Creates WSDL!XsElementDeclaration element from an R2ML!FaultMessageType.
rule XsElementDeclarationFMT {
	from i : R2ML!FaultMessageType (
				i.oclIsTypeOf(R2ML!FaultMessageType)
			)		
	to ele : WSDL!XsElementDeclaration (
				name <- i.name,
				typeDefinition <- complex
			),
		complex : WSDL!XsComplexTypeDefinition (                 
				content <- con
			),
		con : WSDL!XsParticle (
				term <- ter
			),
		ter : WSDL!XsModelGroup (
				compositor <- #sequence,
				particles <- Sequence { i.attributes,
										if not i.referencePropertyRef.oclIsUndefined() then
											i.referencePropertyRef
										else OclUndefined
										endif
									   }
			)	
}

-- Rule 'XsParticleREF'
-- Creates WSDL!XsParticle element from an R2ML!ReferenceProperty
rule XsParticleREF {
	from i : R2ML!ReferenceProperty (
				i.oclIsTypeOf(R2ML!ReferenceProperty)
			)		
	to	part : WSDL!XsParticle (                 
				content <- ele
			),
		ele : WSDL!XsElementDeclaration (
				name <- i.name,
				resolvedElementDeclaration <- i.range.getClassWithThisName()	--TODO: helper
			)
}

-- Rule 'XsParticleATT'
-- Creates WSDL!XsParticle element from an R2ML!Attribute.
rule XsParticleATT {
	from i : R2ML!Attribute (
				i.oclIsTypeOf(R2ML!Attribute)
			)		
	to	part : WSDL!XsParticle (                 
				content <- ele
			),
		ele : WSDL!XsElementDeclaration (
				name <- i.name,
				typeDefinition <- if not i.range.oclIsUndefined() then
									thisModule.SimpleType(i.range)
								  else OclUndefined
								  endif
			)
}

-- Rule 'SimpleType'
-- Creates WSDL!XsSimpleTypeDefinition element from an R2ML!Datatype.
-- This rule is unique lazy rule, which means that is called from other rules
unique lazy rule SimpleType {
	from i : R2ML!Datatype
	to o : WSDL!XsSimpleTypeDefinition (
			name <- i.name
		)		
}

-- Rule 'Interface'
-- Creates WSDL!Interface element from an R2ML!ReactionRuleSet.
-- for each distinct groupID create one Operation
rule Interface {
	from i : R2ML!ReactionRuleSet (
				i.oclIsTypeOf(R2ML!ReactionRuleSet)
			)		
	to	serv : WSDL!Service (
				name <- i.ruleSetID,
				interface <- inter,				
				endpoint <- en
			),
	inter : WSDL!Interface (
				name <- thisModule.setElemName(i.ruleSetID, 'Interface'),
				fault <- i.rules,
				operation <- let setOfGroupIDs : Set (String) = i.rules->iterate(p; s : Set(String) = Set{} |
							 									s->including(p.groupID) ) in
								setOfGroupIDs->collect(e| 
									thisModule.Operation(i.rules->asSequence()->select(c| c.groupID = e)->first()) 
													   )
			),
		en : WSDL!Endpoint (                 
				name <- thisModule.setElemName(i.ruleSetID, 'Endpoint'),
				address <- i.rules->select(c| c.oclIsTypeOf(R2ML!ReactionRule) and not
					c.producedAction.type.oclIsTypeOf(R2ML!FaultMessageType))->first().producedAction.sender
		)
}

-- Rule 'Fault'
-- Creates WSDL!Fault element from an R2ML!ReactionRule.
rule Fault {
	from i : R2ML!ReactionRule (
				i.oclIsTypeOf(R2ML!ReactionRule) and
				i.producedAction.type.oclIsTypeOf(R2ML!FaultMessageType)
			)		
	to	part : WSDL!Fault (
				name <- i.producedAction.type.name,
				element <- i.producedAction.type.getFaultMessageTypeWithThisName()
			)
}

-- Rule 'Operation'
-- Creates WSDL!Operation element from an Sequence (R2ML!ReactionRule) .
-- This rule is lazy rule, which means that is called from other rules
lazy rule Operation {
	from i : R2ML!ReactionRule
	to	part : WSDL!Operation (
				name <- i.groupID,
				pattern <- if thisModule.getAllRRWithThisGroupID(i.groupID).size() = 2 then
								#inout
							else #inonly
							endif,
				input <- thisModule.Input(i.triggeringEvent),
				output <- let rr1 : R2ML!ReactionRule =
						thisModule.getAllRRWithThisGroupID(i.groupID)->
						select(c| not c.producedAction.type.oclIsTypeOf(R2ML!FaultMessageType))->first()
						in
							if not rr1.oclIsUndefined() then
								thisModule.Output(rr1.producedAction)
							else OclUndefined
							endif,
				outfault <- let rr2 : R2ML!ReactionRule =
						thisModule.getAllRRWithThisGroupID(i.groupID)->
						select(c| c.producedAction.type.oclIsTypeOf(R2ML!FaultMessageType))->first()
						in
							if not rr2.oclIsUndefined() then
								thisModule.Outfault(rr2)
							else OclUndefined
							endif						
			)
}

-- Rule 'Input'
-- Creates WSDL!Input element from an R2ML!MessageEventExpression.
-- This rule is lazy rule, which means that is called from other rules
lazy rule Input {
	from i : R2ML!MessageEventExpression (
				i.oclIsTypeOf(R2ML!MessageEventExpression)
			)		
	to	part : WSDL!Input (
				messageLabel <- 'In',
				element <- i.type.getMessageTypeWithThisName()
			)
}

-- Rule 'Output'
-- Creates WSDL!Output element from an R2ML!MessageEventExpression.
-- This rule is lazy rule, which means that is called from other rules
lazy rule Output {
	from i : R2ML!MessageEventExpression (
				i.oclIsTypeOf(R2ML!MessageEventExpression)
			)		
	to	part : WSDL!Output (
				messageLabel <- 'Out',
				element <- i.type.getMessageTypeWithThisName()
			)
}

-- Rule 'Outfault'
-- Creates WSDL!Outfault element from an R2ML!ReactionRule.
-- This rule is lazy rule, which means that is called from other rules
lazy rule Outfault {
	from i : R2ML!ReactionRule (
				i.oclIsTypeOf(R2ML!ReactionRule)
			)		
	to	part : WSDL!Outfault (
				messageLabel <- 'Out',
				fault <- i
			)
}

",atlcompil atl transform r ml metamodel wsdl metamodel creat part m sc these good old ai research group author marko ribar work r ml v beta version todo add bind add addit mep add infault annot with mdr enumer must locat top packag modul r ml wsdl modul templat creat out wsdl in r ml helper helper setelemnam return name element interfac endpoint name servic servic name basenam servic interfac name basenam interfac context thismodul in string name servic in string interfac endpoint out string basenam in helper def setelemnam servicenam string elemnam string string servicenam endswith servic let fromindex integ let toindex integ servicenam lastindexof servic servicenam substr fromindex toindex concat elemnam els oclundefin endif helper getallrrwiththisgroupid return reactionrul groupid context thismodul in string name groipid out sequenc r ml reactionrul helper def getallrrwiththisgroupid valu string sequenc r ml reactionrul r ml reactionrul allinst assequ select c c groupid valu helper getclasswiththisnam return r ml class name name attribut self context r ml type out r ml class helper context r ml type def getclasswiththisnam r ml class r ml class allinst assequ select c c name self name first helper getmessagetypewiththisnam return r ml messagetyp name name attribut self context r ml type out r ml messagetyp helper context r ml type def getmessagetypewiththisnam r ml messagetyp r ml messagetyp allinst assequ select c c name self name first helper getfaultmessagetypewiththisnam return r ml faultmessagetyp name name attribut self context r ml type out r ml faultmessagetyp helper context r ml type def getfaultmessagetypewiththisnam r ml faultmessagetyp r ml faultmessagetyp allinst assequ select c c name self name first rule rule descript creat wsdl descript element r ml rulebas these root element rule descript r ml rulebas oclistypeof r ml rulebas wsdl descript type vocabulari servic rule select c c oclistypeof r ml reactionruleset interfac rule select c c oclistypeof r ml reactionruleset collect e thismodul resolvetemp e inter rule elementtyp creat wsdl elementtyp element r ml vocabulari rule elementtyp r ml vocabulari oclistypeof r ml vocabulari wsdl elementtyp schema schema schema wsdl xsschema schemaloc http www w org wsdl targetnamespac http www bookingservic com wsdl elementdeclar entri rule xselementdeclarationcl creat wsdl xselementdeclar element r ml class rule xselementdeclarationcl r ml class oclistypeof r ml class ele wsdl xselementdeclar name name typedefinit complex complex wsdl xscomplextypedefinit content con con wsdl xsparticl term ter ter wsdl xsmodelgroup compositor sequenc particl sequenc attribut referencepropertyref oclisundefin referencepropertyref els oclundefin endif rule xselementdeclarationmt creat wsdl xselementdeclar element r ml messagetyp rule xselementdeclarationmt r ml messagetyp oclistypeof r ml messagetyp ele wsdl xselementdeclar name name typedefinit complex complex wsdl xscomplextypedefinit content con con wsdl xsparticl term ter ter wsdl xsmodelgroup compositor sequenc particl sequenc attribut referencepropertyref oclisundefin referencepropertyref els oclundefin endif rule xselementdeclarationfmt creat wsdl xselementdeclar element r ml faultmessagetyp rule xselementdeclarationfmt r ml faultmessagetyp oclistypeof r ml faultmessagetyp ele wsdl xselementdeclar name name typedefinit complex complex wsdl xscomplextypedefinit content con con wsdl xsparticl term ter ter wsdl xsmodelgroup compositor sequenc particl sequenc attribut referencepropertyref oclisundefin referencepropertyref els oclundefin endif rule xsparticleref creat wsdl xsparticl element r ml referenceproperti rule xsparticleref r ml referenceproperti oclistypeof r ml referenceproperti part wsdl xsparticl content ele ele wsdl xselementdeclar name name resolvedelementdeclar rang getclasswiththisnam todo helper rule xsparticleatt creat wsdl xsparticl element r ml attribut rule xsparticleatt r ml attribut oclistypeof r ml attribut part wsdl xsparticl content ele ele wsdl xselementdeclar name name typedefinit rang oclisundefin thismodul simpletyp rang els oclundefin endif rule simpletyp creat wsdl xssimpletypedefinit element r ml datatyp this rule uniqu lazi rule mean call rule uniqu lazi rule simpletyp r ml datatyp wsdl xssimpletypedefinit name name rule interfac creat wsdl interfac element r ml reactionruleset distinct groupid creat one oper rule interfac r ml reactionruleset oclistypeof r ml reactionruleset serv wsdl servic name rulesetid interfac inter endpoint en inter wsdl interfac name thismodul setelemnam rulesetid interfac fault rule oper let setofgroupid set string rule iter p set string set includ p groupid setofgroupid collect e thismodul oper rule assequ select c c groupid e first en wsdl endpoint name thismodul setelemnam rulesetid endpoint address rule select c c oclistypeof r ml reactionrul c producedact type oclistypeof r ml faultmessagetyp first producedact sender rule fault creat wsdl fault element r ml reactionrul rule fault r ml reactionrul oclistypeof r ml reactionrul producedact type oclistypeof r ml faultmessagetyp part wsdl fault name producedact type name element producedact type getfaultmessagetypewiththisnam rule oper creat wsdl oper element sequenc r ml reactionrul this rule lazi rule mean call rule lazi rule oper r ml reactionrul part wsdl oper name groupid pattern thismodul getallrrwiththisgroupid groupid size inout els inon endif input thismodul input triggeringev output let rr r ml reactionrul thismodul getallrrwiththisgroupid groupid select c c producedact type oclistypeof r ml faultmessagetyp first rr oclisundefin thismodul output rr producedact els oclundefin endif outfault let rr r ml reactionrul thismodul getallrrwiththisgroupid groupid select c c producedact type oclistypeof r ml faultmessagetyp first rr oclisundefin thismodul outfault rr els oclundefin endif rule input creat wsdl input element r ml messageeventexpress this rule lazi rule mean call rule lazi rule input r ml messageeventexpress oclistypeof r ml messageeventexpress part wsdl input messagelabel in element type getmessagetypewiththisnam rule output creat wsdl output element r ml messageeventexpress this rule lazi rule mean call rule lazi rule output r ml messageeventexpress oclistypeof r ml messageeventexpress part wsdl output messagelabel out element type getmessagetypewiththisnam rule outfault creat wsdl outfault element r ml reactionrul this rule lazi rule mean call rule lazi rule outfault r ml reactionrul oclistypeof r ml reactionrul part wsdl outfault messagelabel out fault,7
235,235,P99-R2ML2XML.atl,"--@atlcompiler atl2006

--------------------------------------------------------------------------------
-- Transforms an R2ML metamodel to XML metamodel.
-- Created as part of M.Sc. theses at GOOD OLD AI Research Group
-- Author: Milan Milanovic (milan@milanovic.org), Marko Ribaric (marko.ribaric@gmail.com)
-- Works for R2ML v0.5-beta
--------------------------------------------------------------------------------
-- Version: 2.0 (General, Integrity & Derivation rule elements) - 6.11.2006.
-- Version: 2.1 (Reaction rule elements) - 7.3.2007
--
-- TODO: 
--	1) Add support for Production rules
--------------------------------------------------------------------------------

module R2ML2XML; -- Module Template
create OUT : XML from IN : R2ML;

-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- HELPER: isNegated
-- Checks if Atom is negated. If property is not defined then it is false.
-- CONTEXT:	R2ML!Atom
-- OUT:		Boolean
helper context R2ML!Atom def: isNegated() : Boolean = 
	if self.isNegated.oclIsUndefined() then
		false
	else self.isNegated
	endif;

-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'RuleBase'
-- Create XML Root element (r2ml:RuleBase) from the R2ML RuleBase element 
rule RuleBase {
	from i : R2ML!RuleBase (
		i.oclIsTypeOf(R2ML!RuleBase)
		)
	to o : XML!Root (
			name <- 'r2ml:RuleBase',
			children <- Sequence { ex, schema, r2ml, r2mlv, xsi, i.rules, i.vocabularies
								 }
		),
	ex : XML!Attribute (
			name <- 'xmlns:ex',
			value <- 'http://www.bookingservice.com/schema'
		),
	schema : XML!Attribute (
			name <- 'xsi:schemaLocation',
			value <- 'http://www.rewerse.net/I1/2006/R2ML http://oxygen.informatik.tu-cottbus.de/R2ML/0.4/R2ML.xsd'
		),
	r2ml : XML!Attribute (
			name <- 'xmlns:r2ml',
			value <- 'http://www.rewerse.net/I1/2006/R2ML'
		),
	r2mlv : XML!Attribute (
			name <- 'xmlns:r2mlv',
			value <- 'http://www.rewerse.net/I1/2006/R2MLV'
		),
	xsi : XML!Attribute (
			name <- 'xmlns:xsi',
			value <- 'http://www.w3.org/2001/XMLSchema-instance'
		)
}

-- Rule 'DerivationRuleSet'
-- Create XML element (r2ml:DerivationRuleSet) from the R2ML DerivationRuleSet element 
rule DerivationRuleSet {
	from i : R2ML!DerivationRuleSet (
			i.oclIsTypeOf(R2ML!DerivationRuleSet)
		)
	to o : XML!Element (
			name <- 'r2ml:DerivationRuleSet',
			children <- i.rules
		)
}

-- Rule 'IntegrityRuleSet'
-- Create XML element (r2ml:IntegrityRuleSet) from the R2ML IntegrityRuleSet element 
rule IntegrityRuleSet {
	from i : R2ML!IntegrityRuleSet (
			i.oclIsTypeOf(R2ML!IntegrityRuleSet)
		)
	to o : XML!Element (
			name <- 'r2ml:IntegrityRuleSet',
			children <- i.rules
		)
}

-- Rule 'ReactionRuleSet'
-- Create XML element (r2ml:ReactionRuleSet) from the R2ML ReactionRuleSet element 
rule ReactionRuleSet {
	from i : R2ML!ReactionRuleSet (
			i.oclIsTypeOf(R2ML!ReactionRuleSet)
		)
	to o : XML!Element (
			name <- 'r2ml:ReactionRuleSet',
			children <- Sequence { ruleSetID, i.rules }
		),
	ruleSetID : XML!Attribute (
			name <- 'r2ml:ruleSetID',
			value <- i.ruleSetID
		)
}

-- Rule 'ProductionRuleSet'
-- Create XML element (r2ml:ProductionRuleSet) from the R2ML ProductionRuleSet element 
rule ProductionRuleSet {
	from i : R2ML!ProductionRuleSet (
			i.oclIsTypeOf(R2ML!ProductionRuleSet)
		)
	to o : XML!Element (
			name <- 'r2ml:ProductionRuleSet',
			children <- i.rules
		)
}

-- Rule 'AlethicIntegrityRule'
-- Create XML element (r2ml:AlethicIntegrityRule) from the R2ML AlethicIntegrityRule element 
rule AlethicIntegrityRule { 
	from i : R2ML!AlethicIntegrityRule (
			i.oclIsTypeOf(R2ML!AlethicIntegrityRule)
		)
	to o : XML!Element (
			name <- 'r2ml:AlethicIntegrityRule',
			children <- Sequence { if not i.ruleID.oclIsUndefined() then
									thisModule.RuleId(i)
									else OclUndefined
									endif,
									constraint
								}
		),
	constraint : XML!Element (
			name <- 'r2ml:constraint',
			children <- Sequence { i.constraint }
		)
}

-- Rule 'RuleId'
-- Create XML attribute (r2ml:ruleID) from the R2ML Rule element 
lazy rule RuleId {
	from i : R2ML!Rule
	to o : XML!Attribute (
			name <- 'r2ml:ruleID',
			value <- i.ruleID
		)
}

-- Rule 'DeonticIntegrityRule'
-- Create XML element (r2ml:DeonticIntegrityRule) from the R2ML DeonticIntegrityRule element 
rule DeonticIntegrityRule { 
	from i : R2ML!DeonticIntegrityRule (
			i.oclIsTypeOf(R2ML!DeonticIntegrityRule)
		)
	to o : XML!Element (
			name <- 'r2ml:DeonticIntegrityRule',
			children <- Sequence { if not i.ruleID.oclIsUndefined() then
									thisModule.RuleId(i)
									else OclUndefined
									endif,
									constraint 
								 }
		),
	constraint : XML!Element (
			name <- 'r2ml:constraint',
			children <- Sequence { i.constraint }
		)
}

-- Rule 'UniversallyQuantifiedFormula'
-- Create XML element (r2ml:UniversallyQuantifiedFormula) from the R2ML UniversallyQuantifiedFormula element 
rule UniversallyQuantifiedFormula {
	from i : R2ML!UniversallyQuantifiedFormula (
			i.oclIsTypeOf(R2ML!UniversallyQuantifiedFormula)
		)
	to o : XML!Element (
			name <- 'r2ml:UniversallyQuantifiedFormula',
			children <- Sequence {
							i.variables->asSequence()->select(c | c.oclIsTypeOf(R2ML!ObjectVariable))->collect(e | thisModule.ObjectVariable(e)),
							i.variables->asSequence()->select(c | c.oclIsTypeOf(R2ML!DataVariable))->collect(e | thisModule.DataVariable(e)),
							i.formula
						}
		)
}

-- Rule 'ExistentiallyQuantifiedFormula'
-- Create XML element (r2ml:ExistentiallyQuantifiedFormula) from the R2ML ExistentiallyQuantifiedFormula element 
rule ExistentiallyQuantifiedFormula {
	from i : R2ML!ExistentiallyQuantifiedFormula (
			i.oclIsTypeOf(R2ML!ExistentiallyQuantifiedFormula)
		)
	to o : XML!Element (
			name <- 'r2ml:ExistentiallyQuantifiedFormula',
			children <- Sequence {
							i.variables->asSequence()->select(c | c.oclIsTypeOf(R2ML!ObjectVariable))->collect(e | thisModule.ObjectVariable(e)),
							i.variables->asSequence()->select(c | c.oclIsTypeOf(R2ML!DataVariable))->collect(e | thisModule.DataVariable(e)),
							i.formula
						}
		)
}

-- Lazy rule 'ClassRule'
-- Create XML attribute (r2ml:classID) from the R2ML Class element 
lazy rule ClassRule {
	from i : R2ML!Class 
	to o : XML!Attribute (
			name <- 'r2ml:classID',
			value <- i.name
		)
}

-- Lazy rule 'ObjectVariable'
-- Create XML element (r2ml:ObjectVariable) from the R2ML ObjectVariable element 
lazy rule ObjectVariable {
	from i : R2ML!ObjectVariable
	to o : XML!Element (
		name <- 'r2ml:ObjectVariable',
		children <- Sequence { attrName, if not i.classRef.oclIsUndefined() then
											thisModule.ClassRule(i.classRef)
										 else OclUndefined
										 endif
							 }
		),
	attrName : XML!Attribute (
			name <- 'r2ml:name',
			value <- i.name
		)
} 

-- Lazy rule 'DataVariable'
-- Create XML element (r2ml:DataVariable) from the R2ML DataVariable element 
lazy rule DataVariable {
	from i : R2ML!DataVariable
	to o : XML!Element (
		name <- 'r2ml:DataVariable',
		children <- Sequence { attrName, if not i.datatypeRef.oclIsUndefined() then
											thisModule.Datatype(i.datatypeRef)
										 else OclUndefined
										 endif,
										 if not i.typeCategory.oclIsUndefined() then
										 	thisModule.TypeCategory(i)
										 else OclUndefined
										 endif
							 }
		),
	attrName : XML!Attribute (
			name <- 'r2ml:name',
			value <- i.name
		)
}

-- Lazy rule 'GenericVariable'
-- Create XML element (r2ml:GenericVariable) from the R2ML GenericVariable element 
lazy rule GenericVariable {
	from i : R2ML!GenericVariable
	to o : XML!Element (
			name <- 'r2ml:GenericVariable',
			children <- Sequence { attrName, if not i.typeRef.oclIsUndefined() then
												thisModule.Datatype(i.typeRef)
										 	 else OclUndefined
										 	 endif 
								 }
		),
	attrName : XML!Attribute (
			name <- 'r2ml:name',
			value <- i.name
		)
}

-- Lazy rule 'Datatype'
-- Create XML attribute (r2ml:datatypeID) from the R2ML Datatype element 
lazy rule Datatype {
	from i : R2ML!Datatype
	to o : XML!Attribute (
			name <- 'r2ml:datatypeID',
			value <- i.name
		)
}

-- Rule 'Implication'
-- Create XML element (r2ml:Implication) from the R2ML Implication element 
rule Implication {
	from i : R2ML!Implication (
			i.oclIsTypeOf(R2ML!Implication)
		)
	to o : XML!Element (
			name <- 'r2ml:Implication',
			children <- Sequence { ant, con }
		),
		ant : XML!Element (
			name <- 'r2ml:antecedent',
			children <- i.antecedent
		),
		con : XML!Element (
			name <- 'r2ml:consequent',
			children <- i.consequent
		)
}

-- Rule 'Conjuction'
-- Create XML element (r2ml:Conjuction) from the R2ML Conjuction element 
rule Conjuction {
	from i : R2ML!Conjuction (
			i.oclIsTypeOf(R2ML!Conjuction)
		)
	to o : XML!Element (
			name <- 'r2ml:Conjunction',
			children <- i.formulas
		)
}

-- Rule 'Disjunction'
-- Create XML element (r2ml:Disjunction) from the R2ML Disjunction element 
rule Disjunction {
	from i : R2ML!Disjunction (
			i.oclIsTypeOf(R2ML!Disjunction)
		)
	to o : XML!Element (
			name <- 'r2ml:Disjunction',
			children <- i.formulas
		)
}

-- Rule 'NegationAsFailure'
-- Create XML element (r2ml:NegationAsFailure) from the R2ML NegationAsFailure element 
rule NegationAsFailure {
	from i : R2ML!NegationAsFailure (
			i.oclIsTypeOf(R2ML!NegationAsFailure)
		)
	to o : XML!Element (
			name <- 'r2ml:NegationAsFailure',
			children <- Sequence { i.formula }
		)
}

-- Rule 'StrongNegation'
-- Create XML element (r2ml:StrongNegation) from the R2ML StrongNegation element 
rule StrongNegation {
	from i : R2ML!StrongNegation (
			i.oclIsTypeOf(R2ML!StrongNegation)
		)
	to o : XML!Element (
			name <- 'r2ml:StrongNegation',
			children <- Sequence { i.formula }
		)
}

-- Rule 'EqualityAtom'
-- Create XML element (r2ml:EqualityAtom) from the R2ML EqualityAtom element 
rule EqualityAtom {
	from i : R2ML!EqualityAtom (
			i.oclIsTypeOf(R2ML!EqualityAtom)
		)
	to o : XML!Element (
			name <- 'r2ml:EqualityAtom',
			children <- Sequence { i.terms->select(c | c.oclIsTypeOf(R2ML!ObjectVariable))->collect(e | thisModule.ObjectVariable(e)),
								   i.terms->select(c | not c.oclIsTypeOf(R2ML!ObjectVariable))
								 }
		)
}

-- Rule 'InequalityAtom'
-- Create XML element (r2ml:InequalityAtom) from the R2ML InequalityAtom element 
rule InequalityAtom {
	from i : R2ML!InequalityAtom (
			i.oclIsTypeOf(R2ML!InequalityAtom)
		)
	to o : XML!Element (
			name <- 'r2ml:InequalityAtom',
			children <- Sequence { i.terms->select(c | c.oclIsTypeOf(R2ML!ObjectVariable))->collect(e | thisModule.ObjectVariable(e)),
								   i.terms->select(c | not c.oclIsTypeOf(R2ML!ObjectVariable))
								 }
		)
}

-- Rule 'DerivationRule'
-- Create XML element (r2ml:DerivationRule) from the R2ML DerivationRule element 
rule DerivationRule { 
	from i : R2ML!DerivationRule (
			i.oclIsTypeOf(R2ML!DerivationRule)
		)
	to o : XML!Element (
			name <- 'r2ml:DerivationRule',
			children <- Sequence { if not i.ruleID.oclIsUndefined() then
									thisModule.RuleId(i)
									else OclUndefined
									endif,
									conditions, 
									conclusions 
								 }
		),
		conditions : XML!Element (
				name <- 'r2ml:conditions',
				children <- i.conditions
			),
		conclusions : XML!Element (
				name <- 'r2ml:conclusion',
				children <- i.conclusions->asSequence()->collect(c | c.atoms)->flatten()->asSequence() -- collect LiteralConjuctions
			)
}

-- Rule 'AtomIsNegated'
-- Create XML attribute (r2ml:isNegated) from the R2ML Atom element 
lazy rule AtomIsNegated {
	from i : R2ML!Atom
	to o : XML!Attribute ( 
			name <- 'r2ml:isNegated',
			value <- 'true'
		)
}

-- Rule 'DataClassificationAtom'
-- Create XML element (r2ml:DataClassificationAtom) from the R2ML DataClassificationAtom element 
rule DataClassificationAtom {
	from i : R2ML!DataClassificationAtom (
			i.oclIsTypeOf(R2ML!DataClassificationAtom)
		)
	to o : XML!Element (
			name <- 'r2ml:DataClassificationAtom',
			children <- Sequence { if i.isNegated() then    	  -- for isNegated attribute
									 thisModule.AtomIsNegated(i)
								   else OclUndefined
								   endif,
								   thisModule.Datatype(i.type),      -- for classID attribute
								   thisModule.DataVariable(i.term)  -- for term 
								}
		)
}

-- Rule 'QFConjunction'
-- Create XML element (r2ml:qf.Conjuction) from the R2ML QFConjunction element 
rule QFConjunction {
	from i : R2ML!QFConjunction (
			i.oclIsTypeOf(R2ML!QFConjunction)
		)
	to o : XML!Element (
			name <- 'r2ml:qf.Conjuction',
			children <- i.formulas
		)
}

-- Rule 'QFDisjunction'
-- Create XML element (r2ml:qf.Disjunction) from the R2ML QFDisjunction element 
rule QFDisjunction {
	from i : R2ML!QFDisjunction (
			i.oclIsTypeOf(R2ML!QFDisjunction)
		)
	to o : XML!Element (
			name <- 'r2ml:qf.Disjunction',
			children <- i.formulas
		)
}

-- Rule 'QFNegationAsFailure'
-- Create XML element (r2ml:qf.NegationAsFailure) from the R2ML QFNegationAsFailure element 
rule QFNegationAsFailure {
	from i : R2ML!QFNegationAsFailure (
			i.oclIsTypeOf(R2ML!QFNegationAsFailure)
		)
	to o : XML!Element (
			name <- 'r2ml:qf.NegationAsFailure',
			children <- Sequence { i.formula }
		)
}

-- Rule 'QFStrongNegation'
-- Create XML element (r2ml:qf.StrongNegation) from the R2ML QFStrongNegation element 
rule QFStrongNegation {
	from i : R2ML!QFStrongNegation (
			i.oclIsTypeOf(R2ML!QFStrongNegation)
		)
	to o : XML!Element (
			name <- 'r2ml:qf.StrongNegation',
			children <- Sequence { i.formula }
		)
}

-- Rule 'DatatypePredicateAtom'
-- Create XML element (r2ml:DatatypePredicateAtom) from the R2ML DatatypePredicateAtom element 
rule DatatypePredicateAtom {
	from i : R2ML!DatatypePredicateAtom (
			i.oclIsTypeOf(R2ML!DatatypePredicateAtom)
		)
	to o : XML!Element (
			name <- 'r2ml:DatatypePredicateAtom',
			children <- Sequence { if i.isNegated() then    	  -- for isNegated attribute
									 thisModule.AtomIsNegated(i)
								   else OclUndefined
								   endif,
								   attr, 
								   dataArgs }
		),
		attr : XML!Attribute (
				name <- 'r2ml:datatypePredicateID',
				value <- i.predicate.name
			),
		dataArgs : XML!Element (
				name <- 'r2ml:dataArguments',
				children <- Sequence { i.dataArguments->asSequence()->select(c | c.oclIsTypeOf(R2ML!DataVariable))->collect(c | thisModule.DataVariable(c)),
									   i.dataArguments->asSequence()->select(c | not c.oclIsTypeOf(R2ML!DataVariable))
									 }
			)
}

-- Rule 'TypeCategory'
-- Create XML attribute (r2ml:typeCategory) for R2ML Term element 
lazy rule TypeCategory {
	from i : R2ML!Term
	to o : XML!Attribute (
		name <- 'r2ml:typeCategory',
		value <- if i.typeCategory = #individual then
					 'individual'
				 else if i.typeCategory = #set then
						  'set'
					  else if i.typeCategory = #orderedSet then
								 'order'
						   else if i.typeCategory = #bag then
									'bag'
							    else if i.typeCategory = #sequence then
										  'sequence'
									 else OclUndefined
								     endif
								endif
						   endif
					  endif
				 endif			
		)
}
			
-- Rule 'DataOperationTermArgs'
-- Create XML element (r2ml:arguments) for R2ML DataOperationTerm element 
lazy rule DataOperationTermArgs {
	from i : R2ML!DataOperationTerm
	to o : XML!Element (
			name <- 'r2ml:arguments',
			children <- Sequence { i.arguments->asSequence()->select(c | c.oclIsTypeOf(R2ML!ObjectVariable))->collect(c | thisModule.ObjectVariable(c)),
								   i.arguments->asSequence()->select(c | c.oclIsTypeOf(R2ML!DataVariable))->collect(c | thisModule.DataVariable(c)),
								   i.arguments->asSequence()->select(c | not c.oclIsTypeOf(R2ML!ObjectVariable) and not c.oclIsTypeOf(R2ML!DataVariable))
								 }
		)
}

-- Rule 'TypedLiteral'
-- Create XML element (r2ml:TypedLiteral) from the R2ML TypedLiteral element 
rule TypedLiteral {
	from i : R2ML!TypedLiteral (
			i.oclIsTypeOf(R2ML!TypedLiteral)
		)
	to o : XML!Element (
			name <- 'r2ml:TypedLiteral',
			children <- Sequence { type, value }
		),
	type : XML!Attribute (
			name <- 'r2ml:datatypeID',
			value <- i.type.name
		),
	value : XML!Attribute (
			name <- 'r2ml:lexicalValue',
			value <- i.lexicalValue
		)
}

-- Rule 'PlainLiteral'
-- Create XML element (r2ml:PlainLiteral) from the R2ML PlainLiteral element
rule PlainLiteral {
	from i : R2ML!PlainLiteral (
			i.oclIsTypeOf(R2ML!PlainLiteral)
		)
	to o : XML!Element (
			name <- Sequence { if not i.languageTag.oclIsUndefined() then 
								thisModule.PlainLiteralLanguageTag(i)
							   else OclUndefined
							   endif, 
							   value
							}
		),
	value : XML!Attribute (
			name <- 'r2ml:lexicalValue',
			value <- i.lexicalValue
		)
}
		
-- Rule 'PlainLiteralLanguageTag'
-- Create XML attribute (r2ml:languageTag) for R2ML PlainLiteral element
lazy rule PlainLiteralLanguageTag {
	from i : R2ML!PlainLiteral
	to o : XML!Attribute (
			name <- 'r2ml:languageTag',
			value <- i.languageTag
		)
}

-- Rule 'AttributeFunctionTerm'
-- Create XML element (r2ml:AttributeFunctionTerm) from the R2ML AttributeFunctionTerm element
rule AttributeFunctionTerm {
	from i : R2ML!AttributeFunctionTerm (
			i.oclIsTypeOf(R2ML!AttributeFunctionTerm)
		)
	to o : XML!Element (
			name <- 'r2ml:AttributeFunctionTerm',
			children <- Sequence { attr,  contextArg, 
								   if not i.typeCategory.oclIsUndefined() then
										thisModule.TypeCategory(i)
								   else OclUndefined
								   endif 
								  }
		),
	attr : XML!Attribute (
			name <- 'r2ml:attributeID',
			value <- i.attribute.name
		),
	contextArg : XML!Element (
			name <- 'r2ml:contextArgument',
			children <- Sequence { if i.contextArgument.oclIsTypeOf(R2ML!ObjectVariable) then 
									thisModule.ObjectVariable(i.contextArgument)
								   else i.contextArgument
								   endif
								 }
		)
}

-- Rule 'AssociationAtom'
-- Create XML element (r2ml:AssociationAtom) from the R2ML AssociationAtom element
rule AssociationAtom {
	from i : R2ML!AssociationAtom (
			i.oclIsTypeOf(R2ML!AssociationAtom)
		)
	to o : XML!Element (
			name <- 'r2ml:AssociationAtom',
			children <- Sequence { if i.isNegated() then    	  -- for isNegated attribute
										thisModule.AtomIsNegated(i)
								   else OclUndefined
								   endif,
								   assocPred,
								   objArgs,
								   if i.dataArguments->size() > 0 then
								   		thisModule.AssociationAtomDataArgs(i)
								   else OclUndefined
								   endif
								   }
		),
	assocPred : XML!Attribute (
			name <- 'r2ml:associationPredicateID',
			value <- i.associationPredicate.name
		),
	objArgs : XML!Element (
			name <- 'r2ml:objectArguments',
			children <- Sequence { i.objectArguments->asSequence()->select(c | c.oclIsTypeOf(R2ML!ObjectVariable))->collect(c | thisModule.ObjectVariable(c)),
								   i.objectArguments->asSequence()->select(c | not c.oclIsTypeOf(R2ML!ObjectVariable))
								 }
		)
}

-- Rule 'AssociationAtomDataArgs'
-- Create XML element (r2ml:dataArguments) for R2ML AssociationAtom element
lazy rule AssociationAtomDataArgs {
	from i : R2ML!AssociationAtom
	to o : XML!Element (
			name <- 'r2ml:dataArguments',
			children <- Sequence { i.dataArguments->asSequence()->select(c | c.oclIsTypeOf(R2ML!DataVariable))->collect(c | thisModule.DataVariable(c)),
								   i.dataArguments->asSequence()->select(c | not c.oclIsTypeOf(R2ML!DataVariable))
								 }
		)
}

-- Rule 'ReferencePropertyFunctionTerm'
-- Create XML element (r2ml:ReferencePropertyFunctionTerm) from the R2ML ReferencePropertyFunctionTerm element
rule ReferencePropertyFunctionTerm {
	from i : R2ML!ReferencePropertyFunctionTerm (
			i.oclIsTypeOf(R2ML!ReferencePropertyFunctionTerm)
		)
	to o : XML!Element (
			name <- 'r2ml:ReferencePropertyFunctionTerm',
			children <- Sequence { refProp, contextArg, 
								   if not i.typeCategory.oclIsUndefined() then
									thisModule.TypeCategory(i)
								   else OclUndefined
								   endif 
								  }
		),
	refProp : XML!Attribute (
			name <- 'r2ml:referencePropertyID',
			value <- i.referencePropertyRef.name
		),
	contextArg : XML!Element (
			name <- 'r2ml:contextArgument',
			children <- Sequence { if i.contextArgument.oclIsTypeOf(R2ML!ObjectVariable) then
									thisModule.ObjectVariable(i.contextArgument)
								   else i.contextArgument
								   endif
								 }
		)
}

-- Rule 'AttributionAtom'
-- Create XML element (r2ml:AttributionAtom) from the R2ML AttributionAtom element
rule AttributionAtom {
	from i : R2ML!AttributionAtom (
			i.oclIsTypeOf(R2ML!AttributionAtom)
		)
	to o : XML!Element (
			name <- 'r2ml:AttributionAtom',
			children <- Sequence { attr, 
   							   	   if i.isNegated() then    	  -- for isNegated attribute
								      thisModule.AtomIsNegated(i)
								   else OclUndefined
								   endif,
								   subject,
								   dataValue
								 }
		),
	attr : XML!Attribute (
			name <- 'r2ml:attributeID',
			value <- i.attribute.name
		),
	subject : XML!Element (
			name <- 'r2ml:subject',
			children <- Sequence { if i.subject.oclIsTypeOf(R2ML!ObjectVariable) then
										thisModule.ObjectVariable(i.subject)
								   else i.subject
								   endif
								 }
		),
	dataValue : XML!Element (
			name <- 'r2ml:dataValue',
			children <- Sequence { if i.dataValue.oclIsTypeOf(R2ML!DataVariable) then
										thisModule.DataVariable(i.dataValue)
								   else i.dataValue
					 			   endif
								 }
		)
}

-- Rule 'ReferencePropertyAtom'
-- Create XML element (r2ml:ReferencePropertyAtom) from the R2ML ReferencePropertyAtom element
rule ReferencePropertyAtom {
	from i : R2ML!ReferencePropertyAtom (
			i.oclIsTypeOf(R2ML!ReferencePropertyAtom)
		)
	to o : XML!Element (
			name <- 'r2ml:ReferencePropertyAtom',
			children <- Sequence { if i.isNegated() then    	  -- for isNegated attribute
								   	thisModule.AtomIsNegated(i)
								   else OclUndefined
								   endif,
								   refProp,
								   subject,
								   object
								  }
		),
	refProp : XML!Attribute (
			name <- 'r2ml:referencePropertyID',
			value <- i.referenceProperty.name
		),
	subject : XML!Element (
			name <- 'r2ml:subject',
			children <- Sequence { if i.subject.oclIsTypeOf(R2ML!ObjectVariable) then
									thisModule.ObjectVariable(i.subject)
								   else i.subject
								   endif
								}
		),
	object : XML!Element (
			name <- 'r2ml:object',
			children <- Sequence { if i.object.oclIsTypeOf(R2ML!ObjectVariable) then
									thisModule.ObjectVariable(i.object)
								   else i.object
								   endif
								}
		)
}

-- Rule 'GenericAtom'
-- Create XML element (r2ml:GenericAtom) from the R2ML GenericAtom element
rule GenericAtom {
	from i : R2ML!GenericAtom (
			i.oclIsTypeOf(R2ML!GenericAtom)
		)
	to o : XML!Element (
			name <- 'r2ml:GenericAtom',
			children <- Sequence { predicate, args }
		),
	predicate : XML!Attribute (
			name <- 'r2ml:predicateID',
			value <- i.predicate.name
		),
	args : XML!Element (
			name <- 'r2ml:arguments',
			children <- Sequence { i.arguments->asSequence()->select(c | c.oclIsTypeOf(R2ML!GenericVariable))->collect(c | thisModule.GenericVariable(c)),
								   i.arguments->asSequence()->select(c | c.oclIsTypeOf(R2ML!ObjectVariable))->collect(c | thisModule.ObjectVariable(c)),
								   i.arguments->asSequence()->select(c | c.oclIsTypeOf(R2ML!DataVariable))->collect(c | thisModule.DataVariable(c)),
								   i.arguments->asSequence()->select(c | not c.oclIsKindOf(R2ML!Variable))
								 }
		)
}

-- Rule 'PredicateType'
-- Create XML attribute (r2ml:predicateType) for R2ML GenericAtom element
lazy rule PredicateType {
	from i : R2ML!GenericPredicate
	to o : XML!Attribute (
			name <- 'r2ml:predicateType',
			value <- if i.predicateTypeID = #ObjectClassificationPredicate then
						'ObjectClassificationPredicate'
						else if i.predicateTypeID = #AttributionPredicate then
							  'AttributionPredicate'
							 else if i.predicateTypeID = #AssociationPredicate then
								   'AssociationPredicate'
								  else if i.predicateTypeID = #ReferencePropertyPredicate then
									    'ReferencePropertyPredicate'
									   else if i.predicateTypeID = #EqualityPredicate then
										     'EqualityPredicate'
										    else if i.predicateTypeID = #InequalityPredicate then
											      'InequalityPredicate'
											     else if i.predicateTypeID = #DatatypePredicate then
												       'DatatypePredicate'
												      else if i.predicateTypeID = #DataClassificationPredicate then
														    'DataClassificationPredicate'
													       else OclUndefined
													       endif
												      endif
												 endif
											endif 
										endif
								   endif
							 endif 
						endif
		)
}

-- Rule 'GenericFunctionTerm'
-- Create XML element (r2ml:GenericFunctionTerm) from the R2ML GenericFunctionTerm element
rule GenericFunctionTerm {
	from i : R2ML!GenericFunctionTerm (
			i.oclIsTypeOf(R2ML!GenericFunctionTerm)
		)
	to o : XML!Element (
			name <- 'r2ml:GenericFunctionTerm',
			children <- Sequence { attr, args }
		),
	attr : XML!Attribute (
			name <- 'r2ml:genericFunctionID',
			value <- i.functor.name
		),
	args : XML!Element ( 
			name <- 'r2ml:arguments',
			children <- Sequence { i.arguments->asSequence()->select(c | c.oclIsTypeOf(R2ML!GenericVariable))->collect(c | thisModule.GenericVariable(c)),
								   i.arguments->asSequence()->select(c | not c.oclIsTypeOf(R2ML!GenericVariable)),
								   if not i.typeCategory.oclIsUndefined() then
									thisModule.TypeCategory(i)
								   else OclUndefined
								   endif 
								 }
		)
}

-- Rule 'DatatypeFunctionTerm'
-- Create XML element (r2ml:DatatypeFunctionTerm) from the R2ML DatatypeFunctionTerm element
rule DatatypeFunctionTerm {
	from i : R2ML!DatatypeFunctionTerm (
			i.oclIsTypeOf(R2ML!DatatypeFunctionTerm)
		)
	to o : XML!Element (
			name <- 'r2ml:DatatypeFunctionTerm',
			children <- Sequence { attr, args }
		),
	attr : XML!Attribute (
			name <- 'datatypeFunctionID',
			value <- i.function.name
		),
	args : XML!Element (
			name <- 'r2ml:dataArguments',
			children <- Sequence { i.dataArguments->asSequence()->select(c | c.oclIsTypeOf(R2ML!DataVariable))->collect(c | thisModule.DataVariable(c)),
								   i.dataArguments->asSequence()->select(c | not c.oclIsTypeOf(R2ML!DataVariable)),
								   if not i.typeCategory.oclIsUndefined() then
									thisModule.TypeCategory(i)
								   else OclUndefined
								   endif 
								 }						
		)
}

-- Rule 'ObjectName'
-- Create XML element (r2ml:ObjectName) from the R2ML ObjectName element
rule ObjectName {
	from i : R2ML!ObjectName (
			i.oclIsTypeOf(R2ML!ObjectName)
		)
	to o : XML!Element (
			name <- 'r2ml:ObjectName',
			children <- Sequence { attr, if not i.classRef.oclIsUndefined() then 
											thisModule.ClassRule(i.classRef)
										 else OclUndefined
										 endif,
										 if not i.typeCategory.oclIsUndefined() then
											thisModule.TypeCategory(i)
								  		 else OclUndefined
								   		 endif
								 }
		),
	attr : XML!Attribute (
			name <- 'r2ml:objectID',
			value <- i.name
		)
}

-- Rule 'ObjectDescriptionAtom'
-- Create XML element (r2ml:ObjectDescriptionAtom) from the R2ML ObjectDescriptionAtom element
rule ObjectDescriptionAtom {
	from i : R2ML!ObjectDescriptionAtom (
			i.oclIsTypeOf(R2ML!ObjectDescriptionAtom)
		)
	to o : XML!Element (
			name <- 'r2ml:ObjectDescriptionAtom',
			children <- Sequence { class, if not i.baseType.oclIsUndefined then 
											thisModule.ClassRule(i.baseType)
										  else OclUndefined 
										  endif,
								   subject,
								   i.slots,
								   objects
			}
		),
	class : XML!Attribute (
			name <- 'r2ml:classID',
			value <- i.type.name
		),
	subject : XML!Element (
			name <- 'r2ml:subject',
			children <- Sequence { if i.subject.oclIsTypeOf(R2ML!ObjectVariable) then 
									thisModule.ObjectVariable(i.subject)
								   else i.subject
								   endif
								 }
		),
	objects : XML!Element (
			name <- 'r2ml:objects',
			children <- i.objects
		)
}

-- Rule 'ObjectSlot'
-- Create XML element (r2ml:ObjectSlot) from the R2ML ObjectSlot element
rule ObjectSlot {
	from i : R2ML!ObjectSlot (
			i.oclIsTypeOf(R2ML!ObjectSlot)
		)
	to o : XML!Element (
			name <- 'r2ml:ObjectSlot',
			children <- Sequence { attr, object }
		),
	attr : XML!Attribute (
			name <- 'r2ml:referencePropertyID',
			value <- i.referenceProperty.name
		),
	object : XML!Element (
			name <- 'r2ml:object',
			children <- Sequence { if i.object.oclIsTypeOf(R2ML!ObjectVariable) then 
									thisModule.ObjectVariable(i.object)
								   else i.object
								   endif
								 }
		)
}

-- Rule 'DataSlot'
-- Create XML element (r2ml:DataSlot) from the R2ML DataSlot element
rule DataSlot {
	from i : R2ML!DataSlot (
			i.oclIsTypeOf(R2ML!DataSlot)
		)
	to o : XML!Element (
			name <- 'r2ml:DataSlot',
			children <- Sequence { attr, value }
		),
	attr : XML!Attribute (
			name <- 'r2ml:attributeID',
			value <- i.attribute.name
		),
	value : XML!Element (
			name <- 'r2ml:value',
			children <- Sequence { if i.value.oclIsTypeOf(R2ML!DataVariable) then 
									thisModule.DataVariable(i.value)
								   else i.value
								   endif
								 }
		)
}

-- Rule 'AtLeastQuantifiedFormula'
-- Create XML element (r2ml:AtLeastQuantifiedFormula) from the R2ML AtLeastQuantifiedFormula element 
rule AtLeastQuantifiedFormula {
	from i : R2ML!AtLeastQuantifiedFormula (
			i.oclIsTypeOf(R2ML!AtLeastQuantifiedFormula)
		)
	to o : XML!Element (
			name <- 'r2ml:AtLeastQuantifiedFormula',
			children <- Sequence {
							attr,
							i.variables->asSequence()->select(c | c.oclIsTypeOf(R2ML!ObjectVariable))->collect(e | thisModule.ObjectVariable(e)),
							i.variables->asSequence()->select(c | c.oclIsTypeOf(R2ML!DataVariable))->collect(e | thisModule.DataVariable(e)),
							i.formula
						}
  		  ),
		attr : XML!Attribute (
			name <- 'r2ml:minCardinality',
			value <- i.minCardinality.toString()
		)
}

-- Rule 'AtMostQuantifiedFormula'
-- Create XML element (r2ml:AtMostQuantifiedFormula) from the R2ML AtMostQuantifiedFormula element 
rule AtMostQuantifiedFormula {
	from i : R2ML!AtMostQuantifiedFormula (
			i.oclIsTypeOf(R2ML!AtMostQuantifiedFormula)
		)
	to o : XML!Element (
			name <- 'r2ml:AtMostQuantifiedFormula',
			children <- Sequence {
							attr,
							i.variables->asSequence()->select(c | c.oclIsTypeOf(R2ML!ObjectVariable))->collect(e | thisModule.ObjectVariable(e)),
							i.variables->asSequence()->select(c | c.oclIsTypeOf(R2ML!DataVariable))->collect(e | thisModule.DataVariable(e)),
							i.formula
						}
  		  ),
		attr : XML!Attribute (
			name <- 'r2ml:maxCardinality',
			value <- i.maxCardinality.toString()
		)
}

-- Rule 'AtLeastAndAtMostQuantifiedFormula'
-- Create XML element (r2ml:AtLeastAndAtMostQuantifiedFormula) from the R2ML AtLeastAndAtMostQuantifiedFormula element.
rule AtLeastAndAtMostQuantifiedFormula {
	from i : R2ML!AtLeastAndAtMostQuantifiedFormula (
			i.oclIsTypeOf(R2ML!AtLeastAndAtMostQuantifiedFormula)
		)
	to o : XML!Element (
			name <- 'r2ml:AtLeastAndAtMostQuantifiedFormula',
			children <- Sequence {
							attrMax, attrMin,
							i.variables->asSequence()->select(c | c.oclIsTypeOf(R2ML!ObjectVariable))->collect(e | thisModule.ObjectVariable(e)),
							i.variables->asSequence()->select(c | c.oclIsTypeOf(R2ML!DataVariable))->collect(e | thisModule.DataVariable(e)),
							i.formula
						}
  		  ),
		attrMax : XML!Attribute (
			name <- 'r2ml:maxCardinality',
			value <- i.maxCardinality.toString()
		),
		attrMin : XML!Attribute (
			name <- 'r2ml:minCardinality',
			value <- i.minCardinality.toString()
		)
}

-- Rule 'ObjectOperationTerm'
-- Create XML element (r2ml:ObjectOperationTerm) from the R2ML ObjectOperationTerm element.
rule ObjectOperationTerm {
	from i : R2ML!ObjectOperationTerm (
			i.oclIsTypeOf(R2ML!ObjectOperationTerm)
		)
	to o : XML!Element (
			name <- 'r2ml:ObjectOperationTerm',
			children <- Sequence { operation, contextArg, 
					
													-- TODO: ObjectOperationTermArgs ?
													if i.arguments->size() > 0 then
															i.arguments
														  else OclUndefined
														  endif
								  }
		),
	operation : XML!Attribute (
			name <- 'r2ml:operationID',
			value <- i.operation.name
		),
	contextArg : XML!Element (
			name <- 'r2ml:contextArgument',
			children <- Sequence { if i.contextArgument.oclIsTypeOf(R2ML!ObjectVariable) then
									thisModule.ObjectVariable(i.contextArgument)
								   else i.contextArgument
								   endif
								 }
		)
}


-- Rule 'DataOperationTerm'
-- Create XML element (r2ml:DataOperationTerm) from the R2ML DataOperationTerm element 
rule DataOperationTerm {
	from i : R2ML!DataOperationTerm (
			i.oclIsTypeOf(R2ML!DataOperationTerm)
		)
	to o : XML!Element (
			name <- 'r2ml:DataOperationTerm',
			children <- Sequence { attr, if i.arguments->size() > 0 then
											thisModule.DataOperationTermArgs(i)
											else OclUndefined
											endif, 
											contArg,
										 if not i.typeCategory.oclIsUndefined() then
										 	thisModule.TypeCategory(i)
										 else OclUndefined
										 endif
								 }
		),
	attr : XML!Attribute (
			name <- 'r2ml:operationID',
			value <- i.dataOperationRef.name
		),
	contArg : XML!Element (
			name <- 'r2ml:contextArgument',
			children <- Sequence { if i.contextArgument.oclIsTypeOf(R2ML!ObjectVariable) then
									thisModule.ObjectVariable(i.contextArgument)
								   else i.contextArgument	
								   endif
								 }
		)
}


-------------------------------------------------------------------------------
-- VOCABULARY -------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'Vocabulary'
-- Create XML element (r2mlv:Vocabulary) from the R2ML PlainLiteral element
rule Vocabulary {
	from i : R2ML!Vocabulary (
			i.oclIsTypeOf(R2ML!Vocabulary)
		)
	to o : XML!Element (
			name <- 'r2mlv:Vocabulary',
			children <- Sequence { i.entries }
		)
}

-- Rule 'ClassR'
-- Create XML element (r2mlv:Class) from the R2ML Class element
rule ClassR {
	from i : R2ML!Class (
			i.oclIsTypeOf(R2ML!Class)
		)
	to o : XML!Element (
			name <- 'r2mlv:Class',
			children <- Sequence { cID, i.attributes, i.referencePropertyRef
		 						 }
		),
		cID : XML!Attribute (
			name <- 'r2mlv:ID',
			value <- i.name
		)		
}

-- Rule 'MessageType'
-- Create XML element (r2mlv:MessageType) from the R2ML MessageType element
rule MessageType {
	from i : R2ML!MessageType (
			i.oclIsTypeOf(R2ML!MessageType)
		)
	to o : XML!Element (
			name <- 'r2mlv:MessageType',
			children <- Sequence { cID, i.attributes, i.referencePropertyRef }
		),
		cID : XML!Attribute (
			name <- 'r2mlv:ID',
			value <- i.name
		)		
}

-- Rule 'FaultMessageType'
-- Create XML element (r2mlv:FaultMessageType) from the R2ML FaultMessageType element
rule FaultMessageType {
	from i : R2ML!FaultMessageType (
			i.oclIsTypeOf(R2ML!FaultMessageType)
		)
	to o : XML!Element (
			name <- 'r2mlv:FaultMessageType',
			children <- Sequence { cID, i.attributes }
		),
		cID : XML!Attribute (
			name <- 'r2mlv:ID',
			value <- i.name
		)		
}
 
-- Rule 'AssociationPredicate'
-- Create XML element (r2mlv:AssociationPredicate) from the R2ML AssociationPredicate element
rule AssociationPredicate {
	from i : R2ML!AssociationPredicate (
			i.oclIsTypeOf(R2ML!AssociationPredicate)
		)
	to o : XML!Element (
			name <- 'r2mlv:AssociationPredicate',
			children <- Sequence { cID , args }
		),
		cID : XML!Attribute (
			name <- 'r2mlv:associationPredicateID',
			value <- i.name
		),
		args : XML!Element (
			name <- 'r2mlv:argumentsType',
			children <- Sequence { 
				i.arguments->asSequence()->select(c | c.oclIsTypeOf(R2ML!Class))->collect(e | thisModule.ClassAssoc(e)),
				i.arguments->asSequence()->select(c | c.oclIsTypeOf(R2ML!MessageType))->collect(e | thisModule.MessageTypeAssoc(e))
								 }
		)
}

lazy rule ClassAssoc {
	from i : R2ML!Class (
			i.oclIsTypeOf(R2ML!Class)
		)
	to o : XML!Element (
			name <- 'r2mlv:Class',
			children <- Sequence { cID }
		),
		cID : XML!Attribute (
			name <- 'r2mlv:ID',
			value <- i.name
		)		
}

lazy rule MessageTypeAssoc {
	from i : R2ML!MessageType (
			i.oclIsTypeOf(R2ML!MessageType)
		)
	to o : XML!Element (
			name <- 'r2mlv:MessageType',
			children <- Sequence { cID }
		),
		cID : XML!Attribute (
			name <- 'r2mlv:ID',
			value <- i.name
		)		
}


-- Rule 'AttributeVoc'
-- Create XML element (Attribute) from the R2ML Attribute element
rule AttributeVoc {
	from i : R2ML!Attribute (
			i.oclIsTypeOf(R2ML!Attribute)
		)
	to o : XML!Element (
			name <- 'r2mlv:Attribute',
			children <- Sequence { cID , range }
		),
		cID : XML!Attribute (
			name <- 'r2mlv:ID',
			value <- i.name
		),
		range : XML!Element (
			name <- 'r2mlv:range',
			children <- Sequence { i.range->asSequence()->select(c | c.oclIsTypeOf(R2ML!Datatype))->collect(e | thisModule.DatatypeVoc(e)) }
		)
} 

-- Rule 'ReferencePropertyVoc'
-- Create XML element (ReferenceProperty) from the R2ML ReferenceProperty element
rule ReferencePropertyVoc {
	from i : R2ML!ReferenceProperty (
			i.oclIsTypeOf(R2ML!ReferenceProperty)
		)
	to o : XML!Element (
			name <- 'r2mlv:ReferenceProperty',
			children <- Sequence { cID , range }
		),
		cID : XML!Attribute (
			name <- 'r2mlv:ID',
			value <- i.name
		),
		range : XML!Element (
			name <- 'r2mlv:range',
			children <- Sequence { i.range->asSequence()->select(c | c.oclIsTypeOf(R2ML!Class))->collect(e | thisModule.ClassAssoc(e)) }
		)
} 

-- Lazy rule 'DatatypeVoc'
-- Create XML attribute (r2ml:datatypeID) from the R2ML Datatype element 
lazy rule DatatypeVoc {
	from i : R2ML!Datatype
	to o : XML!Element (
			name <- 'r2mlv:Datatype',
			children <- Sequence {dtID }
		),
		dtID : XML!Attribute (
			name <- 'r2mlv:ID',
			value <- i.name
		)
}


-------------------------------------------------------------------------------
-- REACTION RULES -------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'ReactionRule'
-- Create XML element (r2ml:ReactionRule) from the R2ML ReactionRule element 
rule ReactionRule { 
	from i : R2ML!ReactionRule (
			i.oclIsTypeOf(R2ML!ReactionRule)
		)
	to o : XML!Element (
			name <- 'r2ml:ReactionRule',
			children <- Sequence { if not i.ruleID.oclIsUndefined() then
										thisModule.RuleId(i)
									else OclUndefined
									endif,
									triggeringEvent,
									conditions, 
									producedAction,
									 if not i.postconditon.oclIsUndefined() then
										postconditon
									else OclUndefined
									endif,
									groupID
								 }
		),
		triggeringEvent : XML!Element (
				name <- 'r2ml:triggeringEvent',
				children <- thisModule.MessageEventExpression(i.triggeringEvent)
			),
		conditions : XML!Element (
				name <- 'r2ml:conditions',
				children <- i.conditions
			),
		producedAction : XML!Element (
				name <- 'r2ml:producedAction',
				children <- thisModule.MessageEventExpression(i.producedAction)
			),
		postconditon : XML!Element (
				name <- 'r2ml:postconditon',
				children <- i.postconditon
			),
		groupID : XML!Attribute (
			name <- 'r2ml:groupID',
			value <- i.groupID
		)			
}

-- Rule 'MessageEventExpression'
-- Create XML element (r2ml:MessageEventExpression) from the R2ML MessageEventExpression element.
lazy rule MessageEventExpression {
	from i : R2ML!MessageEventExpression (
			i.oclIsTypeOf(R2ML!MessageEventExpression)
		)
	to o : XML!Element (
			name <- 'r2ml:MessageEventExpression',
			children <- Sequence {  if not i.type.oclIsUndefined() then
										type
										--thisModule.MeeType(i)	
									else OclUndefined
									endif,
									if not i.startDateTime.oclIsUndefined() then
										startTime
										--thisModule.MeeStartTime(i)
									else OclUndefined
									endif,
									if not i.duration.oclIsUndefined() then
										duration
										--thisModule.MeeDuration(i)
									else OclUndefined
									endif,
									if not i.sender.oclIsUndefined() then
										sender
										--thisModule.MeeSender(i)
									else OclUndefined
									endif,
									if not i.objectVariable.oclIsUndefined() then
										thisModule.ObjectVariable(i.objectVariable)
									else OclUndefined
									endif,
									if not i.slot.oclIsUndefined() then
										i.slot
									else OclUndefined
									endif									
						}
  		  ),
		type : XML!Attribute (
			name <- 'r2ml:eventType',
			value <- i.type.name
		),
		startTime : XML!Attribute (
			name <- 'r2ml:startTime',
			value <- i.startDateTime
		),
		duration : XML!Attribute (
			name <- 'r2ml:duration',
			value <- i.duration
		),
		sender : XML!Attribute (
			name <- 'r2ml:sender',
			value <- i.sender
		)
}

---- Rule 'MeeType'
---- Create XML attribute (r2ml:eventType) for R2ML MessageEventExpression element
--lazy rule MeeType {
--	from i : R2ML!MessageEventExpression
--	to o : XML!Attribute (
--			name <- 'r2ml:eventType',
--			value <- i.type.name
--		)
--}
--
---- Rule 'MeeStartTime'
---- Create XML attribute (r2ml:startTime) for R2ML MessageEventExpression element
--lazy rule MeeStartTime {
--	from i : R2ML!MessageEventExpression
--	to o : XML!Attribute (
--			name <- 'r2ml:startTime',
--			value <- i.startDateTime
--		)
--}
--
---- Rule 'MeeDuration'
---- Create XML attribute (r2ml:duration) for R2ML MessageEventExpression element
--lazy rule MeeDuration {
--	from i : R2ML!MessageEventExpression
--	to o : XML!Attribute (
--			name <- 'r2ml:duration',
--			value <- i.duration
--		)
--}
--
---- Rule 'MeeSender'
---- Create XML attribute (r2ml:sender) for R2ML MessageEventExpression element
--lazy rule MeeSender {
--	from i : R2ML!MessageEventExpression
--	to o : XML!Attribute (
--			name <- 'r2ml:sender',
--			value <- i.sender
--		)
--}

-- Rule 'ObjectClassificationAtom'
-- Create XML element (r2ml:ObjectClassificationAtom) from the R2ML ObjectClassificationAtom element 
rule ObjectClassificationAtom {
	from i : R2ML!ObjectClassificationAtom (
			i.oclIsTypeOf(R2ML!ObjectClassificationAtom)
		)
	to o : XML!Element (
			name <- 'r2ml:ObjectClassificationAtom',
			children <- Sequence { if i.isNegated() then    	  -- for isNegated attribute
									 thisModule.AtomIsNegated(i)
								   else OclUndefined
								   endif,
								   if i.type.oclIsTypeOf(R2ML!Class) then
								  	 	thisModule.ClassRule(i.type)
								   else if 	i.type.oclIsTypeOf(R2ML!MessageType)then
											mtOca
								   		else OclUndefined
								   		endif
								   endif,
								   thisModule.ObjectVariable(i.term)  -- for term 
								}
		),
		mtOca : XML!Attribute (
			name <- 'r2ml:classID',
			value <- if i.type.oclIsTypeOf(R2ML!MessageType)then
				   		i.type.name
			   		else OclUndefined
			   		endif
		)
}

",atlcompil atl transform r ml metamodel xml metamodel creat part m sc these good old ai research group author milan milanov milan milanov org marko ribar marko ribar gmail com work r ml v beta version general integr deriv rule element version reaction rule element todo add support product rule modul r ml xml modul templat creat out xml in r ml helper helper isneg check atom negat if properti defin fals context r ml atom out boolean helper context r ml atom def isneg boolean self isneg oclisundefin fals els self isneg endif rule rule rulebas creat xml root element r ml rulebas r ml rulebas element rule rulebas r ml rulebas oclistypeof r ml rulebas xml root name r ml rulebas children sequenc ex schema r ml r mlv xsi rule vocabulari ex xml attribut name xmlns ex valu http www bookingservic com schema schema xml attribut name xsi schemaloc valu http www rewers net i r ml http oxygen informatik tu cottbus de r ml r ml xsd r ml xml attribut name xmlns r ml valu http www rewers net i r ml r mlv xml attribut name xmlns r mlv valu http www rewers net i r mlv xsi xml attribut name xmlns xsi valu http www w org xmlschema instanc rule derivationruleset creat xml element r ml derivationruleset r ml derivationruleset element rule derivationruleset r ml derivationruleset oclistypeof r ml derivationruleset xml element name r ml derivationruleset children rule rule integrityruleset creat xml element r ml integrityruleset r ml integrityruleset element rule integrityruleset r ml integrityruleset oclistypeof r ml integrityruleset xml element name r ml integrityruleset children rule rule reactionruleset creat xml element r ml reactionruleset r ml reactionruleset element rule reactionruleset r ml reactionruleset oclistypeof r ml reactionruleset xml element name r ml reactionruleset children sequenc rulesetid rule rulesetid xml attribut name r ml rulesetid valu rulesetid rule productionruleset creat xml element r ml productionruleset r ml productionruleset element rule productionruleset r ml productionruleset oclistypeof r ml productionruleset xml element name r ml productionruleset children rule rule alethicintegrityrul creat xml element r ml alethicintegrityrul r ml alethicintegrityrul element rule alethicintegrityrul r ml alethicintegrityrul oclistypeof r ml alethicintegrityrul xml element name r ml alethicintegrityrul children sequenc ruleid oclisundefin thismodul ruleid els oclundefin endif constraint constraint xml element name r ml constraint children sequenc constraint rule ruleid creat xml attribut r ml ruleid r ml rule element lazi rule ruleid r ml rule xml attribut name r ml ruleid valu ruleid rule deonticintegrityrul creat xml element r ml deonticintegrityrul r ml deonticintegrityrul element rule deonticintegrityrul r ml deonticintegrityrul oclistypeof r ml deonticintegrityrul xml element name r ml deonticintegrityrul children sequenc ruleid oclisundefin thismodul ruleid els oclundefin endif constraint constraint xml element name r ml constraint children sequenc constraint rule universallyquantifiedformula creat xml element r ml universallyquantifiedformula r ml universallyquantifiedformula element rule universallyquantifiedformula r ml universallyquantifiedformula oclistypeof r ml universallyquantifiedformula xml element name r ml universallyquantifiedformula children sequenc variabl assequ select c c oclistypeof r ml objectvari collect e thismodul objectvari e variabl assequ select c c oclistypeof r ml datavari collect e thismodul datavari e formula rule existentiallyquantifiedformula creat xml element r ml existentiallyquantifiedformula r ml existentiallyquantifiedformula element rule existentiallyquantifiedformula r ml existentiallyquantifiedformula oclistypeof r ml existentiallyquantifiedformula xml element name r ml existentiallyquantifiedformula children sequenc variabl assequ select c c oclistypeof r ml objectvari collect e thismodul objectvari e variabl assequ select c c oclistypeof r ml datavari collect e thismodul datavari e formula lazi rule classrul creat xml attribut r ml classid r ml class element lazi rule classrul r ml class xml attribut name r ml classid valu name lazi rule objectvari creat xml element r ml objectvari r ml objectvari element lazi rule objectvari r ml objectvari xml element name r ml objectvari children sequenc attrnam classref oclisundefin thismodul classrul classref els oclundefin endif attrnam xml attribut name r ml name valu name lazi rule datavari creat xml element r ml datavari r ml datavari element lazi rule datavari r ml datavari xml element name r ml datavari children sequenc attrnam datatyperef oclisundefin thismodul datatyp datatyperef els oclundefin endif typecategori oclisundefin thismodul typecategori els oclundefin endif attrnam xml attribut name r ml name valu name lazi rule genericvari creat xml element r ml genericvari r ml genericvari element lazi rule genericvari r ml genericvari xml element name r ml genericvari children sequenc attrnam typeref oclisundefin thismodul datatyp typeref els oclundefin endif attrnam xml attribut name r ml name valu name lazi rule datatyp creat xml attribut r ml datatypeid r ml datatyp element lazi rule datatyp r ml datatyp xml attribut name r ml datatypeid valu name rule implic creat xml element r ml implic r ml implic element rule implic r ml implic oclistypeof r ml implic xml element name r ml implic children sequenc ant con ant xml element name r ml anteced children anteced con xml element name r ml consequ children consequ rule conjuct creat xml element r ml conjuct r ml conjuct element rule conjuct r ml conjuct oclistypeof r ml conjuct xml element name r ml conjunct children formula rule disjunct creat xml element r ml disjunct r ml disjunct element rule disjunct r ml disjunct oclistypeof r ml disjunct xml element name r ml disjunct children formula rule negationasfailur creat xml element r ml negationasfailur r ml negationasfailur element rule negationasfailur r ml negationasfailur oclistypeof r ml negationasfailur xml element name r ml negationasfailur children sequenc formula rule strongneg creat xml element r ml strongneg r ml strongneg element rule strongneg r ml strongneg oclistypeof r ml strongneg xml element name r ml strongneg children sequenc formula rule equalityatom creat xml element r ml equalityatom r ml equalityatom element rule equalityatom r ml equalityatom oclistypeof r ml equalityatom xml element name r ml equalityatom children sequenc term select c c oclistypeof r ml objectvari collect e thismodul objectvari e term select c c oclistypeof r ml objectvari rule inequalityatom creat xml element r ml inequalityatom r ml inequalityatom element rule inequalityatom r ml inequalityatom oclistypeof r ml inequalityatom xml element name r ml inequalityatom children sequenc term select c c oclistypeof r ml objectvari collect e thismodul objectvari e term select c c oclistypeof r ml objectvari rule derivationrul creat xml element r ml derivationrul r ml derivationrul element rule derivationrul r ml derivationrul oclistypeof r ml derivationrul xml element name r ml derivationrul children sequenc ruleid oclisundefin thismodul ruleid els oclundefin endif condit conclus condit xml element name r ml condit children condit conclus xml element name r ml conclus children conclus assequ collect c c atom flatten assequ collect literalconjuct rule atomisneg creat xml attribut r ml isneg r ml atom element lazi rule atomisneg r ml atom xml attribut name r ml isneg valu true rule dataclassificationatom creat xml element r ml dataclassificationatom r ml dataclassificationatom element rule dataclassificationatom r ml dataclassificationatom oclistypeof r ml dataclassificationatom xml element name r ml dataclassificationatom children sequenc isneg isneg attribut thismodul atomisneg els oclundefin endif thismodul datatyp type classid attribut thismodul datavari term term rule qfconjunct creat xml element r ml qf conjuct r ml qfconjunct element rule qfconjunct r ml qfconjunct oclistypeof r ml qfconjunct xml element name r ml qf conjuct children formula rule qfdisjunct creat xml element r ml qf disjunct r ml qfdisjunct element rule qfdisjunct r ml qfdisjunct oclistypeof r ml qfdisjunct xml element name r ml qf disjunct children formula rule qfnegationasfailur creat xml element r ml qf negationasfailur r ml qfnegationasfailur element rule qfnegationasfailur r ml qfnegationasfailur oclistypeof r ml qfnegationasfailur xml element name r ml qf negationasfailur children sequenc formula rule qfstrongneg creat xml element r ml qf strongneg r ml qfstrongneg element rule qfstrongneg r ml qfstrongneg oclistypeof r ml qfstrongneg xml element name r ml qf strongneg children sequenc formula rule datatypepredicateatom creat xml element r ml datatypepredicateatom r ml datatypepredicateatom element rule datatypepredicateatom r ml datatypepredicateatom oclistypeof r ml datatypepredicateatom xml element name r ml datatypepredicateatom children sequenc isneg isneg attribut thismodul atomisneg els oclundefin endif attr dataarg attr xml attribut name r ml datatypepredicateid valu predic name dataarg xml element name r ml dataargu children sequenc dataargu assequ select c c oclistypeof r ml datavari collect c thismodul datavari c dataargu assequ select c c oclistypeof r ml datavari rule typecategori creat xml attribut r ml typecategori r ml term element lazi rule typecategori r ml term xml attribut name r ml typecategori valu typecategori individu individu els typecategori set set els typecategori orderedset order els typecategori bag bag els typecategori sequenc sequenc els oclundefin endif endif endif endif endif rule dataoperationtermarg creat xml element r ml argument r ml dataoperationterm element lazi rule dataoperationtermarg r ml dataoperationterm xml element name r ml argument children sequenc argument assequ select c c oclistypeof r ml objectvari collect c thismodul objectvari c argument assequ select c c oclistypeof r ml datavari collect c thismodul datavari c argument assequ select c c oclistypeof r ml objectvari c oclistypeof r ml datavari rule typedliter creat xml element r ml typedliter r ml typedliter element rule typedliter r ml typedliter oclistypeof r ml typedliter xml element name r ml typedliter children sequenc type valu type xml attribut name r ml datatypeid valu type name valu xml attribut name r ml lexicalvalu valu lexicalvalu rule plainliter creat xml element r ml plainliter r ml plainliter element rule plainliter r ml plainliter oclistypeof r ml plainliter xml element name sequenc languagetag oclisundefin thismodul plainliterallanguagetag els oclundefin endif valu valu xml attribut name r ml lexicalvalu valu lexicalvalu rule plainliterallanguagetag creat xml attribut r ml languagetag r ml plainliter element lazi rule plainliterallanguagetag r ml plainliter xml attribut name r ml languagetag valu languagetag rule attributefunctionterm creat xml element r ml attributefunctionterm r ml attributefunctionterm element rule attributefunctionterm r ml attributefunctionterm oclistypeof r ml attributefunctionterm xml element name r ml attributefunctionterm children sequenc attr contextarg typecategori oclisundefin thismodul typecategori els oclundefin endif attr xml attribut name r ml attributeid valu attribut name contextarg xml element name r ml contextargu children sequenc contextargu oclistypeof r ml objectvari thismodul objectvari contextargu els contextargu endif rule associationatom creat xml element r ml associationatom r ml associationatom element rule associationatom r ml associationatom oclistypeof r ml associationatom xml element name r ml associationatom children sequenc isneg isneg attribut thismodul atomisneg els oclundefin endif assocpr objarg dataargu size thismodul associationatomdataarg els oclundefin endif assocpr xml attribut name r ml associationpredicateid valu associationpred name objarg xml element name r ml objectargu children sequenc objectargu assequ select c c oclistypeof r ml objectvari collect c thismodul objectvari c objectargu assequ select c c oclistypeof r ml objectvari rule associationatomdataarg creat xml element r ml dataargu r ml associationatom element lazi rule associationatomdataarg r ml associationatom xml element name r ml dataargu children sequenc dataargu assequ select c c oclistypeof r ml datavari collect c thismodul datavari c dataargu assequ select c c oclistypeof r ml datavari rule referencepropertyfunctionterm creat xml element r ml referencepropertyfunctionterm r ml referencepropertyfunctionterm element rule referencepropertyfunctionterm r ml referencepropertyfunctionterm oclistypeof r ml referencepropertyfunctionterm xml element name r ml referencepropertyfunctionterm children sequenc refprop contextarg typecategori oclisundefin thismodul typecategori els oclundefin endif refprop xml attribut name r ml referencepropertyid valu referencepropertyref name contextarg xml element name r ml contextargu children sequenc contextargu oclistypeof r ml objectvari thismodul objectvari contextargu els contextargu endif rule attributionatom creat xml element r ml attributionatom r ml attributionatom element rule attributionatom r ml attributionatom oclistypeof r ml attributionatom xml element name r ml attributionatom children sequenc attr isneg isneg attribut thismodul atomisneg els oclundefin endif subject datavalu attr xml attribut name r ml attributeid valu attribut name subject xml element name r ml subject children sequenc subject oclistypeof r ml objectvari thismodul objectvari subject els subject endif datavalu xml element name r ml datavalu children sequenc datavalu oclistypeof r ml datavari thismodul datavari datavalu els datavalu endif rule referencepropertyatom creat xml element r ml referencepropertyatom r ml referencepropertyatom element rule referencepropertyatom r ml referencepropertyatom oclistypeof r ml referencepropertyatom xml element name r ml referencepropertyatom children sequenc isneg isneg attribut thismodul atomisneg els oclundefin endif refprop subject object refprop xml attribut name r ml referencepropertyid valu referenceproperti name subject xml element name r ml subject children sequenc subject oclistypeof r ml objectvari thismodul objectvari subject els subject endif object xml element name r ml object children sequenc object oclistypeof r ml objectvari thismodul objectvari object els object endif rule genericatom creat xml element r ml genericatom r ml genericatom element rule genericatom r ml genericatom oclistypeof r ml genericatom xml element name r ml genericatom children sequenc predic arg predic xml attribut name r ml predicateid valu predic name arg xml element name r ml argument children sequenc argument assequ select c c oclistypeof r ml genericvari collect c thismodul genericvari c argument assequ select c c oclistypeof r ml objectvari collect c thismodul objectvari c argument assequ select c c oclistypeof r ml datavari collect c thismodul datavari c argument assequ select c c ocliskindof r ml variabl rule predicatetyp creat xml attribut r ml predicatetyp r ml genericatom element lazi rule predicatetyp r ml genericpred xml attribut name r ml predicatetyp valu predicatetypeid objectclassificationpred objectclassificationpred els predicatetypeid attributionpred attributionpred els predicatetypeid associationpred associationpred els predicatetypeid referencepropertypred referencepropertypred els predicatetypeid equalitypred equalitypred els predicatetypeid inequalitypred inequalitypred els predicatetypeid datatypepred datatypepred els predicatetypeid dataclassificationpred dataclassificationpred els oclundefin endif endif endif endif endif endif endif endif rule genericfunctionterm creat xml element r ml genericfunctionterm r ml genericfunctionterm element rule genericfunctionterm r ml genericfunctionterm oclistypeof r ml genericfunctionterm xml element name r ml genericfunctionterm children sequenc attr arg attr xml attribut name r ml genericfunctionid valu functor name arg xml element name r ml argument children sequenc argument assequ select c c oclistypeof r ml genericvari collect c thismodul genericvari c argument assequ select c c oclistypeof r ml genericvari typecategori oclisundefin thismodul typecategori els oclundefin endif rule datatypefunctionterm creat xml element r ml datatypefunctionterm r ml datatypefunctionterm element rule datatypefunctionterm r ml datatypefunctionterm oclistypeof r ml datatypefunctionterm xml element name r ml datatypefunctionterm children sequenc attr arg attr xml attribut name datatypefunctionid valu function name arg xml element name r ml dataargu children sequenc dataargu assequ select c c oclistypeof r ml datavari collect c thismodul datavari c dataargu assequ select c c oclistypeof r ml datavari typecategori oclisundefin thismodul typecategori els oclundefin endif rule objectnam creat xml element r ml objectnam r ml objectnam element rule objectnam r ml objectnam oclistypeof r ml objectnam xml element name r ml objectnam children sequenc attr classref oclisundefin thismodul classrul classref els oclundefin endif typecategori oclisundefin thismodul typecategori els oclundefin endif attr xml attribut name r ml objectid valu name rule objectdescriptionatom creat xml element r ml objectdescriptionatom r ml objectdescriptionatom element rule objectdescriptionatom r ml objectdescriptionatom oclistypeof r ml objectdescriptionatom xml element name r ml objectdescriptionatom children sequenc class basetyp oclisundefin thismodul classrul basetyp els oclundefin endif subject slot object class xml attribut name r ml classid valu type name subject xml element name r ml subject children sequenc subject oclistypeof r ml objectvari thismodul objectvari subject els subject endif object xml element name r ml object children object rule objectslot creat xml element r ml objectslot r ml objectslot element rule objectslot r ml objectslot oclistypeof r ml objectslot xml element name r ml objectslot children sequenc attr object attr xml attribut name r ml referencepropertyid valu referenceproperti name object xml element name r ml object children sequenc object oclistypeof r ml objectvari thismodul objectvari object els object endif rule dataslot creat xml element r ml dataslot r ml dataslot element rule dataslot r ml dataslot oclistypeof r ml dataslot xml element name r ml dataslot children sequenc attr valu attr xml attribut name r ml attributeid valu attribut name valu xml element name r ml valu children sequenc valu oclistypeof r ml datavari thismodul datavari valu els valu endif rule atleastquantifiedformula creat xml element r ml atleastquantifiedformula r ml atleastquantifiedformula element rule atleastquantifiedformula r ml atleastquantifiedformula oclistypeof r ml atleastquantifiedformula xml element name r ml atleastquantifiedformula children sequenc attr variabl assequ select c c oclistypeof r ml objectvari collect e thismodul objectvari e variabl assequ select c c oclistypeof r ml datavari collect e thismodul datavari e formula attr xml attribut name r ml mincardin valu mincardin tostr rule atmostquantifiedformula creat xml element r ml atmostquantifiedformula r ml atmostquantifiedformula element rule atmostquantifiedformula r ml atmostquantifiedformula oclistypeof r ml atmostquantifiedformula xml element name r ml atmostquantifiedformula children sequenc attr variabl assequ select c c oclistypeof r ml objectvari collect e thismodul objectvari e variabl assequ select c c oclistypeof r ml datavari collect e thismodul datavari e formula attr xml attribut name r ml maxcardin valu maxcardin tostr rule atleastandatmostquantifiedformula creat xml element r ml atleastandatmostquantifiedformula r ml atleastandatmostquantifiedformula element rule atleastandatmostquantifiedformula r ml atleastandatmostquantifiedformula oclistypeof r ml atleastandatmostquantifiedformula xml element name r ml atleastandatmostquantifiedformula children sequenc attrmax attrmin variabl assequ select c c oclistypeof r ml objectvari collect e thismodul objectvari e variabl assequ select c c oclistypeof r ml datavari collect e thismodul datavari e formula attrmax xml attribut name r ml maxcardin valu maxcardin tostr attrmin xml attribut name r ml mincardin valu mincardin tostr rule objectoperationterm creat xml element r ml objectoperationterm r ml objectoperationterm element rule objectoperationterm r ml objectoperationterm oclistypeof r ml objectoperationterm xml element name r ml objectoperationterm children sequenc oper contextarg todo objectoperationtermarg argument size argument els oclundefin endif oper xml attribut name r ml operationid valu oper name contextarg xml element name r ml contextargu children sequenc contextargu oclistypeof r ml objectvari thismodul objectvari contextargu els contextargu endif rule dataoperationterm creat xml element r ml dataoperationterm r ml dataoperationterm element rule dataoperationterm r ml dataoperationterm oclistypeof r ml dataoperationterm xml element name r ml dataoperationterm children sequenc attr argument size thismodul dataoperationtermarg els oclundefin endif contarg typecategori oclisundefin thismodul typecategori els oclundefin endif attr xml attribut name r ml operationid valu dataoperationref name contarg xml element name r ml contextargu children sequenc contextargu oclistypeof r ml objectvari thismodul objectvari contextargu els contextargu endif vocabulari rule vocabulari creat xml element r mlv vocabulari r ml plainliter element rule vocabulari r ml vocabulari oclistypeof r ml vocabulari xml element name r mlv vocabulari children sequenc entri rule classr creat xml element r mlv class r ml class element rule classr r ml class oclistypeof r ml class xml element name r mlv class children sequenc cid attribut referencepropertyref cid xml attribut name r mlv id valu name rule messagetyp creat xml element r mlv messagetyp r ml messagetyp element rule messagetyp r ml messagetyp oclistypeof r ml messagetyp xml element name r mlv messagetyp children sequenc cid attribut referencepropertyref cid xml attribut name r mlv id valu name rule faultmessagetyp creat xml element r mlv faultmessagetyp r ml faultmessagetyp element rule faultmessagetyp r ml faultmessagetyp oclistypeof r ml faultmessagetyp xml element name r mlv faultmessagetyp children sequenc cid attribut cid xml attribut name r mlv id valu name rule associationpred creat xml element r mlv associationpred r ml associationpred element rule associationpred r ml associationpred oclistypeof r ml associationpred xml element name r mlv associationpred children sequenc cid arg cid xml attribut name r mlv associationpredicateid valu name arg xml element name r mlv argumentstyp children sequenc argument assequ select c c oclistypeof r ml class collect e thismodul classassoc e argument assequ select c c oclistypeof r ml messagetyp collect e thismodul messagetypeassoc e lazi rule classassoc r ml class oclistypeof r ml class xml element name r mlv class children sequenc cid cid xml attribut name r mlv id valu name lazi rule messagetypeassoc r ml messagetyp oclistypeof r ml messagetyp xml element name r mlv messagetyp children sequenc cid cid xml attribut name r mlv id valu name rule attributevoc creat xml element attribut r ml attribut element rule attributevoc r ml attribut oclistypeof r ml attribut xml element name r mlv attribut children sequenc cid rang cid xml attribut name r mlv id valu name rang xml element name r mlv rang children sequenc rang assequ select c c oclistypeof r ml datatyp collect e thismodul datatypevoc e rule referencepropertyvoc creat xml element referenceproperti r ml referenceproperti element rule referencepropertyvoc r ml referenceproperti oclistypeof r ml referenceproperti xml element name r mlv referenceproperti children sequenc cid rang cid xml attribut name r mlv id valu name rang xml element name r mlv rang children sequenc rang assequ select c c oclistypeof r ml class collect e thismodul classassoc e lazi rule datatypevoc creat xml attribut r ml datatypeid r ml datatyp element lazi rule datatypevoc r ml datatyp xml element name r mlv datatyp children sequenc dtid dtid xml attribut name r mlv id valu name reaction rule rule reactionrul creat xml element r ml reactionrul r ml reactionrul element rule reactionrul r ml reactionrul oclistypeof r ml reactionrul xml element name r ml reactionrul children sequenc ruleid oclisundefin thismodul ruleid els oclundefin endif triggeringev condit producedact postconditon oclisundefin postconditon els oclundefin endif groupid triggeringev xml element name r ml triggeringev children thismodul messageeventexpress triggeringev condit xml element name r ml condit children condit producedact xml element name r ml producedact children thismodul messageeventexpress producedact postconditon xml element name r ml postconditon children postconditon groupid xml attribut name r ml groupid valu groupid rule messageeventexpress creat xml element r ml messageeventexpress r ml messageeventexpress element lazi rule messageeventexpress r ml messageeventexpress oclistypeof r ml messageeventexpress xml element name r ml messageeventexpress children sequenc type oclisundefin type thismodul meetyp els oclundefin endif startdatetim oclisundefin starttim thismodul meestarttim els oclundefin endif durat oclisundefin durat thismodul meedur els oclundefin endif sender oclisundefin sender thismodul meesend els oclundefin endif objectvari oclisundefin thismodul objectvari objectvari els oclundefin endif slot oclisundefin slot els oclundefin endif type xml attribut name r ml eventtyp valu type name starttim xml attribut name r ml starttim valu startdatetim durat xml attribut name r ml durat valu durat sender xml attribut name r ml sender valu sender rule meetyp creat xml attribut r ml eventtyp r ml messageeventexpress element lazi rule meetyp r ml messageeventexpress xml attribut name r ml eventtyp valu type name rule meestarttim creat xml attribut r ml starttim r ml messageeventexpress element lazi rule meestarttim r ml messageeventexpress xml attribut name r ml starttim valu startdatetim rule meedur creat xml attribut r ml durat r ml messageeventexpress element lazi rule meedur r ml messageeventexpress xml attribut name r ml durat valu durat rule meesend creat xml attribut r ml sender r ml messageeventexpress element lazi rule meesend r ml messageeventexpress xml attribut name r ml sender valu sender rule objectclassificationatom creat xml element r ml objectclassificationatom r ml objectclassificationatom element rule objectclassificationatom r ml objectclassificationatom oclistypeof r ml objectclassificationatom xml element name r ml objectclassificationatom children sequenc isneg isneg attribut thismodul atomisneg els oclundefin endif type oclistypeof r ml class thismodul classrul type els type oclistypeof r ml messagetyp mtoca els oclundefin endif endif thismodul objectvari term term mtoca xml attribut name r ml classid valu type oclistypeof r ml messagetyp type name els oclundefin endif,6
236,236,P99-WSDL2R2ML.atl,"--@atlcompiler atl2006

--------------------------------------------------------------------------------
-- Transforms a WSDL metamodel to R2ML metamodel.
-- Created as part of M.Sc. theses at GOOD OLD AI Research Group
-- Author: Marko Ribaric
-- Works for R2ML v0.5-beta
--------------------------------------------------------------------------------
-- Version: 0.1 - 29.05.2007.
--
-- TODO:
-- 	1) fix for XsSimpleTypeDefinition
--	2) fix ObjectVariable name
--	3) fix lexicalValue for DataSlot
--	4) add Bindings
--  5) fix ruleID (ReactionRule)
--  6) fix sender (MessageEventExpression)
--
-- ANNOTATION: With MDR, Enumerations must be located in top-most package
--------------------------------------------------------------------------------

module WSDL2R2ML; 					-- Module Template
create OUT : R2ML from IN : WSDL;

-- uses strings;

-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- HELPER:	IsInputOrOutputElement()
-- Returns true if the ""value"" is the same as the ""element"" attribute from ""input"" or ""output"" element
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		Boolean
helper def: IsInputOrOutputElement(value: String) : Boolean = 
	let operations: Sequence(WSDL!Operation) = WSDL!Interface.allInstances()->asSequence()->first().operation in
	let inputElem: Sequence(WSDL!Input) = operations->collect(i| i.input)->flatten() in
	let outputElem: Sequence(WSDL!Output) = operations->collect(o| o.output)->flatten() in

	if ( (inputElem->size() > 0) and (inputElem->select(e| e.element.name = value)->size() > 0) ) then
		true
	else if ( (outputElem->size() > 0) and (outputElem->select(e| e.element.name = value)->size() > 0) ) then
			true
		 else
		 	false
		 endif
	endif;

	
-- HELPER:	IsInfaultOrOutfaultElement()
-- Returns true if the value is the same as the ""fault"" attribute from ""infault"" or ""outfault"" element
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		Boolean
helper def: IsInfaultOrOutfaultElement(value: String) : Boolean = 
	let operations: Sequence(WSDL!Operation) = WSDL!Interface.allInstances()->asSequence()->first().operation in
	let infaultElem: Sequence(WSDL!Infault) = operations->collect(i| i.infault)->flatten() in
	let outfaultElem: Sequence(WSDL!Outfault) = operations->collect(o| o.outfault)->flatten() in

	if ( (infaultElem->size() > 0) and (infaultElem->select(e| e.fault.name = value)->size() > 0) ) then
		true
	else if ( (outfaultElem->size() > 0) and (outfaultElem->select(e| e.fault.element.name = value)->size() > 0) ) then
			true
		 else
		 	false
		 endif
	endif;

-- HELPER:	resolveMEP
-- resolve the MEP type
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		String
helper def: resolveMEP(value : String) : String =
	if value = #inout then
			'http://www.w3.org/2006/01/wsdl/in-out'
		else if value = #inonly then
				'http://www.w3.org/2006/01/wsdl/inonly'
			else if value = #outin then
					'http://www.w3.org/2006/01/wsdl/out-in'
				else if value = #robustoutonly then
						'http://www.w3.org/2006/01/wsdl/robustoutonly'
					else if value = #outonly then
							'http://www.w3.org/2006/01/wsdl/outonly'
						else if value = #robust_in_only then
								'http://www.w3.org/2006/01/wsdl/robustinonly'
							else if value = #outoptionalin then
									'http://www.w3.org/2006/01/wsdl/outoptionalin'
								else if value = #inoptionalout then
										'http://www.w3.org/2006/01/wsdl/inoptionalout'
								else OclUndefined
								endif
							endif
						endif
					endif
				endif
			endif
		endif
	endif;


-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'RuleBase'
-- Creates R2ML!RuleBase element from an WSDL!Description. These are root elements.
rule RuleBase {
	from
		i : WSDL!Description (
				i.oclIsTypeOf(WSDL!Description)
			)		
	to
		o : R2ML!RuleBase (                 
				rules <- Sequence { i.service, i.interface },
				vocabularies <- i.types->asSequence()->first()
		) 
}

-- Rule 'Vocabulary'
-- Creates R2ML!Vocabulary element from an WSDL!ElementType.
rule Vocabulary {
	from i : WSDL!ElementType (
			i.oclIsTypeOf(WSDL!ElementType)
		)
	to o : R2ML!Vocabulary (
			entries <- i.schema.elementDeclarations
		)
}

-- Rule 'ClassR'
-- Creates R2ML!Class element from an WSDL!XsElementDeclaration.
rule ClassR {
	from i : WSDL!XsElementDeclaration (
			i.oclIsTypeOf(WSDL!XsElementDeclaration) and
			not i.typeDefinition.oclIsTypeOf(WSDL!XsSimpleTypeDefinition) and
			not thisModule.IsInputOrOutputElement(i.name) and
			not thisModule.IsInfaultOrOutfaultElement(i.name)
			
		)
	to o : R2ML!Class (
			name <- i.name,
			attributes <- if i.typeDefinition.oclIsTypeOf(WSDL!XsComplexTypeDefinition) then
								i.typeDefinition.content.term.particles->collect(e| thisModule.AttributeR(e)) 
						  else	OclUndefined
						  endif
		)
}

-- Rule 'MessageType'
-- Creates R2ML!MessageType element from an WSDL!XsElementDeclaration.
rule MessageType {
	from i : WSDL!XsElementDeclaration (
			i.oclIsTypeOf(WSDL!XsElementDeclaration) and
			not i.typeDefinition.oclIsTypeOf(WSDL!XsSimpleTypeDefinition) and
			thisModule.IsInputOrOutputElement(i.name)
		)
	to o : R2ML!MessageType (
			name <- i.name,
			attributes <- if i.typeDefinition.oclIsTypeOf(WSDL!XsComplexTypeDefinition) then
								Sequence { i.typeDefinition.content.term.particles->select(c| not c.content.name.oclIsUndefined())->collect(e| thisModule.AttributeR(e))
										 }
						  else	OclUndefined
						  endif,
			referencePropertyRef <- if i.typeDefinition.oclIsTypeOf(WSDL!XsComplexTypeDefinition) then
									i.typeDefinition.content.term.particles->select(c| not c.content.resolvedElementDeclaration.oclIsUndefined())
						  else	OclUndefined
						  endif
		)
}

-- Rule 'FaultMessageType'
-- Creates R2ML!FaultMessageType element from an WSDL!XsElementDeclaration.
rule FaultMessageType {
	from i : WSDL!XsElementDeclaration (
			i.oclIsTypeOf(WSDL!XsElementDeclaration) and
			not i.typeDefinition.oclIsTypeOf(WSDL!XsSimpleTypeDefinition) and
			thisModule.IsInfaultOrOutfaultElement(i.name)
		)
	to o : R2ML!FaultMessageType (
			name <- i.name,
			attributes <- if i.typeDefinition.oclIsTypeOf(WSDL!XsComplexTypeDefinition) then
							i.typeDefinition.content.term.particles->collect(e| thisModule.AttributeR(e)) 
						else	OclUndefined
						  endif
		)
}

-- Rule 'AttributeR'
-- Creates R2ML!Attribute element from an WSDL!XsParticle.
-- This rule is lazy rule, which means that is called from other rules
lazy rule AttributeR {
	from i : WSDL!XsParticle (
			i.oclIsTypeOf(WSDL!XsParticle)
		)
	to o : R2ML!Attribute (
			name <- i.content.name,
			range <- thisModule.Datatype(i.content.typeDefinition)
		)
}

-- Rule 'Datatype'
-- Creates R2ML!Datatype element from an WSDL!XsElementDeclaration.
-- This rule is unique lazy rule, which means that is called from other rules
unique lazy rule Datatype {
	from i : XML!XsSimpleTypeDefinition 
	to o : R2ML!Datatype (
			predicateCategory <- #closed,
			name <- i.name
		)
}

-- TODO: fix this
unique lazy rule XsSimpleTypeDefinition {
	from i : WSDL!XsElementDeclaration (
			i.oclIsTypeOf(WSDL!XsElementDeclaration)
		)
	to o : R2ML!GenericVariable (
		
		)
}

-- Rule 'ReferenceProperty'
-- Creates R2ML!ReferenceProperty element from an WSDL!XsParticle.
rule ReferenceProperty {
	from i : WSDL!XsParticle (
			i.oclIsTypeOf(WSDL!XsParticle) and
			i.content->asSequence()->select(c| not c.resolvedElementDeclaration.oclIsUndefined() )->size() > 0
		)
	to o : R2ML!ReferenceProperty (
			name <- i.content.resolvedElementDeclaration.name,
			range <- i.content.resolvedElementDeclaration 
		)
}

-- Rule 'ReactionRuleSet'
-- Creates R2ML!ReactionRuleSet element from an WSDL!Interface.
-- TODO: fix this for other patterns
rule ReactionRuleSet {
	from i : WSDL!Interface (
			i.oclIsTypeOf(WSDL!Interface)
		)
	to o : R2ML!ReactionRuleSet (
			rules <- i.operation.asSequence()->collect(e| 
					 			if (thisModule.resolveMEP(e.pattern) = 'http://www.w3.org/2006/01/wsdl/in-out') then
									Sequence {thisModule.RrRight(e),  thisModule.RrWrong(e)}				
					 			else
					 				thisModule.RrRight(e)
						 		endif
											    		),
			ruleSetID <- i.name 
		)
}

-- Rule 'RrRight'
-- Creates R2ML!ReactionRule element from an WSDL!Operation.
-- This rule is lazy rule, which means that is called from other rules
lazy rule RrRight {
	from i : WSDL!Operation (
			i.oclIsTypeOf(WSDL!Operation)
		)
	to o : R2ML!ReactionRule (
			ruleID <- '???',
			groupID <- i.name,
			triggeringEvent <- i.input->asSequence()->first(),
			producedAction <- i.output->asSequence()->first()
		)
}

-- Rule 'RrWrong'
-- Creates R2ML!ReactionRule element from an WSDL!Operation.
-- This rule is lazy rule, which means that is called from other rules
lazy rule RrWrong {
	from i : WSDL!Operation (
			i.oclIsTypeOf(WSDL!Operation)
		)
	to o : R2ML!ReactionRule (
			ruleID <- '???',
			groupID <- i.name,
			triggeringEvent <- i.input->asSequence()->first(),
			producedAction <- i.outfault->asSequence()->first()
		)
}

-- Rule 'TriggeringEvent'
-- Creates R2ML!MessageEventExpression element from an WSDL!Input.
rule TriggeringEvent {
	from i : WSDL!Input (
			i.oclIsTypeOf(WSDL!Input)
		)
	to o : R2ML!MessageEventExpression (
			sender <- 'to_be_defined',
			objectVariable <- thisModule.ObjectVariable(i.element),
			type <- i.element
		)
}

-- Rule 'ObjectVariable'
-- Creates R2ML!ObjectVariable element from an WSDL!XsElementDeclaration.
-- This rule is lazy rule, which means that is called from other rules
unique lazy rule ObjectVariable {
	from i : WSDL!XsElementDeclaration (
			i.oclIsTypeOf(WSDL!XsElementDeclaration) 
		)
	to o : R2ML!ObjectVariable (
 	        name <- '???',					--TODO: fix this
			typeCategory <- #individual,
			classRef <- i
		)		
}

-- Rule 'ProducedActionRight'
-- Creates R2ML!MessageEventExpression element from an WSDL!Output.
-- TODO: fix for ObjectSlot		
rule ProducedActionRight {
	from i : WSDL!Output (
			i.oclIsTypeOf(WSDL!Output)
		)
	to o : R2ML!MessageEventExpression (
			sender <- WSDL!Endpoint.allInstances()->asSequence()->first().address,
			type <- i.element,
			slot <- i.element.typeDefinition.content.term.particles->first()
		)
}

-- Rule 'ProducedActionWrong'
-- Creates R2ML!MessageEventExpression element from an WSDL!Outfault.
rule ProducedActionWrong {
	from i : WSDL!Outfault (
			i.oclIsTypeOf(WSDL!Outfault)
		)
	to o : R2ML!MessageEventExpression (
			sender <- WSDL!Endpoint.allInstances()->asSequence()->first().address,
			type <- i.fault.element,
			slot <- i.fault.element.typeDefinition.content.term.particles->first()
		)
}

-- Rule 'DataSlot'
-- Creates R2ML!DataSlot element from an WSDL!XsParticle.
-- This rule is lazy rule, which means that is called from other rules
rule DataSlot {
	from i : WSDL!XsParticle (
			i.oclIsTypeOf(WSDL!XsParticle) and 
			( WSDL!Outfault.allInstancesFrom('IN')->asSequence()->collect(e| e.fault.element.typeDefinition.content.term.particles)->flatten()->includes(i)
 			or WSDL!Output.allInstancesFrom('IN')->asSequence()->collect(e| e.element.typeDefinition.content.term.particles)->flatten()->includes(i))
		)
	to o : R2ML!DataSlot (
			value <- type,
			attribute <- thisModule.AttributeR(i)
		),
	type : R2ML!TypedLiteral (
			type <- thisModule.Datatype(i.content.typeDefinition),
			lexicalValue <- '???'		-- this should be a default value
	)
}

",atlcompil atl transform wsdl metamodel r ml metamodel creat part m sc these good old ai research group author marko ribar work r ml v beta version todo fix xssimpletypedefinit fix objectvari name fix lexicalvalu dataslot add bind fix ruleid reactionrul fix sender messageeventexpress annot with mdr enumer must locat top packag modul wsdl r ml modul templat creat out r ml in wsdl use string helper helper isinputoroutputel return true valu element attribut input output element context thismodul in string out boolean helper def isinputoroutputel valu string boolean let oper sequenc wsdl oper wsdl interfac allinst assequ first oper let inputelem sequenc wsdl input oper collect input flatten let outputelem sequenc wsdl output oper collect output flatten inputelem size inputelem select e e element name valu size true els outputelem size outputelem select e e element name valu size true els fals endif endif helper isinfaultoroutfaultel return true valu fault attribut infault outfault element context thismodul in string out boolean helper def isinfaultoroutfaultel valu string boolean let oper sequenc wsdl oper wsdl interfac allinst assequ first oper let infaultelem sequenc wsdl infault oper collect infault flatten let outfaultelem sequenc wsdl outfault oper collect outfault flatten infaultelem size infaultelem select e e fault name valu size true els outfaultelem size outfaultelem select e e fault element name valu size true els fals endif endif helper resolvemep resolv mep type context thismodul in string out string helper def resolvemep valu string string valu inout http www w org wsdl els valu inon http www w org wsdl inon els valu outin http www w org wsdl els valu robustouton http www w org wsdl robustouton els valu outon http www w org wsdl outon els valu robust http www w org wsdl robustinon els valu outoptionalin http www w org wsdl outoptionalin els valu inoptionalout http www w org wsdl inoptionalout els oclundefin endif endif endif endif endif endif endif endif rule rule rulebas creat r ml rulebas element wsdl descript these root element rule rulebas wsdl descript oclistypeof wsdl descript r ml rulebas rule sequenc servic interfac vocabulari type assequ first rule vocabulari creat r ml vocabulari element wsdl elementtyp rule vocabulari wsdl elementtyp oclistypeof wsdl elementtyp r ml vocabulari entri schema elementdeclar rule classr creat r ml class element wsdl xselementdeclar rule classr wsdl xselementdeclar oclistypeof wsdl xselementdeclar typedefinit oclistypeof wsdl xssimpletypedefinit thismodul isinputoroutputel name thismodul isinfaultoroutfaultel name r ml class name name attribut typedefinit oclistypeof wsdl xscomplextypedefinit typedefinit content term particl collect e thismodul attribut e els oclundefin endif rule messagetyp creat r ml messagetyp element wsdl xselementdeclar rule messagetyp wsdl xselementdeclar oclistypeof wsdl xselementdeclar typedefinit oclistypeof wsdl xssimpletypedefinit thismodul isinputoroutputel name r ml messagetyp name name attribut typedefinit oclistypeof wsdl xscomplextypedefinit sequenc typedefinit content term particl select c c content name oclisundefin collect e thismodul attribut e els oclundefin endif referencepropertyref typedefinit oclistypeof wsdl xscomplextypedefinit typedefinit content term particl select c c content resolvedelementdeclar oclisundefin els oclundefin endif rule faultmessagetyp creat r ml faultmessagetyp element wsdl xselementdeclar rule faultmessagetyp wsdl xselementdeclar oclistypeof wsdl xselementdeclar typedefinit oclistypeof wsdl xssimpletypedefinit thismodul isinfaultoroutfaultel name r ml faultmessagetyp name name attribut typedefinit oclistypeof wsdl xscomplextypedefinit typedefinit content term particl collect e thismodul attribut e els oclundefin endif rule attribut creat r ml attribut element wsdl xsparticl this rule lazi rule mean call rule lazi rule attribut wsdl xsparticl oclistypeof wsdl xsparticl r ml attribut name content name rang thismodul datatyp content typedefinit rule datatyp creat r ml datatyp element wsdl xselementdeclar this rule uniqu lazi rule mean call rule uniqu lazi rule datatyp xml xssimpletypedefinit r ml datatyp predicatecategori close name name todo fix uniqu lazi rule xssimpletypedefinit wsdl xselementdeclar oclistypeof wsdl xselementdeclar r ml genericvari rule referenceproperti creat r ml referenceproperti element wsdl xsparticl rule referenceproperti wsdl xsparticl oclistypeof wsdl xsparticl content assequ select c c resolvedelementdeclar oclisundefin size r ml referenceproperti name content resolvedelementdeclar name rang content resolvedelementdeclar rule reactionruleset creat r ml reactionruleset element wsdl interfac todo fix pattern rule reactionruleset wsdl interfac oclistypeof wsdl interfac r ml reactionruleset rule oper assequ collect e thismodul resolvemep e pattern http www w org wsdl sequenc thismodul rrright e thismodul rrwrong e els thismodul rrright e endif rulesetid name rule rrright creat r ml reactionrul element wsdl oper this rule lazi rule mean call rule lazi rule rrright wsdl oper oclistypeof wsdl oper r ml reactionrul ruleid groupid name triggeringev input assequ first producedact output assequ first rule rrwrong creat r ml reactionrul element wsdl oper this rule lazi rule mean call rule lazi rule rrwrong wsdl oper oclistypeof wsdl oper r ml reactionrul ruleid groupid name triggeringev input assequ first producedact outfault assequ first rule triggeringev creat r ml messageeventexpress element wsdl input rule triggeringev wsdl input oclistypeof wsdl input r ml messageeventexpress sender defin objectvari thismodul objectvari element type element rule objectvari creat r ml objectvari element wsdl xselementdeclar this rule lazi rule mean call rule uniqu lazi rule objectvari wsdl xselementdeclar oclistypeof wsdl xselementdeclar r ml objectvari name todo fix typecategori individu classref rule producedactionright creat r ml messageeventexpress element wsdl output todo fix objectslot rule producedactionright wsdl output oclistypeof wsdl output r ml messageeventexpress sender wsdl endpoint allinst assequ first address type element slot element typedefinit content term particl first rule producedactionwrong creat r ml messageeventexpress element wsdl outfault rule producedactionwrong wsdl outfault oclistypeof wsdl outfault r ml messageeventexpress sender wsdl endpoint allinst assequ first address type fault element slot fault element typedefinit content term particl first rule dataslot creat r ml dataslot element wsdl xsparticl this rule lazi rule mean call rule rule dataslot wsdl xsparticl oclistypeof wsdl xsparticl wsdl outfault allinstancesfrom in assequ collect e e fault element typedefinit content term particl flatten includ wsdl output allinstancesfrom in assequ collect e e element typedefinit content term particl flatten includ r ml dataslot valu type attribut thismodul attribut type r ml typedliter type thismodul datatyp content typedefinit lexicalvalu default valu,6
237,237,P99-WSDL2XML.atl,"--@atlcompiler atl2006

--------------------------------------------------------------------------------
-- Transforms a WSDL metamodel to XML metamodel.
-- Created as part of M.Sc. theses at GOOD OLD AI Research Group
-- Author: Marko Ribaric
-- Works for WSDL Metamodel v0.1 (by prof. Gerd Wagner)
--------------------------------------------------------------------------------
-- Version: 0.1 - 01.01.2007.
--
-- TODO:
--------------------------------------------------------------------------------

module WSDL2XML; -- Module Template
create OUT : XML from IN : WSDL;


-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- HELPER:	resolveMEP
-- resolve the MEP type
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		String
helper def: resolveMEP(value : String) : String =
	
	if value = #inout then
			'http://www.w3.org/2006/01/wsdl/in-out'
		else if value = #inonly then
				'http://www.w3.org/2006/01/wsdl/inonly'
			else if value = #outin then
					'http://www.w3.org/2006/01/wsdl/out-in'
				else if value = #robustoutonly then
						'http://www.w3.org/2006/01/wsdl/robustoutonly'
					else if value = #outonly then
							'http://www.w3.org/2006/01/wsdl/outonly'
						else if value = #robust_in_only then
								'http://www.w3.org/2006/01/wsdl/robustinonly'
							else if value = #outoptionalin then
									'http://www.w3.org/2006/01/wsdl/outoptionalin'
								else if value = #inoptionalout then
										'http://www.w3.org/2006/01/wsdl/inoptionalout'
								else OclUndefined
								endif
							endif
						endif
					endif
				endif
			endif
		endif
	endif;
							
	
-- HELPER:	resolveMessageFormat
-- resolve the MessageFormat type
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		String
helper def: resolveMessageFormat(value : String) : String =

	if value = #SOAP12  then
			'http://www.w3.org/2006/01/wsdl/soap'
		else if value = #HTTP then
				'http://www.w3.org/2006/01/wsdl/HTTP'
			else if value = #SOAP11 then 
					OclUndefined				-- ???
				  else OclUndefined
				  endif
			endif
	endif;

-- HELPER:	resolveProtocol
-- resolve the Protocol type
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		String
helper def: resolveProtocol(value : String) : String =
	
	if value = #HTTP then
		'http://www.w3.org/2003/05/soap/bindings/HTTP'
	else if value = #SMTP then 
			'http://www.w3.org/2003/05/soap/bindings/SMTP'
		 else OclUndefined
		 endif
	endif;				  
	

-- HELPER:	resolveSOAPMEP
-- resolve the SOAPMEP type
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		String
helper def: resolveSOAPMEP(value : String) : String =
	
	if value = #requestresponse then
		'http://www.w3.org/2003/05/soap/mep/request-response'
	else if value = #soapresponse then
			'http://www.w3.org/2003/05/soap/mep/soap-response'	-- ???
		 else OclUndefined
		 endif
	endif;				  

-- HELPER:	resolveFaultCodeEnum
-- resolve the FaultCodeEnum type
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		String
helper def: resolveFaultCodeEnum(value : String) : String = 
	
	if value = #Sender then
		'soap:Sender'
	else OclUndefined
	endif;				  


-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'Description'
-- Create XML Root element (description) from the WSDL Description element 
rule Description {
	from i : WSDL!Description (
			i.oclIsTypeOf(WSDL!Description)
		)
	to o : XML!Root (
			name <- 'description',
			children <- Sequence { xmlns, targetNamespace, tns, wsoap, soap, ex,
						i.types, i.interface, i.binding, i.service }
		),
	xmlns : XML!Attribute (
			name <- 'xmlns',
			value <- 'http://www.w3.org/2006/01/wsdl'
		),
	targetNamespace : XML!Attribute (
			name <- 'targetNamespace',
			value <- 'http://www.bookingservice.com/?wsdl'
		),
	tns : XML!Attribute (
			name <- 'xmlns:tns',
			value <- 'http://www.bookingservice.com/?wsdl'
		),
	wsoap : XML!Attribute (
			name <- 'xmlns:wsoap',
			value <- 'http://www.w3.org/2006/01/wsdl/soap'
		),
	soap : XML!Attribute (
			name <- 'xmlns:soap',
			value <- 'http://www.w3.org/2003/05/soap-envelope'
		),
	ex : XML!Attribute (
			name <- 'xmlns:ex',
			value <- 'http://www.bookingservice.com/schema'
		)		
}

-- Rule 'Types'
-- Create XML element (types) from the WSDL Types element 
rule Types {
	from i : WSDL!ElementType (
			i.oclIsTypeOf(WSDL!ElementType)
		)
	to o : XML!Element (
			name <- 'types',
			children <- Sequence { i.schema }
		)
}

-- Rule 'XsSchema'
-- Create XML element (XsSchema) from the WSDL XsSchema element 
rule XsSchema {
	from i : WSDL!XsSchema (
			i.oclIsTypeOf(WSDL!XsSchema)
		)
	to o : XML!Element (
			name <- 'xs:schema',
			children <- Sequence { xs, targetNamespace, xmlns, 
							i.typeDefinitions,
							i.elementDeclarations->collect(e| thisModule.XsElementDeclaration(e))
						}
		),
		xs : XML!Attribute (
			name <- 'xmlns:xs',
			value <- 'http://www.w3.org/2001/XMLSchema'
		),
		targetNamespace : XML!Attribute (
			name <- 'targetNamespace',
			value <- 'http://www.bookingservice.com/schema'
		),
		xmlns : XML!Attribute (
			name <- 'xmlns',
			value <- 'http://www.bookingservice.com/schema'
		)
}

-- Lazy rule 'XsElementDeclaration'
-- Create XML element (xs:element) from the WSDL XsElementDeclaration element 
-- This rule is lazy rule, which means that is called from other rules
lazy rule XsElementDeclaration {
	from i : WSDL!XsElementDeclaration (
			i.oclIsTypeOf(WSDL!XsElementDeclaration)
		)
	to o : XML!Element (
		name <- 'xs:element',
		children <- Sequence { attrName, if i.typeDefinition.oclIsUndefined() then 
												OclUndefined
										 else if i.typeDefinition.oclIsKindOf(WSDL!XsComplexTypeDefinition) then
												i.typeDefinition
										 	  else 
										 		thisModule.XsSimpleTypeDefinition(i.typeDefinition)
											  endif
										 endif
							 }
		),
	attrName : XML!Attribute (
			name <- 'name',
			value <- i.name
		)
}

-- Lazy rule 'XsSimpleTypeDefinition'
-- Create XML attribute (xs:complexType) from the WSDL XsComplexTypeDefinition element
-- This rule is lazy rule, which means that is called from other rules
lazy rule XsSimpleTypeDefinition {
	from i : WSDL!XsSimpleTypeDefinition 
	to o : XML!Attribute (
			name <- 'type',
			value <- i.name
		)
}

-- Rule 'XsComplexTypeDefinition'
-- Create XML element (xs:complexType) from the WSDL XsComplexTypeDefinition element 
rule XsComplexTypeDefinition {
	from i : WSDL!XsComplexTypeDefinition (
			i.oclIsTypeOf(WSDL!XsComplexTypeDefinition)
		)
	to o : XML!Element (
		name <- 'xs:complexType',
		children <- Sequence { if not i.name.oclIsUndefined() then
									attrName 
								else OclUndefined
								endif,
								i.content.term
							 }
		),
	attrName : XML!Attribute (
			name <- 'name',
			value <- i.name
		)
}

-- Rule 'XsModelGroup'
-- Create XML element (xs:sequence) from the WSDL XsModelGroup element 
rule XsModelGroup {
	from i : WSDL!XsModelGroup (
			i.oclIsTypeOf(WSDL!XsModelGroup)
		)
	to o : XML!Element (
		name <- 'xs:sequence',
--		children <- Sequence { i.particles->asSequence()->collect(c | c.content)->flatten() }
		children <- let el : Set (WSDL!XsElementDeclaration) = i.particles->asSequence()->collect(c | c.content)->flatten() in
					if not el.isEmpty() then
						el->collect(e| thisModule.XsElementDec(e))
					else OclUndefined
					endif
		)
}

-- Lazy rule XsElementDec
-- This rule is lazy rule, which means that is called from other rules
lazy rule XsElementDec {
	from i : WSDL!XsElementDeclaration (
			i.oclIsTypeOf(WSDL!XsElementDeclaration)
		)
	to o : XML!Element (
		name <- 'xs:element',
		children <- Sequence {  if i.name.oclIsUndefined() then
									OclUndefined									
								else if i.resolvedElementDeclaration.oclIsUndefined() then
										attrName
					 				else OclUndefined
					 				endif
								endif,
								 if i.resolvedElementDeclaration.oclIsUndefined() then
									if i.typeDefinition.oclIsUndefined() then 
										OclUndefined
								 	else
									 	thisModule.XsSimpleTypeDefinition(i.typeDefinition)
									 endif
								 else
									resElemDecl
								 endif
							 }
		),
	attrName : XML!Attribute (
			name <- 'name',
			value <- i.name
		),
	resElemDecl : XML!Attribute (
			name <- 'ref',
			value <- if not i.resolvedElementDeclaration.oclIsUndefined() then
						i.resolvedElementDeclaration.name
					 else OclUndefined
					 endif
		)		
}

			
-- Rule 'Interface'
-- Create XML element (interface) from the WSDL Interface element 
rule Interface {
	from i : WSDL!Interface (
			i.oclIsTypeOf(WSDL!Interface)
		)
	to o : XML!Element (
			name <- 'interface',
			children <- Sequence { name,
								i.fault,
								i.operation
								}
		),
	name : XML!Attribute (
			name <- 'name',
			value <- i.name
		)
}

			
-- Rule 'InerfaceFault'
-- Create XML element (fault) from the WSDL.Interface.fault element 
rule InterfaceFault {
	from i : WSDL!Fault
	to o : XML!Element (
		name <- 'fault',
		children <- Sequence { name, element }
		),
	name : XML!Attribute (
			name <- 'name',
			value <- i.name
		),
	element : XML!Attribute (
			name <- 'element',
			value <- i.element.name
		)
}

-- Rule 'InerfaceOperation'
-- Create XML element (operation) from the WSDL.Interface.operation element 
rule InterfaceOperation {
	from i : WSDL!Operation
	to o : XML!Element (
		name <- 'operation',
		children <- Sequence { name, pattern,
								i.input,
								i.output,
								i.infault,
								i.outfault
							 }
		),
	name : XML!Attribute (
			name <- 'name',
			value <- i.name
		),
	pattern : XML!Attribute (
			name <- 'pattern',
			value <- thisModule.resolveMEP(i.pattern)
		)
}

-- Rule 'Input'
-- Create XML element (input) from the WSDL Input element 
rule Input {
	from i : WSDL!Input (
			i.oclIsTypeOf(WSDL!Input)
		)
	to o : XML!Element (
			name <- 'input',
			children <- Sequence { messageLabel, element}
		),
	messageLabel : XML!Attribute (
			name <- 'messageLabel',
			value <- i.messageLabel
		),
	element : XML!Attribute (
			name <- 'element',
			value <- i.element.name
		)
}

-- Rule 'Output'
-- Create XML element (output) from the WSDL Output element 
rule Output {
	from i : WSDL!Output (
			i.oclIsTypeOf(WSDL!Output)
		)
	to o : XML!Element (
			name <- 'output',
			children <- Sequence { messageLabel, element}
		),
	messageLabel : XML!Attribute (
			name <- 'messageLabel',
			value <- i.messageLabel
		),
	element : XML!Attribute (
			name <- 'element',
			value <- i.element.name
		)
}

-- Rule 'Outfault'
-- Create XML element (outfault) from the WSDL Outfault element 
rule Outfault {
	from i : WSDL!Outfault (
			i.oclIsTypeOf(WSDL!Outfault)
		)
	to o : XML!Element (
			name <- 'outfault',
			children <- Sequence { messageLabel, ref}
		),
	messageLabel : XML!Attribute (
			name <- 'messageLabel',
			value <- i.messageLabel
		),
	ref : XML!Attribute (
			name <- 'ref',
			value <- i.fault.name
		)
}

-- Rule 'Infault'
-- Create XML element (infault) from the WSDL Infault element 
rule Infault {
	from i : WSDL!Infault (
			i.oclIsTypeOf(WSDL!Infault)
		)
	to o : XML!Element (
			name <- 'Infault',
			children <- Sequence { messageLabel, ref}
		),
	messageLabel : XML!Attribute (
			name <- 'messageLabel',
			value <- i.messageLabel
		),
	ref : XML!Attribute (
			name <- 'ref',
			value <- i.fault.name
		)
}

-- Rule 'Binding'
-- Create XML element (binding) from the WSDL Binding element 
rule Binding {
	from i : WSDL!Binding (
			i.oclIsTypeOf(WSDL!Binding)
		)
	to o : XML!Element (
			name <- 'binding',
			children <- Sequence { name, type, wsoap_protocol,
								bindingInerface,					
								-- thisModule.BindingInterface(i),
								i.bindingFault,
								i.bindingOperation
								}
		),
	name : XML!Attribute (
			name <- 'name',
			value <- i.name
		),
	type : XML!Attribute (
			name <- 'type',
			value <- thisModule.resolveMessageFormat(i.type)
		),
	wsoap_protocol : XML!Attribute (
			name <- 'wsoap_protocol',
			value <- thisModule.resolveProtocol(i.wsoap_protocol)
		),
	bindingInerface : XML!Attribute (
			name <- 'interface',
			value <- i.interface.name
		)
}

-- Lazy rule 'BindingFault'
-- Create XML element (fault) from the WSDL BindingFault element 
rule BindingFault {
	from i : WSDL!BindingFault (
			i.oclIsTypeOf(WSDL!BindingFault)
		)
	to o : XML!Element (
		name <- 'fault',
		children <- Sequence { ref, wsoap_code }
		),
	wsoap_code : XML!Attribute (
			name <- 'wsoap:code',
			value <- thisModule.resolveFaultCodeEnum(i.wsoap_code)
		),
	ref : XML!Attribute (
			name <- 'ref',
			value <- i.fault.name
		)
}

-- Lazy rule 'BindingOperation'
-- Create XML element (operation) from the WSDL BindingOperation element 
rule BindingOperation {
	from i : WSDL!BindingOperation (
			i.oclIsTypeOf(WSDL!BindingOperation)
		)
	to o : XML!Element (
		name <- 'operation',
		children <- Sequence { ref, wsoap_mep }
		),
	wsoap_mep : XML!Attribute (
			name <- 'wsoap:mep',
			value <- thisModule.resolveSOAPMEP(i.wsoap_mep)
		),
	ref : XML!Attribute (
			name <- 'ref',
			value <- i.operation.name
		)
}


-- Rule 'Service'
-- Create XML element (service) from the WSDL Service element 
rule Service {
	from i : WSDL!Service (
			i.oclIsTypeOf(WSDL!Service)
		)
	to o : XML!Element (
			name <- 'service',
			children <- Sequence { name, 
 								   interface,
								   i.endpoint
								}
		),
	name : XML!Attribute (
			name <- 'name',
			value <- i.name
		),
	interface : XML!Attribute (
			name <- 'interface',
			value <- i.interface.name
		)
}

-- Rule 'Endpoint'
-- Create XML element (endpoint) from the WSDL Endpoint element 
rule Endpoint {
	from i : WSDL!Endpoint (
			i.oclIsTypeOf(WSDL!Endpoint)
		)
	to o : XML!Element (
			name <- 'endpoint',
			children <- Sequence { name, 
 								   binding,
								   address
								}
		),
	name : XML!Attribute (
			name <- 'name',
			value <- i.name
		),
	address : XML!Attribute (
			name <- 'address',
			value <- i.address
		),
	binding : XML!Attribute (
			name <- 'binding',
			value <- if not i.binding.oclIsUndefined() then
						i.binding.name
					 else 'temp_value'
					 endif
		)
}


",atlcompil atl transform wsdl metamodel xml metamodel creat part m sc these good old ai research group author marko ribar work wsdl metamodel v prof gerd wagner version todo modul wsdl xml modul templat creat out xml in wsdl helper helper resolvemep resolv mep type context thismodul in string out string helper def resolvemep valu string string valu inout http www w org wsdl els valu inon http www w org wsdl inon els valu outin http www w org wsdl els valu robustouton http www w org wsdl robustouton els valu outon http www w org wsdl outon els valu robust http www w org wsdl robustinon els valu outoptionalin http www w org wsdl outoptionalin els valu inoptionalout http www w org wsdl inoptionalout els oclundefin endif endif endif endif endif endif endif endif helper resolvemessageformat resolv messageformat type context thismodul in string out string helper def resolvemessageformat valu string string valu soap http www w org wsdl soap els valu http http www w org wsdl http els valu soap oclundefin els oclundefin endif endif endif helper resolveprotocol resolv protocol type context thismodul in string out string helper def resolveprotocol valu string string valu http http www w org soap bind http els valu smtp http www w org soap bind smtp els oclundefin endif endif helper resolvesoapmep resolv soapmep type context thismodul in string out string helper def resolvesoapmep valu string string valu requestrespons http www w org soap mep request respons els valu soaprespons http www w org soap mep soap respons els oclundefin endif endif helper resolvefaultcodeenum resolv faultcodeenum type context thismodul in string out string helper def resolvefaultcodeenum valu string string valu sender soap sender els oclundefin endif rule rule descript creat xml root element descript wsdl descript element rule descript wsdl descript oclistypeof wsdl descript xml root name descript children sequenc xmlns targetnamespac tns wsoap soap ex type interfac bind servic xmlns xml attribut name xmlns valu http www w org wsdl targetnamespac xml attribut name targetnamespac valu http www bookingservic com wsdl tns xml attribut name xmlns tns valu http www bookingservic com wsdl wsoap xml attribut name xmlns wsoap valu http www w org wsdl soap soap xml attribut name xmlns soap valu http www w org soap envelop ex xml attribut name xmlns ex valu http www bookingservic com schema rule type creat xml element type wsdl type element rule type wsdl elementtyp oclistypeof wsdl elementtyp xml element name type children sequenc schema rule xsschema creat xml element xsschema wsdl xsschema element rule xsschema wsdl xsschema oclistypeof wsdl xsschema xml element name xs schema children sequenc xs targetnamespac xmlns typedefinit elementdeclar collect e thismodul xselementdeclar e xs xml attribut name xmlns xs valu http www w org xmlschema targetnamespac xml attribut name targetnamespac valu http www bookingservic com schema xmlns xml attribut name xmlns valu http www bookingservic com schema lazi rule xselementdeclar creat xml element xs element wsdl xselementdeclar element this rule lazi rule mean call rule lazi rule xselementdeclar wsdl xselementdeclar oclistypeof wsdl xselementdeclar xml element name xs element children sequenc attrnam typedefinit oclisundefin oclundefin els typedefinit ocliskindof wsdl xscomplextypedefinit typedefinit els thismodul xssimpletypedefinit typedefinit endif endif attrnam xml attribut name name valu name lazi rule xssimpletypedefinit creat xml attribut xs complextyp wsdl xscomplextypedefinit element this rule lazi rule mean call rule lazi rule xssimpletypedefinit wsdl xssimpletypedefinit xml attribut name type valu name rule xscomplextypedefinit creat xml element xs complextyp wsdl xscomplextypedefinit element rule xscomplextypedefinit wsdl xscomplextypedefinit oclistypeof wsdl xscomplextypedefinit xml element name xs complextyp children sequenc name oclisundefin attrnam els oclundefin endif content term attrnam xml attribut name name valu name rule xsmodelgroup creat xml element xs sequenc wsdl xsmodelgroup element rule xsmodelgroup wsdl xsmodelgroup oclistypeof wsdl xsmodelgroup xml element name xs sequenc children sequenc particl assequ collect c c content flatten children let el set wsdl xselementdeclar particl assequ collect c c content flatten el isempti el collect e thismodul xselementdec e els oclundefin endif lazi rule xselementdec this rule lazi rule mean call rule lazi rule xselementdec wsdl xselementdeclar oclistypeof wsdl xselementdeclar xml element name xs element children sequenc name oclisundefin oclundefin els resolvedelementdeclar oclisundefin attrnam els oclundefin endif endif resolvedelementdeclar oclisundefin typedefinit oclisundefin oclundefin els thismodul xssimpletypedefinit typedefinit endif els reselemdecl endif attrnam xml attribut name name valu name reselemdecl xml attribut name ref valu resolvedelementdeclar oclisundefin resolvedelementdeclar name els oclundefin endif rule interfac creat xml element interfac wsdl interfac element rule interfac wsdl interfac oclistypeof wsdl interfac xml element name interfac children sequenc name fault oper name xml attribut name name valu name rule inerfacefault creat xml element fault wsdl interfac fault element rule interfacefault wsdl fault xml element name fault children sequenc name element name xml attribut name name valu name element xml attribut name element valu element name rule inerfaceoper creat xml element oper wsdl interfac oper element rule interfaceoper wsdl oper xml element name oper children sequenc name pattern input output infault outfault name xml attribut name name valu name pattern xml attribut name pattern valu thismodul resolvemep pattern rule input creat xml element input wsdl input element rule input wsdl input oclistypeof wsdl input xml element name input children sequenc messagelabel element messagelabel xml attribut name messagelabel valu messagelabel element xml attribut name element valu element name rule output creat xml element output wsdl output element rule output wsdl output oclistypeof wsdl output xml element name output children sequenc messagelabel element messagelabel xml attribut name messagelabel valu messagelabel element xml attribut name element valu element name rule outfault creat xml element outfault wsdl outfault element rule outfault wsdl outfault oclistypeof wsdl outfault xml element name outfault children sequenc messagelabel ref messagelabel xml attribut name messagelabel valu messagelabel ref xml attribut name ref valu fault name rule infault creat xml element infault wsdl infault element rule infault wsdl infault oclistypeof wsdl infault xml element name infault children sequenc messagelabel ref messagelabel xml attribut name messagelabel valu messagelabel ref xml attribut name ref valu fault name rule bind creat xml element bind wsdl bind element rule bind wsdl bind oclistypeof wsdl bind xml element name bind children sequenc name type wsoap protocol bindinginerfac thismodul bindinginterfac bindingfault bindingoper name xml attribut name name valu name type xml attribut name type valu thismodul resolvemessageformat type wsoap protocol xml attribut name wsoap protocol valu thismodul resolveprotocol wsoap protocol bindinginerfac xml attribut name interfac valu interfac name lazi rule bindingfault creat xml element fault wsdl bindingfault element rule bindingfault wsdl bindingfault oclistypeof wsdl bindingfault xml element name fault children sequenc ref wsoap code wsoap code xml attribut name wsoap code valu thismodul resolvefaultcodeenum wsoap code ref xml attribut name ref valu fault name lazi rule bindingoper creat xml element oper wsdl bindingoper element rule bindingoper wsdl bindingoper oclistypeof wsdl bindingoper xml element name oper children sequenc ref wsoap mep wsoap mep xml attribut name wsoap mep valu thismodul resolvesoapmep wsoap mep ref xml attribut name ref valu oper name rule servic creat xml element servic wsdl servic element rule servic wsdl servic oclistypeof wsdl servic xml element name servic children sequenc name interfac endpoint name xml attribut name name valu name interfac xml attribut name interfac valu interfac name rule endpoint creat xml element endpoint wsdl endpoint element rule endpoint wsdl endpoint oclistypeof wsdl endpoint xml element name endpoint children sequenc name bind address name xml attribut name name valu name address xml attribut name address valu address bind xml attribut name bind valu bind oclisundefin bind name els temp valu endif,7
238,238,P99-XML2R2ML.atl,"--@atlcompiler atl2006

--------------------------------------------------------------------------------
-- Transforms an XML metamodel into a R2ML metamodel.
-- Created as part of M.Sc. theses at GOOD OLD AI Research Group
-- Author: Milan Milanovic (milan@milanovic.org), Marko Ribaric (marko.ribaric@gmail.com)
-- Works for R2ML XML Schema and Metamodel v0.5-beta
--------------------------------------------------------------------------------
-- Version: 2.0 (General, Integrity & Derivation rule elements) - 6.11.2006.
-- Version: 2.1 (Reaction rule elements) - 01.02.2007.
--
-- TODO: 
--	1) Add support for Production rules
--
-- ANNOTATION: With MDR, Enumerations must be located in top-most package
--------------------------------------------------------------------------------
module XML2R2ML;
create OUT : R2ML from IN : XML;

uses XMLHelpers; -- General XML metamodel helpers

-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- XML2R2ML Transformation specific XML helpers

-- HELPER:	isNegated()
-- Returns a boolean that statement is XML!Element attribute XML!Attribute with name 'r2ml:isNegated' is true or false
-- contextual XML!Element.
-- CONTEXT:	XML!Element
-- OUT:		Boolean
helper context XML!Element def: isNegated() : Boolean =
	let kolekcija : Sequence(XML!Attribute) = self.children->select(c | c.oclIsKindOf(XML!Attribute) and c.name = 'r2ml:isNegated') in
	if kolekcija->isEmpty()
	then
		false
	else -- not empty
		let vred : String = kolekcija->first().value in
		if vred = 'true'
		then
			true
		else 
			false
		endif
	endif;

-- HELPER:	getAllRules()
-- Returns a sequence of all XML elements which name is IntegrityRule or DerivationRule or ReactionRule
-- CONTEXT:	thisModule
-- OUT:		Sequence of XML elements
helper def: getAllRules() : Sequence(XML!Element) = 
	XML!Element.allInstances()->select(e | e.name = 'r2ml:AlethicIntegrityRule' or e.name = 'r2ml:DeonticIntegrityRule' or e.name = 'r2ml:DerivationRule' or e.name = 'r2ml:ReactionRule')->asSequence();

-- HELPER: allSubElements
-- Returns a sequence of all XML sub elements for XML element, recursivelly
-- from this element to last element (children)
-- ANNOTATION: Based on ""Transforming Models with ATL"", Frederic Jouault, Ivan Kurtev.
-- CONTEXT:	XML!Element
-- OUT:		Sequence of XML elements
helper context XML!Element def : allSubElements : Sequence(XML!Element) = 
	let subElems : Sequence(XML!Element) = 
		XML!Element.allInstances()->select(c |      			-- 1. get all elements with this parent
			c.parent = self
		)->collect(elems | elems.allSubElements)->flatten()  in -- 2. for every element get subelements
		subElems->union( 										-- 3. when all subelements are apprehended 
																--    for every element, add topmost elements (child of this parent).
			self.children->select(ch | ch.oclIsTypeOf(XML!Element)
	    ))->flatten();

-- HELPER: allSubAttributes
-- Returns a sequence of all XML sub attributes for XML element, recursivelly
-- from this attribute to last attribute (children)
-- CONTEXT:	XML!Element
-- OUT:		Sequence of XML attributes
helper context XML!Element def : allSubAttributes : Sequence(XML!Attribute) = 
	let subAttrs : Sequence(XML!Attribute) = 
    	XML!Element.allInstances()->select(c | 
        	c.parent = self
		)->collect(attrs | attrs.allSubAttributes)->flatten()  in
		subAttrs->union(
			self.children->select(at | at.oclIsTypeOf(XML!Attribute)
		))->flatten();

-- HELPER: getRuleForElement()
-- Returns XML element (Rule, Integrity, Derivation or Reaction) which contains context-ual XML element
-- CONTEXT:	XML!Element
-- OUT:		XML element
helper context XML!Element def: getRuleForElement() : XML!Element = 
	thisModule.getAllRules()->select(c | c.allSubElements->includes(self))->asSequence()->first();

-- HELPER: getRuleForAttribute()
-- Returns XML element (Rule, Integrity of Derivation or Reaction) which contains context-ual XML attribute
-- CONTEXT:	XML!Attribute
-- OUT:		XML element
helper context XML!Attribute def: getRuleForAttribute() : XML!Element = 
	thisModule.getAllRules()->select(c | c.allSubAttributes->includes(self))->asSequence()->first();

-- HELPER:	getDefaultObjectVariable()
-- Return always first ObjectVariable with value
-- This is necessary for unique lazy rule that creates just one 
-- output ObjectVariable for multiple input (with same value)
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		XML!Element
helper def: getDefaultObjectVariable(elem : XML!Element, value: String) : XML!Element = 
	let objVar : Sequence(XML!Element) = elem.getRuleForElement().allSubElements->select(e | e.name = 'r2ml:ObjectVariable')->select(e | e.getAttrVal('r2ml:name') = value and e.hasAttr('r2ml:classID'))->asSequence() in 
	if objVar->isEmpty() then
		elem.getRuleForElement().allSubElements->select(e | e.name = 'r2ml:ObjectVariable')->select(e | e.getAttrVal('r2ml:name') = value)->asSequence()->first()
	else objVar->first()
	endif;

-- HELPER:	getDefaultDataVariable()
-- Same as previous but for Data variable
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		XML!Element
helper def: getDefaultDataVariable(elem: XML!Element, value: String) : XML!Element = 
	elem.getRuleForElement().allSubElements->select(e | e.name = 'r2ml:DataVariable')->select(e | e.getAttrVal('r2ml:name') = value)->asSequence()->first();

-- HELPER:	getDefaultGenericVariable()
-- Same as previous but for Variable
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		XML!Element
helper def: getDefaultGenericVariable(elem : XML!Element, value: String) : XML!Element = 
	elem.getRuleForElement().allSubElements->select(e | e.name = 'r2ml:Variable' or e.name = 'r2ml:GenericVariable')->select(e | e.getAttrVal('r2ml:name') = value)->asSequence()->first();
	
-- HELPER:	getDefaultGenericPredicate()
-- Always returns first predicate associated with GenericAtom
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		XML!Attribute
helper def: getDefaultGenericPredicate(attr : XML!Attribute, value: String) : XML!Attribute = 
	attr.getRuleForAttribute().allSubAttributes->select(e | e.name = 'r2ml:predicateID')->select(e | e.value = value)->asSequence()->first();

-- HELPER:	getDefaultAttribute()
-- Always returns first attribute associated with term
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		XML!Attribute
helper def: getDefaultAttribute(attr : XML!Attribute, value: String) : XML!Attribute = 
	attr.getRuleForAttribute().allSubAttributes->select(e | e.name = 'r2ml:attributeID')->select(e | e.value = value)->asSequence()->first();

-- HELPER:	getDefaultDataType()
-- Always returns first data type
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		XML!Attribute
helper def: getDefaultDataType(attr : XML!Attribute, value: String) : XML!Attribute = 
	attr.getRuleForAttribute().allSubAttributes->select(e | e.name = 'r2ml:datatypeID' or e.name = 'r2ml:type')->select(e | e.value = value)->asSequence()->first();

-- HELPER:	getAllObjectVariables()
-- Return all Object variables from input file
-- CONTEXT:	thisModule
-- OUT:		Sequence of XML Elements
helper def: getAllObjectVariables() : Sequence(XML!Element) = 
	XML!Element.allInstances()->select(e | e.name = 'r2ml:ObjectVariable' );

-- HELPER:	getAllDataVariables()
-- Return all Data variables from input file
-- CONTEXT:	thisModule
-- OUT:		Sequence of XML Elements
helper def: getAllDataVariables() : Sequence(XML!Element) = 
	XML!Element.allInstances()->select(e | e.name = 'r2ml:DataVariable');

-- HELPER:	getAllVariables()
-- Return all Variables from input file
-- CONTEXT:	thisModule
-- OUT:		Sequence of XML Elements
helper def: getAllVariables() : Sequence(XML!Element) = 
	XML!Element.allInstances()->select(e | e.name = 'r2ml:Variable' or e.name = 'r2ml:GenericVariable');


-- HELPER:	getDefaultMessageEventExpr()
-- Return always first MessageEventExpression with value
-- This is necessary for unique lazy rule that creates just one 
-- output ObjectVariable for multiple input (with same value)
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		XML!Element
helper def: getDefaultMessageEventExpr(eventType: String, sender: String) : XML!Element = 
	XML!Element.allInstances()->select(e | e.name = 'r2ml:MessageEventExpression' )->
		select(e | e.getAttrVal('r2ml:eventType') = eventType)->
		select(e | e.getAttrVal('r2ml:sender') = sender)->
		asSequence()->first();


-- HELPER:	getElementFromVocabulary()
-- Return Element from Vocabulary, whose ID equals the input parameter 
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		XML!Element
helper def: getElementFromVocabulary(value: String) : XML!Element = 
	let cla : Sequence(XML!Element) = XML!Element.allInstances()->select(e | e.name = 'r2mlv:Vocabulary')->asSequence() in
	if cla->isEmpty() then
		OclUndefined
	else
		cla->first().children->select(c | c.oclIsKindOf(XML!Element))->select(e | e.getAttrVal('r2mlv:ID') = value)->first()
	endif;

-- HELPER:	getDataTypefromVocabulary()
-- Return Datatype from Vocabulary, whose ID equals the input parameter 
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		XML!Element
helper def: getDataTypefromVocabulary(value: String) : XML!Element = 
	let cla : Sequence(XML!Element) = XML!Element.allInstances()->select(e | e.name = 'r2mlv:Vocabulary')->asSequence() in
	if cla->isEmpty() then
		OclUndefined
	else
		cla->first().allSubElements->select(c | c.name = 'r2mlv:Datatype')->select(e| e.getAttrVal('r2mlv:ID') = value )->first()
	endif;

-- HELPER:	getAttributefromVocabulary()
-- Return Attribute from Vocabulary, whose ID equals the input parameter 
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		XML!Element
helper def: getAttributefromVocabulary(value: String) : XML!Element = 
	let cla : Sequence(XML!Element) = XML!Element.allInstances()->select(e | e.name = 'r2mlv:Vocabulary')->asSequence() in
	if cla->isEmpty() then
		OclUndefined
	else	
		cla->first().allSubElements->select(e | e.name = 'r2mlv:Attribute')->select(c| c.getAttrVal('r2mlv:ID') = value)->first()
	endif;

-- HELPER:	getReferencePropertyfromVocabulary()
-- Return ReferenceProperty from Vocabulary, whose ID equals the input parameter 
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		XML!Element
helper def: getReferencePropertyfromVocabulary(value: String) : XML!Element = 
	let cla : Sequence(XML!Element) = XML!Element.allInstances()->select(e | e.name = 'r2mlv:Vocabulary')->asSequence() in
	if cla->isEmpty() then
		OclUndefined
	else	
		cla->first().allSubElements->select(e | e.name = 'r2mlv:ReferenceProperty')->select(c| c.getAttrVal('r2mlv:ID') = value)->first()
	endif;

-- HELPER:	getClassfromVocabulary()
-- Return Class from Vocabulary, whose ID equals the input parameter 
-- CONTEXT:	thisModule
-- IN:		String
-- OUT:		XML!Element
helper context XML!Element def: getClassfromVocabulary(value: String) : XML!Element = 
	let at : XML!Attribute = self.children->select(c | c.oclIsKindOf(XML!Attribute) and c.name = value)->first() in
	if not at.oclIsUndefined() then
		thisModule.getElementFromVocabulary(at.value)
	else OclUndefined
	endif;

-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'RuleBase'
-- Creates RuleBase from the Root element.
rule RuleBase {
	from
		i : XML!Element (
				i.name = 'r2ml:RuleBase'
			)		
	to
		o : R2ML!RuleBase (                 
				ruleBaseID <- i.getAttrVal('xmlns:r2ml'),
				rules <- i.children->select(c | c.oclIsKindOf(XML!Element) and ( c.name = 'r2ml:ProductionRuleSet'
					or c.name = 'r2ml:IntegrityRuleSet' or c.name = 'r2ml:DerivationRuleSet'
					or c.name = 'r2ml:ReactionRuleSet' ) )->asSequence(),
				vocabularies <- let voc : Set(XML!Element) = i.getElementsByName('r2mlv:Vocabulary') in
								if voc->isEmpty() then
							   		OclUndefined
						    	else
									i.getElementsByName('r2mlv:Vocabulary')->first()
								endif
		)
}

-- Rule 'DerivationRuleSet'
-- Creates DerivationRuleSet from an XML!Element named 'r2ml:DerivationRuleSet'.
rule DerivationRuleSet {
	from
		i : XML!Element(
				i.name = 'r2ml:DerivationRuleSet'
			)
		to
		o : R2ML!DerivationRuleSet (
				rules <- i.children->select(c | c.oclIsKindOf(XML!Element))->asSequence()
		)
}

-- Rule 'IntegrityRuleSet'
-- Creates IntegrityRuleSet from an XML!Element named 'r2ml:IntegrityRuleSet'.
rule IntegrityRuleSet {
	from
		i : XML!Element(
				i.name = 'r2ml:IntegrityRuleSet'
			)
		to
		o : R2ML!IntegrityRuleSet (
				rules <- i.children->select(c | c.oclIsKindOf(XML!Element))->asSequence()
			)		
}

-- Rule 'ReactionRuleSet'
-- Creates ReactionRuleSet from an XML!Element named 'r2ml:ReactionRuleSet'.
rule ReactionRuleSet {
	from
		i : XML!Element(
				i.name = 'r2ml:ReactionRuleSet'
			)
		to
		o : R2ML!ReactionRuleSet (
				rules <- i.children->select(c | c.oclIsKindOf(XML!Element))->asSequence(),
				ruleSetID <- i.getAttrVal('r2ml:ruleSetID')
			)		
}

-- Rule 'ProductionRuleSet'
-- Creates ProductionRuleSet from an XML!Element named 'r2ml:ProductionRuleSet'.
rule ProductionRuleSet {
	from
		i : XML!Element(
				i.name = 'r2ml:ProductionRuleSet'
			)
		to
		o : R2ML!ProductionRuleSet (
				rules <-  i.children->select(c | c.oclIsKindOf(XML!Element))->asSequence()
			)
}

-- Rule 'AlethicIntegrityRule'
-- Creates AlethicIntegrityRule from an XML!Element named 'r2ml:AlethicIntegrityRule'.
rule AlethicIntegrityRule { 
	from
		i : XML!Element (
				i.name = 'r2ml:AlethicIntegrityRule'
			)
  to
		o : R2ML!AlethicIntegrityRule (
				constraint <- i.getElementsByName('r2ml:constraint')->first().children->select(c | c.oclIsKindOf(XML!Element))->first(),
				ruleID <- if i.hasAttr('r2ml:ruleID') = true then
							i.getAttrVal('r2ml:ruleID')
						  else OclUndefined
						  endif
			)
}

-- Rule 'DeonticIntegrityRule'
-- Creates DeonticIntegrityRule from an XML!Element named 'r2ml:DeonticIntegrityRule'.
rule DeonticIntegrityRule { 
	from
		i : XML!Element (
				i.name = 'r2ml:DeonticIntegrityRule'
			)
  to
		o : R2ML!DeonticIntegrityRule (
				constraint <- i.getElementsByName('r2ml:constraint')->first().children->select(c | c.oclIsKindOf(XML!Element))->first(),
				ruleID <- if i.hasAttr('r2ml:ruleID') = true then
							i.getAttrVal('r2ml:ruleID')
						  else OclUndefined
						  endif
			)
}

-- Rule 'UniversallyQuantifiedFormula'
-- Creates UniversallyQuantifiedFormula from an XML!Element named 'r2ml:UniversallyQuantifiedFormula'.
rule UniversallyQuantifiedFormula {
	from i : XML!Element (
				i.name = 'r2ml:UniversallyQuantifiedFormula'
			)
  to
		o : R2ML!UniversallyQuantifiedFormula (
				-- ANNOTATION: Remark on this first time generating variable, we get ObjectVariable elements (children), then with helper getDefaultObjectVariable we get
				--             always same input element (Variable) with that name, and then call unique lazy rule ObjectVariable() to generate variable.
				variables <- Sequence { i.getElementsByName('r2ml:ObjectVariable')->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
									    i.getElementsByName('r2ml:DataVariable')->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e)) },
				formula <- i.children->select(e | thisModule.getAllDataVariables()->excludes(e) and thisModule.getAllObjectVariables()->excludes(e) and e.oclIsTypeOf(XML!Element))->first()
			)
}

-- Rule 'ExistentiallyQuantifiedFormula'
-- Creates ExistentiallyQuantifiedFormula from an XML!Element named 'r2ml:ExistentiallyQuantifiedFormula'.
rule ExistentiallyQuantifiedFormula {
	from i : XML!Element (
				i.name = 'r2ml:ExistentiallyQuantifiedFormula'
			)
  to
		o : R2ML!ExistentiallyQuantifiedFormula (
				variables <- Sequence { i.getElementsByName('r2ml:ObjectVariable')->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
										i.getElementsByName('r2ml:DataVariable')->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e)) },
				formula <- i.children->select(e | thisModule.getAllDataVariables()->excludes(e) and thisModule.getAllObjectVariables()->excludes(e) and e.oclIsTypeOf(XML!Element))->first()
			)
}

-- Rule 'Implication'
-- Creates Implication from an XML!Element named 'r2ml:Implication'.
rule Implication {
	from i : XML!Element (
				i.name = 'r2ml:Implication'
			)
    to
		o : R2ML!Implication (
				antecedent <- i.getElementsByName('r2ml:antecedent')->first().children->first(),
				consequent <- i.getElementsByName('r2ml:consequent')->first().children->first()
			)
}

-- Rule 'Conjuction'
-- Creates Conjuction from an XML!Element named 'r2ml:Conjuction'.
rule Conjuction {
	from i : XML!Element (
				i.name = 'r2ml:Conjunction'
			)
    to
		o : R2ML!Conjuction (
				formulas <- i.children->select(c | c.oclIsKindOf(XML!Element))->asSet()
			)
}

-- Rule 'Disjunction'
-- Creates Disjunction from an XML!Element named 'r2ml:Disjunction'.
rule Disjunction {
	from i : XML!Element (
				i.name = 'r2ml:Disjunction'
			)
    to
		o : R2ML!Disjunction (
				formulas <- i.children->select(c | c.oclIsKindOf(XML!Element))->asSet()
			)
}

-- Rule 'NegationAsFailure'
-- Creates NegationAsFailure from an XML!Element named 'r2ml:NegationAsFailure'.
rule NegationAsFailure {
	from i : XML!Element (
				i.name = 'r2ml:NegationAsFailure'
			)
    to
		o : R2ML!NegationAsFailure (
				formula <- i.children->select(c | c.oclIsKindOf(XML!Element))->first()
		)
}

-- Rule 'StrongNegation'
-- Creates StrongNegation from an XML!Element named 'r2ml:StrongNegation'.
rule StrongNegation {
	from i : XML!Element (
				i.name = 'r2ml:StrongNegation'
			)
    to
		o : R2ML!StrongNegation (
				formula <- i.children->select(c | c.oclIsKindOf(XML!Element))->first()
		)
}

-- Rule 'EqualityAtom'
-- Creates EqualityAtom from an XML!Element named 'r2ml:EqualityAtom'.
rule EqualityAtom {
	from i : XML!Element (
				i.name = 'r2ml:EqualityAtom'
			)
    to
		o : R2ML!EqualityAtom (
				terms <- Sequence { i.children->select(c | c.oclIsKindOf(XML!Element) and c.name = 'r2ml:ObjectVariable')->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
									i.children->select(c | c.oclIsKindOf(XML!Element) and c.name <> 'r2ml:ObjectVariable')				
								  }
			)
}

-- Rule 'InequalityAtom'
-- Creates InequalityAtom from an XML!Element named 'r2ml:InequalityAtom'.
rule InequalityAtom {
	from i : XML!Element (
				i.name = 'r2ml:InequalityAtom'
			)
    to
		o : R2ML!InequalityAtom (
				terms <- Sequence { i.children->select(c | c.oclIsKindOf(XML!Element) and c.name = 'r2ml:ObjectVariable')->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
									i.children->select(c | c.oclIsKindOf(XML!Element) and c.name <> 'r2ml:ObjectVariable')				
								  }
			)
}

-- Rule 'DerivationRule'
-- Creates DerivationRule from an XML!Element named 'r2ml:DerivationRule'.
rule DerivationRule { 
	from
		i : XML!Element (
				i.name = 'r2ml:DerivationRule'
			)
  to
		o : R2ML!DerivationRule (
				conditions <- i.getElementsByName('r2ml:conditions')->first().children->select(c | c.oclIsKindOf(XML!Element))->asSequence(),
				conclusions <- i.getElementsByName('r2ml:conclusion')->first(),
				ruleID <- if i.hasAttr('r2ml:ruleID') = true then
							i.getAttrVal('r2ml:ruleID')
						  else OclUndefined
						  endif
	)
}

-- Rule 'LiteralConjuction'
-- Creates atoms from an XML!Element named r2ml:DerivationRule conclusions'.
rule LiteralConjuction {
	from
		i : XML!Element (
				i.name = 'r2ml:conclusion'
			)
	to
		o : R2ML!LiteralConjunction (	     
				atoms <- i.children->select(c | c.oclIsKindOf(XML!Element))->asSet()
			)
}

-- Rule 'ClassRule'
-- Create Class from XML!Attribute 
-- This is lazy rule which is called from other rules
unique lazy rule ClassRule {
	from
		i : XML!Attribute 
	to
		cla : R2ML!Class (
			name <- i.value,
			predicateCategory <- #closed
		)
}

-- Rule 'DataClassificationAtom'
-- Creates DataClassificationAtom  from an XML!Element named 'r2ml:DataClassificationAtom'.
rule DataClassificationAtom {
	from i : XML!Element (
			i.name = 'r2ml:DataClassificationAtom'
		)
	to 
		obj : R2ML!DataClassificationAtom (
			isNegated <- i.isNegated(),
			type <- thisModule.DatatypeVoc(thisModule.getDataTypefromVocabulary(i.getAttrVal('r2ml:dataTypeID')) ),
			term <- i.children->select(c | c.oclIsKindOf(XML!Element) and c.name = 'r2ml:DataVariable')->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e))->first()			
		)
}

-- Rule 'ObjectVariable'
-- Creates ObjectVariable from an XML!Element named 'r2ml:ObjectVariable'.
-- This rule is unique lazy rule, which means that is called from other rules
unique lazy rule ObjectVariable {
	from i : XML!Element (
			i.name = 'r2ml:ObjectVariable'
		)
	to 
		ov : R2ML!ObjectVariable (
  	        name <- i.getAttrVal('r2ml:name'),
			typeCategory <- #individual,
			classRef <- i.getClassfromVocabulary('r2ml:classID')
		)		
}

-- Rule 'DataVariable'
-- Creates DataVariable from an XML!Element named 'r2ml:DataVariable'.
-- This rule is unique lazy rule, which means that is called from other rules
unique lazy rule DataVariable {
	from i : XML!Element (
			i.name = 'r2ml:DataVariable'
		)
	to 
		odv : R2ML!DataVariable (	
			datatypeRef <- if(i.hasAttr('r2ml:dataTypeID')) then
							thisModule.DatatypeVoc(thisModule.getDataTypefromVocabulary(i.getAttrVal('r2ml:dataTypeID')) )
						   else OclUndefined
						   endif,
			name <- i.getAttrVal('r2ml:name'),
			typeCategory <- if i.hasAttr('r2ml:typeCategory') = true then
								if i.getAttrVal('r2ml:typeCategory') = 'individual' then
									#individual
								else if i.getAttrVal('r2ml:typeCategory') = 'set' then
										#set
									 else if i.getAttrVal('r2ml:typeCategory') = 'order' then
									 		#orderedSet
										  else if i.getAttrVal('r2ml:typeCategory') = 'bag' then
										  		#bag
											   else if i.getAttrVal('r2ml:typeCategory') = 'sequence' then
											   		 #sequence
													else #individual
													endif
											   endif
										  endif
									 endif
								endif								
							else OclUndefined
							endif
		)		
}

-- Rule 'Datatype'
-- Creates Datatype from an XML!Attribute
-- This rule is unique lazy rule, which means that is called from other rules
unique lazy rule Datatype {
	from i : XML!Attribute 
	to o : R2ML!Datatype (
			predicateCategory <- #closed,
			name <- i.value
		)
}

-- Rule 'QFDisjunction'
-- Creates QFDisjunction from an XML!Element named 'r2ml:qf.Disjunction'.
rule QFDisjunction {
	from  i : XML!Element (
			i.name = 'r2ml:qf.Disjunction'
		)
	to
		o : R2ML!QFDisjunction (
				formulas <- i.children->select(c | c.oclIsKindOf(XML!Element))->asSequence()
			)
}

-- Rule 'QFConjunction'
-- Creates QFConjunction from an XML!Element named 'r2ml:qf.Conjunction'.
rule QFConjunction {
	from  i : XML!Element (
			i.name = 'r2ml:qf.Conjuction'
		)
	to
		o : R2ML!QFConjunction (
			formulas <- i.children->select(c | c.oclIsKindOf(XML!Element))->asSequence()
			)
}

-- Rule 'QFNegationAsFailure'
-- Creates QFNegationAsFailure from an XML!Element named 'r2ml:qf.NegationAsFailure'.
rule QFNegationAsFailure {
	from i : XML!Element (
				i.name = 'r2ml:qf.NegationAsFailure'
			)
    to
		o : R2ML!QFNegationAsFailure (
				formula <- i.children->select(c | c.oclIsKindOf(XML!Element))->first()
		)
}

-- Rule 'QFStrongNegation'
-- Creates QFStrongNegation from an XML!Element named 'r2ml:qf.StrongNegation'.
rule QFStrongNegation {
	from i : XML!Element (
				i.name = 'r2ml:qf.StrongNegation'
			)
    to
		o : R2ML!QFStrongNegation (
				formula <- i.children->select(c | c.oclIsKindOf(XML!Element))->first()
		)
}

-- Rule 'DatatypePredicateAtom'
-- Creates DatatypePredicateAtom from an XML!Element named 'r2ml:DatatypePredicateAtom' or 'r2ml:DataPredicateAtom'.
rule DatatypePredicateAtom {
	from i : XML!Element (
		-- r2ml v0.1
		i.name = 'r2ml:DataPredicateAtom' or 
		-- r2ml v0.2
		i.name = 'r2ml:DatatypePredicateAtom'
		)
	to 
		o : R2ML!DatatypePredicateAtom (
			dataArguments <- Sequence{ i.getElementsByName('r2ml:dataArguments')->first().children->select(e | thisModule.getAllDataVariables()->includes(e))->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e)), 
				                       i.getElementsByName('r2ml:dataArguments')->first().children->select(e | not thisModule.getAllDataVariables()->includes(e))->asSequence()},
			predicate <- i.children->select(c | c.oclIsKindOf(XML!Attribute) and c.name = 'r2ml:dataPredicateID' or c.name = 'r2ml:datatypePredicateID')->collect(e | thisModule.DatatypePredicateRule(e))->first(),
			isNegated <- i.isNegated()
		)
}

-- Rule 'DatatypePredicateRule'
-- Creates DatatypePredicateRule from an XML!Attribute
-- This rule is unique lazy rule, which means that is called from other rules
unique lazy rule DatatypePredicateRule {
	from i : XML!Attribute
	to  
		dtp : R2ML!DatatypePredicate (
			predicateCategory <- #closed,
			name <- i.value
		)		
}

-- Rule 'DataOperationTerm'
-- Creates DataOperationTerm from an XML!Element named 'r2ml:DataOperationTerm'.
rule DataOperationTerm {
	from i : XML!Element (
			i.name = 'r2ml:DataOperationTerm'
		)
	to 
		o : R2ML!DataOperationTerm (
			dataOperationRef <- opr,
			arguments <- let args : Set(XML!Element) = i.getElementsByName('r2ml:arguments') in
							if args->isEmpty() then
							   Sequence {}
							-- ANNOTATION: First we get ObjectVariables, then DataVariables, and all elements which are not ObjectVariables or DataVariables
						    else Sequence { args->first().children->select(e | thisModule.getAllDataVariables()->includes(e))->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e)),
						    	            args->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
											args->first().children->select(e | not thisModule.getAllDataVariables()->includes(e) and not thisModule.getAllObjectVariables()->includes(e))->asSequence()
						         }
							endif,
			contextArgument <- let conArg : Set(XML!Element) = i.getElementsByName('r2ml:contextArgument') in
							       if conArg->isEmpty() then
							           OclUndefined	            
							       else Sequence { conArg->first().children->asSequence()->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first(),
							       				   conArg->first().children->asSequence()->select(e | thisModule.getAllObjectVariables()->excludes(e))
							       				 }->select(c | not c.oclIsUndefined())->asSequence()->first()
								   endif,
			typeCategory <- if i.hasAttr('r2ml:typeCategory') = true then
								if i.getAttrVal('r2ml:typeCategory') = 'individual' then
									#individual
								else if i.getAttrVal('r2ml:typeCategory') = 'set' then
										#set
									 else if i.getAttrVal('r2ml:typeCategory') = 'order' then
									 		#orderedSet
										  else if i.getAttrVal('r2ml:typeCategory') = 'bag' then
										  		#bag
											   else if i.getAttrVal('r2ml:typeCategory') = 'sequence' then
											   		 #sequence
													else OclUndefined
													endif
											   endif
										  endif
									 endif
								endif								
							else OclUndefined
							endif
			),
		opr : R2ML!DataOperation (
			name <- i.getAttrVal('r2ml:operationID')
			)
}

-- Rule 'TypedLiteral'
-- Creates TypedLiteral from an XML!Element named 'r2ml:TypedLiteral'.
rule TypedLiteral {
	from i : XML!Element (
			i.name = 'r2ml:TypedLiteral'
		)
	to 
		o : R2ML!TypedLiteral (
				lexicalValue <- i.getAttrVal('r2ml:lexicalValue'),
				type <- thisModule.DatatypeVoc(thisModule.getDataTypefromVocabulary(i.getAttrVal('r2ml:datatypeID')) ),
				typeCategory <- if i.hasAttr('r2ml:typeCategory') = true then
									if i.getAttrVal('r2ml:typeCategory') = 'individual' then
										#individual
									else if i.getAttrVal('r2ml:typeCategory') = 'set' then
											#set
										 else if i.getAttrVal('r2ml:typeCategory') = 'order' then
										 		#orderedSet
											  else if i.getAttrVal('r2ml:typeCategory') = 'bag' then
											  		#bag
												   else if i.getAttrVal('r2ml:typeCategory') = 'sequence' then
												   		 #sequence
														else OclUndefined
														endif
												   endif
											  endif
										 endif
									endif								
								else OclUndefined
								endif
			)
}

-- Rule 'PlainLiteral'
-- Creates PlainLiteral from an XML!Element named 'r2ml:PlainLiteral'.
rule PlainLiteral {
	from i : XML!Element (
			i.name = 'r2ml:PlainLiteral'
		)
	to 
		o : R2ML!PlainLiteral (
				lexicalValue <- i.getAttrVal('r2ml:lexicalValue'),
				languageTag <- i.getAttrVal('r2ml:languageTag'),
				typeCategory <- if i.hasAttr('r2ml:typeCategory') = true then
									if i.getAttrVal('r2ml:typeCategory') = 'individual' then
										#individual
									else if i.getAttrVal('r2ml:typeCategory') = 'set' then
											#set
										 else if i.getAttrVal('r2ml:typeCategory') = 'order' then
										 		#orderedSet
											  else if i.getAttrVal('r2ml:typeCategory') = 'bag' then
											  		#bag
												   else if i.getAttrVal('r2ml:typeCategory') = 'sequence' then
												   		 #sequence
														else OclUndefined
														endif
												   endif
											  endif
										 endif
									endif								
								else OclUndefined
								endif
			)
}

-- Rule 'AssociationAtom'
-- Creates AssociationAtom from an XML!Element named 'r2ml:AssociationAtom'
-- This rule is some complicated, because it is possible that object or data
-- arguments does not exists in input file, so this must be checked first (with let expression).
rule AssociationAtom {
	from i : XML!Element (
		i.name = 'r2ml:AssociationAtom'
		)
	to 
		o : R2ML!AssociationAtom (
			isNegated <- i.isNegated(),
			objectArguments <- let objArgs : Set(XML!Element) = i.getElementsByName('r2ml:objectArguments') in
							       if objArgs->isEmpty() then
								   	  Sequence{}
  						           else Sequence{ objArgs->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)), 
				                                  objArgs->first().children->select(e | thisModule.getAllObjectVariables()->excludes(e))->asSequence()}
								   endif,
			dataArguments <- let dataArgs : Set(XML!Element) = i.getElementsByName('r2ml:dataArguments') in
							     if dataArgs->isEmpty() then
							 	    Sequence{}
						         else Sequence { dataArgs->first().children->asSequence()->select(c | thisModule.getAllDataVariables()->includes(c))->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e)), 
						         				 dataArgs->first().children->asSequence()->select(c | thisModule.getAllDataVariables()->excludes(c))->asSequence()
										       }
						         endif,
			associationPredicate <- asp
			),
		asp : R2ML!AssociationPredicate (
				name <- i.getAttrVal('r2ml:associationPredicateID')
			)
}

-- Rule 'ReferencePropertyFunctionTerm'
-- Creates ReferencePropertyFunctionTerm from an XML!Element named 'r2ml:ReferencePropertyFunctionTerm'.
rule ReferencePropertyFunctionTerm {
	from i : XML!Element (
			i.name = 'r2ml:RoleFunctionTerm' -- v0.3
			or i.name = 'r2ml:ReferencePropertyFunctionTerm' -- v0.4
		)
	to 
		o : R2ML!ReferencePropertyFunctionTerm (
				referencePropertyRef <- thisModule.getReferencePropertyfromVocabulary(i.getAttrVal('r2ml:referencePropertyID')),
				contextArgument <- Sequence { i.getElementsByName('r2ml:contextArgument')->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first(),
											  i.getElementsByName('r2ml:contextArgument')->first().children->select(e | thisModule.getAllObjectVariables()->excludes(e))->first()
											 }->select(c | not c.oclIsUndefined())->asSequence()->first(),
				typeCategory <- if i.hasAttr('r2ml:typeCategory') = true then
									if i.getAttrVal('r2ml:typeCategory') = 'individual' then
										#individual
									else if i.getAttrVal('r2ml:typeCategory') = 'set' then
											#set
										 else if i.getAttrVal('r2ml:typeCategory') = 'order' then
										 		#orderedSet
											  else if i.getAttrVal('r2ml:typeCategory') = 'bag' then
											  		#bag
												   else if i.getAttrVal('r2ml:typeCategory') = 'sequence' then
												   		 #sequence
														else OclUndefined
														endif
												   endif
											  endif
										 endif
									endif								
								else OclUndefined
								endif
			)
}

-- Rule 'AttributionAtom'
-- Creates AttributionAtom from an XML!Element named 'r2ml:AttributionAtom'.
rule AttributionAtom {
	from i : XML!Element (
			i.name = 'r2ml:AttributionAtom'
		)
	to 
		o : R2ML!AttributionAtom (
			isNegated <- i.isNegated(),
			dataValue <- let val : XML!Element = i.getElementsByName('r2ml:dataValue')->first().children->first() in
							if val.name = 'r2ml:DataVariable'			
								then i.getElementsByName('r2ml:dataValue')->first().children->select(e | thisModule.getAllDataVariables()->includes(e))->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e))->first()
								else i.getElementsByName('r2ml:dataValue')->first().children->select(e | not thisModule.getAllDataVariables()->includes(e))->first()
							endif,
			subject <- Sequence { i.getElementsByName('r2ml:subject')->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first(),
								  i.getElementsByName('r2ml:subject')->first().children->select(e | thisModule.getAllObjectVariables()->excludes(e))
							}->select(c | not c.oclIsUndefined())->asSequence()->first(),
			-- here we can have an attribute that is not in the Vocabulary !!!			
			attribute <- let atr: XML!Element = thisModule.getAttributefromVocabulary(i.getAttrVal('r2ml:attributeID')) in
						if not atr.oclIsUndefined() then 
							atr
						else	
							thisModule.Attribute(thisModule.getDefaultAttribute(i.getAttr('r2ml:attributeID'), i.getAttrVal('r2ml:attributeID')))
						endif
			)
}

-- Rule 'Attribute'
-- Creates Attribute from an XML!Attribute named 'r2ml:attributeID'.
unique lazy rule Attribute {
	from i : XML!Attribute 
	to o : R2ML!Attribute (	
			predicateCategory <- #closed,
			name <- i.value
		)
}

-- Rule 'ReferencePropertyAtom'
-- Creates ReferencePropertyAtom from an XML!Element named 'r2ml:ReferencePropertyAtom'.
rule ReferencePropertyAtom {
	from i : XML!Element (
			i.name = 'r2ml:ReferencePropertyAtom'
		)
	to 
		o : R2ML!ReferencePropertyAtom (
				isNegated <- i.isNegated(),
				referenceProperty <- thisModule.getReferencePropertyfromVocabulary(i.getAttrVal('r2ml:referencePropertyID')),
				subject <- Sequence { i.getElementsByName('r2ml:subject')->first().children->select(c | thisModule.getAllObjectVariables()->includes(c))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first(),
							 		  i.getElementsByName('r2ml:subject')->first().children->select(c | thisModule.getAllObjectVariables()->excludes(c))
							 		}->select(c | not c.oclIsUndefined())->asSequence()->first(),
				object <- Sequence { i.getElementsByName('r2ml:object')->first().children->select(c | thisModule.getAllObjectVariables()->includes(c))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first(),
							 		 i.getElementsByName('r2ml:object')->first().children->select(c | thisModule.getAllObjectVariables()->excludes(c))
								   }->select(c | not c.oclIsUndefined())->asSequence()->first()
			)
}

-- Rule 'ReferenceProperty'
-- Creates ReferenceProperty element from an XML!Attribute
-- This rule is unique lazy rule, which means that is called from other rules
unique lazy rule ReferenceProperty {
	from i : XML!Attribute 
	to rfp: R2ML!ReferenceProperty (
				predicateCategory <- #closed,
	    		name <- i.value
	    	)
}

-- Rule 'GenericAtom'
-- Creates GenericAtom element from an XML!Element named 'r2ml:GenericAtom'
rule GenericAtom {
	from i : XML!Element (
			i.name = 'r2ml:GenericAtom'
		)
	to 
		o : R2ML!GenericAtom (
				arguments <- Sequence{ i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllVariables()->includes(e))->collect(e | thisModule.getDefaultGenericVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.GenericVariable(e)), 
					 				   i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllDataVariables()->includes(e))->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e)),
					 				   i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
					                   i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllVariables()->excludes(e) and thisModule.getAllDataVariables()->excludes(e) and thisModule.getAllObjectVariables()->excludes(e))->asSequence()},
				predicate <- thisModule.GenericPredicate(thisModule.getDefaultGenericPredicate(i.getAttr('r2ml:predicateID'), i.getAttrVal('r2ml:predicateID')))
		)
}

-- Rule 'GenericPredicate'
-- Creates Predicate element from an XML!Element named 'r2ml:GenericPredicate'
-- This rule is unique lazy rule, which means that is called from other rules
unique lazy rule GenericPredicate {
	from i : XML!Attribute
	to  
		pre : R2ML!GenericPredicate (
				name <- i.value,
				predicateTypeID <- let pt : String = i.parent.getAttrVal('r2ml:predicateType') in
										if pt <> OclUndefined then
											if pt = 'ObjectClassificationPredicate' then
												#ObjectClassificationPredicate
											else if pt = 'AttributionPredicate' then
													#AttributionPredicate
												 else if pt = 'AssociationPredicate' then
												 	  	#AssociationPredicate
													  else if pt = 'ReferencePropertyPredicate' then
													  	   #ReferencePropertyPredicate
														   else if pt = 'EqualityPredicate' then
														   		#EqualityPredicate
																else if pt = 'InequalityPredicate' then
																		#InequalityPredicate
																	 else if pt = 'DatatypePredicate' then
																	 		#DatatypePredicate
																		  else if pt = 'DataClassificationPredicate' then
																		  		#DataClassificationPredicate
																			   else OclUndefined
																			   endif
																		  endif
																	 endif
																endif 
														   endif
													  endif
												 endif 
											endif
										else OclUndefined
										endif
		)		
}

-- Rule 'GenericVariable'
-- Creates GenericVariable element from an XML!Element named 'r2ml:Variable' or 'r2ml:GenericVariable'
-- This rule is unique lazy rule, which means that it's called from other rules
unique lazy rule GenericVariable {
	from i : XML!Element 
	to 
		o : R2ML!GenericVariable (
				name <- i.getAttrVal('r2ml:name'),
				typeRef <- if i.hasAttr('r2ml:dataTypeID') then 
								thisModule.DatatypeVoc(thisModule.getDataTypefromVocabulary(i.getAttrVal('r2ml:dataTypeID')) )
						   else OclUndefined
						   endif
			)
}

-- Rule 'GenericFunctionTerm'
-- Creates GenericFunctionTerm element from an XML!Element named 'r2ml:FunctionTerm' or 'r2ml:GenericFunctionTerm'
rule GenericFunctionTerm {
	from i : XML!Element (
			i.name = 'r2ml:FunctionTerm' -- v0.3
			or i.name = 'r2ml:GenericFunctionTerm' -- v0.4
		)
	to 
		o : R2ML!GenericFunctionTerm (
				arguments <- Sequence{ i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllVariables()->includes(e))->collect(e | thisModule.getDefaultGenericVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.GenericVariable(e)), 
				   		               i.getElementsByName('r2ml:arguments')->first().children->select(e | not thisModule.getAllVariables()->includes(e))->asSequence()},
				functor <- fun,
				typeCategory <- if i.hasAttr('r2ml:typeCategory') = true then
									if i.getAttrVal('r2ml:typeCategory') = 'individual' then
										#individual
									else if i.getAttrVal('r2ml:typeCategory') = 'set' then
											#set
										 else if i.getAttrVal('r2ml:typeCategory') = 'order' then
										 		#orderedSet
											  else if i.getAttrVal('r2ml:typeCategory') = 'bag' then
											  		#bag
												   else if i.getAttrVal('r2ml:typeCategory') = 'sequence' then
												   		 #sequence
														else OclUndefined
														endif
												   endif
											  endif
										 endif
									endif								
								else OclUndefined
								endif
		),
		fun : R2ML!GenericFunction (
				name <- i.getAttrVal('r2ml:genericFunctionID')
			)
}

-- Rule 'DatatypeFunctionTerm'
-- Creates DatatypeFunctionTerm element from an XML!Element named 'r2ml:DatatypeFunctionTerm'
rule DatatypeFunctionTerm {
	from i : XML!Element (
			i.name = 'r2ml:DatatypeFunctionTerm'
		)
	to o : R2ML!DatatypeFunctionTerm (
			dataArguments <- Sequence{ i.getElementsByName('r2ml:dataArguments')->first().children->select(e | thisModule.getAllDataVariables()->includes(e))->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e))->first(), 
				                       i.getElementsByName('r2ml:dataArguments')->first().children->select(e | not thisModule.getAllDataVariables()->includes(e))->asSequence()},
			function <- dtf,
			typeCategory <- if i.hasAttr('r2ml:typeCategory') = true then
								if i.getAttrVal('r2ml:typeCategory') = 'individual' then
									#individual
								else if i.getAttrVal('r2ml:typeCategory') = 'set' then
										#set
									 else if i.getAttrVal('r2ml:typeCategory') = 'order' then
									 		#orderedSet
										  else if i.getAttrVal('r2ml:typeCategory') = 'bag' then
										  		#bag
											   else if i.getAttrVal('r2ml:typeCategory') = 'sequence' then
											   		 #sequence
													else OclUndefined
													endif
											   endif
										  endif
									 endif
								endif								
							else OclUndefined
							endif
		),
	dtf : R2ML!DatatypeFunction (
			name <- i.getAttrVal('r2ml:datatypeFunctionID')
		)
}

-- Rule 'ObjectName'
-- Creates ObjectName element from an XML!Element named 'r2ml:ObjectName'
rule ObjectName {
	from i : XML!Element (
			i.name = 'r2ml:ObjectName'
		)
	to o : R2ML!ObjectName (
			name <- i.getAttrVal('r2ml:objectID'),
			classRef <- i.getClassfromVocabulary('r2ml:classID'),
			typeCategory <- if i.hasAttr('r2ml:typeCategory') = true then
								if i.getAttrVal('r2ml:typeCategory') = 'individual' then
									#individual
								else if i.getAttrVal('r2ml:typeCategory') = 'set' then
										#set
									 else if i.getAttrVal('r2ml:typeCategory') = 'order' then
									 		#orderedSet
										  else if i.getAttrVal('r2ml:typeCategory') = 'bag' then
										  		#bag
											   else if i.getAttrVal('r2ml:typeCategory') = 'sequence' then
											   		 #sequence
													else OclUndefined
													endif
											   endif
										  endif
									 endif
								endif								
							else OclUndefined
							endif
		)
}

-- Rule 'ObjectDescriptionAtom'
-- Creates ObjectDescriptionAtom element from an XML!Element named 'r2ml:ObjectDescriptionAtom'
rule ObjectDescriptionAtom {
	from i : XML!Element (
			i.name = 'r2ml:ObjectDescriptionAtom'
		)
	to o : R2ML!ObjectDescriptionAtom (
				isNegated <- i.isNegated(),
				type <- i.getClassfromVocabulary('r2ml:classID'),
				slots <- Sequence{ i.getElementsByName('r2ml:DataSlot')->first().children->asSequence(),
								   i.getElementsByName('r2ml:ObjectSlot')->first().children->asSequence() },
				subject <- Sequence { i.getElementsByName('r2ml:subject')->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first(),
								      i.getElementsByName('r2ml:subject')->first().children->select(e | thisModule.getAllObjectVariables()->excludes(e))
							        }->select(c | not c.oclIsUndefined())->asSequence()->first(),
				objects <- i.getElementsByName('r2ml:objects')->first().children->asSequence(),
				baseType <- if i.hasAttr('r2ml:baseType') then
								i.getClassfromVocabulary('r2ml:baseType')
							else OclUndefined
							endif
			)
}

-- Rule 'ObjectSlot'
-- Creates ObjectSlot element from an XML!Element named 'r2ml:ObjectSlot'
rule ObjectSlot {
	from i : XML!Element (
			i.name = 'r2ml:ObjectSlot'
		)
	to 
		o : R2ML!ObjectSlot (
				object <- Sequence { i.getElementsByName('r2ml:object')->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first(),
								     i.getElementsByName('r2ml:object')->first().children->select(e | thisModule.getAllObjectVariables()->excludes(e))
							       }->select(c | not c.oclIsUndefined())->asSequence()->first(),
				referenceProperty <- thisModule.getReferencePropertyfromVocabulary(i.getAttrVal('r2ml:referencePropertyID'))
			) 
}

-- Rule 'DataSlot'
-- Creates DataSlot element from an XML!Element named 'r2ml:DataSlot'
rule DataSlot {
	from i : XML!Element (
			i.name = 'r2ml:DataSlot'
		)
	to 
		o : R2ML!DataSlot (
				value <- Sequence { i.getElementsByName('r2ml:value')->first().children->select(e | thisModule.getAllDataVariables()->includes(e))->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e))->first(),
									i.getElementsByName('r2ml:value')->first().children->select(e | thisModule.getAllDataVariables()->excludes(e))->first()
								  }->select(c | not c.oclIsUndefined())->asSequence()->first(),
				attribute <- thisModule.getAttributefromVocabulary(i.getAttrVal('r2ml:attributeID'))
			) 
}

-- Rule 'AtLeastQuantifiedFormula'
-- Creates AtLeastQuantifiedFormula from an XML!Element named 'r2ml:AtLeastQuantifiedFormula'.
rule AtLeastQuantifiedFormula {
	from i : XML!Element (
				i.name = 'r2ml:AtLeastQuantifiedFormula'
			)
  to
		o : R2ML!AtLeastQuantifiedFormula (
				variables <- Sequence { i.getElementsByName('r2ml:ObjectVariable')->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
									    i.getElementsByName('r2ml:DataVariable')->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e)) },
				formula <- i.children->select(e | thisModule.getAllDataVariables()->excludes(e) and thisModule.getAllObjectVariables()->excludes(e) and e.oclIsTypeOf(XML!Element))->first(),
				minCardinality <- i.getAttrVal('r2ml:minCardinality').toInteger()
			)
}

-- Rule 'AtMostQuantifiedFormula'
-- Creates AtMostQuantifiedFormula from an XML!Element named 'r2ml:AtMostQuantifiedFormula'.
rule AtMostQuantifiedFormula {
	from i : XML!Element (
				i.name = 'r2ml:AtMostQuantifiedFormula'
			)
  to
		o : R2ML!AtMostQuantifiedFormula (
				variables <- Sequence { i.getElementsByName('r2ml:ObjectVariable')->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
									    i.getElementsByName('r2ml:DataVariable')->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e)) },
				formula <- i.children->select(e | thisModule.getAllDataVariables()->excludes(e) and thisModule.getAllObjectVariables()->excludes(e) and e.oclIsTypeOf(XML!Element))->first(),
				maxCardinality <- i.getAttrVal('r2ml:maxCardinality').toInteger()
			)
}

-- Rule 'AtLeastAndAtMostQuantifiedFormula'
-- Creates AtLeastAndAtMostQuantifiedFormula from an XML!Element named 'r2ml:AtLeastAndAtMostQuantifiedFormula'.
rule AtLeastAndAtMostQuantifiedFormula {
	from i : XML!Element (
				i.name = 'r2ml:AtLeastAndAtMostQuantifiedFormula'
			)
  to
		o : R2ML!AtLeastAndAtMostQuantifiedFormula (
				variables <- Sequence { i.getElementsByName('r2ml:ObjectVariable')->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
									    i.getElementsByName('r2ml:DataVariable')->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e)) },
				formula <- i.children->select(e | thisModule.getAllDataVariables()->excludes(e) and thisModule.getAllObjectVariables()->excludes(e) and e.oclIsTypeOf(XML!Element))->first(),
				maxCardinality <- i.getAttrVal('r2ml:maxCardinality').toInteger(),
				minCardinality <- i.getAttrVal('r2ml:minCardinality').toInteger()
			)
}

-- Rule 'ObjectOperationTerm'
-- Creates ObjectOperationTerm from an XML!Element named 'r2ml:ObjectOperationTerm'.
rule ObjectOperationTerm {
	from i : XML!Element (
			i.name = 'r2ml:ObjectOperationTerm'
		)
	to o : R2ML!ObjectOperationTerm (
			operation <- thisModule.ObjectOperation(i.getAttr('r2ml:operationID')),
			arguments <- Sequence { i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
									i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllDataVariables()->includes(e))->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e)),
								    i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllObjectVariables()->excludes(e) and thisModule.getAllDataVariables()->excludes(e))
 							      },
			contextArgument <- Sequence { i.getElementsByName('r2ml:contextArgument')->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first(),
										  i.getElementsByName('r2ml:contextArgument')->first().children->select(e | thisModule.getAllObjectVariables()->excludes(e))->first()
									    }->select(c | not c.oclIsUndefined())->asSequence()->first()
		)
}

-- Lazy Rule 'ObjectOperation'
-- Creates ObjectOperation from an XML!Element named attribute of 'r2ml:ObjectOperationTerm'.
unique lazy rule ObjectOperation {
	from i : XML!Attribute
	to o : R2ML!ObjectOperation (
			name <- i.value
		)
}

-- Rule 'DataOperationTerm'
-- Creates DataOperationTerm from an XML!Element named 'r2ml:DataOperationTerm'.
rule DataOperationTerm {
	from i : XML!Element (
			i.name = 'r2ml:DataOperationTerm'
		)
	to o : R2ML!DataOperationTerm (
			dataOperationRef <- thisModule.DataOperation(i.getAttr('r2ml:operationID')),
			arguments <- Sequence { i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
									i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllDataVariables()->includes(e))->collect(e | thisModule.getDefaultDataVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.DataVariable(e)),
								    i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllObjectVariables()->excludes(e) and thisModule.getAllDataVariables()->excludes(e))
 							      },
			contextArgument <- Sequence { i.getElementsByName('r2ml:contextArgument')->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first(),
										  i.getElementsByName('r2ml:contextArgument')->first().children->select(e | thisModule.getAllObjectVariables()->excludes(e))->first()
									    }->select(c | not c.oclIsUndefined())->asSequence()->first()
		)
}

-- Lazy Rule 'DataOperation'
-- Creates DataOperation from an XML!Element named attribute of 'r2ml:DataOperationTerm'.
unique lazy rule DataOperation {
	from i : XML!Attribute
	to o : R2ML!DataOperation (
			name <- i.value
		)
}

						
-------------------------------------------------------------------------------
-- VOCABULARY -------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'Vocabulary'
-- Creates Vocabulary from the Vocabulary element.
rule Vocabulary {
	from
		i : XML!Element (
				i.name = 'r2mlv:Vocabulary'
			)		
	to
		o : R2ML!Vocabulary (                 
				entries <- i.children->select(c | c.oclIsKindOf(XML!Element))->asSequence()
		)
}

-- Rule 'ClassR'
-- Creates Class from the Class element.
rule ClassR {
	from
		i : XML!Element (
				i.name = 'r2mlv:Class' and
				if not i.parent.oclIsUndefined() then
						i.parent.name = 'r2mlv:Vocabulary'
				else false
				endif	
			)
	to
		cla : R2ML!Class (
			name <- i.getAttrVal('r2mlv:ID'),
			attributes <- i.getElementsByName('r2mlv:Attribute'),
			referencePropertyRef <- i.getElementsByName('r2mlv:ReferenceProperty')->first()
		)
}

-- Rule 'MessageType'
-- Creates MessageType from the MessageType element.
rule MessageType {
	from
		i : XML!Element (
				i.name = 'r2mlv:MessageType' and
				if not i.parent.oclIsUndefined() then
						i.parent.name = 'r2mlv:Vocabulary'
				else false
				endif	
			)
	to
		cla : R2ML!MessageType (
			name <- i.getAttrVal('r2mlv:ID'),
			attributes <- i.getElementsByName('r2mlv:Attribute'),
			referencePropertyRef <- i.getElementsByName('r2mlv:ReferenceProperty')->first()
		)
}

-- Rule 'FaultMessageType'
-- Creates FaultMessageType from the FaultMessageType element.
rule FaultMessageType {
	from
		i : XML!Element (
				i.name = 'r2mlv:FaultMessageType' and
				if not i.parent.oclIsUndefined() then
						i.parent.name = 'r2mlv:Vocabulary'
				else false
				endif
			)
	to
		cla : R2ML!FaultMessageType (
			name <- i.getAttrVal('r2mlv:ID'),
			attributes <- i.getElementsByName('r2mlv:Attribute')
		)
}

-- Rule 'AssociationPredicate'
-- Creates AssociationPredicate from the AssociationPredicate element.
rule AssociationPredicate {
	from
		i : XML!Element (
				i.name = 'r2mlv:AssociationPredicate'
			)
	to
		o : R2ML!AssociationPredicate (
			name <- i.getAttrVal('r2mlv:associationPredicateID'),
			arguments <- Sequence{ 
									i.getElementsByName('r2mlv:argumentsType')->first().children->select(e | e.oclIsKindOf(XML!Element) and e.hasAttr('r2mlv:ID'))->collect(c | thisModule.getElementFromVocabulary(c.getAttrVal('r2mlv:ID') ) )
								 }
		)
}

-- Rule 'Attribute'
-- Creates Attribute from the Attribute element.
rule AttributeVoc {
	from
		i : XML!Element (
				i.name = 'r2mlv:Attribute'
			)
	to
		o : R2ML!Attribute (
			name <- i.getAttrVal('r2mlv:ID'),
			range <- let dt : String = i.getElementsByName('r2mlv:range')->first().getElementsByName('r2mlv:Datatype')->first().getAttrVal('r2mlv:ID') in
						if not dt.oclIsUndefined() then
								thisModule.DatatypeVoc(thisModule.getDataTypefromVocabulary(dt) )
						else OclUndefined
						endif
		)
}

unique lazy rule DatatypeVoc {
	from i : XML!Element 
	to o : R2ML!Datatype (
			name <- i.getAttrVal('r2mlv:ID')
		)
}


-- Rule 'ReferencePropertyVoc'
-- Creates ReferenceProperty from the ReferenceProperty element.
rule ReferencePropertyVoc {
	from
		i : XML!Element (
				i.name = 'r2mlv:ReferenceProperty'
			)
	to
		o : R2ML!ReferenceProperty (
			name <- i.getAttrVal('r2mlv:ID'),
			range <- i.getElementsByName('r2mlv:range')->first().getElementsByName('r2mlv:Class')->first().getClassfromVocabulary('r2mlv:ID')
		)
}

-------------------------------------------------------------------------------
-- REACTION RULES -------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'ReactionRule'
-- Creates ReactionRule from an XML!Element named 'r2ml:ReactionRule'.
rule ReactionRule { 
	from
		i : XML!Element (
				i.name = 'r2ml:ReactionRule'
			)
  to
		o : R2ML!ReactionRule (
				ruleID <- i.getAttrVal('r2ml:ruleID'),
				groupID <- i.getAttrVal('r2ml:groupID'),
				conditions <- let args : Set(XML!Element) = i.getElementsByName('r2ml:conditions') in
								if not args->isEmpty() then
								   i.getElementsByName('r2ml:conditions')->first().children
							    else
							    	OclUndefined
								endif,
				postconditon <- let postCond : Set(XML!Element) = i.getElementsByName('r2ml:postcondition') in
								if not postCond->isEmpty() then
							   		i.getElementsByName('r2ml:postcondition')->first()
						    	else
									OclUndefined
								endif,
				producedAction <- thisModule.MessageEventExpression(i.getElementsByName('r2ml:producedAction')->first().getElementsByName('r2ml:MessageEventExpression').first()), 
				triggeringEvent <- i.getElementsByName('r2ml:triggeringEvent')->first().getElementsByName('r2ml:MessageEventExpression')->
									collect(e | thisModule.getDefaultMessageEventExpr(e.getAttrVal('r2ml:eventType'), e.getAttrVal('r2ml:sender')))->
									collect(e | thisModule.MessageEventExpression(e))->first()
		)
}

-- Rule 'MessageEventExpression'
-- Creates MessageEventExpression from an XML!Element named 'r2ml:MessageEventExpression'.
-- we need unique lazy rule. because we have the same trigerringEvent in both RRs
unique lazy rule MessageEventExpression {
	from
		i : XML!Element (
				i.name = 'r2ml:MessageEventExpression'
			)
	to
		o : R2ML!MessageEventExpression (	 
				sender <- if i.hasAttr('r2ml:sender') then
							i.getAttrVal('r2ml:sender')
						  else
						  	OclUndefined
						  endif,
				startDateTime <- if i.hasAttr('r2ml:startTime') then
							i.getAttrVal('r2ml:startTime')
						  else
						  	OclUndefined
						  endif,
				duration <- if i.hasAttr('r2ml:duration') then
							i.getAttrVal('r2ml:duration')
						  else
						  	OclUndefined
						  endif,
				objectVariable <- let ov : Set(XML!Element) = i.getElementsByName('r2ml:ObjectVariable') in
								if ov->isEmpty() then
							   		OclUndefined
						    	else
									i.getElementsByName('r2ml:ObjectVariable')->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first()
								endif,
				type <- thisModule.getElementFromVocabulary(i.getAttrVal('r2ml:eventType')),
				slot <- let ov : Set(XML!Element) = i.getElementsByName('r2ml:DataSlot') in
								if ov->isEmpty() then
							   		OclUndefined
						    	else
									i.getElementsByName('r2ml:DataSlot').first()
								endif
			)
}

-- Rule 'InvokeActionExpression'
-- Creates InvokeActionExpression from an XML!Element named 'r2ml:InvokeActionExpression'.
rule InvokeActionExpression {
	from i : XML!Element (
			i.name = 'r2ml:InvokeActionExpression'
		)
	to 
		o : R2ML!InvokeActionExpression (
				operation <- opr,
				contextArgument <- i.getElementsByName('r2ml:contextArgument')->first().children->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first(),
				arguments <- let args : Set(XML!Element) = i.getElementsByName('r2ml:arguments') in
							if args->isEmpty() then
							   OclUndefined
						    else
								Sequence{ i.getElementsByName('r2ml:arguments')->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e)),
				                   i.getElementsByName('r2ml:arguments')->first().children->select(e | not thisModule.getAllObjectVariables()->includes(e))->asSequence()}
							endif
			),
		opr : R2ML!Operation (
				name <- i.getAttrVal('r2ml:operationID')
			)
}

-- Rule 'ObjectClassificationAtom'
-- Creates ObjectClassificationAtom  from an XML!Element named 'r2ml:ObjectClassificationAtom'.
rule ObjectClassificationAtom {
	from i : XML!Element (
			i.name = 'r2ml:ObjectClassificationAtom'
		)
	to 
		obj : R2ML!ObjectClassificationAtom (
			isNegated <- i.isNegated(),
			term <- i.children->select(c | c.oclIsKindOf(XML!Element) and c.name = 'r2ml:ObjectVariable')->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first(),
			type <- i.getClassfromVocabulary('r2ml:classID')
		)
}

-- Rule 'AttributeFunctionTerm'
-- Creates AttributeFunctionTerm from an XML!Element named 'r2ml:AttributeFunctionTerm'.
rule AttributeFunctionTerm {
	from i : XML!Element (
			i.name = 'r2ml:AttributeFunctionTerm'
		)
	to 
		o : R2ML!AttributeFunctionTerm (
				typeCategory <- if i.hasAttr('r2ml:typeCategory') = true then
									if i.getAttrVal('r2ml:typeCategory') = 'individual' then
										#individual
									else if i.getAttrVal('r2ml:typeCategory') = 'set' then
											#set
										 else if i.getAttrVal('r2ml:typeCategory') = 'order' then
										 		#orderedSet
											  else if i.getAttrVal('r2ml:typeCategory') = 'bag' then
											  		#bag
												   else if i.getAttrVal('r2ml:typeCategory') = 'sequence' then
												   		 #sequence
														else OclUndefined
														endif
												   endif
											  endif
										 endif
									endif								
								else OclUndefined
								endif,
				contextArgument <- Sequence { i.getElementsByName('r2ml:contextArgument')->first().children->select(e | thisModule.getAllObjectVariables()->includes(e))->collect(e | thisModule.getDefaultObjectVariable(i, e.getAttrVal('r2ml:name')))->collect(e | thisModule.ObjectVariable(e))->first(),
						  					  i.getElementsByName('r2ml:contextArgument')->first().children->select(e | thisModule.getAllObjectVariables()->excludes(e))->asSequence()->first() -- other (non ObjectVariable) object terms
											}->select(c | not c.oclIsUndefined())->asSequence()->first(),
				attribute <- thisModule.getAttributefromVocabulary(i.getAttrVal('r2ml:attributeID'))
		)
}


",atlcompil atl transform xml metamodel r ml metamodel creat part m sc these good old ai research group author milan milanov milan milanov org marko ribar marko ribar gmail com work r ml xml schema metamodel v beta version general integr deriv rule element version reaction rule element todo add support product rule annot with mdr enumer must locat top packag modul xml r ml creat out r ml in xml use xmlhelper general xml metamodel helper helper xml r ml transform specif xml helper helper isneg return boolean statement xml element attribut xml attribut name r ml isneg true fals contextu xml element context xml element out boolean helper context xml element def isneg boolean let kolekcija sequenc xml attribut self children select c c ocliskindof xml attribut c name r ml isneg kolekcija isempti fals els empti let vred string kolekcija first valu vred true true els fals endif endif helper getallrul return sequenc xml element name integrityrul derivationrul reactionrul context thismodul out sequenc xml element helper def getallrul sequenc xml element xml element allinst select e e name r ml alethicintegrityrul e name r ml deonticintegrityrul e name r ml derivationrul e name r ml reactionrul assequ helper allsubel return sequenc xml sub element xml element recursivelli element last element children annot base transform model atl freder jouault ivan kurtev context xml element out sequenc xml element helper context xml element def allsubel sequenc xml element let subelem sequenc xml element xml element allinst select c get element parent c parent self collect elem elem allsubel flatten everi element get subel subelem union subel apprehend everi element add topmost element child parent self children select ch ch oclistypeof xml element flatten helper allsubattribut return sequenc xml sub attribut xml element recursivelli attribut last attribut children context xml element out sequenc xml attribut helper context xml element def allsubattribut sequenc xml attribut let subattr sequenc xml attribut xml element allinst select c c parent self collect attr attr allsubattribut flatten subattr union self children select oclistypeof xml attribut flatten helper getruleforel return xml element rule integr deriv reaction contain context ual xml element context xml element out xml element helper context xml element def getruleforel xml element thismodul getallrul select c c allsubel includ self assequ first helper getruleforattribut return xml element rule integr deriv reaction contain context ual xml attribut context xml attribut out xml element helper context xml attribut def getruleforattribut xml element thismodul getallrul select c c allsubattribut includ self assequ first helper getdefaultobjectvari return alway first objectvari valu this necessari uniqu lazi rule creat one output objectvari multipl input valu context thismodul in string out xml element helper def getdefaultobjectvari elem xml element valu string xml element let objvar sequenc xml element elem getruleforel allsubel select e e name r ml objectvari select e e getattrv r ml name valu e hasattr r ml classid assequ objvar isempti elem getruleforel allsubel select e e name r ml objectvari select e e getattrv r ml name valu assequ first els objvar first endif helper getdefaultdatavari same previous data variabl context thismodul in string out xml element helper def getdefaultdatavari elem xml element valu string xml element elem getruleforel allsubel select e e name r ml datavari select e e getattrv r ml name valu assequ first helper getdefaultgenericvari same previous variabl context thismodul in string out xml element helper def getdefaultgenericvari elem xml element valu string xml element elem getruleforel allsubel select e e name r ml variabl e name r ml genericvari select e e getattrv r ml name valu assequ first helper getdefaultgenericpred alway return first predic associ genericatom context thismodul in string out xml attribut helper def getdefaultgenericpred attr xml attribut valu string xml attribut attr getruleforattribut allsubattribut select e e name r ml predicateid select e e valu valu assequ first helper getdefaultattribut alway return first attribut associ term context thismodul in string out xml attribut helper def getdefaultattribut attr xml attribut valu string xml attribut attr getruleforattribut allsubattribut select e e name r ml attributeid select e e valu valu assequ first helper getdefaultdatatyp alway return first data type context thismodul in string out xml attribut helper def getdefaultdatatyp attr xml attribut valu string xml attribut attr getruleforattribut allsubattribut select e e name r ml datatypeid e name r ml type select e e valu valu assequ first helper getallobjectvari return object variabl input file context thismodul out sequenc xml element helper def getallobjectvari sequenc xml element xml element allinst select e e name r ml objectvari helper getalldatavari return data variabl input file context thismodul out sequenc xml element helper def getalldatavari sequenc xml element xml element allinst select e e name r ml datavari helper getallvari return variabl input file context thismodul out sequenc xml element helper def getallvari sequenc xml element xml element allinst select e e name r ml variabl e name r ml genericvari helper getdefaultmessageeventexpr return alway first messageeventexpress valu this necessari uniqu lazi rule creat one output objectvari multipl input valu context thismodul in string out xml element helper def getdefaultmessageeventexpr eventtyp string sender string xml element xml element allinst select e e name r ml messageeventexpress select e e getattrv r ml eventtyp eventtyp select e e getattrv r ml sender sender assequ first helper getelementfromvocabulari return element vocabulari whose id equal input paramet context thismodul in string out xml element helper def getelementfromvocabulari valu string xml element let cla sequenc xml element xml element allinst select e e name r mlv vocabulari assequ cla isempti oclundefin els cla first children select c c ocliskindof xml element select e e getattrv r mlv id valu first endif helper getdatatypefromvocabulari return datatyp vocabulari whose id equal input paramet context thismodul in string out xml element helper def getdatatypefromvocabulari valu string xml element let cla sequenc xml element xml element allinst select e e name r mlv vocabulari assequ cla isempti oclundefin els cla first allsubel select c c name r mlv datatyp select e e getattrv r mlv id valu first endif helper getattributefromvocabulari return attribut vocabulari whose id equal input paramet context thismodul in string out xml element helper def getattributefromvocabulari valu string xml element let cla sequenc xml element xml element allinst select e e name r mlv vocabulari assequ cla isempti oclundefin els cla first allsubel select e e name r mlv attribut select c c getattrv r mlv id valu first endif helper getreferencepropertyfromvocabulari return referenceproperti vocabulari whose id equal input paramet context thismodul in string out xml element helper def getreferencepropertyfromvocabulari valu string xml element let cla sequenc xml element xml element allinst select e e name r mlv vocabulari assequ cla isempti oclundefin els cla first allsubel select e e name r mlv referenceproperti select c c getattrv r mlv id valu first endif helper getclassfromvocabulari return class vocabulari whose id equal input paramet context thismodul in string out xml element helper context xml element def getclassfromvocabulari valu string xml element let xml attribut self children select c c ocliskindof xml attribut c name valu first oclisundefin thismodul getelementfromvocabulari valu els oclundefin endif rule rule rulebas creat rulebas root element rule rulebas xml element name r ml rulebas r ml rulebas rulebaseid getattrv xmlns r ml rule children select c c ocliskindof xml element c name r ml productionruleset c name r ml integrityruleset c name r ml derivationruleset c name r ml reactionruleset assequ vocabulari let voc set xml element getelementsbynam r mlv vocabulari voc isempti oclundefin els getelementsbynam r mlv vocabulari first endif rule derivationruleset creat derivationruleset xml element name r ml derivationruleset rule derivationruleset xml element name r ml derivationruleset r ml derivationruleset rule children select c c ocliskindof xml element assequ rule integrityruleset creat integrityruleset xml element name r ml integrityruleset rule integrityruleset xml element name r ml integrityruleset r ml integrityruleset rule children select c c ocliskindof xml element assequ rule reactionruleset creat reactionruleset xml element name r ml reactionruleset rule reactionruleset xml element name r ml reactionruleset r ml reactionruleset rule children select c c ocliskindof xml element assequ rulesetid getattrv r ml rulesetid rule productionruleset creat productionruleset xml element name r ml productionruleset rule productionruleset xml element name r ml productionruleset r ml productionruleset rule children select c c ocliskindof xml element assequ rule alethicintegrityrul creat alethicintegrityrul xml element name r ml alethicintegrityrul rule alethicintegrityrul xml element name r ml alethicintegrityrul r ml alethicintegrityrul constraint getelementsbynam r ml constraint first children select c c ocliskindof xml element first ruleid hasattr r ml ruleid true getattrv r ml ruleid els oclundefin endif rule deonticintegrityrul creat deonticintegrityrul xml element name r ml deonticintegrityrul rule deonticintegrityrul xml element name r ml deonticintegrityrul r ml deonticintegrityrul constraint getelementsbynam r ml constraint first children select c c ocliskindof xml element first ruleid hasattr r ml ruleid true getattrv r ml ruleid els oclundefin endif rule universallyquantifiedformula creat universallyquantifiedformula xml element name r ml universallyquantifiedformula rule universallyquantifiedformula xml element name r ml universallyquantifiedformula r ml universallyquantifiedformula annot remark first time generat variabl get objectvari element children helper getdefaultobjectvari get alway input element variabl name call uniqu lazi rule objectvari generat variabl variabl sequenc getelementsbynam r ml objectvari collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e getelementsbynam r ml datavari collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e formula children select e thismodul getalldatavari exclud e thismodul getallobjectvari exclud e e oclistypeof xml element first rule existentiallyquantifiedformula creat existentiallyquantifiedformula xml element name r ml existentiallyquantifiedformula rule existentiallyquantifiedformula xml element name r ml existentiallyquantifiedformula r ml existentiallyquantifiedformula variabl sequenc getelementsbynam r ml objectvari collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e getelementsbynam r ml datavari collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e formula children select e thismodul getalldatavari exclud e thismodul getallobjectvari exclud e e oclistypeof xml element first rule implic creat implic xml element name r ml implic rule implic xml element name r ml implic r ml implic anteced getelementsbynam r ml anteced first children first consequ getelementsbynam r ml consequ first children first rule conjuct creat conjuct xml element name r ml conjuct rule conjuct xml element name r ml conjunct r ml conjuct formula children select c c ocliskindof xml element asset rule disjunct creat disjunct xml element name r ml disjunct rule disjunct xml element name r ml disjunct r ml disjunct formula children select c c ocliskindof xml element asset rule negationasfailur creat negationasfailur xml element name r ml negationasfailur rule negationasfailur xml element name r ml negationasfailur r ml negationasfailur formula children select c c ocliskindof xml element first rule strongneg creat strongneg xml element name r ml strongneg rule strongneg xml element name r ml strongneg r ml strongneg formula children select c c ocliskindof xml element first rule equalityatom creat equalityatom xml element name r ml equalityatom rule equalityatom xml element name r ml equalityatom r ml equalityatom term sequenc children select c c ocliskindof xml element c name r ml objectvari collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e children select c c ocliskindof xml element c name r ml objectvari rule inequalityatom creat inequalityatom xml element name r ml inequalityatom rule inequalityatom xml element name r ml inequalityatom r ml inequalityatom term sequenc children select c c ocliskindof xml element c name r ml objectvari collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e children select c c ocliskindof xml element c name r ml objectvari rule derivationrul creat derivationrul xml element name r ml derivationrul rule derivationrul xml element name r ml derivationrul r ml derivationrul condit getelementsbynam r ml condit first children select c c ocliskindof xml element assequ conclus getelementsbynam r ml conclus first ruleid hasattr r ml ruleid true getattrv r ml ruleid els oclundefin endif rule literalconjuct creat atom xml element name r ml derivationrul conclus rule literalconjuct xml element name r ml conclus r ml literalconjunct atom children select c c ocliskindof xml element asset rule classrul creat class xml attribut this lazi rule call rule uniqu lazi rule classrul xml attribut cla r ml class name valu predicatecategori close rule dataclassificationatom creat dataclassificationatom xml element name r ml dataclassificationatom rule dataclassificationatom xml element name r ml dataclassificationatom obj r ml dataclassificationatom isneg isneg type thismodul datatypevoc thismodul getdatatypefromvocabulari getattrv r ml datatypeid term children select c c ocliskindof xml element c name r ml datavari collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e first rule objectvari creat objectvari xml element name r ml objectvari this rule uniqu lazi rule mean call rule uniqu lazi rule objectvari xml element name r ml objectvari ov r ml objectvari name getattrv r ml name typecategori individu classref getclassfromvocabulari r ml classid rule datavari creat datavari xml element name r ml datavari this rule uniqu lazi rule mean call rule uniqu lazi rule datavari xml element name r ml datavari odv r ml datavari datatyperef hasattr r ml datatypeid thismodul datatypevoc thismodul getdatatypefromvocabulari getattrv r ml datatypeid els oclundefin endif name getattrv r ml name typecategori hasattr r ml typecategori true getattrv r ml typecategori individu individu els getattrv r ml typecategori set set els getattrv r ml typecategori order orderedset els getattrv r ml typecategori bag bag els getattrv r ml typecategori sequenc sequenc els individu endif endif endif endif endif els oclundefin endif rule datatyp creat datatyp xml attribut this rule uniqu lazi rule mean call rule uniqu lazi rule datatyp xml attribut r ml datatyp predicatecategori close name valu rule qfdisjunct creat qfdisjunct xml element name r ml qf disjunct rule qfdisjunct xml element name r ml qf disjunct r ml qfdisjunct formula children select c c ocliskindof xml element assequ rule qfconjunct creat qfconjunct xml element name r ml qf conjunct rule qfconjunct xml element name r ml qf conjuct r ml qfconjunct formula children select c c ocliskindof xml element assequ rule qfnegationasfailur creat qfnegationasfailur xml element name r ml qf negationasfailur rule qfnegationasfailur xml element name r ml qf negationasfailur r ml qfnegationasfailur formula children select c c ocliskindof xml element first rule qfstrongneg creat qfstrongneg xml element name r ml qf strongneg rule qfstrongneg xml element name r ml qf strongneg r ml qfstrongneg formula children select c c ocliskindof xml element first rule datatypepredicateatom creat datatypepredicateatom xml element name r ml datatypepredicateatom r ml datapredicateatom rule datatypepredicateatom xml element r ml v name r ml datapredicateatom r ml v name r ml datatypepredicateatom r ml datatypepredicateatom dataargu sequenc getelementsbynam r ml dataargu first children select e thismodul getalldatavari includ e collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e getelementsbynam r ml dataargu first children select e thismodul getalldatavari includ e assequ predic children select c c ocliskindof xml attribut c name r ml datapredicateid c name r ml datatypepredicateid collect e thismodul datatypepredicaterul e first isneg isneg rule datatypepredicaterul creat datatypepredicaterul xml attribut this rule uniqu lazi rule mean call rule uniqu lazi rule datatypepredicaterul xml attribut dtp r ml datatypepred predicatecategori close name valu rule dataoperationterm creat dataoperationterm xml element name r ml dataoperationterm rule dataoperationterm xml element name r ml dataoperationterm r ml dataoperationterm dataoperationref opr argument let arg set xml element getelementsbynam r ml argument arg isempti sequenc annot first get objectvari datavari element objectvari datavari els sequenc arg first children select e thismodul getalldatavari includ e collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e arg first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e arg first children select e thismodul getalldatavari includ e thismodul getallobjectvari includ e assequ endif contextargu let conarg set xml element getelementsbynam r ml contextargu conarg isempti oclundefin els sequenc conarg first children assequ select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first conarg first children assequ select e thismodul getallobjectvari exclud e select c c oclisundefin assequ first endif typecategori hasattr r ml typecategori true getattrv r ml typecategori individu individu els getattrv r ml typecategori set set els getattrv r ml typecategori order orderedset els getattrv r ml typecategori bag bag els getattrv r ml typecategori sequenc sequenc els oclundefin endif endif endif endif endif els oclundefin endif opr r ml dataoper name getattrv r ml operationid rule typedliter creat typedliter xml element name r ml typedliter rule typedliter xml element name r ml typedliter r ml typedliter lexicalvalu getattrv r ml lexicalvalu type thismodul datatypevoc thismodul getdatatypefromvocabulari getattrv r ml datatypeid typecategori hasattr r ml typecategori true getattrv r ml typecategori individu individu els getattrv r ml typecategori set set els getattrv r ml typecategori order orderedset els getattrv r ml typecategori bag bag els getattrv r ml typecategori sequenc sequenc els oclundefin endif endif endif endif endif els oclundefin endif rule plainliter creat plainliter xml element name r ml plainliter rule plainliter xml element name r ml plainliter r ml plainliter lexicalvalu getattrv r ml lexicalvalu languagetag getattrv r ml languagetag typecategori hasattr r ml typecategori true getattrv r ml typecategori individu individu els getattrv r ml typecategori set set els getattrv r ml typecategori order orderedset els getattrv r ml typecategori bag bag els getattrv r ml typecategori sequenc sequenc els oclundefin endif endif endif endif endif els oclundefin endif rule associationatom creat associationatom xml element name r ml associationatom this rule complic possibl object data argument exist input file must check first let express rule associationatom xml element name r ml associationatom r ml associationatom isneg isneg objectargu let objarg set xml element getelementsbynam r ml objectargu objarg isempti sequenc els sequenc objarg first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e objarg first children select e thismodul getallobjectvari exclud e assequ endif dataargu let dataarg set xml element getelementsbynam r ml dataargu dataarg isempti sequenc els sequenc dataarg first children assequ select c thismodul getalldatavari includ c collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e dataarg first children assequ select c thismodul getalldatavari exclud c assequ endif associationpred asp asp r ml associationpred name getattrv r ml associationpredicateid rule referencepropertyfunctionterm creat referencepropertyfunctionterm xml element name r ml referencepropertyfunctionterm rule referencepropertyfunctionterm xml element name r ml rolefunctionterm v name r ml referencepropertyfunctionterm v r ml referencepropertyfunctionterm referencepropertyref thismodul getreferencepropertyfromvocabulari getattrv r ml referencepropertyid contextargu sequenc getelementsbynam r ml contextargu first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first getelementsbynam r ml contextargu first children select e thismodul getallobjectvari exclud e first select c c oclisundefin assequ first typecategori hasattr r ml typecategori true getattrv r ml typecategori individu individu els getattrv r ml typecategori set set els getattrv r ml typecategori order orderedset els getattrv r ml typecategori bag bag els getattrv r ml typecategori sequenc sequenc els oclundefin endif endif endif endif endif els oclundefin endif rule attributionatom creat attributionatom xml element name r ml attributionatom rule attributionatom xml element name r ml attributionatom r ml attributionatom isneg isneg datavalu let val xml element getelementsbynam r ml datavalu first children first val name r ml datavari getelementsbynam r ml datavalu first children select e thismodul getalldatavari includ e collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e first els getelementsbynam r ml datavalu first children select e thismodul getalldatavari includ e first endif subject sequenc getelementsbynam r ml subject first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first getelementsbynam r ml subject first children select e thismodul getallobjectvari exclud e select c c oclisundefin assequ first attribut vocabulari attribut let atr xml element thismodul getattributefromvocabulari getattrv r ml attributeid atr oclisundefin atr els thismodul attribut thismodul getdefaultattribut getattr r ml attributeid getattrv r ml attributeid endif rule attribut creat attribut xml attribut name r ml attributeid uniqu lazi rule attribut xml attribut r ml attribut predicatecategori close name valu rule referencepropertyatom creat referencepropertyatom xml element name r ml referencepropertyatom rule referencepropertyatom xml element name r ml referencepropertyatom r ml referencepropertyatom isneg isneg referenceproperti thismodul getreferencepropertyfromvocabulari getattrv r ml referencepropertyid subject sequenc getelementsbynam r ml subject first children select c thismodul getallobjectvari includ c collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first getelementsbynam r ml subject first children select c thismodul getallobjectvari exclud c select c c oclisundefin assequ first object sequenc getelementsbynam r ml object first children select c thismodul getallobjectvari includ c collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first getelementsbynam r ml object first children select c thismodul getallobjectvari exclud c select c c oclisundefin assequ first rule referenceproperti creat referenceproperti element xml attribut this rule uniqu lazi rule mean call rule uniqu lazi rule referenceproperti xml attribut rfp r ml referenceproperti predicatecategori close name valu rule genericatom creat genericatom element xml element name r ml genericatom rule genericatom xml element name r ml genericatom r ml genericatom argument sequenc getelementsbynam r ml argument first children select e thismodul getallvari includ e collect e thismodul getdefaultgenericvari e getattrv r ml name collect e thismodul genericvari e getelementsbynam r ml argument first children select e thismodul getalldatavari includ e collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e getelementsbynam r ml argument first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e getelementsbynam r ml argument first children select e thismodul getallvari exclud e thismodul getalldatavari exclud e thismodul getallobjectvari exclud e assequ predic thismodul genericpred thismodul getdefaultgenericpred getattr r ml predicateid getattrv r ml predicateid rule genericpred creat predic element xml element name r ml genericpred this rule uniqu lazi rule mean call rule uniqu lazi rule genericpred xml attribut pre r ml genericpred name valu predicatetypeid let pt string parent getattrv r ml predicatetyp pt oclundefin pt objectclassificationpred objectclassificationpred els pt attributionpred attributionpred els pt associationpred associationpred els pt referencepropertypred referencepropertypred els pt equalitypred equalitypred els pt inequalitypred inequalitypred els pt datatypepred datatypepred els pt dataclassificationpred dataclassificationpred els oclundefin endif endif endif endif endif endif endif endif els oclundefin endif rule genericvari creat genericvari element xml element name r ml variabl r ml genericvari this rule uniqu lazi rule mean call rule uniqu lazi rule genericvari xml element r ml genericvari name getattrv r ml name typeref hasattr r ml datatypeid thismodul datatypevoc thismodul getdatatypefromvocabulari getattrv r ml datatypeid els oclundefin endif rule genericfunctionterm creat genericfunctionterm element xml element name r ml functionterm r ml genericfunctionterm rule genericfunctionterm xml element name r ml functionterm v name r ml genericfunctionterm v r ml genericfunctionterm argument sequenc getelementsbynam r ml argument first children select e thismodul getallvari includ e collect e thismodul getdefaultgenericvari e getattrv r ml name collect e thismodul genericvari e getelementsbynam r ml argument first children select e thismodul getallvari includ e assequ functor fun typecategori hasattr r ml typecategori true getattrv r ml typecategori individu individu els getattrv r ml typecategori set set els getattrv r ml typecategori order orderedset els getattrv r ml typecategori bag bag els getattrv r ml typecategori sequenc sequenc els oclundefin endif endif endif endif endif els oclundefin endif fun r ml genericfunct name getattrv r ml genericfunctionid rule datatypefunctionterm creat datatypefunctionterm element xml element name r ml datatypefunctionterm rule datatypefunctionterm xml element name r ml datatypefunctionterm r ml datatypefunctionterm dataargu sequenc getelementsbynam r ml dataargu first children select e thismodul getalldatavari includ e collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e first getelementsbynam r ml dataargu first children select e thismodul getalldatavari includ e assequ function dtf typecategori hasattr r ml typecategori true getattrv r ml typecategori individu individu els getattrv r ml typecategori set set els getattrv r ml typecategori order orderedset els getattrv r ml typecategori bag bag els getattrv r ml typecategori sequenc sequenc els oclundefin endif endif endif endif endif els oclundefin endif dtf r ml datatypefunct name getattrv r ml datatypefunctionid rule objectnam creat objectnam element xml element name r ml objectnam rule objectnam xml element name r ml objectnam r ml objectnam name getattrv r ml objectid classref getclassfromvocabulari r ml classid typecategori hasattr r ml typecategori true getattrv r ml typecategori individu individu els getattrv r ml typecategori set set els getattrv r ml typecategori order orderedset els getattrv r ml typecategori bag bag els getattrv r ml typecategori sequenc sequenc els oclundefin endif endif endif endif endif els oclundefin endif rule objectdescriptionatom creat objectdescriptionatom element xml element name r ml objectdescriptionatom rule objectdescriptionatom xml element name r ml objectdescriptionatom r ml objectdescriptionatom isneg isneg type getclassfromvocabulari r ml classid slot sequenc getelementsbynam r ml dataslot first children assequ getelementsbynam r ml objectslot first children assequ subject sequenc getelementsbynam r ml subject first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first getelementsbynam r ml subject first children select e thismodul getallobjectvari exclud e select c c oclisundefin assequ first object getelementsbynam r ml object first children assequ basetyp hasattr r ml basetyp getclassfromvocabulari r ml basetyp els oclundefin endif rule objectslot creat objectslot element xml element name r ml objectslot rule objectslot xml element name r ml objectslot r ml objectslot object sequenc getelementsbynam r ml object first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first getelementsbynam r ml object first children select e thismodul getallobjectvari exclud e select c c oclisundefin assequ first referenceproperti thismodul getreferencepropertyfromvocabulari getattrv r ml referencepropertyid rule dataslot creat dataslot element xml element name r ml dataslot rule dataslot xml element name r ml dataslot r ml dataslot valu sequenc getelementsbynam r ml valu first children select e thismodul getalldatavari includ e collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e first getelementsbynam r ml valu first children select e thismodul getalldatavari exclud e first select c c oclisundefin assequ first attribut thismodul getattributefromvocabulari getattrv r ml attributeid rule atleastquantifiedformula creat atleastquantifiedformula xml element name r ml atleastquantifiedformula rule atleastquantifiedformula xml element name r ml atleastquantifiedformula r ml atleastquantifiedformula variabl sequenc getelementsbynam r ml objectvari collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e getelementsbynam r ml datavari collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e formula children select e thismodul getalldatavari exclud e thismodul getallobjectvari exclud e e oclistypeof xml element first mincardin getattrv r ml mincardin tointeg rule atmostquantifiedformula creat atmostquantifiedformula xml element name r ml atmostquantifiedformula rule atmostquantifiedformula xml element name r ml atmostquantifiedformula r ml atmostquantifiedformula variabl sequenc getelementsbynam r ml objectvari collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e getelementsbynam r ml datavari collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e formula children select e thismodul getalldatavari exclud e thismodul getallobjectvari exclud e e oclistypeof xml element first maxcardin getattrv r ml maxcardin tointeg rule atleastandatmostquantifiedformula creat atleastandatmostquantifiedformula xml element name r ml atleastandatmostquantifiedformula rule atleastandatmostquantifiedformula xml element name r ml atleastandatmostquantifiedformula r ml atleastandatmostquantifiedformula variabl sequenc getelementsbynam r ml objectvari collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e getelementsbynam r ml datavari collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e formula children select e thismodul getalldatavari exclud e thismodul getallobjectvari exclud e e oclistypeof xml element first maxcardin getattrv r ml maxcardin tointeg mincardin getattrv r ml mincardin tointeg rule objectoperationterm creat objectoperationterm xml element name r ml objectoperationterm rule objectoperationterm xml element name r ml objectoperationterm r ml objectoperationterm oper thismodul objectoper getattr r ml operationid argument sequenc getelementsbynam r ml argument first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e getelementsbynam r ml argument first children select e thismodul getalldatavari includ e collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e getelementsbynam r ml argument first children select e thismodul getallobjectvari exclud e thismodul getalldatavari exclud e contextargu sequenc getelementsbynam r ml contextargu first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first getelementsbynam r ml contextargu first children select e thismodul getallobjectvari exclud e first select c c oclisundefin assequ first lazi rule objectoper creat objectoper xml element name attribut r ml objectoperationterm uniqu lazi rule objectoper xml attribut r ml objectoper name valu rule dataoperationterm creat dataoperationterm xml element name r ml dataoperationterm rule dataoperationterm xml element name r ml dataoperationterm r ml dataoperationterm dataoperationref thismodul dataoper getattr r ml operationid argument sequenc getelementsbynam r ml argument first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e getelementsbynam r ml argument first children select e thismodul getalldatavari includ e collect e thismodul getdefaultdatavari e getattrv r ml name collect e thismodul datavari e getelementsbynam r ml argument first children select e thismodul getallobjectvari exclud e thismodul getalldatavari exclud e contextargu sequenc getelementsbynam r ml contextargu first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first getelementsbynam r ml contextargu first children select e thismodul getallobjectvari exclud e first select c c oclisundefin assequ first lazi rule dataoper creat dataoper xml element name attribut r ml dataoperationterm uniqu lazi rule dataoper xml attribut r ml dataoper name valu vocabulari rule vocabulari creat vocabulari vocabulari element rule vocabulari xml element name r mlv vocabulari r ml vocabulari entri children select c c ocliskindof xml element assequ rule classr creat class class element rule classr xml element name r mlv class parent oclisundefin parent name r mlv vocabulari els fals endif cla r ml class name getattrv r mlv id attribut getelementsbynam r mlv attribut referencepropertyref getelementsbynam r mlv referenceproperti first rule messagetyp creat messagetyp messagetyp element rule messagetyp xml element name r mlv messagetyp parent oclisundefin parent name r mlv vocabulari els fals endif cla r ml messagetyp name getattrv r mlv id attribut getelementsbynam r mlv attribut referencepropertyref getelementsbynam r mlv referenceproperti first rule faultmessagetyp creat faultmessagetyp faultmessagetyp element rule faultmessagetyp xml element name r mlv faultmessagetyp parent oclisundefin parent name r mlv vocabulari els fals endif cla r ml faultmessagetyp name getattrv r mlv id attribut getelementsbynam r mlv attribut rule associationpred creat associationpred associationpred element rule associationpred xml element name r mlv associationpred r ml associationpred name getattrv r mlv associationpredicateid argument sequenc getelementsbynam r mlv argumentstyp first children select e e ocliskindof xml element e hasattr r mlv id collect c thismodul getelementfromvocabulari c getattrv r mlv id rule attribut creat attribut attribut element rule attributevoc xml element name r mlv attribut r ml attribut name getattrv r mlv id rang let dt string getelementsbynam r mlv rang first getelementsbynam r mlv datatyp first getattrv r mlv id dt oclisundefin thismodul datatypevoc thismodul getdatatypefromvocabulari dt els oclundefin endif uniqu lazi rule datatypevoc xml element r ml datatyp name getattrv r mlv id rule referencepropertyvoc creat referenceproperti referenceproperti element rule referencepropertyvoc xml element name r mlv referenceproperti r ml referenceproperti name getattrv r mlv id rang getelementsbynam r mlv rang first getelementsbynam r mlv class first getclassfromvocabulari r mlv id reaction rule rule reactionrul creat reactionrul xml element name r ml reactionrul rule reactionrul xml element name r ml reactionrul r ml reactionrul ruleid getattrv r ml ruleid groupid getattrv r ml groupid condit let arg set xml element getelementsbynam r ml condit arg isempti getelementsbynam r ml condit first children els oclundefin endif postconditon let postcond set xml element getelementsbynam r ml postcondit postcond isempti getelementsbynam r ml postcondit first els oclundefin endif producedact thismodul messageeventexpress getelementsbynam r ml producedact first getelementsbynam r ml messageeventexpress first triggeringev getelementsbynam r ml triggeringev first getelementsbynam r ml messageeventexpress collect e thismodul getdefaultmessageeventexpr e getattrv r ml eventtyp e getattrv r ml sender collect e thismodul messageeventexpress e first rule messageeventexpress creat messageeventexpress xml element name r ml messageeventexpress need uniqu lazi rule trigerringev rrs uniqu lazi rule messageeventexpress xml element name r ml messageeventexpress r ml messageeventexpress sender hasattr r ml sender getattrv r ml sender els oclundefin endif startdatetim hasattr r ml starttim getattrv r ml starttim els oclundefin endif durat hasattr r ml durat getattrv r ml durat els oclundefin endif objectvari let ov set xml element getelementsbynam r ml objectvari ov isempti oclundefin els getelementsbynam r ml objectvari select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first endif type thismodul getelementfromvocabulari getattrv r ml eventtyp slot let ov set xml element getelementsbynam r ml dataslot ov isempti oclundefin els getelementsbynam r ml dataslot first endif rule invokeactionexpress creat invokeactionexpress xml element name r ml invokeactionexpress rule invokeactionexpress xml element name r ml invokeactionexpress r ml invokeactionexpress oper opr contextargu getelementsbynam r ml contextargu first children collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first argument let arg set xml element getelementsbynam r ml argument arg isempti oclundefin els sequenc getelementsbynam r ml argument first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e getelementsbynam r ml argument first children select e thismodul getallobjectvari includ e assequ endif opr r ml oper name getattrv r ml operationid rule objectclassificationatom creat objectclassificationatom xml element name r ml objectclassificationatom rule objectclassificationatom xml element name r ml objectclassificationatom obj r ml objectclassificationatom isneg isneg term children select c c ocliskindof xml element c name r ml objectvari collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first type getclassfromvocabulari r ml classid rule attributefunctionterm creat attributefunctionterm xml element name r ml attributefunctionterm rule attributefunctionterm xml element name r ml attributefunctionterm r ml attributefunctionterm typecategori hasattr r ml typecategori true getattrv r ml typecategori individu individu els getattrv r ml typecategori set set els getattrv r ml typecategori order orderedset els getattrv r ml typecategori bag bag els getattrv r ml typecategori sequenc sequenc els oclundefin endif endif endif endif endif els oclundefin endif contextargu sequenc getelementsbynam r ml contextargu first children select e thismodul getallobjectvari includ e collect e thismodul getdefaultobjectvari e getattrv r ml name collect e thismodul objectvari e first getelementsbynam r ml contextargu first children select e thismodul getallobjectvari exclud e assequ first non objectvari object term select c c oclisundefin assequ first attribut thismodul getattributefromvocabulari getattrv r ml attributeid,6
239,239,P99-XML2WSDL.atl,"--@atlcompiler atl2006

--------------------------------------------------------------------------------
-- Transforms an XML metamodel into a WSDL metamodel.
-- Created as part of M.Sc. theses at GOOD OLD AI Research Group
-- Author: Marko Ribaric
-- Works for WSDL Metamodel v0.1 (by prof. Gerd Wagner)
--------------------------------------------------------------------------------
-- Version: 0.1 - 01.01.2007.
--
-- TODO:
-- ANNOTATION: With MDR, Enumerations must be located in top-most package
--------------------------------------------------------------------------------
module XML2WSDL; -- Module Template
create OUT : WSDL from IN : XML;

uses XMLHelpers;

-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- XML2R2ML Transformation specific XML helpers

-- HELPER:	isNegated()
-- Returns a boolean that statement is XML!Element attribute XML!Attribute with name 'r2ml:isNegated' is true or false
-- contextual XML!Element.
-- CONTEXT:	XML!Element
-- OUT:		Boolean
helper context XML!Element def: isNegated() : Boolean =
	let kolekcija : Sequence(XML!Attribute) = self.children->select(c | c.oclIsKindOf(XML!Attribute) and c.name = 'r2ml:isNegated') in
	if kolekcija->isEmpty()
	then
		false
	else -- not empty
		let vred : String = kolekcija->first().value in
		if vred = 'true'
		then
			true
		else 
			false
		endif
	endif;

-- HELPER: allSubElements
-- Returns a sequence of all XML sub elements for XML element, recursivelly
-- from this element to last element (children)
-- ANNOTATION: Based on ""Transforming Models with ATL"", Frederic Jouault, Ivan Kurtev.
-- CONTEXT:	XML!Element
-- OUT:		Sequence of XML elements
helper context XML!Element def : allSubElements : Sequence(XML!Element) = 
	let subElems : Sequence(XML!Element) = 
		XML!Element.allInstances()->select(c |      			-- 1. get all elements with this parent
			c.parent = self
		)->collect(elems | elems.allSubElements)->flatten()  in -- 2. for every element get subelements
		subElems->union( 										-- 3. when all subelements are apprehended 
																--    for every element, add topmost elements (child of this parent).
			self.children->select(ch | ch.oclIsTypeOf(XML!Element)
	    ))->flatten();

-- HELPER: allSubAttributes
-- Returns a sequence of all XML sub attributes for XML element, recursivelly
-- from this attribute to last attribute (children)
-- CONTEXT:	XML!Element
-- OUT:		Sequence of XML attributes
helper context XML!Element def : allSubAttributes : Sequence(XML!Attribute) = 
	let subAttrs : Sequence(XML!Attribute) = 
    	XML!Element.allInstances()->select(c | 
        	c.parent = self
		)->collect(attrs | attrs.allSubAttributes)->flatten()  in
		subAttrs->union(
			self.children->select(at | at.oclIsTypeOf(XML!Attribute)
		))->flatten();


-- HELPER:	resolveMEP
-- resolve the MEP type
-- CONTEXT:	XML!Element
-- IN:
-- OUT:		String
helper context XML!Element def: resolveMEP() : XML!Element =
	let value : String = self.getAttrVal('pattern') in
	
	if value = 'http://www.w3.org/2006/01/wsdl/in-out' then
			#inout
		else if value = 'http://www.w3.org/2006/01/wsdl/inonly' then
				#inonly
			else if value = 'http://www.w3.org/2006/01/wsdl/out-in' then
					#outin
				else if value = 'http://www.w3.org/2006/01/wsdl/robustoutonly' then
						#robustoutonly
					else if value = 'http://www.w3.org/2006/01/wsdl/outonly' then
							#outonly
						else if value = 'http://www.w3.org/2006/01/wsdl/robustinonly' then
								#robust_in_only
							else if value = 'http://www.w3.org/2006/01/wsdl/outoptionalin' then
									#outoptionalin
								else if value = 'http://www.w3.org/2006/01/wsdl/inoptionalout' then
										#inoptionalout
								else OclUndefined
								endif
							endif
						endif
					endif
				endif
			endif
		endif
	endif;
							
	
-- HELPER:	resolveMessageFormat
-- resolve the MessageFormat type
-- CONTEXT:	XML!Element
-- IN:
-- OUT:		String
helper context XML!Element def: resolveMessageFormat() : XML!Element =
	let value : String = self.getAttrVal('type') in

	if value = 'http://www.w3.org/2006/01/wsdl/soap' then
			#SOAP12
		else if value = 'http://www.w3.org/2006/01/wsdl/HTTP' then
				#HTTP
			else  #SOAP11
			endif
	endif;

-- HELPER:	resolveProtocol
-- resolve the Protocol type
-- CONTEXT:	XML!Element
-- IN:
-- OUT:		String
helper context XML!Element def: resolveProtocol() : XML!Element =
	let value : String = self.getAttrVal('wsoap:protocol') in
	
	if value = 'http://www.w3.org/2003/05/soap/bindings/HTTP' then
		#HTTP
	else #SMTP
	endif;				  
	

-- HELPER:	resolveSOAPMEP
-- resolve the SOAPMEP type
-- CONTEXT:	XML!Element
-- IN:
-- OUT:		String
helper context XML!Element def: resolveSOAPMEP() : XML!Element =
	let value : String = self.getAttrVal('wsoap:mep') in
	
	if value = 'http://www.w3.org/2003/05/soap/mep/request-response' then
  		#requestresponse
	else #soapresponse
	endif;				  

-- HELPER:	resolveFaultCodeEnum
-- resolve the FaultCodeEnum type
-- CONTEXT:	XML!Element
-- IN:
-- OUT:		String
helper context XML!Element def: resolveFaultCodeEnum() : XML!Element = 
	let value : String = self.getAttrVal('wsoap:code') in
	
	if value = 'soap:Sender' then
  		#Sender
	else OclUndefined
	endif;				  


-- HELPER:	splitNameSpace
-- returns string before or after the colon sign
-- CONTEXT:	thisModule
-- IN:		String (beforeColon|afterColon)
-- OUT:		String
helper def: splitNameSpace(str2split : String, str2return : String) : String =
	let strSeq : Sequence(String) = str2split.split(':') in
	if strSeq->size() = 2 then
		if str2return = 'beforeColon' then
			strSeq->first()
		else if str2return = 'afterColon' then
				strSeq->last()
			 else OclUndefined
			 endif
		endif
	else OclUndefined
	endif;


-- HELPER:	getBindingReference
-- return the correct reference to Binding element
-- CONTEXT:	XML!Element
-- IN:
-- OUT:		XML!Element
helper context XML!Element def: getBindingReference() : XML!Element =
    XML!Element.allInstances()->
	select(e | e.name = 'binding' and 
		e.getAttrVal('name') = self.getAttrVal('binding'))->first();


-- HELPER:	getInterfaceReference
-- return the correct reference to Interface element
-- CONTEXT:	XML!Element
-- IN:
-- OUT:		XML!Element
helper context XML!Element def: getInterfaceReference() : XML!Element =
    XML!Element.allInstances()->
	select(e | e.name = 'interface' and
		e.getAttrVal('name') = self.getAttrVal('interface'))->first();	


-- HELPER:	getFaultReference
-- return the correct reference to Fault element
-- CONTEXT:	XML!Element
-- IN:
-- OUT:		XML!Element
helper context XML!Element def: getFaultReference() : XML!Element =
    XML!Element.allInstances()->
	select(e | e.name = 'fault' and
		e.getAttrVal('name') = self.getAttrVal('ref'))->first();	


-- HELPER:	getOperationReference
-- return the correct reference to Operation element
-- CONTEXT:	XML!Element
-- IN:
-- OUT:		XML!Element
helper context XML!Element def: getOperationReference() : XML!Element =
    XML!Element.allInstances()->
	select(e | e.name = 'operation' and
		e.getAttrVal('name') = self.getAttrVal('ref'))->first();	


-- HELPER:	getElementReference
-- return the correct reference to XsElementDeclaration
-- CONTEXT:	XML!Element
-- IN:
-- OUT:		XML!Element
helper context XML!Element def: getElementReference() : XML!Element =
    XML!Element.allInstances()->
	select(e | e.name = 'xs:element' and
		e.getAttrVal('name') = self.getAttrVal('element'))->first();	


helper context XML!Element def: getRefElementReference() : XML!Element =
    XML!Element.allInstances()->
	select(e | e.name = 'xs:element' and
		e.getAttrVal('name') = self.getAttrVal('ref'))->first();	


-- HELPER:	isSimpleType
-- returns true if xs:element is one of these simple types
-- CONTEXT:	XML!Element
-- IN:
-- OUT:		Boolean
helper context XML!Element def: isSimpleType() : Boolean =
	let name : String = self.name in
	let type : String = 
		if name = 'xs:element' then 
			self.getAttrVal('type')
		else 
			OclUndefined
		endif
	in
	
	if not type.oclIsUndefined() then
	    if type = 'xs:string' then
			true
		else if type = 'xs:boolean' then
				true
			else if type = 'xs:decimal' then
					true
				else if type = 'xs:float' then
					true
					else if type = 'xs:double' then
						true
						else if type = 'xs:duration' then
							true
							else if type = 'xs:dateTime' then
								true
								else if type = 'xs:time' then
									true
									else if type = 'xs:date' then
										true
										else if type = 'xs:gYearMonth' then
											true
											else if type = 'xs:gYear' then
												true
												else if type = 'xs:gMonthDay' then
													true
													else if type = 'xs:gDay' then
														true
														else if type = 'xs:gMonth' then
															true
															else if type = 'xs:hexBinary' then
																true
																else if type = 'xs:base64Binary' then
																	true
																	else if type = 'xs:anyURI' then
																		true
																		else if type = 'xs:QName' then
																			true
																			else if type = 'xs:NOTATION' then
																					true
																			 	else
																					false
			 																	endif
																			endif
																		endif
																	endif
																endif
															endif
														endif
													endif
												endif
											endif
										endif
									endif
								endif
							endif
						endif
					endif
				endif
			endif
		endif
	 else
	 	false
	 endif;

helper context XML!Element def: getDefaultSimpleType() : XML!Attribute =
    XML!Element.allInstances()->
	select(e | e.name = 'xs:element' and e.getAttrVal('type') = self.getAttrVal('type'))->
	flatten()->first().getAttr('type')->asSequence()->first();


-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'Description'
-- Creates Description from the Root element.
rule Description {
	from
		i : XML!Element (
				i.name = 'description'
			)		
	to
		o : WSDL!Description (                 
				types <- i.getElementsByName('types'),
				interface <- i.getElementsByName('interface'),
				binding <- i.getElementsByName('binding'),
				service <- i.getElementsByName('service')				
		)
}


-- Rule 'ElementType'
-- Creates ElementType from the types element.
rule ElementType {
	from
		i : XML!Element (
				i.name = 'types'
			)		
	to
		o : WSDL!ElementType (                 
				schema <- i.getElementsByName('xs:schema').first()
		)
}

-- Rule 'XsSchema'
-- Creates XsSchema from the xs:schema element.
rule XsSchema {
	from
		i : XML!Element (
				i.name = 'xs:schema'
			)		
	to
		o : WSDL!XsSchema (
			    schemaLocation <- i.getAttrVal('xmlns'),
				targetNamespace <- i.getAttrVal('targetNamespace'),
				elementDeclarations <- i.getElementsByName('xs:element'),
				typeDefinitions <- i.getElementsByName('xs:complexType')
		)
}

-- Rule 'XsComplexTypeDefinition'
-- Creates XsComplexTypeDefinition from the xs:complexType element.
rule XsComplexTypeDefinition {
	from
		i : XML!Element (
				i.name = 'xs:complexType' 
			)		
	to
		o : WSDL!XsComplexTypeDefinition (                 
				name <- i.getAttrVal('name'),
				content <- con
			),
		con : WSDL!XsParticle (
				term <- ter
			),
		ter : WSDL!XsModelGroup (
				compositor <- #sequence,
				particles <- i.getElementsByName('xs:sequence').first().getElementsByName('xs:element')->asSequence()
			)
}


-- Rule 'SimpleType'
-- Creates XsSimpleTypeDefinition from an XML!Attribute 
-- This rule is unique lazy rule, which means that is called from other rules
unique lazy rule SimpleType {
	from i : XML!Attribute
	to 
		o : WSDL!XsSimpleTypeDefinition (
			name <- i.value
		)		
}


-- Rule 'XsElementDeclaration'
-- Creates XsElementDeclaration from the xs:element element.
rule XsElementDeclaration {
	from
		i : XML!Element (
				i.name = 'xs:element' and not
					if not i.parent.oclIsUndefined() then
						i.parent.name = 'xs:sequence'
					else true
					endif
			)		
	to
		ele : WSDL!XsElementDeclaration (
				name <- i.getAttrVal('name'),
				typeDefinition <- if (i.isSimpleType()) then
				 					thisModule.SimpleType( i.getDefaultSimpleType() )
								else 
									if  not i.getElementsByName('xs:complexType')->isEmpty()  then
										i.getElementsByName('xs:complexType').first()
									else
										if i.hasAttr('type') then
											XML!Element.allInstances()->select(e | e.name = 'xs:complexType')->select(e | e.getAttrVal('name') = i.getAttrVal('type'))->asSequence()->first()
										else
											OclUndefined
										endif									
									endif
								endif
			)	
}

-- Rule 'SequenceElementDeclaration'
-- Creates XsElementDeclaration from the xs:element element
-- that is positioned inside the xs:sequence element.
rule SequenceElementDeclaration {
	from
		i : XML!Element (
				i.name = 'xs:element' and
					if not i.parent.oclIsUndefined() then
						i.parent.name = 'xs:sequence'
					else false
					endif				
			)		
	to
		o : WSDL!XsParticle (                 
				content <- ele
			),
		ele : WSDL!XsElementDeclaration (
				name <- i.getAttrVal('name'),
				typeDefinition <- if (i.isSimpleType()) then
									thisModule.SimpleType( i.getDefaultSimpleType() )
								else 
									if  not i.getElementsByName('xs:complexType')->isEmpty() then
										i.getElementsByName('xs:complexType').first()
									else
										if i.hasAttr('type') then
											XML!Element.allInstances()->select(e | e.name = 'xs:complexType')->select(e | e.getAttrVal('name') = i.getAttrVal('type'))->asSequence()->first()
										else
											OclUndefined
										endif	
									endif
								endif,
				resolvedElementDeclaration <- if i.hasAttr('ref') then
												i.getRefElementReference()
											  else OclUndefined
											  endif
			)
}

-- Rule 'Interface'
-- Creates Interface from the interface element.
rule Interface {
	from
		i : XML!Element (
				i.name = 'interface'
			)		
	to
		o : WSDL!Interface (                 
				name <- i.getAttrVal('name'),
				fault <- i.getElementsByName('fault'),
				operation <- i.getElementsByName('operation')
		)
}


-- Rule 'Fault'
-- Creates Fault from the fault element.
rule Fault {
	from
		i : XML!Element (
				i.name = 'fault' and not
					if not i.parent.oclIsUndefined() then
						i.parent.name = 'binding'
					else true
					endif
			)		
	to
		o : WSDL!Fault (                 
				name <- i.getAttrVal('name'),
				element <- i.getElementReference(),
				elementNS <- thisModule.splitNameSpace(i.getAttrVal('element'),'beforeColon')
		)
}

-- Rule 'Operation'
-- Creates Operation from the operation element.
rule Operation {
	from
		i : XML!Element (
				i.name = 'operation' and
					if not i.parent.oclIsUndefined() then
						i.parent.name = 'interface'
					else false
					endif
			)		
	to
		o : WSDL!Operation (                 
				name <- i.getAttrVal('name'),
				pattern <- i.resolveMEP(),
				input <- i.getElementsByName('input'),
				output <- i.getElementsByName('output'),
				infault <- i.getElementsByName('infault'),
				outfault <- i.getElementsByName('outfault')
		)

}

-- Rule 'Input'
-- Creates Input from the input element.
rule Input {
	from
		i : XML!Element (
				i.name = 'input'
			)		
	to
		o : WSDL!Input (                 
				messageLabel <- i.getAttrVal('messageLabel'),
				element <- i.getElementReference(),
				elementNS <- thisModule.splitNameSpace(i.getAttrVal('element'),'beforeColon')
		)
}

-- Rule 'Output'
-- Creates Output from the output element.
rule Output {
	from
		i : XML!Element (
				i.name = 'output'
			)		
	to
		o : WSDL!Output (                 
				messageLabel <- i.getAttrVal('messageLabel'),
				element <- i.getElementReference(),
				elementNS <- thisModule.splitNameSpace(i.getAttrVal('element'),'beforeColon')
		)
}

-- Rule 'Infault'
-- Creates Infault from the infault element.
rule Infault {
	from
		i : XML!Element (
				i.name = 'infault'
			)		
	to
		o : WSDL!Infault (                 
				messageLabel <- i.getAttrVal('messageLabel'),
				fault <- i.getFaultReference(),
				faultNS <- thisModule.splitNameSpace(i.getAttrVal('ref'),'beforeColon')
		)
}

-- Rule 'Outfault'
-- Creates Outfault from the outfault element.
rule Outfault {
	from
		i : XML!Element (
				i.name = 'outfault'
			)		
	to
		o : WSDL!Outfault (                 
				messageLabel <- i.getAttrVal('messageLabel'),
				fault <- i.getFaultReference(),
				faultNS <- thisModule.splitNameSpace(i.getAttrVal('ref'),'beforeColon')
		)
}

-- Rule 'Binding'
-- Creates Binding from the binding element.
rule Binding {
	from
		i : XML!Element (
				i.name = 'binding'
			)		
	to
		o : WSDL!Binding (                 
				name <- i.getAttrVal('name'),
				type <- i.resolveMessageFormat(),
				wsoap_protocol <- if i.hasAttr('wsoap:protocol') = true then
									i.resolveProtocol()
								 else OclUndefined
								 endif,	
				bindingOperation <- i.getElementsByName('operation'),
				bindingFault <- i.getElementsByName('fault'),
				interface <- i.getInterfaceReference(),
				interfaceNS <- thisModule.splitNameSpace(i.getAttrVal('interface'),'beforeColon')
		)
}


-- Rule 'BindingOperation'
-- Creates BindingOperation from the operation element.
rule BindingOperation {
	from
		i : XML!Element (
				i.name = 'operation' and 
					if not i.parent.oclIsUndefined() then
						i.parent.name = 'binding'
					else false
					endif
			)		
	to
		o : WSDL!BindingOperation (                 
				wsoap_mep <- if i.hasAttr('wsoap:mep') = true then
								i.resolveSOAPMEP()
							 else OclUndefined	
							 endif,
				operation <- i.getOperationReference(),
				operationNS <- thisModule.splitNameSpace(i.getAttrVal('ref'),'beforeColon')
		)
}

-- Rule 'BindingFault'
-- Creates BindingFault from the fault element.
rule BindingFault {
	from
		i : XML!Element (
				i.name = 'fault' and 
					if not i.parent.oclIsUndefined() then
						i.parent.name = 'binding'
					else false
					endif
			)		
	to
		o : WSDL!BindingFault (                 
				wsoap_code <- if i.hasAttr('wsoap:code') = true then
								i.resolveFaultCodeEnum()
							 else OclUndefined	
							 endif,
				fault <- i.getFaultReference(),
				faultNS <- thisModule.splitNameSpace(i.getAttrVal('ref'),'beforeColon')
		)
}


-- Rule 'Service'
-- Creates Service from the service element.
rule Service {
	from
		i : XML!Element (
				i.name = 'service'
			)		
	to
		o : WSDL!Service (                 
				name <- i.getAttrVal('name'),
				endpoint <- i.getElementsByName('endpoint'),
				interface <- i.getInterfaceReference(),
				interfaceNS <- thisModule.splitNameSpace(i.getAttrVal('interface'),'beforeColon')
		)
}


-- Rule 'Endpoint'
-- Creates Endpoint from the endpoint element.
rule Endpoint {
	from
		i : XML!Element (
				i.name = 'endpoint' 
			)		
	to
		o : WSDL!Endpoint (                 
				name <- i.getAttrVal('name'),
				address <- i.getAttrVal('address'),
				binding <- i.getBindingReference(),
				bindingNS <- thisModule.splitNameSpace(i.getAttrVal('binding'),'beforeColon')
		)
}


",atlcompil atl transform xml metamodel wsdl metamodel creat part m sc these good old ai research group author marko ribar work wsdl metamodel v prof gerd wagner version todo annot with mdr enumer must locat top packag modul xml wsdl modul templat creat out wsdl in xml use xmlhelper helper xml r ml transform specif xml helper helper isneg return boolean statement xml element attribut xml attribut name r ml isneg true fals contextu xml element context xml element out boolean helper context xml element def isneg boolean let kolekcija sequenc xml attribut self children select c c ocliskindof xml attribut c name r ml isneg kolekcija isempti fals els empti let vred string kolekcija first valu vred true true els fals endif endif helper allsubel return sequenc xml sub element xml element recursivelli element last element children annot base transform model atl freder jouault ivan kurtev context xml element out sequenc xml element helper context xml element def allsubel sequenc xml element let subelem sequenc xml element xml element allinst select c get element parent c parent self collect elem elem allsubel flatten everi element get subel subelem union subel apprehend everi element add topmost element child parent self children select ch ch oclistypeof xml element flatten helper allsubattribut return sequenc xml sub attribut xml element recursivelli attribut last attribut children context xml element out sequenc xml attribut helper context xml element def allsubattribut sequenc xml attribut let subattr sequenc xml attribut xml element allinst select c c parent self collect attr attr allsubattribut flatten subattr union self children select oclistypeof xml attribut flatten helper resolvemep resolv mep type context xml element in out string helper context xml element def resolvemep xml element let valu string self getattrv pattern valu http www w org wsdl inout els valu http www w org wsdl inon inon els valu http www w org wsdl outin els valu http www w org wsdl robustouton robustouton els valu http www w org wsdl outon outon els valu http www w org wsdl robustinon robust els valu http www w org wsdl outoptionalin outoptionalin els valu http www w org wsdl inoptionalout inoptionalout els oclundefin endif endif endif endif endif endif endif endif helper resolvemessageformat resolv messageformat type context xml element in out string helper context xml element def resolvemessageformat xml element let valu string self getattrv type valu http www w org wsdl soap soap els valu http www w org wsdl http http els soap endif endif helper resolveprotocol resolv protocol type context xml element in out string helper context xml element def resolveprotocol xml element let valu string self getattrv wsoap protocol valu http www w org soap bind http http els smtp endif helper resolvesoapmep resolv soapmep type context xml element in out string helper context xml element def resolvesoapmep xml element let valu string self getattrv wsoap mep valu http www w org soap mep request respons requestrespons els soaprespons endif helper resolvefaultcodeenum resolv faultcodeenum type context xml element in out string helper context xml element def resolvefaultcodeenum xml element let valu string self getattrv wsoap code valu soap sender sender els oclundefin endif helper splitnamespac return string colon sign context thismodul in string beforecolon aftercolon out string helper def splitnamespac str split string str return string string let strseq sequenc string str split split strseq size str return beforecolon strseq first els str return aftercolon strseq last els oclundefin endif endif els oclundefin endif helper getbindingrefer return correct refer bind element context xml element in out xml element helper context xml element def getbindingrefer xml element xml element allinst select e e name bind e getattrv name self getattrv bind first helper getinterfacerefer return correct refer interfac element context xml element in out xml element helper context xml element def getinterfacerefer xml element xml element allinst select e e name interfac e getattrv name self getattrv interfac first helper getfaultrefer return correct refer fault element context xml element in out xml element helper context xml element def getfaultrefer xml element xml element allinst select e e name fault e getattrv name self getattrv ref first helper getoperationrefer return correct refer oper element context xml element in out xml element helper context xml element def getoperationrefer xml element xml element allinst select e e name oper e getattrv name self getattrv ref first helper getelementrefer return correct refer xselementdeclar context xml element in out xml element helper context xml element def getelementrefer xml element xml element allinst select e e name xs element e getattrv name self getattrv element first helper context xml element def getrefelementrefer xml element xml element allinst select e e name xs element e getattrv name self getattrv ref first helper issimpletyp return true xs element one simpl type context xml element in out boolean helper context xml element def issimpletyp boolean let name string self name let type string name xs element self getattrv type els oclundefin endif type oclisundefin type xs string true els type xs boolean true els type xs decim true els type xs float true els type xs doubl true els type xs durat true els type xs datetim true els type xs time true els type xs date true els type xs gyearmonth true els type xs gyear true els type xs gmonthday true els type xs gday true els type xs gmonth true els type xs hexbinari true els type xs base binari true els type xs anyuri true els type xs qname true els type xs notat true els fals endif endif endif endif endif endif endif endif endif endif endif endif endif endif endif endif endif endif endif els fals endif helper context xml element def getdefaultsimpletyp xml attribut xml element allinst select e e name xs element e getattrv type self getattrv type flatten first getattr type assequ first rule rule descript creat descript root element rule descript xml element name descript wsdl descript type getelementsbynam type interfac getelementsbynam interfac bind getelementsbynam bind servic getelementsbynam servic rule elementtyp creat elementtyp type element rule elementtyp xml element name type wsdl elementtyp schema getelementsbynam xs schema first rule xsschema creat xsschema xs schema element rule xsschema xml element name xs schema wsdl xsschema schemaloc getattrv xmlns targetnamespac getattrv targetnamespac elementdeclar getelementsbynam xs element typedefinit getelementsbynam xs complextyp rule xscomplextypedefinit creat xscomplextypedefinit xs complextyp element rule xscomplextypedefinit xml element name xs complextyp wsdl xscomplextypedefinit name getattrv name content con con wsdl xsparticl term ter ter wsdl xsmodelgroup compositor sequenc particl getelementsbynam xs sequenc first getelementsbynam xs element assequ rule simpletyp creat xssimpletypedefinit xml attribut this rule uniqu lazi rule mean call rule uniqu lazi rule simpletyp xml attribut wsdl xssimpletypedefinit name valu rule xselementdeclar creat xselementdeclar xs element element rule xselementdeclar xml element name xs element parent oclisundefin parent name xs sequenc els true endif ele wsdl xselementdeclar name getattrv name typedefinit issimpletyp thismodul simpletyp getdefaultsimpletyp els getelementsbynam xs complextyp isempti getelementsbynam xs complextyp first els hasattr type xml element allinst select e e name xs complextyp select e e getattrv name getattrv type assequ first els oclundefin endif endif endif rule sequenceelementdeclar creat xselementdeclar xs element element posit insid xs sequenc element rule sequenceelementdeclar xml element name xs element parent oclisundefin parent name xs sequenc els fals endif wsdl xsparticl content ele ele wsdl xselementdeclar name getattrv name typedefinit issimpletyp thismodul simpletyp getdefaultsimpletyp els getelementsbynam xs complextyp isempti getelementsbynam xs complextyp first els hasattr type xml element allinst select e e name xs complextyp select e e getattrv name getattrv type assequ first els oclundefin endif endif endif resolvedelementdeclar hasattr ref getrefelementrefer els oclundefin endif rule interfac creat interfac interfac element rule interfac xml element name interfac wsdl interfac name getattrv name fault getelementsbynam fault oper getelementsbynam oper rule fault creat fault fault element rule fault xml element name fault parent oclisundefin parent name bind els true endif wsdl fault name getattrv name element getelementrefer elementn thismodul splitnamespac getattrv element beforecolon rule oper creat oper oper element rule oper xml element name oper parent oclisundefin parent name interfac els fals endif wsdl oper name getattrv name pattern resolvemep input getelementsbynam input output getelementsbynam output infault getelementsbynam infault outfault getelementsbynam outfault rule input creat input input element rule input xml element name input wsdl input messagelabel getattrv messagelabel element getelementrefer elementn thismodul splitnamespac getattrv element beforecolon rule output creat output output element rule output xml element name output wsdl output messagelabel getattrv messagelabel element getelementrefer elementn thismodul splitnamespac getattrv element beforecolon rule infault creat infault infault element rule infault xml element name infault wsdl infault messagelabel getattrv messagelabel fault getfaultrefer faultn thismodul splitnamespac getattrv ref beforecolon rule outfault creat outfault outfault element rule outfault xml element name outfault wsdl outfault messagelabel getattrv messagelabel fault getfaultrefer faultn thismodul splitnamespac getattrv ref beforecolon rule bind creat bind bind element rule bind xml element name bind wsdl bind name getattrv name type resolvemessageformat wsoap protocol hasattr wsoap protocol true resolveprotocol els oclundefin endif bindingoper getelementsbynam oper bindingfault getelementsbynam fault interfac getinterfacerefer interfacen thismodul splitnamespac getattrv interfac beforecolon rule bindingoper creat bindingoper oper element rule bindingoper xml element name oper parent oclisundefin parent name bind els fals endif wsdl bindingoper wsoap mep hasattr wsoap mep true resolvesoapmep els oclundefin endif oper getoperationrefer operationn thismodul splitnamespac getattrv ref beforecolon rule bindingfault creat bindingfault fault element rule bindingfault xml element name fault parent oclisundefin parent name bind els fals endif wsdl bindingfault wsoap code hasattr wsoap code true resolvefaultcodeenum els oclundefin endif fault getfaultrefer faultn thismodul splitnamespac getattrv ref beforecolon rule servic creat servic servic element rule servic xml element name servic wsdl servic name getattrv name endpoint getelementsbynam endpoint interfac getinterfacerefer interfacen thismodul splitnamespac getattrv interfac beforecolon rule endpoint creat endpoint endpoint element rule endpoint xml element name endpoint wsdl endpoint name getattrv name address getattrv address bind getbindingrefer bindingn thismodul splitnamespac getattrv bind beforecolon,7
